////FHIR r4b types
////https://hl7.org/fhir/r4b

import fhir/r4bvaluesets
import gleam/bool
import gleam/dynamic/decode.{type Decoder}
import gleam/json.{type Json}
import gleam/option.{type Option, None, Some}

///http://hl7.org/fhir/r4b/StructureDefinition/Address#resource
pub type Address {
  Address(
    id: Option(String),
    extension: List(Extension),
    use_: Option(r4bvaluesets.Addressuse),
    type_: Option(r4bvaluesets.Addresstype),
    text: Option(String),
    line: List(String),
    city: Option(String),
    district: Option(String),
    state: Option(String),
    postal_code: Option(String),
    country: Option(String),
    period: Option(Period),
  )
}

pub fn address_new() -> Address {
  Address(
    period: None,
    country: None,
    postal_code: None,
    state: None,
    district: None,
    city: None,
    line: [],
    text: None,
    type_: None,
    use_: None,
    extension: [],
    id: None,
  )
}

pub fn address_to_json(address: Address) -> Json {
  let Address(
    period:,
    country:,
    postal_code:,
    state:,
    district:,
    city:,
    line:,
    text:,
    type_:,
    use_:,
    extension:,
    id:,
  ) = address
  let fields = []
  let fields = case period {
    Some(v) -> [#("period", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case country {
    Some(v) -> [#("country", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case postal_code {
    Some(v) -> [#("postalCode", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case state {
    Some(v) -> [#("state", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case district {
    Some(v) -> [#("district", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case city {
    Some(v) -> [#("city", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case line {
    [] -> fields
    _ -> [#("line", json.array(line, json.string)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", r4bvaluesets.addresstype_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case use_ {
    Some(v) -> [#("use", r4bvaluesets.addressuse_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn address_decoder() -> Decoder(Address) {
  use period <- decode.optional_field(
    "period",
    None,
    decode.optional(period_decoder()),
  )
  use country <- decode.optional_field(
    "country",
    None,
    decode.optional(decode.string),
  )
  use postal_code <- decode.optional_field(
    "postalCode",
    None,
    decode.optional(decode.string),
  )
  use state <- decode.optional_field(
    "state",
    None,
    decode.optional(decode.string),
  )
  use district <- decode.optional_field(
    "district",
    None,
    decode.optional(decode.string),
  )
  use city <- decode.optional_field(
    "city",
    None,
    decode.optional(decode.string),
  )
  use line <- decode.optional_field("line", [], decode.list(decode.string))
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(decode.string),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(r4bvaluesets.addresstype_decoder()),
  )
  use use_ <- decode.optional_field(
    "use",
    None,
    decode.optional(r4bvaluesets.addressuse_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(Address(
    period:,
    country:,
    postal_code:,
    state:,
    district:,
    city:,
    line:,
    text:,
    type_:,
    use_:,
    extension:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/Age#resource
pub type Age {
  Age(
    id: Option(String),
    extension: List(Extension),
    value: Option(Float),
    comparator: Option(r4bvaluesets.Quantitycomparator),
    unit: Option(String),
    system: Option(String),
    code: Option(String),
  )
}

pub fn age_new() -> Age {
  Age(
    code: None,
    system: None,
    unit: None,
    comparator: None,
    value: None,
    extension: [],
    id: None,
  )
}

pub fn age_to_json(age: Age) -> Json {
  let Age(code:, system:, unit:, comparator:, value:, extension:, id:) = age
  let fields = []
  let fields = case code {
    Some(v) -> [#("code", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case system {
    Some(v) -> [#("system", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case unit {
    Some(v) -> [#("unit", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case comparator {
    Some(v) -> [
      #("comparator", r4bvaluesets.quantitycomparator_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case value {
    Some(v) -> [#("value", json.float(v)), ..fields]
    None -> fields
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn age_decoder() -> Decoder(Age) {
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(decode.string),
  )
  use system <- decode.optional_field(
    "system",
    None,
    decode.optional(decode.string),
  )
  use unit <- decode.optional_field(
    "unit",
    None,
    decode.optional(decode.string),
  )
  use comparator <- decode.optional_field(
    "comparator",
    None,
    decode.optional(r4bvaluesets.quantitycomparator_decoder()),
  )
  use value <- decode.optional_field(
    "value",
    None,
    decode.optional(decode.float),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(Age(
    code:,
    system:,
    unit:,
    comparator:,
    value:,
    extension:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/Annotation#resource
pub type Annotation {
  Annotation(
    id: Option(String),
    extension: List(Extension),
    author: Option(AnnotationAuthor),
    time: Option(String),
    text: String,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Annotation#resource
pub type AnnotationAuthor {
  AnnotationAuthorReference(author: Reference)
  AnnotationAuthorString(author: String)
}

pub fn annotation_author_to_json(elt: AnnotationAuthor) -> Json {
  case elt {
    AnnotationAuthorReference(v) -> reference_to_json(v)
    AnnotationAuthorString(v) -> json.string(v)
  }
}

pub fn annotation_author_decoder() -> Decoder(AnnotationAuthor) {
  decode.one_of(
    decode.field("authorReference", reference_decoder(), decode.success)
      |> decode.map(AnnotationAuthorReference),
    [
      decode.field("authorString", decode.string, decode.success)
      |> decode.map(AnnotationAuthorString),
    ],
  )
}

pub fn annotation_new(text text: String) -> Annotation {
  Annotation(text:, time: None, author: None, extension: [], id: None)
}

pub fn annotation_to_json(annotation: Annotation) -> Json {
  let Annotation(text:, time:, author:, extension:, id:) = annotation
  let fields = [
    #("text", json.string(text)),
  ]
  let fields = case time {
    Some(v) -> [#("time", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case author {
    Some(v) -> [
      #(
        "author"
          <> case v {
          AnnotationAuthorReference(_) -> "Reference"
          AnnotationAuthorString(_) -> "String"
        },
        annotation_author_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn annotation_decoder() -> Decoder(Annotation) {
  use text <- decode.field("text", decode.string)
  use time <- decode.optional_field(
    "time",
    None,
    decode.optional(decode.string),
  )
  use author <- decode.then(none_if_omitted(annotation_author_decoder()))
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(Annotation(text:, time:, author:, extension:, id:))
}

///http://hl7.org/fhir/r4b/StructureDefinition/Attachment#resource
pub type Attachment {
  Attachment(
    id: Option(String),
    extension: List(Extension),
    content_type: Option(String),
    language: Option(String),
    data: Option(String),
    url: Option(String),
    size: Option(Int),
    hash: Option(String),
    title: Option(String),
    creation: Option(String),
  )
}

pub fn attachment_new() -> Attachment {
  Attachment(
    creation: None,
    title: None,
    hash: None,
    size: None,
    url: None,
    data: None,
    language: None,
    content_type: None,
    extension: [],
    id: None,
  )
}

pub fn attachment_to_json(attachment: Attachment) -> Json {
  let Attachment(
    creation:,
    title:,
    hash:,
    size:,
    url:,
    data:,
    language:,
    content_type:,
    extension:,
    id:,
  ) = attachment
  let fields = []
  let fields = case creation {
    Some(v) -> [#("creation", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case title {
    Some(v) -> [#("title", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case hash {
    Some(v) -> [#("hash", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case size {
    Some(v) -> [#("size", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case url {
    Some(v) -> [#("url", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case data {
    Some(v) -> [#("data", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case content_type {
    Some(v) -> [#("contentType", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn attachment_decoder() -> Decoder(Attachment) {
  use creation <- decode.optional_field(
    "creation",
    None,
    decode.optional(decode.string),
  )
  use title <- decode.optional_field(
    "title",
    None,
    decode.optional(decode.string),
  )
  use hash <- decode.optional_field(
    "hash",
    None,
    decode.optional(decode.string),
  )
  use size <- decode.optional_field("size", None, decode.optional(decode.int))
  use url <- decode.optional_field("url", None, decode.optional(decode.string))
  use data <- decode.optional_field(
    "data",
    None,
    decode.optional(decode.string),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use content_type <- decode.optional_field(
    "contentType",
    None,
    decode.optional(decode.string),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(Attachment(
    creation:,
    title:,
    hash:,
    size:,
    url:,
    data:,
    language:,
    content_type:,
    extension:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/CodeableConcept#resource
pub type Codeableconcept {
  Codeableconcept(
    id: Option(String),
    extension: List(Extension),
    coding: List(Coding),
    text: Option(String),
  )
}

pub fn codeableconcept_new() -> Codeableconcept {
  Codeableconcept(text: None, coding: [], extension: [], id: None)
}

pub fn codeableconcept_to_json(codeableconcept: Codeableconcept) -> Json {
  let Codeableconcept(text:, coding:, extension:, id:) = codeableconcept
  let fields = []
  let fields = case text {
    Some(v) -> [#("text", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case coding {
    [] -> fields
    _ -> [#("coding", json.array(coding, coding_to_json)), ..fields]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn codeableconcept_decoder() -> Decoder(Codeableconcept) {
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(decode.string),
  )
  use coding <- decode.optional_field(
    "coding",
    [],
    decode.list(coding_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(Codeableconcept(text:, coding:, extension:, id:))
}

///http://hl7.org/fhir/r4b/StructureDefinition/CodeableReference#resource
pub type Codeablereference {
  Codeablereference(
    id: Option(String),
    extension: List(Extension),
    concept: Option(Codeableconcept),
    reference: Option(Reference),
  )
}

pub fn codeablereference_new() -> Codeablereference {
  Codeablereference(reference: None, concept: None, extension: [], id: None)
}

pub fn codeablereference_to_json(codeablereference: Codeablereference) -> Json {
  let Codeablereference(reference:, concept:, extension:, id:) =
    codeablereference
  let fields = []
  let fields = case reference {
    Some(v) -> [#("reference", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case concept {
    Some(v) -> [#("concept", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn codeablereference_decoder() -> Decoder(Codeablereference) {
  use reference <- decode.optional_field(
    "reference",
    None,
    decode.optional(reference_decoder()),
  )
  use concept <- decode.optional_field(
    "concept",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(Codeablereference(reference:, concept:, extension:, id:))
}

///http://hl7.org/fhir/r4b/StructureDefinition/Coding#resource
pub type Coding {
  Coding(
    id: Option(String),
    extension: List(Extension),
    system: Option(String),
    version: Option(String),
    code: Option(String),
    display: Option(String),
    user_selected: Option(Bool),
  )
}

pub fn coding_new() -> Coding {
  Coding(
    user_selected: None,
    display: None,
    code: None,
    version: None,
    system: None,
    extension: [],
    id: None,
  )
}

pub fn coding_to_json(coding: Coding) -> Json {
  let Coding(
    user_selected:,
    display:,
    code:,
    version:,
    system:,
    extension:,
    id:,
  ) = coding
  let fields = []
  let fields = case user_selected {
    Some(v) -> [#("userSelected", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case display {
    Some(v) -> [#("display", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case code {
    Some(v) -> [#("code", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case version {
    Some(v) -> [#("version", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case system {
    Some(v) -> [#("system", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn coding_decoder() -> Decoder(Coding) {
  use user_selected <- decode.optional_field(
    "userSelected",
    None,
    decode.optional(decode.bool),
  )
  use display <- decode.optional_field(
    "display",
    None,
    decode.optional(decode.string),
  )
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(decode.string),
  )
  use version <- decode.optional_field(
    "version",
    None,
    decode.optional(decode.string),
  )
  use system <- decode.optional_field(
    "system",
    None,
    decode.optional(decode.string),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(Coding(
    user_selected:,
    display:,
    code:,
    version:,
    system:,
    extension:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/ContactDetail#resource
pub type Contactdetail {
  Contactdetail(
    id: Option(String),
    extension: List(Extension),
    name: Option(String),
    telecom: List(Contactpoint),
  )
}

pub fn contactdetail_new() -> Contactdetail {
  Contactdetail(telecom: [], name: None, extension: [], id: None)
}

pub fn contactdetail_to_json(contactdetail: Contactdetail) -> Json {
  let Contactdetail(telecom:, name:, extension:, id:) = contactdetail
  let fields = []
  let fields = case telecom {
    [] -> fields
    _ -> [#("telecom", json.array(telecom, contactpoint_to_json)), ..fields]
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn contactdetail_decoder() -> Decoder(Contactdetail) {
  use telecom <- decode.optional_field(
    "telecom",
    [],
    decode.list(contactpoint_decoder()),
  )
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(Contactdetail(telecom:, name:, extension:, id:))
}

///http://hl7.org/fhir/r4b/StructureDefinition/ContactPoint#resource
pub type Contactpoint {
  Contactpoint(
    id: Option(String),
    extension: List(Extension),
    system: Option(r4bvaluesets.Contactpointsystem),
    value: Option(String),
    use_: Option(r4bvaluesets.Contactpointuse),
    rank: Option(Int),
    period: Option(Period),
  )
}

pub fn contactpoint_new() -> Contactpoint {
  Contactpoint(
    period: None,
    rank: None,
    use_: None,
    value: None,
    system: None,
    extension: [],
    id: None,
  )
}

pub fn contactpoint_to_json(contactpoint: Contactpoint) -> Json {
  let Contactpoint(period:, rank:, use_:, value:, system:, extension:, id:) =
    contactpoint
  let fields = []
  let fields = case period {
    Some(v) -> [#("period", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case rank {
    Some(v) -> [#("rank", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case use_ {
    Some(v) -> [#("use", r4bvaluesets.contactpointuse_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case value {
    Some(v) -> [#("value", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case system {
    Some(v) -> [
      #("system", r4bvaluesets.contactpointsystem_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn contactpoint_decoder() -> Decoder(Contactpoint) {
  use period <- decode.optional_field(
    "period",
    None,
    decode.optional(period_decoder()),
  )
  use rank <- decode.optional_field("rank", None, decode.optional(decode.int))
  use use_ <- decode.optional_field(
    "use",
    None,
    decode.optional(r4bvaluesets.contactpointuse_decoder()),
  )
  use value <- decode.optional_field(
    "value",
    None,
    decode.optional(decode.string),
  )
  use system <- decode.optional_field(
    "system",
    None,
    decode.optional(r4bvaluesets.contactpointsystem_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(Contactpoint(
    period:,
    rank:,
    use_:,
    value:,
    system:,
    extension:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/Contributor#resource
pub type Contributor {
  Contributor(
    id: Option(String),
    extension: List(Extension),
    type_: r4bvaluesets.Contributortype,
    name: String,
    contact: List(Contactdetail),
  )
}

pub fn contributor_new(
  name name: String,
  type_ type_: r4bvaluesets.Contributortype,
) -> Contributor {
  Contributor(contact: [], name:, type_:, extension: [], id: None)
}

pub fn contributor_to_json(contributor: Contributor) -> Json {
  let Contributor(contact:, name:, type_:, extension:, id:) = contributor
  let fields = [
    #("name", json.string(name)),
    #("type", r4bvaluesets.contributortype_to_json(type_)),
  ]
  let fields = case contact {
    [] -> fields
    _ -> [#("contact", json.array(contact, contactdetail_to_json)), ..fields]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn contributor_decoder() -> Decoder(Contributor) {
  use contact <- decode.optional_field(
    "contact",
    [],
    decode.list(contactdetail_decoder()),
  )
  use name <- decode.field("name", decode.string)
  use type_ <- decode.field("type", r4bvaluesets.contributortype_decoder())
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(Contributor(contact:, name:, type_:, extension:, id:))
}

///http://hl7.org/fhir/r4b/StructureDefinition/Count#resource
pub type Count {
  Count(
    id: Option(String),
    extension: List(Extension),
    value: Option(Float),
    comparator: Option(r4bvaluesets.Quantitycomparator),
    unit: Option(String),
    system: Option(String),
    code: Option(String),
  )
}

pub fn count_new() -> Count {
  Count(
    code: None,
    system: None,
    unit: None,
    comparator: None,
    value: None,
    extension: [],
    id: None,
  )
}

pub fn count_to_json(count: Count) -> Json {
  let Count(code:, system:, unit:, comparator:, value:, extension:, id:) = count
  let fields = []
  let fields = case code {
    Some(v) -> [#("code", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case system {
    Some(v) -> [#("system", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case unit {
    Some(v) -> [#("unit", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case comparator {
    Some(v) -> [
      #("comparator", r4bvaluesets.quantitycomparator_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case value {
    Some(v) -> [#("value", json.float(v)), ..fields]
    None -> fields
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn count_decoder() -> Decoder(Count) {
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(decode.string),
  )
  use system <- decode.optional_field(
    "system",
    None,
    decode.optional(decode.string),
  )
  use unit <- decode.optional_field(
    "unit",
    None,
    decode.optional(decode.string),
  )
  use comparator <- decode.optional_field(
    "comparator",
    None,
    decode.optional(r4bvaluesets.quantitycomparator_decoder()),
  )
  use value <- decode.optional_field(
    "value",
    None,
    decode.optional(decode.float),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(Count(
    code:,
    system:,
    unit:,
    comparator:,
    value:,
    extension:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/DataRequirement#resource
pub type Datarequirement {
  Datarequirement(
    id: Option(String),
    extension: List(Extension),
    type_: r4bvaluesets.Alltypes,
    profile: List(String),
    subject: Option(DatarequirementSubject),
    must_support: List(String),
    code_filter: List(DatarequirementCodefilter),
    date_filter: List(DatarequirementDatefilter),
    limit: Option(Int),
    sort: List(DatarequirementSort),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/DataRequirement#resource
pub type DatarequirementSubject {
  DatarequirementSubjectCodeableconcept(subject: Codeableconcept)
  DatarequirementSubjectReference(subject: Reference)
}

pub fn datarequirement_subject_to_json(elt: DatarequirementSubject) -> Json {
  case elt {
    DatarequirementSubjectCodeableconcept(v) -> codeableconcept_to_json(v)
    DatarequirementSubjectReference(v) -> reference_to_json(v)
  }
}

pub fn datarequirement_subject_decoder() -> Decoder(DatarequirementSubject) {
  decode.one_of(
    decode.field(
      "subjectCodeableConcept",
      codeableconcept_decoder(),
      decode.success,
    )
      |> decode.map(DatarequirementSubjectCodeableconcept),
    [
      decode.field("subjectReference", reference_decoder(), decode.success)
      |> decode.map(DatarequirementSubjectReference),
    ],
  )
}

pub fn datarequirement_new(
  type_ type_: r4bvaluesets.Alltypes,
) -> Datarequirement {
  Datarequirement(
    sort: [],
    limit: None,
    date_filter: [],
    code_filter: [],
    must_support: [],
    subject: None,
    profile: [],
    type_:,
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/DataRequirement#resource
pub type DatarequirementCodefilter {
  DatarequirementCodefilter(
    id: Option(String),
    extension: List(Extension),
    path: Option(String),
    search_param: Option(String),
    value_set: Option(String),
    code: List(Coding),
  )
}

pub fn datarequirement_codefilter_new() -> DatarequirementCodefilter {
  DatarequirementCodefilter(
    code: [],
    value_set: None,
    search_param: None,
    path: None,
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/DataRequirement#resource
pub type DatarequirementDatefilter {
  DatarequirementDatefilter(
    id: Option(String),
    extension: List(Extension),
    path: Option(String),
    search_param: Option(String),
    value: Option(DatarequirementDatefilterValue),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/DataRequirement#resource
pub type DatarequirementDatefilterValue {
  DatarequirementDatefilterValueDatetime(value: String)
  DatarequirementDatefilterValuePeriod(value: Period)
  DatarequirementDatefilterValueDuration(value: Duration)
}

pub fn datarequirement_datefilter_value_to_json(
  elt: DatarequirementDatefilterValue,
) -> Json {
  case elt {
    DatarequirementDatefilterValueDatetime(v) -> json.string(v)
    DatarequirementDatefilterValuePeriod(v) -> period_to_json(v)
    DatarequirementDatefilterValueDuration(v) -> duration_to_json(v)
  }
}

pub fn datarequirement_datefilter_value_decoder() -> Decoder(
  DatarequirementDatefilterValue,
) {
  decode.one_of(
    decode.field("valueDateTime", decode.string, decode.success)
      |> decode.map(DatarequirementDatefilterValueDatetime),
    [
      decode.field("valuePeriod", period_decoder(), decode.success)
        |> decode.map(DatarequirementDatefilterValuePeriod),
      decode.field("valueDuration", duration_decoder(), decode.success)
        |> decode.map(DatarequirementDatefilterValueDuration),
    ],
  )
}

pub fn datarequirement_datefilter_new() -> DatarequirementDatefilter {
  DatarequirementDatefilter(
    value: None,
    search_param: None,
    path: None,
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/DataRequirement#resource
pub type DatarequirementSort {
  DatarequirementSort(
    id: Option(String),
    extension: List(Extension),
    path: String,
    direction: r4bvaluesets.Sortdirection,
  )
}

pub fn datarequirement_sort_new(
  direction direction: r4bvaluesets.Sortdirection,
  path path: String,
) -> DatarequirementSort {
  DatarequirementSort(direction:, path:, extension: [], id: None)
}

pub fn datarequirement_sort_to_json(
  datarequirement_sort: DatarequirementSort,
) -> Json {
  let DatarequirementSort(direction:, path:, extension:, id:) =
    datarequirement_sort
  let fields = [
    #("direction", r4bvaluesets.sortdirection_to_json(direction)),
    #("path", json.string(path)),
  ]
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn datarequirement_sort_decoder() -> Decoder(DatarequirementSort) {
  use direction <- decode.field(
    "direction",
    r4bvaluesets.sortdirection_decoder(),
  )
  use path <- decode.field("path", decode.string)
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(DatarequirementSort(direction:, path:, extension:, id:))
}

pub fn datarequirement_datefilter_to_json(
  datarequirement_datefilter: DatarequirementDatefilter,
) -> Json {
  let DatarequirementDatefilter(value:, search_param:, path:, extension:, id:) =
    datarequirement_datefilter
  let fields = []
  let fields = case value {
    Some(v) -> [
      #(
        "value"
          <> case v {
          DatarequirementDatefilterValueDatetime(_) -> "Datetime"
          DatarequirementDatefilterValuePeriod(_) -> "Period"
          DatarequirementDatefilterValueDuration(_) -> "Duration"
        },
        datarequirement_datefilter_value_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case search_param {
    Some(v) -> [#("searchParam", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case path {
    Some(v) -> [#("path", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn datarequirement_datefilter_decoder() -> Decoder(
  DatarequirementDatefilter,
) {
  use value <- decode.then(
    none_if_omitted(datarequirement_datefilter_value_decoder()),
  )
  use search_param <- decode.optional_field(
    "searchParam",
    None,
    decode.optional(decode.string),
  )
  use path <- decode.optional_field(
    "path",
    None,
    decode.optional(decode.string),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(DatarequirementDatefilter(
    value:,
    search_param:,
    path:,
    extension:,
    id:,
  ))
}

pub fn datarequirement_codefilter_to_json(
  datarequirement_codefilter: DatarequirementCodefilter,
) -> Json {
  let DatarequirementCodefilter(
    code:,
    value_set:,
    search_param:,
    path:,
    extension:,
    id:,
  ) = datarequirement_codefilter
  let fields = []
  let fields = case code {
    [] -> fields
    _ -> [#("code", json.array(code, coding_to_json)), ..fields]
  }
  let fields = case value_set {
    Some(v) -> [#("valueSet", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case search_param {
    Some(v) -> [#("searchParam", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case path {
    Some(v) -> [#("path", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn datarequirement_codefilter_decoder() -> Decoder(
  DatarequirementCodefilter,
) {
  use code <- decode.optional_field("code", [], decode.list(coding_decoder()))
  use value_set <- decode.optional_field(
    "valueSet",
    None,
    decode.optional(decode.string),
  )
  use search_param <- decode.optional_field(
    "searchParam",
    None,
    decode.optional(decode.string),
  )
  use path <- decode.optional_field(
    "path",
    None,
    decode.optional(decode.string),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(DatarequirementCodefilter(
    code:,
    value_set:,
    search_param:,
    path:,
    extension:,
    id:,
  ))
}

pub fn datarequirement_to_json(datarequirement: Datarequirement) -> Json {
  let Datarequirement(
    sort:,
    limit:,
    date_filter:,
    code_filter:,
    must_support:,
    subject:,
    profile:,
    type_:,
    extension:,
    id:,
  ) = datarequirement
  let fields = [
    #("type", r4bvaluesets.alltypes_to_json(type_)),
  ]
  let fields = case sort {
    [] -> fields
    _ -> [#("sort", json.array(sort, datarequirement_sort_to_json)), ..fields]
  }
  let fields = case limit {
    Some(v) -> [#("limit", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case date_filter {
    [] -> fields
    _ -> [
      #(
        "dateFilter",
        json.array(date_filter, datarequirement_datefilter_to_json),
      ),
      ..fields
    ]
  }
  let fields = case code_filter {
    [] -> fields
    _ -> [
      #(
        "codeFilter",
        json.array(code_filter, datarequirement_codefilter_to_json),
      ),
      ..fields
    ]
  }
  let fields = case must_support {
    [] -> fields
    _ -> [#("mustSupport", json.array(must_support, json.string)), ..fields]
  }
  let fields = case subject {
    Some(v) -> [
      #(
        "subject"
          <> case v {
          DatarequirementSubjectCodeableconcept(_) -> "Codeableconcept"
          DatarequirementSubjectReference(_) -> "Reference"
        },
        datarequirement_subject_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case profile {
    [] -> fields
    _ -> [#("profile", json.array(profile, json.string)), ..fields]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn datarequirement_decoder() -> Decoder(Datarequirement) {
  use sort <- decode.optional_field(
    "sort",
    [],
    decode.list(datarequirement_sort_decoder()),
  )
  use limit <- decode.optional_field("limit", None, decode.optional(decode.int))
  use date_filter <- decode.optional_field(
    "dateFilter",
    [],
    decode.list(datarequirement_datefilter_decoder()),
  )
  use code_filter <- decode.optional_field(
    "codeFilter",
    [],
    decode.list(datarequirement_codefilter_decoder()),
  )
  use must_support <- decode.optional_field(
    "mustSupport",
    [],
    decode.list(decode.string),
  )
  use subject <- decode.then(none_if_omitted(datarequirement_subject_decoder()))
  use profile <- decode.optional_field(
    "profile",
    [],
    decode.list(decode.string),
  )
  use type_ <- decode.field("type", r4bvaluesets.alltypes_decoder())
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(Datarequirement(
    sort:,
    limit:,
    date_filter:,
    code_filter:,
    must_support:,
    subject:,
    profile:,
    type_:,
    extension:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/Distance#resource
pub type Distance {
  Distance(
    id: Option(String),
    extension: List(Extension),
    value: Option(Float),
    comparator: Option(r4bvaluesets.Quantitycomparator),
    unit: Option(String),
    system: Option(String),
    code: Option(String),
  )
}

pub fn distance_new() -> Distance {
  Distance(
    code: None,
    system: None,
    unit: None,
    comparator: None,
    value: None,
    extension: [],
    id: None,
  )
}

pub fn distance_to_json(distance: Distance) -> Json {
  let Distance(code:, system:, unit:, comparator:, value:, extension:, id:) =
    distance
  let fields = []
  let fields = case code {
    Some(v) -> [#("code", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case system {
    Some(v) -> [#("system", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case unit {
    Some(v) -> [#("unit", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case comparator {
    Some(v) -> [
      #("comparator", r4bvaluesets.quantitycomparator_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case value {
    Some(v) -> [#("value", json.float(v)), ..fields]
    None -> fields
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn distance_decoder() -> Decoder(Distance) {
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(decode.string),
  )
  use system <- decode.optional_field(
    "system",
    None,
    decode.optional(decode.string),
  )
  use unit <- decode.optional_field(
    "unit",
    None,
    decode.optional(decode.string),
  )
  use comparator <- decode.optional_field(
    "comparator",
    None,
    decode.optional(r4bvaluesets.quantitycomparator_decoder()),
  )
  use value <- decode.optional_field(
    "value",
    None,
    decode.optional(decode.float),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(Distance(
    code:,
    system:,
    unit:,
    comparator:,
    value:,
    extension:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/Dosage#resource
pub type Dosage {
  Dosage(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    sequence: Option(Int),
    text: Option(String),
    additional_instruction: List(Codeableconcept),
    patient_instruction: Option(String),
    timing: Option(Timing),
    as_needed: Option(DosageAsneeded),
    site: Option(Codeableconcept),
    route: Option(Codeableconcept),
    method: Option(Codeableconcept),
    dose_and_rate: List(DosageDoseandrate),
    max_dose_per_period: Option(Ratio),
    max_dose_per_administration: Option(Quantity),
    max_dose_per_lifetime: Option(Quantity),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Dosage#resource
pub type DosageAsneeded {
  DosageAsneededBoolean(as_needed: Bool)
  DosageAsneededCodeableconcept(as_needed: Codeableconcept)
}

pub fn dosage_asneeded_to_json(elt: DosageAsneeded) -> Json {
  case elt {
    DosageAsneededBoolean(v) -> json.bool(v)
    DosageAsneededCodeableconcept(v) -> codeableconcept_to_json(v)
  }
}

pub fn dosage_asneeded_decoder() -> Decoder(DosageAsneeded) {
  decode.one_of(
    decode.field("asNeededBoolean", decode.bool, decode.success)
      |> decode.map(DosageAsneededBoolean),
    [
      decode.field(
        "asNeededCodeableConcept",
        codeableconcept_decoder(),
        decode.success,
      )
      |> decode.map(DosageAsneededCodeableconcept),
    ],
  )
}

pub fn dosage_new() -> Dosage {
  Dosage(
    max_dose_per_lifetime: None,
    max_dose_per_administration: None,
    max_dose_per_period: None,
    dose_and_rate: [],
    method: None,
    route: None,
    site: None,
    as_needed: None,
    timing: None,
    patient_instruction: None,
    additional_instruction: [],
    text: None,
    sequence: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Dosage#resource
pub type DosageDoseandrate {
  DosageDoseandrate(
    id: Option(String),
    extension: List(Extension),
    type_: Option(Codeableconcept),
    dose: Option(DosageDoseandrateDose),
    rate: Option(DosageDoseandrateRate),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Dosage#resource
pub type DosageDoseandrateDose {
  DosageDoseandrateDoseRange(dose: Range)
  DosageDoseandrateDoseQuantity(dose: Quantity)
}

pub fn dosage_doseandrate_dose_to_json(elt: DosageDoseandrateDose) -> Json {
  case elt {
    DosageDoseandrateDoseRange(v) -> range_to_json(v)
    DosageDoseandrateDoseQuantity(v) -> quantity_to_json(v)
  }
}

pub fn dosage_doseandrate_dose_decoder() -> Decoder(DosageDoseandrateDose) {
  decode.one_of(
    decode.field("doseRange", range_decoder(), decode.success)
      |> decode.map(DosageDoseandrateDoseRange),
    [
      decode.field("doseQuantity", quantity_decoder(), decode.success)
      |> decode.map(DosageDoseandrateDoseQuantity),
    ],
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Dosage#resource
pub type DosageDoseandrateRate {
  DosageDoseandrateRateRatio(rate: Ratio)
  DosageDoseandrateRateRange(rate: Range)
  DosageDoseandrateRateQuantity(rate: Quantity)
}

pub fn dosage_doseandrate_rate_to_json(elt: DosageDoseandrateRate) -> Json {
  case elt {
    DosageDoseandrateRateRatio(v) -> ratio_to_json(v)
    DosageDoseandrateRateRange(v) -> range_to_json(v)
    DosageDoseandrateRateQuantity(v) -> quantity_to_json(v)
  }
}

pub fn dosage_doseandrate_rate_decoder() -> Decoder(DosageDoseandrateRate) {
  decode.one_of(
    decode.field("rateRatio", ratio_decoder(), decode.success)
      |> decode.map(DosageDoseandrateRateRatio),
    [
      decode.field("rateRange", range_decoder(), decode.success)
        |> decode.map(DosageDoseandrateRateRange),
      decode.field("rateQuantity", quantity_decoder(), decode.success)
        |> decode.map(DosageDoseandrateRateQuantity),
    ],
  )
}

pub fn dosage_doseandrate_new() -> DosageDoseandrate {
  DosageDoseandrate(
    rate: None,
    dose: None,
    type_: None,
    extension: [],
    id: None,
  )
}

pub fn dosage_doseandrate_to_json(dosage_doseandrate: DosageDoseandrate) -> Json {
  let DosageDoseandrate(rate:, dose:, type_:, extension:, id:) =
    dosage_doseandrate
  let fields = []
  let fields = case rate {
    Some(v) -> [
      #(
        "rate"
          <> case v {
          DosageDoseandrateRateRatio(_) -> "Ratio"
          DosageDoseandrateRateRange(_) -> "Range"
          DosageDoseandrateRateQuantity(_) -> "Quantity"
        },
        dosage_doseandrate_rate_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case dose {
    Some(v) -> [
      #(
        "dose"
          <> case v {
          DosageDoseandrateDoseRange(_) -> "Range"
          DosageDoseandrateDoseQuantity(_) -> "Quantity"
        },
        dosage_doseandrate_dose_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn dosage_doseandrate_decoder() -> Decoder(DosageDoseandrate) {
  use rate <- decode.then(none_if_omitted(dosage_doseandrate_rate_decoder()))
  use dose <- decode.then(none_if_omitted(dosage_doseandrate_dose_decoder()))
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(DosageDoseandrate(rate:, dose:, type_:, extension:, id:))
}

pub fn dosage_to_json(dosage: Dosage) -> Json {
  let Dosage(
    max_dose_per_lifetime:,
    max_dose_per_administration:,
    max_dose_per_period:,
    dose_and_rate:,
    method:,
    route:,
    site:,
    as_needed:,
    timing:,
    patient_instruction:,
    additional_instruction:,
    text:,
    sequence:,
    modifier_extension:,
    extension:,
    id:,
  ) = dosage
  let fields = []
  let fields = case max_dose_per_lifetime {
    Some(v) -> [#("maxDosePerLifetime", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case max_dose_per_administration {
    Some(v) -> [#("maxDosePerAdministration", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case max_dose_per_period {
    Some(v) -> [#("maxDosePerPeriod", ratio_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case dose_and_rate {
    [] -> fields
    _ -> [
      #("doseAndRate", json.array(dose_and_rate, dosage_doseandrate_to_json)),
      ..fields
    ]
  }
  let fields = case method {
    Some(v) -> [#("method", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case route {
    Some(v) -> [#("route", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case site {
    Some(v) -> [#("site", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case as_needed {
    Some(v) -> [
      #(
        "asNeeded"
          <> case v {
          DosageAsneededBoolean(_) -> "Boolean"
          DosageAsneededCodeableconcept(_) -> "Codeableconcept"
        },
        dosage_asneeded_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case timing {
    Some(v) -> [#("timing", timing_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case patient_instruction {
    Some(v) -> [#("patientInstruction", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case additional_instruction {
    [] -> fields
    _ -> [
      #(
        "additionalInstruction",
        json.array(additional_instruction, codeableconcept_to_json),
      ),
      ..fields
    ]
  }
  let fields = case text {
    Some(v) -> [#("text", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case sequence {
    Some(v) -> [#("sequence", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn dosage_decoder() -> Decoder(Dosage) {
  use max_dose_per_lifetime <- decode.optional_field(
    "maxDosePerLifetime",
    None,
    decode.optional(quantity_decoder()),
  )
  use max_dose_per_administration <- decode.optional_field(
    "maxDosePerAdministration",
    None,
    decode.optional(quantity_decoder()),
  )
  use max_dose_per_period <- decode.optional_field(
    "maxDosePerPeriod",
    None,
    decode.optional(ratio_decoder()),
  )
  use dose_and_rate <- decode.optional_field(
    "doseAndRate",
    [],
    decode.list(dosage_doseandrate_decoder()),
  )
  use method <- decode.optional_field(
    "method",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use route <- decode.optional_field(
    "route",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use site <- decode.optional_field(
    "site",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use as_needed <- decode.then(none_if_omitted(dosage_asneeded_decoder()))
  use timing <- decode.optional_field(
    "timing",
    None,
    decode.optional(timing_decoder()),
  )
  use patient_instruction <- decode.optional_field(
    "patientInstruction",
    None,
    decode.optional(decode.string),
  )
  use additional_instruction <- decode.optional_field(
    "additionalInstruction",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(decode.string),
  )
  use sequence <- decode.optional_field(
    "sequence",
    None,
    decode.optional(decode.int),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(Dosage(
    max_dose_per_lifetime:,
    max_dose_per_administration:,
    max_dose_per_period:,
    dose_and_rate:,
    method:,
    route:,
    site:,
    as_needed:,
    timing:,
    patient_instruction:,
    additional_instruction:,
    text:,
    sequence:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/Duration#resource
pub type Duration {
  Duration(
    id: Option(String),
    extension: List(Extension),
    value: Option(Float),
    comparator: Option(r4bvaluesets.Quantitycomparator),
    unit: Option(String),
    system: Option(String),
    code: Option(String),
  )
}

pub fn duration_new() -> Duration {
  Duration(
    code: None,
    system: None,
    unit: None,
    comparator: None,
    value: None,
    extension: [],
    id: None,
  )
}

pub fn duration_to_json(duration: Duration) -> Json {
  let Duration(code:, system:, unit:, comparator:, value:, extension:, id:) =
    duration
  let fields = []
  let fields = case code {
    Some(v) -> [#("code", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case system {
    Some(v) -> [#("system", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case unit {
    Some(v) -> [#("unit", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case comparator {
    Some(v) -> [
      #("comparator", r4bvaluesets.quantitycomparator_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case value {
    Some(v) -> [#("value", json.float(v)), ..fields]
    None -> fields
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn duration_decoder() -> Decoder(Duration) {
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(decode.string),
  )
  use system <- decode.optional_field(
    "system",
    None,
    decode.optional(decode.string),
  )
  use unit <- decode.optional_field(
    "unit",
    None,
    decode.optional(decode.string),
  )
  use comparator <- decode.optional_field(
    "comparator",
    None,
    decode.optional(r4bvaluesets.quantitycomparator_decoder()),
  )
  use value <- decode.optional_field(
    "value",
    None,
    decode.optional(decode.float),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(Duration(
    code:,
    system:,
    unit:,
    comparator:,
    value:,
    extension:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/ElementDefinition#resource
pub type Elementdefinition {
  Elementdefinition(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    path: String,
    representation: List(r4bvaluesets.Propertyrepresentation),
    slice_name: Option(String),
    slice_is_constraining: Option(Bool),
    label: Option(String),
    code: List(Coding),
    slicing: Option(ElementdefinitionSlicing),
    short: Option(String),
    definition: Option(String),
    comment: Option(String),
    requirements: Option(String),
    alias: List(String),
    min: Option(Int),
    max: Option(String),
    base: Option(ElementdefinitionBase),
    content_reference: Option(String),
    type_: List(ElementdefinitionType),
    default_value: Option(ElementdefinitionDefaultvalue),
    meaning_when_missing: Option(String),
    order_meaning: Option(String),
    fixed: Option(ElementdefinitionFixed),
    pattern: Option(ElementdefinitionPattern),
    example: List(ElementdefinitionExample),
    min_value: Option(ElementdefinitionMinvalue),
    max_value: Option(ElementdefinitionMaxvalue),
    max_length: Option(Int),
    condition: List(String),
    constraint: List(ElementdefinitionConstraint),
    must_support: Option(Bool),
    is_modifier: Option(Bool),
    is_modifier_reason: Option(String),
    is_summary: Option(Bool),
    binding: Option(ElementdefinitionBinding),
    mapping: List(ElementdefinitionMapping),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ElementDefinition#resource
pub type ElementdefinitionDefaultvalue {
  ElementdefinitionDefaultvalueBase64binary(default_value: String)
  ElementdefinitionDefaultvalueBoolean(default_value: Bool)
  ElementdefinitionDefaultvalueCanonical(default_value: String)
  ElementdefinitionDefaultvalueCode(default_value: String)
  ElementdefinitionDefaultvalueDate(default_value: String)
  ElementdefinitionDefaultvalueDatetime(default_value: String)
  ElementdefinitionDefaultvalueDecimal(default_value: Float)
  ElementdefinitionDefaultvalueId(default_value: String)
  ElementdefinitionDefaultvalueInstant(default_value: String)
  ElementdefinitionDefaultvalueInteger(default_value: Int)
  ElementdefinitionDefaultvalueMarkdown(default_value: String)
  ElementdefinitionDefaultvalueOid(default_value: String)
  ElementdefinitionDefaultvaluePositiveint(default_value: Int)
  ElementdefinitionDefaultvalueString(default_value: String)
  ElementdefinitionDefaultvalueTime(default_value: String)
  ElementdefinitionDefaultvalueUnsignedint(default_value: Int)
  ElementdefinitionDefaultvalueUri(default_value: String)
  ElementdefinitionDefaultvalueUrl(default_value: String)
  ElementdefinitionDefaultvalueUuid(default_value: String)
  ElementdefinitionDefaultvalueAddress(default_value: Address)
  ElementdefinitionDefaultvalueAge(default_value: Age)
  ElementdefinitionDefaultvalueAnnotation(default_value: Annotation)
  ElementdefinitionDefaultvalueAttachment(default_value: Attachment)
  ElementdefinitionDefaultvalueCodeableconcept(default_value: Codeableconcept)
  ElementdefinitionDefaultvalueCodeablereference(
    default_value: Codeablereference,
  )
  ElementdefinitionDefaultvalueCoding(default_value: Coding)
  ElementdefinitionDefaultvalueContactpoint(default_value: Contactpoint)
  ElementdefinitionDefaultvalueCount(default_value: Count)
  ElementdefinitionDefaultvalueDistance(default_value: Distance)
  ElementdefinitionDefaultvalueDuration(default_value: Duration)
  ElementdefinitionDefaultvalueHumanname(default_value: Humanname)
  ElementdefinitionDefaultvalueIdentifier(default_value: Identifier)
  ElementdefinitionDefaultvalueMoney(default_value: Money)
  ElementdefinitionDefaultvaluePeriod(default_value: Period)
  ElementdefinitionDefaultvalueQuantity(default_value: Quantity)
  ElementdefinitionDefaultvalueRange(default_value: Range)
  ElementdefinitionDefaultvalueRatio(default_value: Ratio)
  ElementdefinitionDefaultvalueRatiorange(default_value: Ratiorange)
  ElementdefinitionDefaultvalueReference(default_value: Reference)
  ElementdefinitionDefaultvalueSampleddata(default_value: Sampleddata)
  ElementdefinitionDefaultvalueSignature(default_value: Signature)
  ElementdefinitionDefaultvalueTiming(default_value: Timing)
  ElementdefinitionDefaultvalueContactdetail(default_value: Contactdetail)
  ElementdefinitionDefaultvalueContributor(default_value: Contributor)
  ElementdefinitionDefaultvalueDatarequirement(default_value: Datarequirement)
  ElementdefinitionDefaultvalueExpression(default_value: Expression)
  ElementdefinitionDefaultvalueParameterdefinition(
    default_value: Parameterdefinition,
  )
  ElementdefinitionDefaultvalueRelatedartifact(default_value: Relatedartifact)
  ElementdefinitionDefaultvalueTriggerdefinition(
    default_value: Triggerdefinition,
  )
  ElementdefinitionDefaultvalueUsagecontext(default_value: Usagecontext)
  ElementdefinitionDefaultvalueDosage(default_value: Dosage)
}

pub fn elementdefinition_defaultvalue_to_json(
  elt: ElementdefinitionDefaultvalue,
) -> Json {
  case elt {
    ElementdefinitionDefaultvalueBase64binary(v) -> json.string(v)
    ElementdefinitionDefaultvalueBoolean(v) -> json.bool(v)
    ElementdefinitionDefaultvalueCanonical(v) -> json.string(v)
    ElementdefinitionDefaultvalueCode(v) -> json.string(v)
    ElementdefinitionDefaultvalueDate(v) -> json.string(v)
    ElementdefinitionDefaultvalueDatetime(v) -> json.string(v)
    ElementdefinitionDefaultvalueDecimal(v) -> json.float(v)
    ElementdefinitionDefaultvalueId(v) -> json.string(v)
    ElementdefinitionDefaultvalueInstant(v) -> json.string(v)
    ElementdefinitionDefaultvalueInteger(v) -> json.int(v)
    ElementdefinitionDefaultvalueMarkdown(v) -> json.string(v)
    ElementdefinitionDefaultvalueOid(v) -> json.string(v)
    ElementdefinitionDefaultvaluePositiveint(v) -> json.int(v)
    ElementdefinitionDefaultvalueString(v) -> json.string(v)
    ElementdefinitionDefaultvalueTime(v) -> json.string(v)
    ElementdefinitionDefaultvalueUnsignedint(v) -> json.int(v)
    ElementdefinitionDefaultvalueUri(v) -> json.string(v)
    ElementdefinitionDefaultvalueUrl(v) -> json.string(v)
    ElementdefinitionDefaultvalueUuid(v) -> json.string(v)
    ElementdefinitionDefaultvalueAddress(v) -> address_to_json(v)
    ElementdefinitionDefaultvalueAge(v) -> age_to_json(v)
    ElementdefinitionDefaultvalueAnnotation(v) -> annotation_to_json(v)
    ElementdefinitionDefaultvalueAttachment(v) -> attachment_to_json(v)
    ElementdefinitionDefaultvalueCodeableconcept(v) ->
      codeableconcept_to_json(v)
    ElementdefinitionDefaultvalueCodeablereference(v) ->
      codeablereference_to_json(v)
    ElementdefinitionDefaultvalueCoding(v) -> coding_to_json(v)
    ElementdefinitionDefaultvalueContactpoint(v) -> contactpoint_to_json(v)
    ElementdefinitionDefaultvalueCount(v) -> count_to_json(v)
    ElementdefinitionDefaultvalueDistance(v) -> distance_to_json(v)
    ElementdefinitionDefaultvalueDuration(v) -> duration_to_json(v)
    ElementdefinitionDefaultvalueHumanname(v) -> humanname_to_json(v)
    ElementdefinitionDefaultvalueIdentifier(v) -> identifier_to_json(v)
    ElementdefinitionDefaultvalueMoney(v) -> money_to_json(v)
    ElementdefinitionDefaultvaluePeriod(v) -> period_to_json(v)
    ElementdefinitionDefaultvalueQuantity(v) -> quantity_to_json(v)
    ElementdefinitionDefaultvalueRange(v) -> range_to_json(v)
    ElementdefinitionDefaultvalueRatio(v) -> ratio_to_json(v)
    ElementdefinitionDefaultvalueRatiorange(v) -> ratiorange_to_json(v)
    ElementdefinitionDefaultvalueReference(v) -> reference_to_json(v)
    ElementdefinitionDefaultvalueSampleddata(v) -> sampleddata_to_json(v)
    ElementdefinitionDefaultvalueSignature(v) -> signature_to_json(v)
    ElementdefinitionDefaultvalueTiming(v) -> timing_to_json(v)
    ElementdefinitionDefaultvalueContactdetail(v) -> contactdetail_to_json(v)
    ElementdefinitionDefaultvalueContributor(v) -> contributor_to_json(v)
    ElementdefinitionDefaultvalueDatarequirement(v) ->
      datarequirement_to_json(v)
    ElementdefinitionDefaultvalueExpression(v) -> expression_to_json(v)
    ElementdefinitionDefaultvalueParameterdefinition(v) ->
      parameterdefinition_to_json(v)
    ElementdefinitionDefaultvalueRelatedartifact(v) ->
      relatedartifact_to_json(v)
    ElementdefinitionDefaultvalueTriggerdefinition(v) ->
      triggerdefinition_to_json(v)
    ElementdefinitionDefaultvalueUsagecontext(v) -> usagecontext_to_json(v)
    ElementdefinitionDefaultvalueDosage(v) -> dosage_to_json(v)
  }
}

pub fn elementdefinition_defaultvalue_decoder() -> Decoder(
  ElementdefinitionDefaultvalue,
) {
  decode.one_of(
    decode.field("defaultValueBase64Binary", decode.string, decode.success)
      |> decode.map(ElementdefinitionDefaultvalueBase64binary),
    [
      decode.field("defaultValueBoolean", decode.bool, decode.success)
        |> decode.map(ElementdefinitionDefaultvalueBoolean),
      decode.field("defaultValueCanonical", decode.string, decode.success)
        |> decode.map(ElementdefinitionDefaultvalueCanonical),
      decode.field("defaultValueCode", decode.string, decode.success)
        |> decode.map(ElementdefinitionDefaultvalueCode),
      decode.field("defaultValueDate", decode.string, decode.success)
        |> decode.map(ElementdefinitionDefaultvalueDate),
      decode.field("defaultValueDateTime", decode.string, decode.success)
        |> decode.map(ElementdefinitionDefaultvalueDatetime),
      decode.field("defaultValueDecimal", decode.float, decode.success)
        |> decode.map(ElementdefinitionDefaultvalueDecimal),
      decode.field("defaultValueId", decode.string, decode.success)
        |> decode.map(ElementdefinitionDefaultvalueId),
      decode.field("defaultValueInstant", decode.string, decode.success)
        |> decode.map(ElementdefinitionDefaultvalueInstant),
      decode.field("defaultValueInteger", decode.int, decode.success)
        |> decode.map(ElementdefinitionDefaultvalueInteger),
      decode.field("defaultValueMarkdown", decode.string, decode.success)
        |> decode.map(ElementdefinitionDefaultvalueMarkdown),
      decode.field("defaultValueOid", decode.string, decode.success)
        |> decode.map(ElementdefinitionDefaultvalueOid),
      decode.field("defaultValuePositiveInt", decode.int, decode.success)
        |> decode.map(ElementdefinitionDefaultvaluePositiveint),
      decode.field("defaultValueString", decode.string, decode.success)
        |> decode.map(ElementdefinitionDefaultvalueString),
      decode.field("defaultValueTime", decode.string, decode.success)
        |> decode.map(ElementdefinitionDefaultvalueTime),
      decode.field("defaultValueUnsignedInt", decode.int, decode.success)
        |> decode.map(ElementdefinitionDefaultvalueUnsignedint),
      decode.field("defaultValueUri", decode.string, decode.success)
        |> decode.map(ElementdefinitionDefaultvalueUri),
      decode.field("defaultValueUrl", decode.string, decode.success)
        |> decode.map(ElementdefinitionDefaultvalueUrl),
      decode.field("defaultValueUuid", decode.string, decode.success)
        |> decode.map(ElementdefinitionDefaultvalueUuid),
      decode.field("defaultValueAddress", address_decoder(), decode.success)
        |> decode.map(ElementdefinitionDefaultvalueAddress),
      decode.field("defaultValueAge", age_decoder(), decode.success)
        |> decode.map(ElementdefinitionDefaultvalueAge),
      decode.field(
        "defaultValueAnnotation",
        annotation_decoder(),
        decode.success,
      )
        |> decode.map(ElementdefinitionDefaultvalueAnnotation),
      decode.field(
        "defaultValueAttachment",
        attachment_decoder(),
        decode.success,
      )
        |> decode.map(ElementdefinitionDefaultvalueAttachment),
      decode.field(
        "defaultValueCodeableConcept",
        codeableconcept_decoder(),
        decode.success,
      )
        |> decode.map(ElementdefinitionDefaultvalueCodeableconcept),
      decode.field(
        "defaultValueCodeableReference",
        codeablereference_decoder(),
        decode.success,
      )
        |> decode.map(ElementdefinitionDefaultvalueCodeablereference),
      decode.field("defaultValueCoding", coding_decoder(), decode.success)
        |> decode.map(ElementdefinitionDefaultvalueCoding),
      decode.field(
        "defaultValueContactPoint",
        contactpoint_decoder(),
        decode.success,
      )
        |> decode.map(ElementdefinitionDefaultvalueContactpoint),
      decode.field("defaultValueCount", count_decoder(), decode.success)
        |> decode.map(ElementdefinitionDefaultvalueCount),
      decode.field("defaultValueDistance", distance_decoder(), decode.success)
        |> decode.map(ElementdefinitionDefaultvalueDistance),
      decode.field("defaultValueDuration", duration_decoder(), decode.success)
        |> decode.map(ElementdefinitionDefaultvalueDuration),
      decode.field("defaultValueHumanName", humanname_decoder(), decode.success)
        |> decode.map(ElementdefinitionDefaultvalueHumanname),
      decode.field(
        "defaultValueIdentifier",
        identifier_decoder(),
        decode.success,
      )
        |> decode.map(ElementdefinitionDefaultvalueIdentifier),
      decode.field("defaultValueMoney", money_decoder(), decode.success)
        |> decode.map(ElementdefinitionDefaultvalueMoney),
      decode.field("defaultValuePeriod", period_decoder(), decode.success)
        |> decode.map(ElementdefinitionDefaultvaluePeriod),
      decode.field("defaultValueQuantity", quantity_decoder(), decode.success)
        |> decode.map(ElementdefinitionDefaultvalueQuantity),
      decode.field("defaultValueRange", range_decoder(), decode.success)
        |> decode.map(ElementdefinitionDefaultvalueRange),
      decode.field("defaultValueRatio", ratio_decoder(), decode.success)
        |> decode.map(ElementdefinitionDefaultvalueRatio),
      decode.field(
        "defaultValueRatioRange",
        ratiorange_decoder(),
        decode.success,
      )
        |> decode.map(ElementdefinitionDefaultvalueRatiorange),
      decode.field("defaultValueReference", reference_decoder(), decode.success)
        |> decode.map(ElementdefinitionDefaultvalueReference),
      decode.field(
        "defaultValueSampledData",
        sampleddata_decoder(),
        decode.success,
      )
        |> decode.map(ElementdefinitionDefaultvalueSampleddata),
      decode.field("defaultValueSignature", signature_decoder(), decode.success)
        |> decode.map(ElementdefinitionDefaultvalueSignature),
      decode.field("defaultValueTiming", timing_decoder(), decode.success)
        |> decode.map(ElementdefinitionDefaultvalueTiming),
      decode.field(
        "defaultValueContactDetail",
        contactdetail_decoder(),
        decode.success,
      )
        |> decode.map(ElementdefinitionDefaultvalueContactdetail),
      decode.field(
        "defaultValueContributor",
        contributor_decoder(),
        decode.success,
      )
        |> decode.map(ElementdefinitionDefaultvalueContributor),
      decode.field(
        "defaultValueDataRequirement",
        datarequirement_decoder(),
        decode.success,
      )
        |> decode.map(ElementdefinitionDefaultvalueDatarequirement),
      decode.field(
        "defaultValueExpression",
        expression_decoder(),
        decode.success,
      )
        |> decode.map(ElementdefinitionDefaultvalueExpression),
      decode.field(
        "defaultValueParameterDefinition",
        parameterdefinition_decoder(),
        decode.success,
      )
        |> decode.map(ElementdefinitionDefaultvalueParameterdefinition),
      decode.field(
        "defaultValueRelatedArtifact",
        relatedartifact_decoder(),
        decode.success,
      )
        |> decode.map(ElementdefinitionDefaultvalueRelatedartifact),
      decode.field(
        "defaultValueTriggerDefinition",
        triggerdefinition_decoder(),
        decode.success,
      )
        |> decode.map(ElementdefinitionDefaultvalueTriggerdefinition),
      decode.field(
        "defaultValueUsageContext",
        usagecontext_decoder(),
        decode.success,
      )
        |> decode.map(ElementdefinitionDefaultvalueUsagecontext),
      decode.field("defaultValueDosage", dosage_decoder(), decode.success)
        |> decode.map(ElementdefinitionDefaultvalueDosage),
    ],
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ElementDefinition#resource
pub type ElementdefinitionFixed {
  ElementdefinitionFixedBase64binary(fixed: String)
  ElementdefinitionFixedBoolean(fixed: Bool)
  ElementdefinitionFixedCanonical(fixed: String)
  ElementdefinitionFixedCode(fixed: String)
  ElementdefinitionFixedDate(fixed: String)
  ElementdefinitionFixedDatetime(fixed: String)
  ElementdefinitionFixedDecimal(fixed: Float)
  ElementdefinitionFixedId(fixed: String)
  ElementdefinitionFixedInstant(fixed: String)
  ElementdefinitionFixedInteger(fixed: Int)
  ElementdefinitionFixedMarkdown(fixed: String)
  ElementdefinitionFixedOid(fixed: String)
  ElementdefinitionFixedPositiveint(fixed: Int)
  ElementdefinitionFixedString(fixed: String)
  ElementdefinitionFixedTime(fixed: String)
  ElementdefinitionFixedUnsignedint(fixed: Int)
  ElementdefinitionFixedUri(fixed: String)
  ElementdefinitionFixedUrl(fixed: String)
  ElementdefinitionFixedUuid(fixed: String)
  ElementdefinitionFixedAddress(fixed: Address)
  ElementdefinitionFixedAge(fixed: Age)
  ElementdefinitionFixedAnnotation(fixed: Annotation)
  ElementdefinitionFixedAttachment(fixed: Attachment)
  ElementdefinitionFixedCodeableconcept(fixed: Codeableconcept)
  ElementdefinitionFixedCodeablereference(fixed: Codeablereference)
  ElementdefinitionFixedCoding(fixed: Coding)
  ElementdefinitionFixedContactpoint(fixed: Contactpoint)
  ElementdefinitionFixedCount(fixed: Count)
  ElementdefinitionFixedDistance(fixed: Distance)
  ElementdefinitionFixedDuration(fixed: Duration)
  ElementdefinitionFixedHumanname(fixed: Humanname)
  ElementdefinitionFixedIdentifier(fixed: Identifier)
  ElementdefinitionFixedMoney(fixed: Money)
  ElementdefinitionFixedPeriod(fixed: Period)
  ElementdefinitionFixedQuantity(fixed: Quantity)
  ElementdefinitionFixedRange(fixed: Range)
  ElementdefinitionFixedRatio(fixed: Ratio)
  ElementdefinitionFixedRatiorange(fixed: Ratiorange)
  ElementdefinitionFixedReference(fixed: Reference)
  ElementdefinitionFixedSampleddata(fixed: Sampleddata)
  ElementdefinitionFixedSignature(fixed: Signature)
  ElementdefinitionFixedTiming(fixed: Timing)
  ElementdefinitionFixedContactdetail(fixed: Contactdetail)
  ElementdefinitionFixedContributor(fixed: Contributor)
  ElementdefinitionFixedDatarequirement(fixed: Datarequirement)
  ElementdefinitionFixedExpression(fixed: Expression)
  ElementdefinitionFixedParameterdefinition(fixed: Parameterdefinition)
  ElementdefinitionFixedRelatedartifact(fixed: Relatedartifact)
  ElementdefinitionFixedTriggerdefinition(fixed: Triggerdefinition)
  ElementdefinitionFixedUsagecontext(fixed: Usagecontext)
  ElementdefinitionFixedDosage(fixed: Dosage)
}

pub fn elementdefinition_fixed_to_json(elt: ElementdefinitionFixed) -> Json {
  case elt {
    ElementdefinitionFixedBase64binary(v) -> json.string(v)
    ElementdefinitionFixedBoolean(v) -> json.bool(v)
    ElementdefinitionFixedCanonical(v) -> json.string(v)
    ElementdefinitionFixedCode(v) -> json.string(v)
    ElementdefinitionFixedDate(v) -> json.string(v)
    ElementdefinitionFixedDatetime(v) -> json.string(v)
    ElementdefinitionFixedDecimal(v) -> json.float(v)
    ElementdefinitionFixedId(v) -> json.string(v)
    ElementdefinitionFixedInstant(v) -> json.string(v)
    ElementdefinitionFixedInteger(v) -> json.int(v)
    ElementdefinitionFixedMarkdown(v) -> json.string(v)
    ElementdefinitionFixedOid(v) -> json.string(v)
    ElementdefinitionFixedPositiveint(v) -> json.int(v)
    ElementdefinitionFixedString(v) -> json.string(v)
    ElementdefinitionFixedTime(v) -> json.string(v)
    ElementdefinitionFixedUnsignedint(v) -> json.int(v)
    ElementdefinitionFixedUri(v) -> json.string(v)
    ElementdefinitionFixedUrl(v) -> json.string(v)
    ElementdefinitionFixedUuid(v) -> json.string(v)
    ElementdefinitionFixedAddress(v) -> address_to_json(v)
    ElementdefinitionFixedAge(v) -> age_to_json(v)
    ElementdefinitionFixedAnnotation(v) -> annotation_to_json(v)
    ElementdefinitionFixedAttachment(v) -> attachment_to_json(v)
    ElementdefinitionFixedCodeableconcept(v) -> codeableconcept_to_json(v)
    ElementdefinitionFixedCodeablereference(v) -> codeablereference_to_json(v)
    ElementdefinitionFixedCoding(v) -> coding_to_json(v)
    ElementdefinitionFixedContactpoint(v) -> contactpoint_to_json(v)
    ElementdefinitionFixedCount(v) -> count_to_json(v)
    ElementdefinitionFixedDistance(v) -> distance_to_json(v)
    ElementdefinitionFixedDuration(v) -> duration_to_json(v)
    ElementdefinitionFixedHumanname(v) -> humanname_to_json(v)
    ElementdefinitionFixedIdentifier(v) -> identifier_to_json(v)
    ElementdefinitionFixedMoney(v) -> money_to_json(v)
    ElementdefinitionFixedPeriod(v) -> period_to_json(v)
    ElementdefinitionFixedQuantity(v) -> quantity_to_json(v)
    ElementdefinitionFixedRange(v) -> range_to_json(v)
    ElementdefinitionFixedRatio(v) -> ratio_to_json(v)
    ElementdefinitionFixedRatiorange(v) -> ratiorange_to_json(v)
    ElementdefinitionFixedReference(v) -> reference_to_json(v)
    ElementdefinitionFixedSampleddata(v) -> sampleddata_to_json(v)
    ElementdefinitionFixedSignature(v) -> signature_to_json(v)
    ElementdefinitionFixedTiming(v) -> timing_to_json(v)
    ElementdefinitionFixedContactdetail(v) -> contactdetail_to_json(v)
    ElementdefinitionFixedContributor(v) -> contributor_to_json(v)
    ElementdefinitionFixedDatarequirement(v) -> datarequirement_to_json(v)
    ElementdefinitionFixedExpression(v) -> expression_to_json(v)
    ElementdefinitionFixedParameterdefinition(v) ->
      parameterdefinition_to_json(v)
    ElementdefinitionFixedRelatedartifact(v) -> relatedartifact_to_json(v)
    ElementdefinitionFixedTriggerdefinition(v) -> triggerdefinition_to_json(v)
    ElementdefinitionFixedUsagecontext(v) -> usagecontext_to_json(v)
    ElementdefinitionFixedDosage(v) -> dosage_to_json(v)
  }
}

pub fn elementdefinition_fixed_decoder() -> Decoder(ElementdefinitionFixed) {
  decode.one_of(
    decode.field("fixedBase64Binary", decode.string, decode.success)
      |> decode.map(ElementdefinitionFixedBase64binary),
    [
      decode.field("fixedBoolean", decode.bool, decode.success)
        |> decode.map(ElementdefinitionFixedBoolean),
      decode.field("fixedCanonical", decode.string, decode.success)
        |> decode.map(ElementdefinitionFixedCanonical),
      decode.field("fixedCode", decode.string, decode.success)
        |> decode.map(ElementdefinitionFixedCode),
      decode.field("fixedDate", decode.string, decode.success)
        |> decode.map(ElementdefinitionFixedDate),
      decode.field("fixedDateTime", decode.string, decode.success)
        |> decode.map(ElementdefinitionFixedDatetime),
      decode.field("fixedDecimal", decode.float, decode.success)
        |> decode.map(ElementdefinitionFixedDecimal),
      decode.field("fixedId", decode.string, decode.success)
        |> decode.map(ElementdefinitionFixedId),
      decode.field("fixedInstant", decode.string, decode.success)
        |> decode.map(ElementdefinitionFixedInstant),
      decode.field("fixedInteger", decode.int, decode.success)
        |> decode.map(ElementdefinitionFixedInteger),
      decode.field("fixedMarkdown", decode.string, decode.success)
        |> decode.map(ElementdefinitionFixedMarkdown),
      decode.field("fixedOid", decode.string, decode.success)
        |> decode.map(ElementdefinitionFixedOid),
      decode.field("fixedPositiveInt", decode.int, decode.success)
        |> decode.map(ElementdefinitionFixedPositiveint),
      decode.field("fixedString", decode.string, decode.success)
        |> decode.map(ElementdefinitionFixedString),
      decode.field("fixedTime", decode.string, decode.success)
        |> decode.map(ElementdefinitionFixedTime),
      decode.field("fixedUnsignedInt", decode.int, decode.success)
        |> decode.map(ElementdefinitionFixedUnsignedint),
      decode.field("fixedUri", decode.string, decode.success)
        |> decode.map(ElementdefinitionFixedUri),
      decode.field("fixedUrl", decode.string, decode.success)
        |> decode.map(ElementdefinitionFixedUrl),
      decode.field("fixedUuid", decode.string, decode.success)
        |> decode.map(ElementdefinitionFixedUuid),
      decode.field("fixedAddress", address_decoder(), decode.success)
        |> decode.map(ElementdefinitionFixedAddress),
      decode.field("fixedAge", age_decoder(), decode.success)
        |> decode.map(ElementdefinitionFixedAge),
      decode.field("fixedAnnotation", annotation_decoder(), decode.success)
        |> decode.map(ElementdefinitionFixedAnnotation),
      decode.field("fixedAttachment", attachment_decoder(), decode.success)
        |> decode.map(ElementdefinitionFixedAttachment),
      decode.field(
        "fixedCodeableConcept",
        codeableconcept_decoder(),
        decode.success,
      )
        |> decode.map(ElementdefinitionFixedCodeableconcept),
      decode.field(
        "fixedCodeableReference",
        codeablereference_decoder(),
        decode.success,
      )
        |> decode.map(ElementdefinitionFixedCodeablereference),
      decode.field("fixedCoding", coding_decoder(), decode.success)
        |> decode.map(ElementdefinitionFixedCoding),
      decode.field("fixedContactPoint", contactpoint_decoder(), decode.success)
        |> decode.map(ElementdefinitionFixedContactpoint),
      decode.field("fixedCount", count_decoder(), decode.success)
        |> decode.map(ElementdefinitionFixedCount),
      decode.field("fixedDistance", distance_decoder(), decode.success)
        |> decode.map(ElementdefinitionFixedDistance),
      decode.field("fixedDuration", duration_decoder(), decode.success)
        |> decode.map(ElementdefinitionFixedDuration),
      decode.field("fixedHumanName", humanname_decoder(), decode.success)
        |> decode.map(ElementdefinitionFixedHumanname),
      decode.field("fixedIdentifier", identifier_decoder(), decode.success)
        |> decode.map(ElementdefinitionFixedIdentifier),
      decode.field("fixedMoney", money_decoder(), decode.success)
        |> decode.map(ElementdefinitionFixedMoney),
      decode.field("fixedPeriod", period_decoder(), decode.success)
        |> decode.map(ElementdefinitionFixedPeriod),
      decode.field("fixedQuantity", quantity_decoder(), decode.success)
        |> decode.map(ElementdefinitionFixedQuantity),
      decode.field("fixedRange", range_decoder(), decode.success)
        |> decode.map(ElementdefinitionFixedRange),
      decode.field("fixedRatio", ratio_decoder(), decode.success)
        |> decode.map(ElementdefinitionFixedRatio),
      decode.field("fixedRatioRange", ratiorange_decoder(), decode.success)
        |> decode.map(ElementdefinitionFixedRatiorange),
      decode.field("fixedReference", reference_decoder(), decode.success)
        |> decode.map(ElementdefinitionFixedReference),
      decode.field("fixedSampledData", sampleddata_decoder(), decode.success)
        |> decode.map(ElementdefinitionFixedSampleddata),
      decode.field("fixedSignature", signature_decoder(), decode.success)
        |> decode.map(ElementdefinitionFixedSignature),
      decode.field("fixedTiming", timing_decoder(), decode.success)
        |> decode.map(ElementdefinitionFixedTiming),
      decode.field(
        "fixedContactDetail",
        contactdetail_decoder(),
        decode.success,
      )
        |> decode.map(ElementdefinitionFixedContactdetail),
      decode.field("fixedContributor", contributor_decoder(), decode.success)
        |> decode.map(ElementdefinitionFixedContributor),
      decode.field(
        "fixedDataRequirement",
        datarequirement_decoder(),
        decode.success,
      )
        |> decode.map(ElementdefinitionFixedDatarequirement),
      decode.field("fixedExpression", expression_decoder(), decode.success)
        |> decode.map(ElementdefinitionFixedExpression),
      decode.field(
        "fixedParameterDefinition",
        parameterdefinition_decoder(),
        decode.success,
      )
        |> decode.map(ElementdefinitionFixedParameterdefinition),
      decode.field(
        "fixedRelatedArtifact",
        relatedartifact_decoder(),
        decode.success,
      )
        |> decode.map(ElementdefinitionFixedRelatedartifact),
      decode.field(
        "fixedTriggerDefinition",
        triggerdefinition_decoder(),
        decode.success,
      )
        |> decode.map(ElementdefinitionFixedTriggerdefinition),
      decode.field("fixedUsageContext", usagecontext_decoder(), decode.success)
        |> decode.map(ElementdefinitionFixedUsagecontext),
      decode.field("fixedDosage", dosage_decoder(), decode.success)
        |> decode.map(ElementdefinitionFixedDosage),
    ],
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ElementDefinition#resource
pub type ElementdefinitionPattern {
  ElementdefinitionPatternBase64binary(pattern: String)
  ElementdefinitionPatternBoolean(pattern: Bool)
  ElementdefinitionPatternCanonical(pattern: String)
  ElementdefinitionPatternCode(pattern: String)
  ElementdefinitionPatternDate(pattern: String)
  ElementdefinitionPatternDatetime(pattern: String)
  ElementdefinitionPatternDecimal(pattern: Float)
  ElementdefinitionPatternId(pattern: String)
  ElementdefinitionPatternInstant(pattern: String)
  ElementdefinitionPatternInteger(pattern: Int)
  ElementdefinitionPatternMarkdown(pattern: String)
  ElementdefinitionPatternOid(pattern: String)
  ElementdefinitionPatternPositiveint(pattern: Int)
  ElementdefinitionPatternString(pattern: String)
  ElementdefinitionPatternTime(pattern: String)
  ElementdefinitionPatternUnsignedint(pattern: Int)
  ElementdefinitionPatternUri(pattern: String)
  ElementdefinitionPatternUrl(pattern: String)
  ElementdefinitionPatternUuid(pattern: String)
  ElementdefinitionPatternAddress(pattern: Address)
  ElementdefinitionPatternAge(pattern: Age)
  ElementdefinitionPatternAnnotation(pattern: Annotation)
  ElementdefinitionPatternAttachment(pattern: Attachment)
  ElementdefinitionPatternCodeableconcept(pattern: Codeableconcept)
  ElementdefinitionPatternCodeablereference(pattern: Codeablereference)
  ElementdefinitionPatternCoding(pattern: Coding)
  ElementdefinitionPatternContactpoint(pattern: Contactpoint)
  ElementdefinitionPatternCount(pattern: Count)
  ElementdefinitionPatternDistance(pattern: Distance)
  ElementdefinitionPatternDuration(pattern: Duration)
  ElementdefinitionPatternHumanname(pattern: Humanname)
  ElementdefinitionPatternIdentifier(pattern: Identifier)
  ElementdefinitionPatternMoney(pattern: Money)
  ElementdefinitionPatternPeriod(pattern: Period)
  ElementdefinitionPatternQuantity(pattern: Quantity)
  ElementdefinitionPatternRange(pattern: Range)
  ElementdefinitionPatternRatio(pattern: Ratio)
  ElementdefinitionPatternRatiorange(pattern: Ratiorange)
  ElementdefinitionPatternReference(pattern: Reference)
  ElementdefinitionPatternSampleddata(pattern: Sampleddata)
  ElementdefinitionPatternSignature(pattern: Signature)
  ElementdefinitionPatternTiming(pattern: Timing)
  ElementdefinitionPatternContactdetail(pattern: Contactdetail)
  ElementdefinitionPatternContributor(pattern: Contributor)
  ElementdefinitionPatternDatarequirement(pattern: Datarequirement)
  ElementdefinitionPatternExpression(pattern: Expression)
  ElementdefinitionPatternParameterdefinition(pattern: Parameterdefinition)
  ElementdefinitionPatternRelatedartifact(pattern: Relatedartifact)
  ElementdefinitionPatternTriggerdefinition(pattern: Triggerdefinition)
  ElementdefinitionPatternUsagecontext(pattern: Usagecontext)
  ElementdefinitionPatternDosage(pattern: Dosage)
}

pub fn elementdefinition_pattern_to_json(elt: ElementdefinitionPattern) -> Json {
  case elt {
    ElementdefinitionPatternBase64binary(v) -> json.string(v)
    ElementdefinitionPatternBoolean(v) -> json.bool(v)
    ElementdefinitionPatternCanonical(v) -> json.string(v)
    ElementdefinitionPatternCode(v) -> json.string(v)
    ElementdefinitionPatternDate(v) -> json.string(v)
    ElementdefinitionPatternDatetime(v) -> json.string(v)
    ElementdefinitionPatternDecimal(v) -> json.float(v)
    ElementdefinitionPatternId(v) -> json.string(v)
    ElementdefinitionPatternInstant(v) -> json.string(v)
    ElementdefinitionPatternInteger(v) -> json.int(v)
    ElementdefinitionPatternMarkdown(v) -> json.string(v)
    ElementdefinitionPatternOid(v) -> json.string(v)
    ElementdefinitionPatternPositiveint(v) -> json.int(v)
    ElementdefinitionPatternString(v) -> json.string(v)
    ElementdefinitionPatternTime(v) -> json.string(v)
    ElementdefinitionPatternUnsignedint(v) -> json.int(v)
    ElementdefinitionPatternUri(v) -> json.string(v)
    ElementdefinitionPatternUrl(v) -> json.string(v)
    ElementdefinitionPatternUuid(v) -> json.string(v)
    ElementdefinitionPatternAddress(v) -> address_to_json(v)
    ElementdefinitionPatternAge(v) -> age_to_json(v)
    ElementdefinitionPatternAnnotation(v) -> annotation_to_json(v)
    ElementdefinitionPatternAttachment(v) -> attachment_to_json(v)
    ElementdefinitionPatternCodeableconcept(v) -> codeableconcept_to_json(v)
    ElementdefinitionPatternCodeablereference(v) -> codeablereference_to_json(v)
    ElementdefinitionPatternCoding(v) -> coding_to_json(v)
    ElementdefinitionPatternContactpoint(v) -> contactpoint_to_json(v)
    ElementdefinitionPatternCount(v) -> count_to_json(v)
    ElementdefinitionPatternDistance(v) -> distance_to_json(v)
    ElementdefinitionPatternDuration(v) -> duration_to_json(v)
    ElementdefinitionPatternHumanname(v) -> humanname_to_json(v)
    ElementdefinitionPatternIdentifier(v) -> identifier_to_json(v)
    ElementdefinitionPatternMoney(v) -> money_to_json(v)
    ElementdefinitionPatternPeriod(v) -> period_to_json(v)
    ElementdefinitionPatternQuantity(v) -> quantity_to_json(v)
    ElementdefinitionPatternRange(v) -> range_to_json(v)
    ElementdefinitionPatternRatio(v) -> ratio_to_json(v)
    ElementdefinitionPatternRatiorange(v) -> ratiorange_to_json(v)
    ElementdefinitionPatternReference(v) -> reference_to_json(v)
    ElementdefinitionPatternSampleddata(v) -> sampleddata_to_json(v)
    ElementdefinitionPatternSignature(v) -> signature_to_json(v)
    ElementdefinitionPatternTiming(v) -> timing_to_json(v)
    ElementdefinitionPatternContactdetail(v) -> contactdetail_to_json(v)
    ElementdefinitionPatternContributor(v) -> contributor_to_json(v)
    ElementdefinitionPatternDatarequirement(v) -> datarequirement_to_json(v)
    ElementdefinitionPatternExpression(v) -> expression_to_json(v)
    ElementdefinitionPatternParameterdefinition(v) ->
      parameterdefinition_to_json(v)
    ElementdefinitionPatternRelatedartifact(v) -> relatedartifact_to_json(v)
    ElementdefinitionPatternTriggerdefinition(v) -> triggerdefinition_to_json(v)
    ElementdefinitionPatternUsagecontext(v) -> usagecontext_to_json(v)
    ElementdefinitionPatternDosage(v) -> dosage_to_json(v)
  }
}

pub fn elementdefinition_pattern_decoder() -> Decoder(ElementdefinitionPattern) {
  decode.one_of(
    decode.field("patternBase64Binary", decode.string, decode.success)
      |> decode.map(ElementdefinitionPatternBase64binary),
    [
      decode.field("patternBoolean", decode.bool, decode.success)
        |> decode.map(ElementdefinitionPatternBoolean),
      decode.field("patternCanonical", decode.string, decode.success)
        |> decode.map(ElementdefinitionPatternCanonical),
      decode.field("patternCode", decode.string, decode.success)
        |> decode.map(ElementdefinitionPatternCode),
      decode.field("patternDate", decode.string, decode.success)
        |> decode.map(ElementdefinitionPatternDate),
      decode.field("patternDateTime", decode.string, decode.success)
        |> decode.map(ElementdefinitionPatternDatetime),
      decode.field("patternDecimal", decode.float, decode.success)
        |> decode.map(ElementdefinitionPatternDecimal),
      decode.field("patternId", decode.string, decode.success)
        |> decode.map(ElementdefinitionPatternId),
      decode.field("patternInstant", decode.string, decode.success)
        |> decode.map(ElementdefinitionPatternInstant),
      decode.field("patternInteger", decode.int, decode.success)
        |> decode.map(ElementdefinitionPatternInteger),
      decode.field("patternMarkdown", decode.string, decode.success)
        |> decode.map(ElementdefinitionPatternMarkdown),
      decode.field("patternOid", decode.string, decode.success)
        |> decode.map(ElementdefinitionPatternOid),
      decode.field("patternPositiveInt", decode.int, decode.success)
        |> decode.map(ElementdefinitionPatternPositiveint),
      decode.field("patternString", decode.string, decode.success)
        |> decode.map(ElementdefinitionPatternString),
      decode.field("patternTime", decode.string, decode.success)
        |> decode.map(ElementdefinitionPatternTime),
      decode.field("patternUnsignedInt", decode.int, decode.success)
        |> decode.map(ElementdefinitionPatternUnsignedint),
      decode.field("patternUri", decode.string, decode.success)
        |> decode.map(ElementdefinitionPatternUri),
      decode.field("patternUrl", decode.string, decode.success)
        |> decode.map(ElementdefinitionPatternUrl),
      decode.field("patternUuid", decode.string, decode.success)
        |> decode.map(ElementdefinitionPatternUuid),
      decode.field("patternAddress", address_decoder(), decode.success)
        |> decode.map(ElementdefinitionPatternAddress),
      decode.field("patternAge", age_decoder(), decode.success)
        |> decode.map(ElementdefinitionPatternAge),
      decode.field("patternAnnotation", annotation_decoder(), decode.success)
        |> decode.map(ElementdefinitionPatternAnnotation),
      decode.field("patternAttachment", attachment_decoder(), decode.success)
        |> decode.map(ElementdefinitionPatternAttachment),
      decode.field(
        "patternCodeableConcept",
        codeableconcept_decoder(),
        decode.success,
      )
        |> decode.map(ElementdefinitionPatternCodeableconcept),
      decode.field(
        "patternCodeableReference",
        codeablereference_decoder(),
        decode.success,
      )
        |> decode.map(ElementdefinitionPatternCodeablereference),
      decode.field("patternCoding", coding_decoder(), decode.success)
        |> decode.map(ElementdefinitionPatternCoding),
      decode.field(
        "patternContactPoint",
        contactpoint_decoder(),
        decode.success,
      )
        |> decode.map(ElementdefinitionPatternContactpoint),
      decode.field("patternCount", count_decoder(), decode.success)
        |> decode.map(ElementdefinitionPatternCount),
      decode.field("patternDistance", distance_decoder(), decode.success)
        |> decode.map(ElementdefinitionPatternDistance),
      decode.field("patternDuration", duration_decoder(), decode.success)
        |> decode.map(ElementdefinitionPatternDuration),
      decode.field("patternHumanName", humanname_decoder(), decode.success)
        |> decode.map(ElementdefinitionPatternHumanname),
      decode.field("patternIdentifier", identifier_decoder(), decode.success)
        |> decode.map(ElementdefinitionPatternIdentifier),
      decode.field("patternMoney", money_decoder(), decode.success)
        |> decode.map(ElementdefinitionPatternMoney),
      decode.field("patternPeriod", period_decoder(), decode.success)
        |> decode.map(ElementdefinitionPatternPeriod),
      decode.field("patternQuantity", quantity_decoder(), decode.success)
        |> decode.map(ElementdefinitionPatternQuantity),
      decode.field("patternRange", range_decoder(), decode.success)
        |> decode.map(ElementdefinitionPatternRange),
      decode.field("patternRatio", ratio_decoder(), decode.success)
        |> decode.map(ElementdefinitionPatternRatio),
      decode.field("patternRatioRange", ratiorange_decoder(), decode.success)
        |> decode.map(ElementdefinitionPatternRatiorange),
      decode.field("patternReference", reference_decoder(), decode.success)
        |> decode.map(ElementdefinitionPatternReference),
      decode.field("patternSampledData", sampleddata_decoder(), decode.success)
        |> decode.map(ElementdefinitionPatternSampleddata),
      decode.field("patternSignature", signature_decoder(), decode.success)
        |> decode.map(ElementdefinitionPatternSignature),
      decode.field("patternTiming", timing_decoder(), decode.success)
        |> decode.map(ElementdefinitionPatternTiming),
      decode.field(
        "patternContactDetail",
        contactdetail_decoder(),
        decode.success,
      )
        |> decode.map(ElementdefinitionPatternContactdetail),
      decode.field("patternContributor", contributor_decoder(), decode.success)
        |> decode.map(ElementdefinitionPatternContributor),
      decode.field(
        "patternDataRequirement",
        datarequirement_decoder(),
        decode.success,
      )
        |> decode.map(ElementdefinitionPatternDatarequirement),
      decode.field("patternExpression", expression_decoder(), decode.success)
        |> decode.map(ElementdefinitionPatternExpression),
      decode.field(
        "patternParameterDefinition",
        parameterdefinition_decoder(),
        decode.success,
      )
        |> decode.map(ElementdefinitionPatternParameterdefinition),
      decode.field(
        "patternRelatedArtifact",
        relatedartifact_decoder(),
        decode.success,
      )
        |> decode.map(ElementdefinitionPatternRelatedartifact),
      decode.field(
        "patternTriggerDefinition",
        triggerdefinition_decoder(),
        decode.success,
      )
        |> decode.map(ElementdefinitionPatternTriggerdefinition),
      decode.field(
        "patternUsageContext",
        usagecontext_decoder(),
        decode.success,
      )
        |> decode.map(ElementdefinitionPatternUsagecontext),
      decode.field("patternDosage", dosage_decoder(), decode.success)
        |> decode.map(ElementdefinitionPatternDosage),
    ],
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ElementDefinition#resource
pub type ElementdefinitionMinvalue {
  ElementdefinitionMinvalueDate(min_value: String)
  ElementdefinitionMinvalueDatetime(min_value: String)
  ElementdefinitionMinvalueInstant(min_value: String)
  ElementdefinitionMinvalueTime(min_value: String)
  ElementdefinitionMinvalueDecimal(min_value: Float)
  ElementdefinitionMinvalueInteger(min_value: Int)
  ElementdefinitionMinvaluePositiveint(min_value: Int)
  ElementdefinitionMinvalueUnsignedint(min_value: Int)
  ElementdefinitionMinvalueQuantity(min_value: Quantity)
}

pub fn elementdefinition_minvalue_to_json(
  elt: ElementdefinitionMinvalue,
) -> Json {
  case elt {
    ElementdefinitionMinvalueDate(v) -> json.string(v)
    ElementdefinitionMinvalueDatetime(v) -> json.string(v)
    ElementdefinitionMinvalueInstant(v) -> json.string(v)
    ElementdefinitionMinvalueTime(v) -> json.string(v)
    ElementdefinitionMinvalueDecimal(v) -> json.float(v)
    ElementdefinitionMinvalueInteger(v) -> json.int(v)
    ElementdefinitionMinvaluePositiveint(v) -> json.int(v)
    ElementdefinitionMinvalueUnsignedint(v) -> json.int(v)
    ElementdefinitionMinvalueQuantity(v) -> quantity_to_json(v)
  }
}

pub fn elementdefinition_minvalue_decoder() -> Decoder(
  ElementdefinitionMinvalue,
) {
  decode.one_of(
    decode.field("minValueDate", decode.string, decode.success)
      |> decode.map(ElementdefinitionMinvalueDate),
    [
      decode.field("minValueDateTime", decode.string, decode.success)
        |> decode.map(ElementdefinitionMinvalueDatetime),
      decode.field("minValueInstant", decode.string, decode.success)
        |> decode.map(ElementdefinitionMinvalueInstant),
      decode.field("minValueTime", decode.string, decode.success)
        |> decode.map(ElementdefinitionMinvalueTime),
      decode.field("minValueDecimal", decode.float, decode.success)
        |> decode.map(ElementdefinitionMinvalueDecimal),
      decode.field("minValueInteger", decode.int, decode.success)
        |> decode.map(ElementdefinitionMinvalueInteger),
      decode.field("minValuePositiveInt", decode.int, decode.success)
        |> decode.map(ElementdefinitionMinvaluePositiveint),
      decode.field("minValueUnsignedInt", decode.int, decode.success)
        |> decode.map(ElementdefinitionMinvalueUnsignedint),
      decode.field("minValueQuantity", quantity_decoder(), decode.success)
        |> decode.map(ElementdefinitionMinvalueQuantity),
    ],
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ElementDefinition#resource
pub type ElementdefinitionMaxvalue {
  ElementdefinitionMaxvalueDate(max_value: String)
  ElementdefinitionMaxvalueDatetime(max_value: String)
  ElementdefinitionMaxvalueInstant(max_value: String)
  ElementdefinitionMaxvalueTime(max_value: String)
  ElementdefinitionMaxvalueDecimal(max_value: Float)
  ElementdefinitionMaxvalueInteger(max_value: Int)
  ElementdefinitionMaxvaluePositiveint(max_value: Int)
  ElementdefinitionMaxvalueUnsignedint(max_value: Int)
  ElementdefinitionMaxvalueQuantity(max_value: Quantity)
}

pub fn elementdefinition_maxvalue_to_json(
  elt: ElementdefinitionMaxvalue,
) -> Json {
  case elt {
    ElementdefinitionMaxvalueDate(v) -> json.string(v)
    ElementdefinitionMaxvalueDatetime(v) -> json.string(v)
    ElementdefinitionMaxvalueInstant(v) -> json.string(v)
    ElementdefinitionMaxvalueTime(v) -> json.string(v)
    ElementdefinitionMaxvalueDecimal(v) -> json.float(v)
    ElementdefinitionMaxvalueInteger(v) -> json.int(v)
    ElementdefinitionMaxvaluePositiveint(v) -> json.int(v)
    ElementdefinitionMaxvalueUnsignedint(v) -> json.int(v)
    ElementdefinitionMaxvalueQuantity(v) -> quantity_to_json(v)
  }
}

pub fn elementdefinition_maxvalue_decoder() -> Decoder(
  ElementdefinitionMaxvalue,
) {
  decode.one_of(
    decode.field("maxValueDate", decode.string, decode.success)
      |> decode.map(ElementdefinitionMaxvalueDate),
    [
      decode.field("maxValueDateTime", decode.string, decode.success)
        |> decode.map(ElementdefinitionMaxvalueDatetime),
      decode.field("maxValueInstant", decode.string, decode.success)
        |> decode.map(ElementdefinitionMaxvalueInstant),
      decode.field("maxValueTime", decode.string, decode.success)
        |> decode.map(ElementdefinitionMaxvalueTime),
      decode.field("maxValueDecimal", decode.float, decode.success)
        |> decode.map(ElementdefinitionMaxvalueDecimal),
      decode.field("maxValueInteger", decode.int, decode.success)
        |> decode.map(ElementdefinitionMaxvalueInteger),
      decode.field("maxValuePositiveInt", decode.int, decode.success)
        |> decode.map(ElementdefinitionMaxvaluePositiveint),
      decode.field("maxValueUnsignedInt", decode.int, decode.success)
        |> decode.map(ElementdefinitionMaxvalueUnsignedint),
      decode.field("maxValueQuantity", quantity_decoder(), decode.success)
        |> decode.map(ElementdefinitionMaxvalueQuantity),
    ],
  )
}

pub fn elementdefinition_new(path path: String) -> Elementdefinition {
  Elementdefinition(
    mapping: [],
    binding: None,
    is_summary: None,
    is_modifier_reason: None,
    is_modifier: None,
    must_support: None,
    constraint: [],
    condition: [],
    max_length: None,
    max_value: None,
    min_value: None,
    example: [],
    pattern: None,
    fixed: None,
    order_meaning: None,
    meaning_when_missing: None,
    default_value: None,
    type_: [],
    content_reference: None,
    base: None,
    max: None,
    min: None,
    alias: [],
    requirements: None,
    comment: None,
    definition: None,
    short: None,
    slicing: None,
    code: [],
    label: None,
    slice_is_constraining: None,
    slice_name: None,
    representation: [],
    path:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ElementDefinition#resource
pub type ElementdefinitionSlicing {
  ElementdefinitionSlicing(
    id: Option(String),
    extension: List(Extension),
    discriminator: List(ElementdefinitionSlicingDiscriminator),
    description: Option(String),
    ordered: Option(Bool),
    rules: r4bvaluesets.Resourceslicingrules,
  )
}

pub fn elementdefinition_slicing_new(
  rules rules: r4bvaluesets.Resourceslicingrules,
) -> ElementdefinitionSlicing {
  ElementdefinitionSlicing(
    rules:,
    ordered: None,
    description: None,
    discriminator: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ElementDefinition#resource
pub type ElementdefinitionSlicingDiscriminator {
  ElementdefinitionSlicingDiscriminator(
    id: Option(String),
    extension: List(Extension),
    type_: r4bvaluesets.Discriminatortype,
    path: String,
  )
}

pub fn elementdefinition_slicing_discriminator_new(
  path path: String,
  type_ type_: r4bvaluesets.Discriminatortype,
) -> ElementdefinitionSlicingDiscriminator {
  ElementdefinitionSlicingDiscriminator(path:, type_:, extension: [], id: None)
}

///http://hl7.org/fhir/r4b/StructureDefinition/ElementDefinition#resource
pub type ElementdefinitionBase {
  ElementdefinitionBase(
    id: Option(String),
    extension: List(Extension),
    path: String,
    min: Int,
    max: String,
  )
}

pub fn elementdefinition_base_new(
  max max: String,
  min min: Int,
  path path: String,
) -> ElementdefinitionBase {
  ElementdefinitionBase(max:, min:, path:, extension: [], id: None)
}

///http://hl7.org/fhir/r4b/StructureDefinition/ElementDefinition#resource
pub type ElementdefinitionType {
  ElementdefinitionType(
    id: Option(String),
    extension: List(Extension),
    code: String,
    profile: List(String),
    target_profile: List(String),
    aggregation: List(r4bvaluesets.Resourceaggregationmode),
    versioning: Option(r4bvaluesets.Referenceversionrules),
  )
}

pub fn elementdefinition_type_new(code code: String) -> ElementdefinitionType {
  ElementdefinitionType(
    versioning: None,
    aggregation: [],
    target_profile: [],
    profile: [],
    code:,
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ElementDefinition#resource
pub type ElementdefinitionExample {
  ElementdefinitionExample(
    id: Option(String),
    extension: List(Extension),
    label: String,
    value: ElementdefinitionExampleValue,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ElementDefinition#resource
pub type ElementdefinitionExampleValue {
  ElementdefinitionExampleValueBase64binary(value: String)
  ElementdefinitionExampleValueBoolean(value: Bool)
  ElementdefinitionExampleValueCanonical(value: String)
  ElementdefinitionExampleValueCode(value: String)
  ElementdefinitionExampleValueDate(value: String)
  ElementdefinitionExampleValueDatetime(value: String)
  ElementdefinitionExampleValueDecimal(value: Float)
  ElementdefinitionExampleValueId(value: String)
  ElementdefinitionExampleValueInstant(value: String)
  ElementdefinitionExampleValueInteger(value: Int)
  ElementdefinitionExampleValueMarkdown(value: String)
  ElementdefinitionExampleValueOid(value: String)
  ElementdefinitionExampleValuePositiveint(value: Int)
  ElementdefinitionExampleValueString(value: String)
  ElementdefinitionExampleValueTime(value: String)
  ElementdefinitionExampleValueUnsignedint(value: Int)
  ElementdefinitionExampleValueUri(value: String)
  ElementdefinitionExampleValueUrl(value: String)
  ElementdefinitionExampleValueUuid(value: String)
  ElementdefinitionExampleValueAddress(value: Address)
  ElementdefinitionExampleValueAge(value: Age)
  ElementdefinitionExampleValueAnnotation(value: Annotation)
  ElementdefinitionExampleValueAttachment(value: Attachment)
  ElementdefinitionExampleValueCodeableconcept(value: Codeableconcept)
  ElementdefinitionExampleValueCodeablereference(value: Codeablereference)
  ElementdefinitionExampleValueCoding(value: Coding)
  ElementdefinitionExampleValueContactpoint(value: Contactpoint)
  ElementdefinitionExampleValueCount(value: Count)
  ElementdefinitionExampleValueDistance(value: Distance)
  ElementdefinitionExampleValueDuration(value: Duration)
  ElementdefinitionExampleValueHumanname(value: Humanname)
  ElementdefinitionExampleValueIdentifier(value: Identifier)
  ElementdefinitionExampleValueMoney(value: Money)
  ElementdefinitionExampleValuePeriod(value: Period)
  ElementdefinitionExampleValueQuantity(value: Quantity)
  ElementdefinitionExampleValueRange(value: Range)
  ElementdefinitionExampleValueRatio(value: Ratio)
  ElementdefinitionExampleValueRatiorange(value: Ratiorange)
  ElementdefinitionExampleValueReference(value: Reference)
  ElementdefinitionExampleValueSampleddata(value: Sampleddata)
  ElementdefinitionExampleValueSignature(value: Signature)
  ElementdefinitionExampleValueTiming(value: Timing)
  ElementdefinitionExampleValueContactdetail(value: Contactdetail)
  ElementdefinitionExampleValueContributor(value: Contributor)
  ElementdefinitionExampleValueDatarequirement(value: Datarequirement)
  ElementdefinitionExampleValueExpression(value: Expression)
  ElementdefinitionExampleValueParameterdefinition(value: Parameterdefinition)
  ElementdefinitionExampleValueRelatedartifact(value: Relatedartifact)
  ElementdefinitionExampleValueTriggerdefinition(value: Triggerdefinition)
  ElementdefinitionExampleValueUsagecontext(value: Usagecontext)
  ElementdefinitionExampleValueDosage(value: Dosage)
}

pub fn elementdefinition_example_value_to_json(
  elt: ElementdefinitionExampleValue,
) -> Json {
  case elt {
    ElementdefinitionExampleValueBase64binary(v) -> json.string(v)
    ElementdefinitionExampleValueBoolean(v) -> json.bool(v)
    ElementdefinitionExampleValueCanonical(v) -> json.string(v)
    ElementdefinitionExampleValueCode(v) -> json.string(v)
    ElementdefinitionExampleValueDate(v) -> json.string(v)
    ElementdefinitionExampleValueDatetime(v) -> json.string(v)
    ElementdefinitionExampleValueDecimal(v) -> json.float(v)
    ElementdefinitionExampleValueId(v) -> json.string(v)
    ElementdefinitionExampleValueInstant(v) -> json.string(v)
    ElementdefinitionExampleValueInteger(v) -> json.int(v)
    ElementdefinitionExampleValueMarkdown(v) -> json.string(v)
    ElementdefinitionExampleValueOid(v) -> json.string(v)
    ElementdefinitionExampleValuePositiveint(v) -> json.int(v)
    ElementdefinitionExampleValueString(v) -> json.string(v)
    ElementdefinitionExampleValueTime(v) -> json.string(v)
    ElementdefinitionExampleValueUnsignedint(v) -> json.int(v)
    ElementdefinitionExampleValueUri(v) -> json.string(v)
    ElementdefinitionExampleValueUrl(v) -> json.string(v)
    ElementdefinitionExampleValueUuid(v) -> json.string(v)
    ElementdefinitionExampleValueAddress(v) -> address_to_json(v)
    ElementdefinitionExampleValueAge(v) -> age_to_json(v)
    ElementdefinitionExampleValueAnnotation(v) -> annotation_to_json(v)
    ElementdefinitionExampleValueAttachment(v) -> attachment_to_json(v)
    ElementdefinitionExampleValueCodeableconcept(v) ->
      codeableconcept_to_json(v)
    ElementdefinitionExampleValueCodeablereference(v) ->
      codeablereference_to_json(v)
    ElementdefinitionExampleValueCoding(v) -> coding_to_json(v)
    ElementdefinitionExampleValueContactpoint(v) -> contactpoint_to_json(v)
    ElementdefinitionExampleValueCount(v) -> count_to_json(v)
    ElementdefinitionExampleValueDistance(v) -> distance_to_json(v)
    ElementdefinitionExampleValueDuration(v) -> duration_to_json(v)
    ElementdefinitionExampleValueHumanname(v) -> humanname_to_json(v)
    ElementdefinitionExampleValueIdentifier(v) -> identifier_to_json(v)
    ElementdefinitionExampleValueMoney(v) -> money_to_json(v)
    ElementdefinitionExampleValuePeriod(v) -> period_to_json(v)
    ElementdefinitionExampleValueQuantity(v) -> quantity_to_json(v)
    ElementdefinitionExampleValueRange(v) -> range_to_json(v)
    ElementdefinitionExampleValueRatio(v) -> ratio_to_json(v)
    ElementdefinitionExampleValueRatiorange(v) -> ratiorange_to_json(v)
    ElementdefinitionExampleValueReference(v) -> reference_to_json(v)
    ElementdefinitionExampleValueSampleddata(v) -> sampleddata_to_json(v)
    ElementdefinitionExampleValueSignature(v) -> signature_to_json(v)
    ElementdefinitionExampleValueTiming(v) -> timing_to_json(v)
    ElementdefinitionExampleValueContactdetail(v) -> contactdetail_to_json(v)
    ElementdefinitionExampleValueContributor(v) -> contributor_to_json(v)
    ElementdefinitionExampleValueDatarequirement(v) ->
      datarequirement_to_json(v)
    ElementdefinitionExampleValueExpression(v) -> expression_to_json(v)
    ElementdefinitionExampleValueParameterdefinition(v) ->
      parameterdefinition_to_json(v)
    ElementdefinitionExampleValueRelatedartifact(v) ->
      relatedartifact_to_json(v)
    ElementdefinitionExampleValueTriggerdefinition(v) ->
      triggerdefinition_to_json(v)
    ElementdefinitionExampleValueUsagecontext(v) -> usagecontext_to_json(v)
    ElementdefinitionExampleValueDosage(v) -> dosage_to_json(v)
  }
}

pub fn elementdefinition_example_value_decoder() -> Decoder(
  ElementdefinitionExampleValue,
) {
  decode.one_of(
    decode.field("valueBase64Binary", decode.string, decode.success)
      |> decode.map(ElementdefinitionExampleValueBase64binary),
    [
      decode.field("valueBoolean", decode.bool, decode.success)
        |> decode.map(ElementdefinitionExampleValueBoolean),
      decode.field("valueCanonical", decode.string, decode.success)
        |> decode.map(ElementdefinitionExampleValueCanonical),
      decode.field("valueCode", decode.string, decode.success)
        |> decode.map(ElementdefinitionExampleValueCode),
      decode.field("valueDate", decode.string, decode.success)
        |> decode.map(ElementdefinitionExampleValueDate),
      decode.field("valueDateTime", decode.string, decode.success)
        |> decode.map(ElementdefinitionExampleValueDatetime),
      decode.field("valueDecimal", decode.float, decode.success)
        |> decode.map(ElementdefinitionExampleValueDecimal),
      decode.field("valueId", decode.string, decode.success)
        |> decode.map(ElementdefinitionExampleValueId),
      decode.field("valueInstant", decode.string, decode.success)
        |> decode.map(ElementdefinitionExampleValueInstant),
      decode.field("valueInteger", decode.int, decode.success)
        |> decode.map(ElementdefinitionExampleValueInteger),
      decode.field("valueMarkdown", decode.string, decode.success)
        |> decode.map(ElementdefinitionExampleValueMarkdown),
      decode.field("valueOid", decode.string, decode.success)
        |> decode.map(ElementdefinitionExampleValueOid),
      decode.field("valuePositiveInt", decode.int, decode.success)
        |> decode.map(ElementdefinitionExampleValuePositiveint),
      decode.field("valueString", decode.string, decode.success)
        |> decode.map(ElementdefinitionExampleValueString),
      decode.field("valueTime", decode.string, decode.success)
        |> decode.map(ElementdefinitionExampleValueTime),
      decode.field("valueUnsignedInt", decode.int, decode.success)
        |> decode.map(ElementdefinitionExampleValueUnsignedint),
      decode.field("valueUri", decode.string, decode.success)
        |> decode.map(ElementdefinitionExampleValueUri),
      decode.field("valueUrl", decode.string, decode.success)
        |> decode.map(ElementdefinitionExampleValueUrl),
      decode.field("valueUuid", decode.string, decode.success)
        |> decode.map(ElementdefinitionExampleValueUuid),
      decode.field("valueAddress", address_decoder(), decode.success)
        |> decode.map(ElementdefinitionExampleValueAddress),
      decode.field("valueAge", age_decoder(), decode.success)
        |> decode.map(ElementdefinitionExampleValueAge),
      decode.field("valueAnnotation", annotation_decoder(), decode.success)
        |> decode.map(ElementdefinitionExampleValueAnnotation),
      decode.field("valueAttachment", attachment_decoder(), decode.success)
        |> decode.map(ElementdefinitionExampleValueAttachment),
      decode.field(
        "valueCodeableConcept",
        codeableconcept_decoder(),
        decode.success,
      )
        |> decode.map(ElementdefinitionExampleValueCodeableconcept),
      decode.field(
        "valueCodeableReference",
        codeablereference_decoder(),
        decode.success,
      )
        |> decode.map(ElementdefinitionExampleValueCodeablereference),
      decode.field("valueCoding", coding_decoder(), decode.success)
        |> decode.map(ElementdefinitionExampleValueCoding),
      decode.field("valueContactPoint", contactpoint_decoder(), decode.success)
        |> decode.map(ElementdefinitionExampleValueContactpoint),
      decode.field("valueCount", count_decoder(), decode.success)
        |> decode.map(ElementdefinitionExampleValueCount),
      decode.field("valueDistance", distance_decoder(), decode.success)
        |> decode.map(ElementdefinitionExampleValueDistance),
      decode.field("valueDuration", duration_decoder(), decode.success)
        |> decode.map(ElementdefinitionExampleValueDuration),
      decode.field("valueHumanName", humanname_decoder(), decode.success)
        |> decode.map(ElementdefinitionExampleValueHumanname),
      decode.field("valueIdentifier", identifier_decoder(), decode.success)
        |> decode.map(ElementdefinitionExampleValueIdentifier),
      decode.field("valueMoney", money_decoder(), decode.success)
        |> decode.map(ElementdefinitionExampleValueMoney),
      decode.field("valuePeriod", period_decoder(), decode.success)
        |> decode.map(ElementdefinitionExampleValuePeriod),
      decode.field("valueQuantity", quantity_decoder(), decode.success)
        |> decode.map(ElementdefinitionExampleValueQuantity),
      decode.field("valueRange", range_decoder(), decode.success)
        |> decode.map(ElementdefinitionExampleValueRange),
      decode.field("valueRatio", ratio_decoder(), decode.success)
        |> decode.map(ElementdefinitionExampleValueRatio),
      decode.field("valueRatioRange", ratiorange_decoder(), decode.success)
        |> decode.map(ElementdefinitionExampleValueRatiorange),
      decode.field("valueReference", reference_decoder(), decode.success)
        |> decode.map(ElementdefinitionExampleValueReference),
      decode.field("valueSampledData", sampleddata_decoder(), decode.success)
        |> decode.map(ElementdefinitionExampleValueSampleddata),
      decode.field("valueSignature", signature_decoder(), decode.success)
        |> decode.map(ElementdefinitionExampleValueSignature),
      decode.field("valueTiming", timing_decoder(), decode.success)
        |> decode.map(ElementdefinitionExampleValueTiming),
      decode.field(
        "valueContactDetail",
        contactdetail_decoder(),
        decode.success,
      )
        |> decode.map(ElementdefinitionExampleValueContactdetail),
      decode.field("valueContributor", contributor_decoder(), decode.success)
        |> decode.map(ElementdefinitionExampleValueContributor),
      decode.field(
        "valueDataRequirement",
        datarequirement_decoder(),
        decode.success,
      )
        |> decode.map(ElementdefinitionExampleValueDatarequirement),
      decode.field("valueExpression", expression_decoder(), decode.success)
        |> decode.map(ElementdefinitionExampleValueExpression),
      decode.field(
        "valueParameterDefinition",
        parameterdefinition_decoder(),
        decode.success,
      )
        |> decode.map(ElementdefinitionExampleValueParameterdefinition),
      decode.field(
        "valueRelatedArtifact",
        relatedartifact_decoder(),
        decode.success,
      )
        |> decode.map(ElementdefinitionExampleValueRelatedartifact),
      decode.field(
        "valueTriggerDefinition",
        triggerdefinition_decoder(),
        decode.success,
      )
        |> decode.map(ElementdefinitionExampleValueTriggerdefinition),
      decode.field("valueUsageContext", usagecontext_decoder(), decode.success)
        |> decode.map(ElementdefinitionExampleValueUsagecontext),
      decode.field("valueDosage", dosage_decoder(), decode.success)
        |> decode.map(ElementdefinitionExampleValueDosage),
    ],
  )
}

pub fn elementdefinition_example_new(
  value value: ElementdefinitionExampleValue,
  label label: String,
) -> ElementdefinitionExample {
  ElementdefinitionExample(value:, label:, extension: [], id: None)
}

///http://hl7.org/fhir/r4b/StructureDefinition/ElementDefinition#resource
pub type ElementdefinitionConstraint {
  ElementdefinitionConstraint(
    id: Option(String),
    extension: List(Extension),
    key: String,
    requirements: Option(String),
    severity: r4bvaluesets.Constraintseverity,
    human: String,
    expression: Option(String),
    xpath: Option(String),
    source: Option(String),
  )
}

pub fn elementdefinition_constraint_new(
  human human: String,
  severity severity: r4bvaluesets.Constraintseverity,
  key key: String,
) -> ElementdefinitionConstraint {
  ElementdefinitionConstraint(
    source: None,
    xpath: None,
    expression: None,
    human:,
    severity:,
    requirements: None,
    key:,
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ElementDefinition#resource
pub type ElementdefinitionBinding {
  ElementdefinitionBinding(
    id: Option(String),
    extension: List(Extension),
    strength: r4bvaluesets.Bindingstrength,
    description: Option(String),
    value_set: Option(String),
  )
}

pub fn elementdefinition_binding_new(
  strength strength: r4bvaluesets.Bindingstrength,
) -> ElementdefinitionBinding {
  ElementdefinitionBinding(
    value_set: None,
    description: None,
    strength:,
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ElementDefinition#resource
pub type ElementdefinitionMapping {
  ElementdefinitionMapping(
    id: Option(String),
    extension: List(Extension),
    identity: String,
    language: Option(String),
    map: String,
    comment: Option(String),
  )
}

pub fn elementdefinition_mapping_new(
  map map: String,
  identity identity: String,
) -> ElementdefinitionMapping {
  ElementdefinitionMapping(
    comment: None,
    map:,
    language: None,
    identity:,
    extension: [],
    id: None,
  )
}

pub fn elementdefinition_mapping_to_json(
  elementdefinition_mapping: ElementdefinitionMapping,
) -> Json {
  let ElementdefinitionMapping(
    comment:,
    map:,
    language:,
    identity:,
    extension:,
    id:,
  ) = elementdefinition_mapping
  let fields = [
    #("map", json.string(map)),
    #("identity", json.string(identity)),
  ]
  let fields = case comment {
    Some(v) -> [#("comment", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn elementdefinition_mapping_decoder() -> Decoder(ElementdefinitionMapping) {
  use comment <- decode.optional_field(
    "comment",
    None,
    decode.optional(decode.string),
  )
  use map <- decode.field("map", decode.string)
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use identity <- decode.field("identity", decode.string)
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ElementdefinitionMapping(
    comment:,
    map:,
    language:,
    identity:,
    extension:,
    id:,
  ))
}

pub fn elementdefinition_binding_to_json(
  elementdefinition_binding: ElementdefinitionBinding,
) -> Json {
  let ElementdefinitionBinding(
    value_set:,
    description:,
    strength:,
    extension:,
    id:,
  ) = elementdefinition_binding
  let fields = [
    #("strength", r4bvaluesets.bindingstrength_to_json(strength)),
  ]
  let fields = case value_set {
    Some(v) -> [#("valueSet", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn elementdefinition_binding_decoder() -> Decoder(ElementdefinitionBinding) {
  use value_set <- decode.optional_field(
    "valueSet",
    None,
    decode.optional(decode.string),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use strength <- decode.field(
    "strength",
    r4bvaluesets.bindingstrength_decoder(),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ElementdefinitionBinding(
    value_set:,
    description:,
    strength:,
    extension:,
    id:,
  ))
}

pub fn elementdefinition_constraint_to_json(
  elementdefinition_constraint: ElementdefinitionConstraint,
) -> Json {
  let ElementdefinitionConstraint(
    source:,
    xpath:,
    expression:,
    human:,
    severity:,
    requirements:,
    key:,
    extension:,
    id:,
  ) = elementdefinition_constraint
  let fields = [
    #("human", json.string(human)),
    #("severity", r4bvaluesets.constraintseverity_to_json(severity)),
    #("key", json.string(key)),
  ]
  let fields = case source {
    Some(v) -> [#("source", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case xpath {
    Some(v) -> [#("xpath", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case expression {
    Some(v) -> [#("expression", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case requirements {
    Some(v) -> [#("requirements", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn elementdefinition_constraint_decoder() -> Decoder(
  ElementdefinitionConstraint,
) {
  use source <- decode.optional_field(
    "source",
    None,
    decode.optional(decode.string),
  )
  use xpath <- decode.optional_field(
    "xpath",
    None,
    decode.optional(decode.string),
  )
  use expression <- decode.optional_field(
    "expression",
    None,
    decode.optional(decode.string),
  )
  use human <- decode.field("human", decode.string)
  use severity <- decode.field(
    "severity",
    r4bvaluesets.constraintseverity_decoder(),
  )
  use requirements <- decode.optional_field(
    "requirements",
    None,
    decode.optional(decode.string),
  )
  use key <- decode.field("key", decode.string)
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ElementdefinitionConstraint(
    source:,
    xpath:,
    expression:,
    human:,
    severity:,
    requirements:,
    key:,
    extension:,
    id:,
  ))
}

pub fn elementdefinition_example_to_json(
  elementdefinition_example: ElementdefinitionExample,
) -> Json {
  let ElementdefinitionExample(value:, label:, extension:, id:) =
    elementdefinition_example
  let fields = [
    #("value", elementdefinition_example_value_to_json(value)),
    #("label", json.string(label)),
  ]
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn elementdefinition_example_decoder() -> Decoder(ElementdefinitionExample) {
  use value <- decode.then(elementdefinition_example_value_decoder())
  use label <- decode.field("label", decode.string)
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ElementdefinitionExample(value:, label:, extension:, id:))
}

pub fn elementdefinition_type_to_json(
  elementdefinition_type: ElementdefinitionType,
) -> Json {
  let ElementdefinitionType(
    versioning:,
    aggregation:,
    target_profile:,
    profile:,
    code:,
    extension:,
    id:,
  ) = elementdefinition_type
  let fields = [
    #("code", json.string(code)),
  ]
  let fields = case versioning {
    Some(v) -> [
      #("versioning", r4bvaluesets.referenceversionrules_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case aggregation {
    [] -> fields
    _ -> [
      #(
        "aggregation",
        json.array(aggregation, r4bvaluesets.resourceaggregationmode_to_json),
      ),
      ..fields
    ]
  }
  let fields = case target_profile {
    [] -> fields
    _ -> [#("targetProfile", json.array(target_profile, json.string)), ..fields]
  }
  let fields = case profile {
    [] -> fields
    _ -> [#("profile", json.array(profile, json.string)), ..fields]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn elementdefinition_type_decoder() -> Decoder(ElementdefinitionType) {
  use versioning <- decode.optional_field(
    "versioning",
    None,
    decode.optional(r4bvaluesets.referenceversionrules_decoder()),
  )
  use aggregation <- decode.optional_field(
    "aggregation",
    [],
    decode.list(r4bvaluesets.resourceaggregationmode_decoder()),
  )
  use target_profile <- decode.optional_field(
    "targetProfile",
    [],
    decode.list(decode.string),
  )
  use profile <- decode.optional_field(
    "profile",
    [],
    decode.list(decode.string),
  )
  use code <- decode.field("code", decode.string)
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ElementdefinitionType(
    versioning:,
    aggregation:,
    target_profile:,
    profile:,
    code:,
    extension:,
    id:,
  ))
}

pub fn elementdefinition_base_to_json(
  elementdefinition_base: ElementdefinitionBase,
) -> Json {
  let ElementdefinitionBase(max:, min:, path:, extension:, id:) =
    elementdefinition_base
  let fields = [
    #("max", json.string(max)),
    #("min", json.int(min)),
    #("path", json.string(path)),
  ]
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn elementdefinition_base_decoder() -> Decoder(ElementdefinitionBase) {
  use max <- decode.field("max", decode.string)
  use min <- decode.field("min", decode.int)
  use path <- decode.field("path", decode.string)
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ElementdefinitionBase(max:, min:, path:, extension:, id:))
}

pub fn elementdefinition_slicing_discriminator_to_json(
  elementdefinition_slicing_discriminator: ElementdefinitionSlicingDiscriminator,
) -> Json {
  let ElementdefinitionSlicingDiscriminator(path:, type_:, extension:, id:) =
    elementdefinition_slicing_discriminator
  let fields = [
    #("path", json.string(path)),
    #("type", r4bvaluesets.discriminatortype_to_json(type_)),
  ]
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn elementdefinition_slicing_discriminator_decoder() -> Decoder(
  ElementdefinitionSlicingDiscriminator,
) {
  use path <- decode.field("path", decode.string)
  use type_ <- decode.field("type", r4bvaluesets.discriminatortype_decoder())
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ElementdefinitionSlicingDiscriminator(
    path:,
    type_:,
    extension:,
    id:,
  ))
}

pub fn elementdefinition_slicing_to_json(
  elementdefinition_slicing: ElementdefinitionSlicing,
) -> Json {
  let ElementdefinitionSlicing(
    rules:,
    ordered:,
    description:,
    discriminator:,
    extension:,
    id:,
  ) = elementdefinition_slicing
  let fields = [
    #("rules", r4bvaluesets.resourceslicingrules_to_json(rules)),
  ]
  let fields = case ordered {
    Some(v) -> [#("ordered", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case discriminator {
    [] -> fields
    _ -> [
      #(
        "discriminator",
        json.array(
          discriminator,
          elementdefinition_slicing_discriminator_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn elementdefinition_slicing_decoder() -> Decoder(ElementdefinitionSlicing) {
  use rules <- decode.field(
    "rules",
    r4bvaluesets.resourceslicingrules_decoder(),
  )
  use ordered <- decode.optional_field(
    "ordered",
    None,
    decode.optional(decode.bool),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use discriminator <- decode.optional_field(
    "discriminator",
    [],
    decode.list(elementdefinition_slicing_discriminator_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ElementdefinitionSlicing(
    rules:,
    ordered:,
    description:,
    discriminator:,
    extension:,
    id:,
  ))
}

pub fn elementdefinition_to_json(elementdefinition: Elementdefinition) -> Json {
  let Elementdefinition(
    mapping:,
    binding:,
    is_summary:,
    is_modifier_reason:,
    is_modifier:,
    must_support:,
    constraint:,
    condition:,
    max_length:,
    max_value:,
    min_value:,
    example:,
    pattern:,
    fixed:,
    order_meaning:,
    meaning_when_missing:,
    default_value:,
    type_:,
    content_reference:,
    base:,
    max:,
    min:,
    alias:,
    requirements:,
    comment:,
    definition:,
    short:,
    slicing:,
    code:,
    label:,
    slice_is_constraining:,
    slice_name:,
    representation:,
    path:,
    modifier_extension:,
    extension:,
    id:,
  ) = elementdefinition
  let fields = [
    #("path", json.string(path)),
  ]
  let fields = case mapping {
    [] -> fields
    _ -> [
      #("mapping", json.array(mapping, elementdefinition_mapping_to_json)),
      ..fields
    ]
  }
  let fields = case binding {
    Some(v) -> [#("binding", elementdefinition_binding_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case is_summary {
    Some(v) -> [#("isSummary", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case is_modifier_reason {
    Some(v) -> [#("isModifierReason", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case is_modifier {
    Some(v) -> [#("isModifier", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case must_support {
    Some(v) -> [#("mustSupport", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case constraint {
    [] -> fields
    _ -> [
      #(
        "constraint",
        json.array(constraint, elementdefinition_constraint_to_json),
      ),
      ..fields
    ]
  }
  let fields = case condition {
    [] -> fields
    _ -> [#("condition", json.array(condition, json.string)), ..fields]
  }
  let fields = case max_length {
    Some(v) -> [#("maxLength", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case max_value {
    Some(v) -> [
      #(
        "maxValue"
          <> case v {
          ElementdefinitionMaxvalueDate(_) -> "Date"
          ElementdefinitionMaxvalueDatetime(_) -> "Datetime"
          ElementdefinitionMaxvalueInstant(_) -> "Instant"
          ElementdefinitionMaxvalueTime(_) -> "Time"
          ElementdefinitionMaxvalueDecimal(_) -> "Decimal"
          ElementdefinitionMaxvalueInteger(_) -> "Integer"
          ElementdefinitionMaxvaluePositiveint(_) -> "Positiveint"
          ElementdefinitionMaxvalueUnsignedint(_) -> "Unsignedint"
          ElementdefinitionMaxvalueQuantity(_) -> "Quantity"
        },
        elementdefinition_maxvalue_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case min_value {
    Some(v) -> [
      #(
        "minValue"
          <> case v {
          ElementdefinitionMinvalueDate(_) -> "Date"
          ElementdefinitionMinvalueDatetime(_) -> "Datetime"
          ElementdefinitionMinvalueInstant(_) -> "Instant"
          ElementdefinitionMinvalueTime(_) -> "Time"
          ElementdefinitionMinvalueDecimal(_) -> "Decimal"
          ElementdefinitionMinvalueInteger(_) -> "Integer"
          ElementdefinitionMinvaluePositiveint(_) -> "Positiveint"
          ElementdefinitionMinvalueUnsignedint(_) -> "Unsignedint"
          ElementdefinitionMinvalueQuantity(_) -> "Quantity"
        },
        elementdefinition_minvalue_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case example {
    [] -> fields
    _ -> [
      #("example", json.array(example, elementdefinition_example_to_json)),
      ..fields
    ]
  }
  let fields = case pattern {
    Some(v) -> [
      #(
        "pattern"
          <> case v {
          ElementdefinitionPatternBase64binary(_) -> "Base64binary"
          ElementdefinitionPatternBoolean(_) -> "Boolean"
          ElementdefinitionPatternCanonical(_) -> "Canonical"
          ElementdefinitionPatternCode(_) -> "Code"
          ElementdefinitionPatternDate(_) -> "Date"
          ElementdefinitionPatternDatetime(_) -> "Datetime"
          ElementdefinitionPatternDecimal(_) -> "Decimal"
          ElementdefinitionPatternId(_) -> "Id"
          ElementdefinitionPatternInstant(_) -> "Instant"
          ElementdefinitionPatternInteger(_) -> "Integer"
          ElementdefinitionPatternMarkdown(_) -> "Markdown"
          ElementdefinitionPatternOid(_) -> "Oid"
          ElementdefinitionPatternPositiveint(_) -> "Positiveint"
          ElementdefinitionPatternString(_) -> "String"
          ElementdefinitionPatternTime(_) -> "Time"
          ElementdefinitionPatternUnsignedint(_) -> "Unsignedint"
          ElementdefinitionPatternUri(_) -> "Uri"
          ElementdefinitionPatternUrl(_) -> "Url"
          ElementdefinitionPatternUuid(_) -> "Uuid"
          ElementdefinitionPatternAddress(_) -> "Address"
          ElementdefinitionPatternAge(_) -> "Age"
          ElementdefinitionPatternAnnotation(_) -> "Annotation"
          ElementdefinitionPatternAttachment(_) -> "Attachment"
          ElementdefinitionPatternCodeableconcept(_) -> "Codeableconcept"
          ElementdefinitionPatternCodeablereference(_) -> "Codeablereference"
          ElementdefinitionPatternCoding(_) -> "Coding"
          ElementdefinitionPatternContactpoint(_) -> "Contactpoint"
          ElementdefinitionPatternCount(_) -> "Count"
          ElementdefinitionPatternDistance(_) -> "Distance"
          ElementdefinitionPatternDuration(_) -> "Duration"
          ElementdefinitionPatternHumanname(_) -> "Humanname"
          ElementdefinitionPatternIdentifier(_) -> "Identifier"
          ElementdefinitionPatternMoney(_) -> "Money"
          ElementdefinitionPatternPeriod(_) -> "Period"
          ElementdefinitionPatternQuantity(_) -> "Quantity"
          ElementdefinitionPatternRange(_) -> "Range"
          ElementdefinitionPatternRatio(_) -> "Ratio"
          ElementdefinitionPatternRatiorange(_) -> "Ratiorange"
          ElementdefinitionPatternReference(_) -> "Reference"
          ElementdefinitionPatternSampleddata(_) -> "Sampleddata"
          ElementdefinitionPatternSignature(_) -> "Signature"
          ElementdefinitionPatternTiming(_) -> "Timing"
          ElementdefinitionPatternContactdetail(_) -> "Contactdetail"
          ElementdefinitionPatternContributor(_) -> "Contributor"
          ElementdefinitionPatternDatarequirement(_) -> "Datarequirement"
          ElementdefinitionPatternExpression(_) -> "Expression"
          ElementdefinitionPatternParameterdefinition(_) ->
            "Parameterdefinition"
          ElementdefinitionPatternRelatedartifact(_) -> "Relatedartifact"
          ElementdefinitionPatternTriggerdefinition(_) -> "Triggerdefinition"
          ElementdefinitionPatternUsagecontext(_) -> "Usagecontext"
          ElementdefinitionPatternDosage(_) -> "Dosage"
        },
        elementdefinition_pattern_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case fixed {
    Some(v) -> [
      #(
        "fixed"
          <> case v {
          ElementdefinitionFixedBase64binary(_) -> "Base64binary"
          ElementdefinitionFixedBoolean(_) -> "Boolean"
          ElementdefinitionFixedCanonical(_) -> "Canonical"
          ElementdefinitionFixedCode(_) -> "Code"
          ElementdefinitionFixedDate(_) -> "Date"
          ElementdefinitionFixedDatetime(_) -> "Datetime"
          ElementdefinitionFixedDecimal(_) -> "Decimal"
          ElementdefinitionFixedId(_) -> "Id"
          ElementdefinitionFixedInstant(_) -> "Instant"
          ElementdefinitionFixedInteger(_) -> "Integer"
          ElementdefinitionFixedMarkdown(_) -> "Markdown"
          ElementdefinitionFixedOid(_) -> "Oid"
          ElementdefinitionFixedPositiveint(_) -> "Positiveint"
          ElementdefinitionFixedString(_) -> "String"
          ElementdefinitionFixedTime(_) -> "Time"
          ElementdefinitionFixedUnsignedint(_) -> "Unsignedint"
          ElementdefinitionFixedUri(_) -> "Uri"
          ElementdefinitionFixedUrl(_) -> "Url"
          ElementdefinitionFixedUuid(_) -> "Uuid"
          ElementdefinitionFixedAddress(_) -> "Address"
          ElementdefinitionFixedAge(_) -> "Age"
          ElementdefinitionFixedAnnotation(_) -> "Annotation"
          ElementdefinitionFixedAttachment(_) -> "Attachment"
          ElementdefinitionFixedCodeableconcept(_) -> "Codeableconcept"
          ElementdefinitionFixedCodeablereference(_) -> "Codeablereference"
          ElementdefinitionFixedCoding(_) -> "Coding"
          ElementdefinitionFixedContactpoint(_) -> "Contactpoint"
          ElementdefinitionFixedCount(_) -> "Count"
          ElementdefinitionFixedDistance(_) -> "Distance"
          ElementdefinitionFixedDuration(_) -> "Duration"
          ElementdefinitionFixedHumanname(_) -> "Humanname"
          ElementdefinitionFixedIdentifier(_) -> "Identifier"
          ElementdefinitionFixedMoney(_) -> "Money"
          ElementdefinitionFixedPeriod(_) -> "Period"
          ElementdefinitionFixedQuantity(_) -> "Quantity"
          ElementdefinitionFixedRange(_) -> "Range"
          ElementdefinitionFixedRatio(_) -> "Ratio"
          ElementdefinitionFixedRatiorange(_) -> "Ratiorange"
          ElementdefinitionFixedReference(_) -> "Reference"
          ElementdefinitionFixedSampleddata(_) -> "Sampleddata"
          ElementdefinitionFixedSignature(_) -> "Signature"
          ElementdefinitionFixedTiming(_) -> "Timing"
          ElementdefinitionFixedContactdetail(_) -> "Contactdetail"
          ElementdefinitionFixedContributor(_) -> "Contributor"
          ElementdefinitionFixedDatarequirement(_) -> "Datarequirement"
          ElementdefinitionFixedExpression(_) -> "Expression"
          ElementdefinitionFixedParameterdefinition(_) -> "Parameterdefinition"
          ElementdefinitionFixedRelatedartifact(_) -> "Relatedartifact"
          ElementdefinitionFixedTriggerdefinition(_) -> "Triggerdefinition"
          ElementdefinitionFixedUsagecontext(_) -> "Usagecontext"
          ElementdefinitionFixedDosage(_) -> "Dosage"
        },
        elementdefinition_fixed_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case order_meaning {
    Some(v) -> [#("orderMeaning", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meaning_when_missing {
    Some(v) -> [#("meaningWhenMissing", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case default_value {
    Some(v) -> [
      #(
        "defaultValue"
          <> case v {
          ElementdefinitionDefaultvalueBase64binary(_) -> "Base64binary"
          ElementdefinitionDefaultvalueBoolean(_) -> "Boolean"
          ElementdefinitionDefaultvalueCanonical(_) -> "Canonical"
          ElementdefinitionDefaultvalueCode(_) -> "Code"
          ElementdefinitionDefaultvalueDate(_) -> "Date"
          ElementdefinitionDefaultvalueDatetime(_) -> "Datetime"
          ElementdefinitionDefaultvalueDecimal(_) -> "Decimal"
          ElementdefinitionDefaultvalueId(_) -> "Id"
          ElementdefinitionDefaultvalueInstant(_) -> "Instant"
          ElementdefinitionDefaultvalueInteger(_) -> "Integer"
          ElementdefinitionDefaultvalueMarkdown(_) -> "Markdown"
          ElementdefinitionDefaultvalueOid(_) -> "Oid"
          ElementdefinitionDefaultvaluePositiveint(_) -> "Positiveint"
          ElementdefinitionDefaultvalueString(_) -> "String"
          ElementdefinitionDefaultvalueTime(_) -> "Time"
          ElementdefinitionDefaultvalueUnsignedint(_) -> "Unsignedint"
          ElementdefinitionDefaultvalueUri(_) -> "Uri"
          ElementdefinitionDefaultvalueUrl(_) -> "Url"
          ElementdefinitionDefaultvalueUuid(_) -> "Uuid"
          ElementdefinitionDefaultvalueAddress(_) -> "Address"
          ElementdefinitionDefaultvalueAge(_) -> "Age"
          ElementdefinitionDefaultvalueAnnotation(_) -> "Annotation"
          ElementdefinitionDefaultvalueAttachment(_) -> "Attachment"
          ElementdefinitionDefaultvalueCodeableconcept(_) -> "Codeableconcept"
          ElementdefinitionDefaultvalueCodeablereference(_) ->
            "Codeablereference"
          ElementdefinitionDefaultvalueCoding(_) -> "Coding"
          ElementdefinitionDefaultvalueContactpoint(_) -> "Contactpoint"
          ElementdefinitionDefaultvalueCount(_) -> "Count"
          ElementdefinitionDefaultvalueDistance(_) -> "Distance"
          ElementdefinitionDefaultvalueDuration(_) -> "Duration"
          ElementdefinitionDefaultvalueHumanname(_) -> "Humanname"
          ElementdefinitionDefaultvalueIdentifier(_) -> "Identifier"
          ElementdefinitionDefaultvalueMoney(_) -> "Money"
          ElementdefinitionDefaultvaluePeriod(_) -> "Period"
          ElementdefinitionDefaultvalueQuantity(_) -> "Quantity"
          ElementdefinitionDefaultvalueRange(_) -> "Range"
          ElementdefinitionDefaultvalueRatio(_) -> "Ratio"
          ElementdefinitionDefaultvalueRatiorange(_) -> "Ratiorange"
          ElementdefinitionDefaultvalueReference(_) -> "Reference"
          ElementdefinitionDefaultvalueSampleddata(_) -> "Sampleddata"
          ElementdefinitionDefaultvalueSignature(_) -> "Signature"
          ElementdefinitionDefaultvalueTiming(_) -> "Timing"
          ElementdefinitionDefaultvalueContactdetail(_) -> "Contactdetail"
          ElementdefinitionDefaultvalueContributor(_) -> "Contributor"
          ElementdefinitionDefaultvalueDatarequirement(_) -> "Datarequirement"
          ElementdefinitionDefaultvalueExpression(_) -> "Expression"
          ElementdefinitionDefaultvalueParameterdefinition(_) ->
            "Parameterdefinition"
          ElementdefinitionDefaultvalueRelatedartifact(_) -> "Relatedartifact"
          ElementdefinitionDefaultvalueTriggerdefinition(_) ->
            "Triggerdefinition"
          ElementdefinitionDefaultvalueUsagecontext(_) -> "Usagecontext"
          ElementdefinitionDefaultvalueDosage(_) -> "Dosage"
        },
        elementdefinition_defaultvalue_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case type_ {
    [] -> fields
    _ -> [
      #("type", json.array(type_, elementdefinition_type_to_json)),
      ..fields
    ]
  }
  let fields = case content_reference {
    Some(v) -> [#("contentReference", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case base {
    Some(v) -> [#("base", elementdefinition_base_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case max {
    Some(v) -> [#("max", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case min {
    Some(v) -> [#("min", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case alias {
    [] -> fields
    _ -> [#("alias", json.array(alias, json.string)), ..fields]
  }
  let fields = case requirements {
    Some(v) -> [#("requirements", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case comment {
    Some(v) -> [#("comment", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case definition {
    Some(v) -> [#("definition", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case short {
    Some(v) -> [#("short", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case slicing {
    Some(v) -> [#("slicing", elementdefinition_slicing_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case code {
    [] -> fields
    _ -> [#("code", json.array(code, coding_to_json)), ..fields]
  }
  let fields = case label {
    Some(v) -> [#("label", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case slice_is_constraining {
    Some(v) -> [#("sliceIsConstraining", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case slice_name {
    Some(v) -> [#("sliceName", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case representation {
    [] -> fields
    _ -> [
      #(
        "representation",
        json.array(representation, r4bvaluesets.propertyrepresentation_to_json),
      ),
      ..fields
    ]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn elementdefinition_decoder() -> Decoder(Elementdefinition) {
  use mapping <- decode.optional_field(
    "mapping",
    [],
    decode.list(elementdefinition_mapping_decoder()),
  )
  use binding <- decode.optional_field(
    "binding",
    None,
    decode.optional(elementdefinition_binding_decoder()),
  )
  use is_summary <- decode.optional_field(
    "isSummary",
    None,
    decode.optional(decode.bool),
  )
  use is_modifier_reason <- decode.optional_field(
    "isModifierReason",
    None,
    decode.optional(decode.string),
  )
  use is_modifier <- decode.optional_field(
    "isModifier",
    None,
    decode.optional(decode.bool),
  )
  use must_support <- decode.optional_field(
    "mustSupport",
    None,
    decode.optional(decode.bool),
  )
  use constraint <- decode.optional_field(
    "constraint",
    [],
    decode.list(elementdefinition_constraint_decoder()),
  )
  use condition <- decode.optional_field(
    "condition",
    [],
    decode.list(decode.string),
  )
  use max_length <- decode.optional_field(
    "maxLength",
    None,
    decode.optional(decode.int),
  )
  use max_value <- decode.then(
    none_if_omitted(elementdefinition_maxvalue_decoder()),
  )
  use min_value <- decode.then(
    none_if_omitted(elementdefinition_minvalue_decoder()),
  )
  use example <- decode.optional_field(
    "example",
    [],
    decode.list(elementdefinition_example_decoder()),
  )
  use pattern <- decode.then(
    none_if_omitted(elementdefinition_pattern_decoder()),
  )
  use fixed <- decode.then(none_if_omitted(elementdefinition_fixed_decoder()))
  use order_meaning <- decode.optional_field(
    "orderMeaning",
    None,
    decode.optional(decode.string),
  )
  use meaning_when_missing <- decode.optional_field(
    "meaningWhenMissing",
    None,
    decode.optional(decode.string),
  )
  use default_value <- decode.then(
    none_if_omitted(elementdefinition_defaultvalue_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    [],
    decode.list(elementdefinition_type_decoder()),
  )
  use content_reference <- decode.optional_field(
    "contentReference",
    None,
    decode.optional(decode.string),
  )
  use base <- decode.optional_field(
    "base",
    None,
    decode.optional(elementdefinition_base_decoder()),
  )
  use max <- decode.optional_field("max", None, decode.optional(decode.string))
  use min <- decode.optional_field("min", None, decode.optional(decode.int))
  use alias <- decode.optional_field("alias", [], decode.list(decode.string))
  use requirements <- decode.optional_field(
    "requirements",
    None,
    decode.optional(decode.string),
  )
  use comment <- decode.optional_field(
    "comment",
    None,
    decode.optional(decode.string),
  )
  use definition <- decode.optional_field(
    "definition",
    None,
    decode.optional(decode.string),
  )
  use short <- decode.optional_field(
    "short",
    None,
    decode.optional(decode.string),
  )
  use slicing <- decode.optional_field(
    "slicing",
    None,
    decode.optional(elementdefinition_slicing_decoder()),
  )
  use code <- decode.optional_field("code", [], decode.list(coding_decoder()))
  use label <- decode.optional_field(
    "label",
    None,
    decode.optional(decode.string),
  )
  use slice_is_constraining <- decode.optional_field(
    "sliceIsConstraining",
    None,
    decode.optional(decode.bool),
  )
  use slice_name <- decode.optional_field(
    "sliceName",
    None,
    decode.optional(decode.string),
  )
  use representation <- decode.optional_field(
    "representation",
    [],
    decode.list(r4bvaluesets.propertyrepresentation_decoder()),
  )
  use path <- decode.field("path", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(Elementdefinition(
    mapping:,
    binding:,
    is_summary:,
    is_modifier_reason:,
    is_modifier:,
    must_support:,
    constraint:,
    condition:,
    max_length:,
    max_value:,
    min_value:,
    example:,
    pattern:,
    fixed:,
    order_meaning:,
    meaning_when_missing:,
    default_value:,
    type_:,
    content_reference:,
    base:,
    max:,
    min:,
    alias:,
    requirements:,
    comment:,
    definition:,
    short:,
    slicing:,
    code:,
    label:,
    slice_is_constraining:,
    slice_name:,
    representation:,
    path:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/Expression#resource
pub type Expression {
  Expression(
    id: Option(String),
    extension: List(Extension),
    description: Option(String),
    name: Option(String),
    language: String,
    expression: Option(String),
    reference: Option(String),
  )
}

pub fn expression_new(language language: String) -> Expression {
  Expression(
    reference: None,
    expression: None,
    language:,
    name: None,
    description: None,
    extension: [],
    id: None,
  )
}

pub fn expression_to_json(expression: Expression) -> Json {
  let Expression(
    reference:,
    expression:,
    language:,
    name:,
    description:,
    extension:,
    id:,
  ) = expression
  let fields = [
    #("language", json.string(language)),
  ]
  let fields = case reference {
    Some(v) -> [#("reference", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case expression {
    Some(v) -> [#("expression", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn expression_decoder() -> Decoder(Expression) {
  use reference <- decode.optional_field(
    "reference",
    None,
    decode.optional(decode.string),
  )
  use expression <- decode.optional_field(
    "expression",
    None,
    decode.optional(decode.string),
  )
  use language <- decode.field("language", decode.string)
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(Expression(
    reference:,
    expression:,
    language:,
    name:,
    description:,
    extension:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/Extension#resource
pub type Extension {
  Extension(
    id: Option(String),
    extension: List(Extension),
    url: String,
    value: Option(ExtensionValue),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Extension#resource
pub type ExtensionValue {
  ExtensionValueBase64binary(value: String)
  ExtensionValueBoolean(value: Bool)
  ExtensionValueCanonical(value: String)
  ExtensionValueCode(value: String)
  ExtensionValueDate(value: String)
  ExtensionValueDatetime(value: String)
  ExtensionValueDecimal(value: Float)
  ExtensionValueId(value: String)
  ExtensionValueInstant(value: String)
  ExtensionValueInteger(value: Int)
  ExtensionValueMarkdown(value: String)
  ExtensionValueOid(value: String)
  ExtensionValuePositiveint(value: Int)
  ExtensionValueString(value: String)
  ExtensionValueTime(value: String)
  ExtensionValueUnsignedint(value: Int)
  ExtensionValueUri(value: String)
  ExtensionValueUrl(value: String)
  ExtensionValueUuid(value: String)
  ExtensionValueAddress(value: Address)
  ExtensionValueAge(value: Age)
  ExtensionValueAnnotation(value: Annotation)
  ExtensionValueAttachment(value: Attachment)
  ExtensionValueCodeableconcept(value: Codeableconcept)
  ExtensionValueCodeablereference(value: Codeablereference)
  ExtensionValueCoding(value: Coding)
  ExtensionValueContactpoint(value: Contactpoint)
  ExtensionValueCount(value: Count)
  ExtensionValueDistance(value: Distance)
  ExtensionValueDuration(value: Duration)
  ExtensionValueHumanname(value: Humanname)
  ExtensionValueIdentifier(value: Identifier)
  ExtensionValueMoney(value: Money)
  ExtensionValuePeriod(value: Period)
  ExtensionValueQuantity(value: Quantity)
  ExtensionValueRange(value: Range)
  ExtensionValueRatio(value: Ratio)
  ExtensionValueRatiorange(value: Ratiorange)
  ExtensionValueReference(value: Reference)
  ExtensionValueSampleddata(value: Sampleddata)
  ExtensionValueSignature(value: Signature)
  ExtensionValueTiming(value: Timing)
  ExtensionValueContactdetail(value: Contactdetail)
  ExtensionValueContributor(value: Contributor)
  ExtensionValueDatarequirement(value: Datarequirement)
  ExtensionValueExpression(value: Expression)
  ExtensionValueParameterdefinition(value: Parameterdefinition)
  ExtensionValueRelatedartifact(value: Relatedartifact)
  ExtensionValueTriggerdefinition(value: Triggerdefinition)
  ExtensionValueUsagecontext(value: Usagecontext)
  ExtensionValueDosage(value: Dosage)
}

pub fn extension_value_to_json(elt: ExtensionValue) -> Json {
  case elt {
    ExtensionValueBase64binary(v) -> json.string(v)
    ExtensionValueBoolean(v) -> json.bool(v)
    ExtensionValueCanonical(v) -> json.string(v)
    ExtensionValueCode(v) -> json.string(v)
    ExtensionValueDate(v) -> json.string(v)
    ExtensionValueDatetime(v) -> json.string(v)
    ExtensionValueDecimal(v) -> json.float(v)
    ExtensionValueId(v) -> json.string(v)
    ExtensionValueInstant(v) -> json.string(v)
    ExtensionValueInteger(v) -> json.int(v)
    ExtensionValueMarkdown(v) -> json.string(v)
    ExtensionValueOid(v) -> json.string(v)
    ExtensionValuePositiveint(v) -> json.int(v)
    ExtensionValueString(v) -> json.string(v)
    ExtensionValueTime(v) -> json.string(v)
    ExtensionValueUnsignedint(v) -> json.int(v)
    ExtensionValueUri(v) -> json.string(v)
    ExtensionValueUrl(v) -> json.string(v)
    ExtensionValueUuid(v) -> json.string(v)
    ExtensionValueAddress(v) -> address_to_json(v)
    ExtensionValueAge(v) -> age_to_json(v)
    ExtensionValueAnnotation(v) -> annotation_to_json(v)
    ExtensionValueAttachment(v) -> attachment_to_json(v)
    ExtensionValueCodeableconcept(v) -> codeableconcept_to_json(v)
    ExtensionValueCodeablereference(v) -> codeablereference_to_json(v)
    ExtensionValueCoding(v) -> coding_to_json(v)
    ExtensionValueContactpoint(v) -> contactpoint_to_json(v)
    ExtensionValueCount(v) -> count_to_json(v)
    ExtensionValueDistance(v) -> distance_to_json(v)
    ExtensionValueDuration(v) -> duration_to_json(v)
    ExtensionValueHumanname(v) -> humanname_to_json(v)
    ExtensionValueIdentifier(v) -> identifier_to_json(v)
    ExtensionValueMoney(v) -> money_to_json(v)
    ExtensionValuePeriod(v) -> period_to_json(v)
    ExtensionValueQuantity(v) -> quantity_to_json(v)
    ExtensionValueRange(v) -> range_to_json(v)
    ExtensionValueRatio(v) -> ratio_to_json(v)
    ExtensionValueRatiorange(v) -> ratiorange_to_json(v)
    ExtensionValueReference(v) -> reference_to_json(v)
    ExtensionValueSampleddata(v) -> sampleddata_to_json(v)
    ExtensionValueSignature(v) -> signature_to_json(v)
    ExtensionValueTiming(v) -> timing_to_json(v)
    ExtensionValueContactdetail(v) -> contactdetail_to_json(v)
    ExtensionValueContributor(v) -> contributor_to_json(v)
    ExtensionValueDatarequirement(v) -> datarequirement_to_json(v)
    ExtensionValueExpression(v) -> expression_to_json(v)
    ExtensionValueParameterdefinition(v) -> parameterdefinition_to_json(v)
    ExtensionValueRelatedartifact(v) -> relatedartifact_to_json(v)
    ExtensionValueTriggerdefinition(v) -> triggerdefinition_to_json(v)
    ExtensionValueUsagecontext(v) -> usagecontext_to_json(v)
    ExtensionValueDosage(v) -> dosage_to_json(v)
  }
}

pub fn extension_value_decoder() -> Decoder(ExtensionValue) {
  decode.one_of(
    decode.field("valueBase64Binary", decode.string, decode.success)
      |> decode.map(ExtensionValueBase64binary),
    [
      decode.field("valueBoolean", decode.bool, decode.success)
        |> decode.map(ExtensionValueBoolean),
      decode.field("valueCanonical", decode.string, decode.success)
        |> decode.map(ExtensionValueCanonical),
      decode.field("valueCode", decode.string, decode.success)
        |> decode.map(ExtensionValueCode),
      decode.field("valueDate", decode.string, decode.success)
        |> decode.map(ExtensionValueDate),
      decode.field("valueDateTime", decode.string, decode.success)
        |> decode.map(ExtensionValueDatetime),
      decode.field("valueDecimal", decode.float, decode.success)
        |> decode.map(ExtensionValueDecimal),
      decode.field("valueId", decode.string, decode.success)
        |> decode.map(ExtensionValueId),
      decode.field("valueInstant", decode.string, decode.success)
        |> decode.map(ExtensionValueInstant),
      decode.field("valueInteger", decode.int, decode.success)
        |> decode.map(ExtensionValueInteger),
      decode.field("valueMarkdown", decode.string, decode.success)
        |> decode.map(ExtensionValueMarkdown),
      decode.field("valueOid", decode.string, decode.success)
        |> decode.map(ExtensionValueOid),
      decode.field("valuePositiveInt", decode.int, decode.success)
        |> decode.map(ExtensionValuePositiveint),
      decode.field("valueString", decode.string, decode.success)
        |> decode.map(ExtensionValueString),
      decode.field("valueTime", decode.string, decode.success)
        |> decode.map(ExtensionValueTime),
      decode.field("valueUnsignedInt", decode.int, decode.success)
        |> decode.map(ExtensionValueUnsignedint),
      decode.field("valueUri", decode.string, decode.success)
        |> decode.map(ExtensionValueUri),
      decode.field("valueUrl", decode.string, decode.success)
        |> decode.map(ExtensionValueUrl),
      decode.field("valueUuid", decode.string, decode.success)
        |> decode.map(ExtensionValueUuid),
      decode.field("valueAddress", address_decoder(), decode.success)
        |> decode.map(ExtensionValueAddress),
      decode.field("valueAge", age_decoder(), decode.success)
        |> decode.map(ExtensionValueAge),
      decode.field("valueAnnotation", annotation_decoder(), decode.success)
        |> decode.map(ExtensionValueAnnotation),
      decode.field("valueAttachment", attachment_decoder(), decode.success)
        |> decode.map(ExtensionValueAttachment),
      decode.field(
        "valueCodeableConcept",
        codeableconcept_decoder(),
        decode.success,
      )
        |> decode.map(ExtensionValueCodeableconcept),
      decode.field(
        "valueCodeableReference",
        codeablereference_decoder(),
        decode.success,
      )
        |> decode.map(ExtensionValueCodeablereference),
      decode.field("valueCoding", coding_decoder(), decode.success)
        |> decode.map(ExtensionValueCoding),
      decode.field("valueContactPoint", contactpoint_decoder(), decode.success)
        |> decode.map(ExtensionValueContactpoint),
      decode.field("valueCount", count_decoder(), decode.success)
        |> decode.map(ExtensionValueCount),
      decode.field("valueDistance", distance_decoder(), decode.success)
        |> decode.map(ExtensionValueDistance),
      decode.field("valueDuration", duration_decoder(), decode.success)
        |> decode.map(ExtensionValueDuration),
      decode.field("valueHumanName", humanname_decoder(), decode.success)
        |> decode.map(ExtensionValueHumanname),
      decode.field("valueIdentifier", identifier_decoder(), decode.success)
        |> decode.map(ExtensionValueIdentifier),
      decode.field("valueMoney", money_decoder(), decode.success)
        |> decode.map(ExtensionValueMoney),
      decode.field("valuePeriod", period_decoder(), decode.success)
        |> decode.map(ExtensionValuePeriod),
      decode.field("valueQuantity", quantity_decoder(), decode.success)
        |> decode.map(ExtensionValueQuantity),
      decode.field("valueRange", range_decoder(), decode.success)
        |> decode.map(ExtensionValueRange),
      decode.field("valueRatio", ratio_decoder(), decode.success)
        |> decode.map(ExtensionValueRatio),
      decode.field("valueRatioRange", ratiorange_decoder(), decode.success)
        |> decode.map(ExtensionValueRatiorange),
      decode.field("valueReference", reference_decoder(), decode.success)
        |> decode.map(ExtensionValueReference),
      decode.field("valueSampledData", sampleddata_decoder(), decode.success)
        |> decode.map(ExtensionValueSampleddata),
      decode.field("valueSignature", signature_decoder(), decode.success)
        |> decode.map(ExtensionValueSignature),
      decode.field("valueTiming", timing_decoder(), decode.success)
        |> decode.map(ExtensionValueTiming),
      decode.field(
        "valueContactDetail",
        contactdetail_decoder(),
        decode.success,
      )
        |> decode.map(ExtensionValueContactdetail),
      decode.field("valueContributor", contributor_decoder(), decode.success)
        |> decode.map(ExtensionValueContributor),
      decode.field(
        "valueDataRequirement",
        datarequirement_decoder(),
        decode.success,
      )
        |> decode.map(ExtensionValueDatarequirement),
      decode.field("valueExpression", expression_decoder(), decode.success)
        |> decode.map(ExtensionValueExpression),
      decode.field(
        "valueParameterDefinition",
        parameterdefinition_decoder(),
        decode.success,
      )
        |> decode.map(ExtensionValueParameterdefinition),
      decode.field(
        "valueRelatedArtifact",
        relatedartifact_decoder(),
        decode.success,
      )
        |> decode.map(ExtensionValueRelatedartifact),
      decode.field(
        "valueTriggerDefinition",
        triggerdefinition_decoder(),
        decode.success,
      )
        |> decode.map(ExtensionValueTriggerdefinition),
      decode.field("valueUsageContext", usagecontext_decoder(), decode.success)
        |> decode.map(ExtensionValueUsagecontext),
      decode.field("valueDosage", dosage_decoder(), decode.success)
        |> decode.map(ExtensionValueDosage),
    ],
  )
}

pub fn extension_new(url url: String) -> Extension {
  Extension(value: None, url:, extension: [], id: None)
}

pub fn extension_to_json(extension: Extension) -> Json {
  let Extension(value:, url:, extension:, id:) = extension
  let fields = [
    #("url", json.string(url)),
  ]
  let fields = case value {
    Some(v) -> [
      #(
        "value"
          <> case v {
          ExtensionValueBase64binary(_) -> "Base64binary"
          ExtensionValueBoolean(_) -> "Boolean"
          ExtensionValueCanonical(_) -> "Canonical"
          ExtensionValueCode(_) -> "Code"
          ExtensionValueDate(_) -> "Date"
          ExtensionValueDatetime(_) -> "Datetime"
          ExtensionValueDecimal(_) -> "Decimal"
          ExtensionValueId(_) -> "Id"
          ExtensionValueInstant(_) -> "Instant"
          ExtensionValueInteger(_) -> "Integer"
          ExtensionValueMarkdown(_) -> "Markdown"
          ExtensionValueOid(_) -> "Oid"
          ExtensionValuePositiveint(_) -> "Positiveint"
          ExtensionValueString(_) -> "String"
          ExtensionValueTime(_) -> "Time"
          ExtensionValueUnsignedint(_) -> "Unsignedint"
          ExtensionValueUri(_) -> "Uri"
          ExtensionValueUrl(_) -> "Url"
          ExtensionValueUuid(_) -> "Uuid"
          ExtensionValueAddress(_) -> "Address"
          ExtensionValueAge(_) -> "Age"
          ExtensionValueAnnotation(_) -> "Annotation"
          ExtensionValueAttachment(_) -> "Attachment"
          ExtensionValueCodeableconcept(_) -> "Codeableconcept"
          ExtensionValueCodeablereference(_) -> "Codeablereference"
          ExtensionValueCoding(_) -> "Coding"
          ExtensionValueContactpoint(_) -> "Contactpoint"
          ExtensionValueCount(_) -> "Count"
          ExtensionValueDistance(_) -> "Distance"
          ExtensionValueDuration(_) -> "Duration"
          ExtensionValueHumanname(_) -> "Humanname"
          ExtensionValueIdentifier(_) -> "Identifier"
          ExtensionValueMoney(_) -> "Money"
          ExtensionValuePeriod(_) -> "Period"
          ExtensionValueQuantity(_) -> "Quantity"
          ExtensionValueRange(_) -> "Range"
          ExtensionValueRatio(_) -> "Ratio"
          ExtensionValueRatiorange(_) -> "Ratiorange"
          ExtensionValueReference(_) -> "Reference"
          ExtensionValueSampleddata(_) -> "Sampleddata"
          ExtensionValueSignature(_) -> "Signature"
          ExtensionValueTiming(_) -> "Timing"
          ExtensionValueContactdetail(_) -> "Contactdetail"
          ExtensionValueContributor(_) -> "Contributor"
          ExtensionValueDatarequirement(_) -> "Datarequirement"
          ExtensionValueExpression(_) -> "Expression"
          ExtensionValueParameterdefinition(_) -> "Parameterdefinition"
          ExtensionValueRelatedartifact(_) -> "Relatedartifact"
          ExtensionValueTriggerdefinition(_) -> "Triggerdefinition"
          ExtensionValueUsagecontext(_) -> "Usagecontext"
          ExtensionValueDosage(_) -> "Dosage"
        },
        extension_value_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn extension_decoder() -> Decoder(Extension) {
  use value <- decode.then(none_if_omitted(extension_value_decoder()))
  use url <- decode.field("url", decode.string)
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(Extension(value:, url:, extension:, id:))
}

///http://hl7.org/fhir/r4b/StructureDefinition/HumanName#resource
pub type Humanname {
  Humanname(
    id: Option(String),
    extension: List(Extension),
    use_: Option(r4bvaluesets.Nameuse),
    text: Option(String),
    family: Option(String),
    given: List(String),
    prefix: List(String),
    suffix: List(String),
    period: Option(Period),
  )
}

pub fn humanname_new() -> Humanname {
  Humanname(
    period: None,
    suffix: [],
    prefix: [],
    given: [],
    family: None,
    text: None,
    use_: None,
    extension: [],
    id: None,
  )
}

pub fn humanname_to_json(humanname: Humanname) -> Json {
  let Humanname(
    period:,
    suffix:,
    prefix:,
    given:,
    family:,
    text:,
    use_:,
    extension:,
    id:,
  ) = humanname
  let fields = []
  let fields = case period {
    Some(v) -> [#("period", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case suffix {
    [] -> fields
    _ -> [#("suffix", json.array(suffix, json.string)), ..fields]
  }
  let fields = case prefix {
    [] -> fields
    _ -> [#("prefix", json.array(prefix, json.string)), ..fields]
  }
  let fields = case given {
    [] -> fields
    _ -> [#("given", json.array(given, json.string)), ..fields]
  }
  let fields = case family {
    Some(v) -> [#("family", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case text {
    Some(v) -> [#("text", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case use_ {
    Some(v) -> [#("use", r4bvaluesets.nameuse_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn humanname_decoder() -> Decoder(Humanname) {
  use period <- decode.optional_field(
    "period",
    None,
    decode.optional(period_decoder()),
  )
  use suffix <- decode.optional_field("suffix", [], decode.list(decode.string))
  use prefix <- decode.optional_field("prefix", [], decode.list(decode.string))
  use given <- decode.optional_field("given", [], decode.list(decode.string))
  use family <- decode.optional_field(
    "family",
    None,
    decode.optional(decode.string),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(decode.string),
  )
  use use_ <- decode.optional_field(
    "use",
    None,
    decode.optional(r4bvaluesets.nameuse_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(Humanname(
    period:,
    suffix:,
    prefix:,
    given:,
    family:,
    text:,
    use_:,
    extension:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/Identifier#resource
pub type Identifier {
  Identifier(
    id: Option(String),
    extension: List(Extension),
    use_: Option(r4bvaluesets.Identifieruse),
    type_: Option(Codeableconcept),
    system: Option(String),
    value: Option(String),
    period: Option(Period),
    assigner: Option(Reference),
  )
}

pub fn identifier_new() -> Identifier {
  Identifier(
    assigner: None,
    period: None,
    value: None,
    system: None,
    type_: None,
    use_: None,
    extension: [],
    id: None,
  )
}

pub fn identifier_to_json(identifier: Identifier) -> Json {
  let Identifier(
    assigner:,
    period:,
    value:,
    system:,
    type_:,
    use_:,
    extension:,
    id:,
  ) = identifier
  let fields = []
  let fields = case assigner {
    Some(v) -> [#("assigner", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case period {
    Some(v) -> [#("period", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case value {
    Some(v) -> [#("value", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case system {
    Some(v) -> [#("system", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case use_ {
    Some(v) -> [#("use", r4bvaluesets.identifieruse_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn identifier_decoder() -> Decoder(Identifier) {
  use assigner <- decode.optional_field(
    "assigner",
    None,
    decode.optional(reference_decoder()),
  )
  use period <- decode.optional_field(
    "period",
    None,
    decode.optional(period_decoder()),
  )
  use value <- decode.optional_field(
    "value",
    None,
    decode.optional(decode.string),
  )
  use system <- decode.optional_field(
    "system",
    None,
    decode.optional(decode.string),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use use_ <- decode.optional_field(
    "use",
    None,
    decode.optional(r4bvaluesets.identifieruse_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(Identifier(
    assigner:,
    period:,
    value:,
    system:,
    type_:,
    use_:,
    extension:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/MarketingStatus#resource
pub type Marketingstatus {
  Marketingstatus(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    country: Option(Codeableconcept),
    jurisdiction: Option(Codeableconcept),
    status: Codeableconcept,
    date_range: Option(Period),
    restore_date: Option(String),
  )
}

pub fn marketingstatus_new(status status: Codeableconcept) -> Marketingstatus {
  Marketingstatus(
    restore_date: None,
    date_range: None,
    status:,
    jurisdiction: None,
    country: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn marketingstatus_to_json(marketingstatus: Marketingstatus) -> Json {
  let Marketingstatus(
    restore_date:,
    date_range:,
    status:,
    jurisdiction:,
    country:,
    modifier_extension:,
    extension:,
    id:,
  ) = marketingstatus
  let fields = [
    #("status", codeableconcept_to_json(status)),
  ]
  let fields = case restore_date {
    Some(v) -> [#("restoreDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case date_range {
    Some(v) -> [#("dateRange", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case jurisdiction {
    Some(v) -> [#("jurisdiction", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case country {
    Some(v) -> [#("country", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn marketingstatus_decoder() -> Decoder(Marketingstatus) {
  use restore_date <- decode.optional_field(
    "restoreDate",
    None,
    decode.optional(decode.string),
  )
  use date_range <- decode.optional_field(
    "dateRange",
    None,
    decode.optional(period_decoder()),
  )
  use status <- decode.field("status", codeableconcept_decoder())
  use jurisdiction <- decode.optional_field(
    "jurisdiction",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use country <- decode.optional_field(
    "country",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(Marketingstatus(
    restore_date:,
    date_range:,
    status:,
    jurisdiction:,
    country:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/Meta#resource
pub type Meta {
  Meta(
    id: Option(String),
    extension: List(Extension),
    version_id: Option(String),
    last_updated: Option(String),
    source: Option(String),
    profile: List(String),
    security: List(Coding),
    tag: List(Coding),
  )
}

pub fn meta_new() -> Meta {
  Meta(
    tag: [],
    security: [],
    profile: [],
    source: None,
    last_updated: None,
    version_id: None,
    extension: [],
    id: None,
  )
}

pub fn meta_to_json(meta: Meta) -> Json {
  let Meta(
    tag:,
    security:,
    profile:,
    source:,
    last_updated:,
    version_id:,
    extension:,
    id:,
  ) = meta
  let fields = []
  let fields = case tag {
    [] -> fields
    _ -> [#("tag", json.array(tag, coding_to_json)), ..fields]
  }
  let fields = case security {
    [] -> fields
    _ -> [#("security", json.array(security, coding_to_json)), ..fields]
  }
  let fields = case profile {
    [] -> fields
    _ -> [#("profile", json.array(profile, json.string)), ..fields]
  }
  let fields = case source {
    Some(v) -> [#("source", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case last_updated {
    Some(v) -> [#("lastUpdated", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case version_id {
    Some(v) -> [#("versionId", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn meta_decoder() -> Decoder(Meta) {
  use tag <- decode.optional_field("tag", [], decode.list(coding_decoder()))
  use security <- decode.optional_field(
    "security",
    [],
    decode.list(coding_decoder()),
  )
  use profile <- decode.optional_field(
    "profile",
    [],
    decode.list(decode.string),
  )
  use source <- decode.optional_field(
    "source",
    None,
    decode.optional(decode.string),
  )
  use last_updated <- decode.optional_field(
    "lastUpdated",
    None,
    decode.optional(decode.string),
  )
  use version_id <- decode.optional_field(
    "versionId",
    None,
    decode.optional(decode.string),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(Meta(
    tag:,
    security:,
    profile:,
    source:,
    last_updated:,
    version_id:,
    extension:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/Money#resource
pub type Money {
  Money(
    id: Option(String),
    extension: List(Extension),
    value: Option(Float),
    currency: Option(String),
  )
}

pub fn money_new() -> Money {
  Money(currency: None, value: None, extension: [], id: None)
}

pub fn money_to_json(money: Money) -> Json {
  let Money(currency:, value:, extension:, id:) = money
  let fields = []
  let fields = case currency {
    Some(v) -> [#("currency", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case value {
    Some(v) -> [#("value", json.float(v)), ..fields]
    None -> fields
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn money_decoder() -> Decoder(Money) {
  use currency <- decode.optional_field(
    "currency",
    None,
    decode.optional(decode.string),
  )
  use value <- decode.optional_field(
    "value",
    None,
    decode.optional(decode.float),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(Money(currency:, value:, extension:, id:))
}

///http://hl7.org/fhir/r4b/StructureDefinition/Narrative#resource
pub type Narrative {
  Narrative(
    id: Option(String),
    extension: List(Extension),
    status: r4bvaluesets.Narrativestatus,
    div: String,
  )
}

pub fn narrative_new(
  div div: String,
  status status: r4bvaluesets.Narrativestatus,
) -> Narrative {
  Narrative(div:, status:, extension: [], id: None)
}

pub fn narrative_to_json(narrative: Narrative) -> Json {
  let Narrative(div:, status:, extension:, id:) = narrative
  let fields = [
    #("div", json.string(div)),
    #("status", r4bvaluesets.narrativestatus_to_json(status)),
  ]
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn narrative_decoder() -> Decoder(Narrative) {
  use div <- decode.field("div", decode.string)
  use status <- decode.field("status", r4bvaluesets.narrativestatus_decoder())
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(Narrative(div:, status:, extension:, id:))
}

///http://hl7.org/fhir/r4b/StructureDefinition/ParameterDefinition#resource
pub type Parameterdefinition {
  Parameterdefinition(
    id: Option(String),
    extension: List(Extension),
    name: Option(String),
    use_: r4bvaluesets.Operationparameteruse,
    min: Option(Int),
    max: Option(String),
    documentation: Option(String),
    type_: r4bvaluesets.Alltypes,
    profile: Option(String),
  )
}

pub fn parameterdefinition_new(
  type_ type_: r4bvaluesets.Alltypes,
  use_ use_: r4bvaluesets.Operationparameteruse,
) -> Parameterdefinition {
  Parameterdefinition(
    profile: None,
    type_:,
    documentation: None,
    max: None,
    min: None,
    use_:,
    name: None,
    extension: [],
    id: None,
  )
}

pub fn parameterdefinition_to_json(
  parameterdefinition: Parameterdefinition,
) -> Json {
  let Parameterdefinition(
    profile:,
    type_:,
    documentation:,
    max:,
    min:,
    use_:,
    name:,
    extension:,
    id:,
  ) = parameterdefinition
  let fields = [
    #("type", r4bvaluesets.alltypes_to_json(type_)),
    #("use", r4bvaluesets.operationparameteruse_to_json(use_)),
  ]
  let fields = case profile {
    Some(v) -> [#("profile", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case documentation {
    Some(v) -> [#("documentation", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case max {
    Some(v) -> [#("max", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case min {
    Some(v) -> [#("min", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn parameterdefinition_decoder() -> Decoder(Parameterdefinition) {
  use profile <- decode.optional_field(
    "profile",
    None,
    decode.optional(decode.string),
  )
  use type_ <- decode.field("type", r4bvaluesets.alltypes_decoder())
  use documentation <- decode.optional_field(
    "documentation",
    None,
    decode.optional(decode.string),
  )
  use max <- decode.optional_field("max", None, decode.optional(decode.string))
  use min <- decode.optional_field("min", None, decode.optional(decode.int))
  use use_ <- decode.field("use", r4bvaluesets.operationparameteruse_decoder())
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(Parameterdefinition(
    profile:,
    type_:,
    documentation:,
    max:,
    min:,
    use_:,
    name:,
    extension:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/Period#resource
pub type Period {
  Period(
    id: Option(String),
    extension: List(Extension),
    start: Option(String),
    end: Option(String),
  )
}

pub fn period_new() -> Period {
  Period(end: None, start: None, extension: [], id: None)
}

pub fn period_to_json(period: Period) -> Json {
  let Period(end:, start:, extension:, id:) = period
  let fields = []
  let fields = case end {
    Some(v) -> [#("end", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case start {
    Some(v) -> [#("start", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn period_decoder() -> Decoder(Period) {
  use end <- decode.optional_field("end", None, decode.optional(decode.string))
  use start <- decode.optional_field(
    "start",
    None,
    decode.optional(decode.string),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(Period(end:, start:, extension:, id:))
}

///http://hl7.org/fhir/r4b/StructureDefinition/Population#resource
pub type Population {
  Population(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    age: Option(PopulationAge),
    gender: Option(Codeableconcept),
    race: Option(Codeableconcept),
    physiological_condition: Option(Codeableconcept),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Population#resource
pub type PopulationAge {
  PopulationAgeRange(age: Range)
  PopulationAgeCodeableconcept(age: Codeableconcept)
}

pub fn population_age_to_json(elt: PopulationAge) -> Json {
  case elt {
    PopulationAgeRange(v) -> range_to_json(v)
    PopulationAgeCodeableconcept(v) -> codeableconcept_to_json(v)
  }
}

pub fn population_age_decoder() -> Decoder(PopulationAge) {
  decode.one_of(
    decode.field("ageRange", range_decoder(), decode.success)
      |> decode.map(PopulationAgeRange),
    [
      decode.field(
        "ageCodeableConcept",
        codeableconcept_decoder(),
        decode.success,
      )
      |> decode.map(PopulationAgeCodeableconcept),
    ],
  )
}

pub fn population_new() -> Population {
  Population(
    physiological_condition: None,
    race: None,
    gender: None,
    age: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn population_to_json(population: Population) -> Json {
  let Population(
    physiological_condition:,
    race:,
    gender:,
    age:,
    modifier_extension:,
    extension:,
    id:,
  ) = population
  let fields = []
  let fields = case physiological_condition {
    Some(v) -> [
      #("physiologicalCondition", codeableconcept_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case race {
    Some(v) -> [#("race", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case gender {
    Some(v) -> [#("gender", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case age {
    Some(v) -> [
      #(
        "age"
          <> case v {
          PopulationAgeRange(_) -> "Range"
          PopulationAgeCodeableconcept(_) -> "Codeableconcept"
        },
        population_age_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn population_decoder() -> Decoder(Population) {
  use physiological_condition <- decode.optional_field(
    "physiologicalCondition",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use race <- decode.optional_field(
    "race",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use gender <- decode.optional_field(
    "gender",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use age <- decode.then(none_if_omitted(population_age_decoder()))
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(Population(
    physiological_condition:,
    race:,
    gender:,
    age:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/ProdCharacteristic#resource
pub type Prodcharacteristic {
  Prodcharacteristic(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    height: Option(Quantity),
    width: Option(Quantity),
    depth: Option(Quantity),
    weight: Option(Quantity),
    nominal_volume: Option(Quantity),
    external_diameter: Option(Quantity),
    shape: Option(String),
    color: List(String),
    imprint: List(String),
    image: List(Attachment),
    scoring: Option(Codeableconcept),
  )
}

pub fn prodcharacteristic_new() -> Prodcharacteristic {
  Prodcharacteristic(
    scoring: None,
    image: [],
    imprint: [],
    color: [],
    shape: None,
    external_diameter: None,
    nominal_volume: None,
    weight: None,
    depth: None,
    width: None,
    height: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn prodcharacteristic_to_json(
  prodcharacteristic: Prodcharacteristic,
) -> Json {
  let Prodcharacteristic(
    scoring:,
    image:,
    imprint:,
    color:,
    shape:,
    external_diameter:,
    nominal_volume:,
    weight:,
    depth:,
    width:,
    height:,
    modifier_extension:,
    extension:,
    id:,
  ) = prodcharacteristic
  let fields = []
  let fields = case scoring {
    Some(v) -> [#("scoring", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case image {
    [] -> fields
    _ -> [#("image", json.array(image, attachment_to_json)), ..fields]
  }
  let fields = case imprint {
    [] -> fields
    _ -> [#("imprint", json.array(imprint, json.string)), ..fields]
  }
  let fields = case color {
    [] -> fields
    _ -> [#("color", json.array(color, json.string)), ..fields]
  }
  let fields = case shape {
    Some(v) -> [#("shape", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case external_diameter {
    Some(v) -> [#("externalDiameter", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case nominal_volume {
    Some(v) -> [#("nominalVolume", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case weight {
    Some(v) -> [#("weight", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case depth {
    Some(v) -> [#("depth", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case width {
    Some(v) -> [#("width", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case height {
    Some(v) -> [#("height", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn prodcharacteristic_decoder() -> Decoder(Prodcharacteristic) {
  use scoring <- decode.optional_field(
    "scoring",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use image <- decode.optional_field(
    "image",
    [],
    decode.list(attachment_decoder()),
  )
  use imprint <- decode.optional_field(
    "imprint",
    [],
    decode.list(decode.string),
  )
  use color <- decode.optional_field("color", [], decode.list(decode.string))
  use shape <- decode.optional_field(
    "shape",
    None,
    decode.optional(decode.string),
  )
  use external_diameter <- decode.optional_field(
    "externalDiameter",
    None,
    decode.optional(quantity_decoder()),
  )
  use nominal_volume <- decode.optional_field(
    "nominalVolume",
    None,
    decode.optional(quantity_decoder()),
  )
  use weight <- decode.optional_field(
    "weight",
    None,
    decode.optional(quantity_decoder()),
  )
  use depth <- decode.optional_field(
    "depth",
    None,
    decode.optional(quantity_decoder()),
  )
  use width <- decode.optional_field(
    "width",
    None,
    decode.optional(quantity_decoder()),
  )
  use height <- decode.optional_field(
    "height",
    None,
    decode.optional(quantity_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(Prodcharacteristic(
    scoring:,
    image:,
    imprint:,
    color:,
    shape:,
    external_diameter:,
    nominal_volume:,
    weight:,
    depth:,
    width:,
    height:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/ProductShelfLife#resource
pub type Productshelflife {
  Productshelflife(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: Option(Identifier),
    type_: Codeableconcept,
    period: Quantity,
    special_precautions_for_storage: List(Codeableconcept),
  )
}

pub fn productshelflife_new(
  period period: Quantity,
  type_ type_: Codeableconcept,
) -> Productshelflife {
  Productshelflife(
    special_precautions_for_storage: [],
    period:,
    type_:,
    identifier: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn productshelflife_to_json(productshelflife: Productshelflife) -> Json {
  let Productshelflife(
    special_precautions_for_storage:,
    period:,
    type_:,
    identifier:,
    modifier_extension:,
    extension:,
    id:,
  ) = productshelflife
  let fields = [
    #("period", quantity_to_json(period)),
    #("type", codeableconcept_to_json(type_)),
  ]
  let fields = case special_precautions_for_storage {
    [] -> fields
    _ -> [
      #(
        "specialPrecautionsForStorage",
        json.array(special_precautions_for_storage, codeableconcept_to_json),
      ),
      ..fields
    ]
  }
  let fields = case identifier {
    Some(v) -> [#("identifier", identifier_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn productshelflife_decoder() -> Decoder(Productshelflife) {
  use special_precautions_for_storage <- decode.optional_field(
    "specialPrecautionsForStorage",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use period <- decode.field("period", quantity_decoder())
  use type_ <- decode.field("type", codeableconcept_decoder())
  use identifier <- decode.optional_field(
    "identifier",
    None,
    decode.optional(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(Productshelflife(
    special_precautions_for_storage:,
    period:,
    type_:,
    identifier:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/Quantity#resource
pub type Quantity {
  Quantity(
    id: Option(String),
    extension: List(Extension),
    value: Option(Float),
    comparator: Option(r4bvaluesets.Quantitycomparator),
    unit: Option(String),
    system: Option(String),
    code: Option(String),
  )
}

pub fn quantity_new() -> Quantity {
  Quantity(
    code: None,
    system: None,
    unit: None,
    comparator: None,
    value: None,
    extension: [],
    id: None,
  )
}

pub fn quantity_to_json(quantity: Quantity) -> Json {
  let Quantity(code:, system:, unit:, comparator:, value:, extension:, id:) =
    quantity
  let fields = []
  let fields = case code {
    Some(v) -> [#("code", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case system {
    Some(v) -> [#("system", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case unit {
    Some(v) -> [#("unit", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case comparator {
    Some(v) -> [
      #("comparator", r4bvaluesets.quantitycomparator_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case value {
    Some(v) -> [#("value", json.float(v)), ..fields]
    None -> fields
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn quantity_decoder() -> Decoder(Quantity) {
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(decode.string),
  )
  use system <- decode.optional_field(
    "system",
    None,
    decode.optional(decode.string),
  )
  use unit <- decode.optional_field(
    "unit",
    None,
    decode.optional(decode.string),
  )
  use comparator <- decode.optional_field(
    "comparator",
    None,
    decode.optional(r4bvaluesets.quantitycomparator_decoder()),
  )
  use value <- decode.optional_field(
    "value",
    None,
    decode.optional(decode.float),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(Quantity(
    code:,
    system:,
    unit:,
    comparator:,
    value:,
    extension:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/Range#resource
pub type Range {
  Range(
    id: Option(String),
    extension: List(Extension),
    low: Option(Quantity),
    high: Option(Quantity),
  )
}

pub fn range_new() -> Range {
  Range(high: None, low: None, extension: [], id: None)
}

pub fn range_to_json(range: Range) -> Json {
  let Range(high:, low:, extension:, id:) = range
  let fields = []
  let fields = case high {
    Some(v) -> [#("high", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case low {
    Some(v) -> [#("low", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn range_decoder() -> Decoder(Range) {
  use high <- decode.optional_field(
    "high",
    None,
    decode.optional(quantity_decoder()),
  )
  use low <- decode.optional_field(
    "low",
    None,
    decode.optional(quantity_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(Range(high:, low:, extension:, id:))
}

///http://hl7.org/fhir/r4b/StructureDefinition/Ratio#resource
pub type Ratio {
  Ratio(
    id: Option(String),
    extension: List(Extension),
    numerator: Option(Quantity),
    denominator: Option(Quantity),
  )
}

pub fn ratio_new() -> Ratio {
  Ratio(denominator: None, numerator: None, extension: [], id: None)
}

pub fn ratio_to_json(ratio: Ratio) -> Json {
  let Ratio(denominator:, numerator:, extension:, id:) = ratio
  let fields = []
  let fields = case denominator {
    Some(v) -> [#("denominator", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case numerator {
    Some(v) -> [#("numerator", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn ratio_decoder() -> Decoder(Ratio) {
  use denominator <- decode.optional_field(
    "denominator",
    None,
    decode.optional(quantity_decoder()),
  )
  use numerator <- decode.optional_field(
    "numerator",
    None,
    decode.optional(quantity_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(Ratio(denominator:, numerator:, extension:, id:))
}

///http://hl7.org/fhir/r4b/StructureDefinition/RatioRange#resource
pub type Ratiorange {
  Ratiorange(
    id: Option(String),
    extension: List(Extension),
    low_numerator: Option(Quantity),
    high_numerator: Option(Quantity),
    denominator: Option(Quantity),
  )
}

pub fn ratiorange_new() -> Ratiorange {
  Ratiorange(
    denominator: None,
    high_numerator: None,
    low_numerator: None,
    extension: [],
    id: None,
  )
}

pub fn ratiorange_to_json(ratiorange: Ratiorange) -> Json {
  let Ratiorange(denominator:, high_numerator:, low_numerator:, extension:, id:) =
    ratiorange
  let fields = []
  let fields = case denominator {
    Some(v) -> [#("denominator", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case high_numerator {
    Some(v) -> [#("highNumerator", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case low_numerator {
    Some(v) -> [#("lowNumerator", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn ratiorange_decoder() -> Decoder(Ratiorange) {
  use denominator <- decode.optional_field(
    "denominator",
    None,
    decode.optional(quantity_decoder()),
  )
  use high_numerator <- decode.optional_field(
    "highNumerator",
    None,
    decode.optional(quantity_decoder()),
  )
  use low_numerator <- decode.optional_field(
    "lowNumerator",
    None,
    decode.optional(quantity_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(Ratiorange(
    denominator:,
    high_numerator:,
    low_numerator:,
    extension:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/Reference#resource
pub type Reference {
  Reference(
    id: Option(String),
    extension: List(Extension),
    reference: Option(String),
    type_: Option(String),
    identifier: Option(Identifier),
    display: Option(String),
  )
}

pub fn reference_new() -> Reference {
  Reference(
    display: None,
    identifier: None,
    type_: None,
    reference: None,
    extension: [],
    id: None,
  )
}

pub fn reference_to_json(reference: Reference) -> Json {
  let Reference(display:, identifier:, type_:, reference:, extension:, id:) =
    reference
  let fields = []
  let fields = case display {
    Some(v) -> [#("display", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    Some(v) -> [#("identifier", identifier_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case reference {
    Some(v) -> [#("reference", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn reference_decoder() -> Decoder(Reference) {
  use display <- decode.optional_field(
    "display",
    None,
    decode.optional(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    None,
    decode.optional(identifier_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(decode.string),
  )
  use reference <- decode.optional_field(
    "reference",
    None,
    decode.optional(decode.string),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(Reference(
    display:,
    identifier:,
    type_:,
    reference:,
    extension:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/RelatedArtifact#resource
pub type Relatedartifact {
  Relatedartifact(
    id: Option(String),
    extension: List(Extension),
    type_: r4bvaluesets.Relatedartifacttype,
    label: Option(String),
    display: Option(String),
    citation: Option(String),
    url: Option(String),
    document: Option(Attachment),
    resource: Option(String),
  )
}

pub fn relatedartifact_new(
  type_ type_: r4bvaluesets.Relatedartifacttype,
) -> Relatedartifact {
  Relatedartifact(
    resource: None,
    document: None,
    url: None,
    citation: None,
    display: None,
    label: None,
    type_:,
    extension: [],
    id: None,
  )
}

pub fn relatedartifact_to_json(relatedartifact: Relatedartifact) -> Json {
  let Relatedartifact(
    resource:,
    document:,
    url:,
    citation:,
    display:,
    label:,
    type_:,
    extension:,
    id:,
  ) = relatedartifact
  let fields = [
    #("type", r4bvaluesets.relatedartifacttype_to_json(type_)),
  ]
  let fields = case resource {
    Some(v) -> [#("resource", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case document {
    Some(v) -> [#("document", attachment_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case url {
    Some(v) -> [#("url", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case citation {
    Some(v) -> [#("citation", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case display {
    Some(v) -> [#("display", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case label {
    Some(v) -> [#("label", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn relatedartifact_decoder() -> Decoder(Relatedartifact) {
  use resource <- decode.optional_field(
    "resource",
    None,
    decode.optional(decode.string),
  )
  use document <- decode.optional_field(
    "document",
    None,
    decode.optional(attachment_decoder()),
  )
  use url <- decode.optional_field("url", None, decode.optional(decode.string))
  use citation <- decode.optional_field(
    "citation",
    None,
    decode.optional(decode.string),
  )
  use display <- decode.optional_field(
    "display",
    None,
    decode.optional(decode.string),
  )
  use label <- decode.optional_field(
    "label",
    None,
    decode.optional(decode.string),
  )
  use type_ <- decode.field("type", r4bvaluesets.relatedartifacttype_decoder())
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(Relatedartifact(
    resource:,
    document:,
    url:,
    citation:,
    display:,
    label:,
    type_:,
    extension:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/SampledData#resource
pub type Sampleddata {
  Sampleddata(
    id: Option(String),
    extension: List(Extension),
    origin: Quantity,
    period: Float,
    factor: Option(Float),
    lower_limit: Option(Float),
    upper_limit: Option(Float),
    dimensions: Int,
    data: Option(String),
  )
}

pub fn sampleddata_new(
  dimensions dimensions: Int,
  period period: Float,
  origin origin: Quantity,
) -> Sampleddata {
  Sampleddata(
    data: None,
    dimensions:,
    upper_limit: None,
    lower_limit: None,
    factor: None,
    period:,
    origin:,
    extension: [],
    id: None,
  )
}

pub fn sampleddata_to_json(sampleddata: Sampleddata) -> Json {
  let Sampleddata(
    data:,
    dimensions:,
    upper_limit:,
    lower_limit:,
    factor:,
    period:,
    origin:,
    extension:,
    id:,
  ) = sampleddata
  let fields = [
    #("dimensions", json.int(dimensions)),
    #("period", json.float(period)),
    #("origin", quantity_to_json(origin)),
  ]
  let fields = case data {
    Some(v) -> [#("data", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case upper_limit {
    Some(v) -> [#("upperLimit", json.float(v)), ..fields]
    None -> fields
  }
  let fields = case lower_limit {
    Some(v) -> [#("lowerLimit", json.float(v)), ..fields]
    None -> fields
  }
  let fields = case factor {
    Some(v) -> [#("factor", json.float(v)), ..fields]
    None -> fields
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn sampleddata_decoder() -> Decoder(Sampleddata) {
  use data <- decode.optional_field(
    "data",
    None,
    decode.optional(decode.string),
  )
  use dimensions <- decode.field("dimensions", decode.int)
  use upper_limit <- decode.optional_field(
    "upperLimit",
    None,
    decode.optional(decode.float),
  )
  use lower_limit <- decode.optional_field(
    "lowerLimit",
    None,
    decode.optional(decode.float),
  )
  use factor <- decode.optional_field(
    "factor",
    None,
    decode.optional(decode.float),
  )
  use period <- decode.field("period", decode.float)
  use origin <- decode.field("origin", quantity_decoder())
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(Sampleddata(
    data:,
    dimensions:,
    upper_limit:,
    lower_limit:,
    factor:,
    period:,
    origin:,
    extension:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/Signature#resource
pub type Signature {
  Signature(
    id: Option(String),
    extension: List(Extension),
    type_: List(Coding),
    when: String,
    who: Reference,
    on_behalf_of: Option(Reference),
    target_format: Option(String),
    sig_format: Option(String),
    data: Option(String),
  )
}

pub fn signature_new(who who: Reference, when when: String) -> Signature {
  Signature(
    data: None,
    sig_format: None,
    target_format: None,
    on_behalf_of: None,
    who:,
    when:,
    type_: [],
    extension: [],
    id: None,
  )
}

pub fn signature_to_json(signature: Signature) -> Json {
  let Signature(
    data:,
    sig_format:,
    target_format:,
    on_behalf_of:,
    who:,
    when:,
    type_:,
    extension:,
    id:,
  ) = signature
  let fields = [
    #("who", reference_to_json(who)),
    #("when", json.string(when)),
  ]
  let fields = case data {
    Some(v) -> [#("data", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case sig_format {
    Some(v) -> [#("sigFormat", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case target_format {
    Some(v) -> [#("targetFormat", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case on_behalf_of {
    Some(v) -> [#("onBehalfOf", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    [] -> fields
    _ -> [#("type", json.array(type_, coding_to_json)), ..fields]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn signature_decoder() -> Decoder(Signature) {
  use data <- decode.optional_field(
    "data",
    None,
    decode.optional(decode.string),
  )
  use sig_format <- decode.optional_field(
    "sigFormat",
    None,
    decode.optional(decode.string),
  )
  use target_format <- decode.optional_field(
    "targetFormat",
    None,
    decode.optional(decode.string),
  )
  use on_behalf_of <- decode.optional_field(
    "onBehalfOf",
    None,
    decode.optional(reference_decoder()),
  )
  use who <- decode.field("who", reference_decoder())
  use when <- decode.field("when", decode.string)
  use type_ <- decode.optional_field("type", [], decode.list(coding_decoder()))
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(Signature(
    data:,
    sig_format:,
    target_format:,
    on_behalf_of:,
    who:,
    when:,
    type_:,
    extension:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/Timing#resource
pub type Timing {
  Timing(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    event: List(String),
    repeat: Option(TimingRepeat),
    code: Option(Codeableconcept),
  )
}

pub fn timing_new() -> Timing {
  Timing(
    code: None,
    repeat: None,
    event: [],
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Timing#resource
pub type TimingRepeat {
  TimingRepeat(
    id: Option(String),
    extension: List(Extension),
    bounds: Option(TimingRepeatBounds),
    count: Option(Int),
    count_max: Option(Int),
    duration: Option(Float),
    duration_max: Option(Float),
    duration_unit: Option(r4bvaluesets.Unitsoftime),
    frequency: Option(Int),
    frequency_max: Option(Int),
    period: Option(Float),
    period_max: Option(Float),
    period_unit: Option(r4bvaluesets.Unitsoftime),
    day_of_week: List(r4bvaluesets.Daysofweek),
    time_of_day: List(String),
    when: List(r4bvaluesets.Eventtiming),
    offset: Option(Int),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Timing#resource
pub type TimingRepeatBounds {
  TimingRepeatBoundsDuration(bounds: Duration)
  TimingRepeatBoundsRange(bounds: Range)
  TimingRepeatBoundsPeriod(bounds: Period)
}

pub fn timing_repeat_bounds_to_json(elt: TimingRepeatBounds) -> Json {
  case elt {
    TimingRepeatBoundsDuration(v) -> duration_to_json(v)
    TimingRepeatBoundsRange(v) -> range_to_json(v)
    TimingRepeatBoundsPeriod(v) -> period_to_json(v)
  }
}

pub fn timing_repeat_bounds_decoder() -> Decoder(TimingRepeatBounds) {
  decode.one_of(
    decode.field("boundsDuration", duration_decoder(), decode.success)
      |> decode.map(TimingRepeatBoundsDuration),
    [
      decode.field("boundsRange", range_decoder(), decode.success)
        |> decode.map(TimingRepeatBoundsRange),
      decode.field("boundsPeriod", period_decoder(), decode.success)
        |> decode.map(TimingRepeatBoundsPeriod),
    ],
  )
}

pub fn timing_repeat_new() -> TimingRepeat {
  TimingRepeat(
    offset: None,
    when: [],
    time_of_day: [],
    day_of_week: [],
    period_unit: None,
    period_max: None,
    period: None,
    frequency_max: None,
    frequency: None,
    duration_unit: None,
    duration_max: None,
    duration: None,
    count_max: None,
    count: None,
    bounds: None,
    extension: [],
    id: None,
  )
}

pub fn timing_repeat_to_json(timing_repeat: TimingRepeat) -> Json {
  let TimingRepeat(
    offset:,
    when:,
    time_of_day:,
    day_of_week:,
    period_unit:,
    period_max:,
    period:,
    frequency_max:,
    frequency:,
    duration_unit:,
    duration_max:,
    duration:,
    count_max:,
    count:,
    bounds:,
    extension:,
    id:,
  ) = timing_repeat
  let fields = []
  let fields = case offset {
    Some(v) -> [#("offset", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case when {
    [] -> fields
    _ -> [
      #("when", json.array(when, r4bvaluesets.eventtiming_to_json)),
      ..fields
    ]
  }
  let fields = case time_of_day {
    [] -> fields
    _ -> [#("timeOfDay", json.array(time_of_day, json.string)), ..fields]
  }
  let fields = case day_of_week {
    [] -> fields
    _ -> [
      #("dayOfWeek", json.array(day_of_week, r4bvaluesets.daysofweek_to_json)),
      ..fields
    ]
  }
  let fields = case period_unit {
    Some(v) -> [#("periodUnit", r4bvaluesets.unitsoftime_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case period_max {
    Some(v) -> [#("periodMax", json.float(v)), ..fields]
    None -> fields
  }
  let fields = case period {
    Some(v) -> [#("period", json.float(v)), ..fields]
    None -> fields
  }
  let fields = case frequency_max {
    Some(v) -> [#("frequencyMax", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case frequency {
    Some(v) -> [#("frequency", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case duration_unit {
    Some(v) -> [
      #("durationUnit", r4bvaluesets.unitsoftime_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case duration_max {
    Some(v) -> [#("durationMax", json.float(v)), ..fields]
    None -> fields
  }
  let fields = case duration {
    Some(v) -> [#("duration", json.float(v)), ..fields]
    None -> fields
  }
  let fields = case count_max {
    Some(v) -> [#("countMax", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case count {
    Some(v) -> [#("count", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case bounds {
    Some(v) -> [
      #(
        "bounds"
          <> case v {
          TimingRepeatBoundsDuration(_) -> "Duration"
          TimingRepeatBoundsRange(_) -> "Range"
          TimingRepeatBoundsPeriod(_) -> "Period"
        },
        timing_repeat_bounds_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn timing_repeat_decoder() -> Decoder(TimingRepeat) {
  use offset <- decode.optional_field(
    "offset",
    None,
    decode.optional(decode.int),
  )
  use when <- decode.optional_field(
    "when",
    [],
    decode.list(r4bvaluesets.eventtiming_decoder()),
  )
  use time_of_day <- decode.optional_field(
    "timeOfDay",
    [],
    decode.list(decode.string),
  )
  use day_of_week <- decode.optional_field(
    "dayOfWeek",
    [],
    decode.list(r4bvaluesets.daysofweek_decoder()),
  )
  use period_unit <- decode.optional_field(
    "periodUnit",
    None,
    decode.optional(r4bvaluesets.unitsoftime_decoder()),
  )
  use period_max <- decode.optional_field(
    "periodMax",
    None,
    decode.optional(decode.float),
  )
  use period <- decode.optional_field(
    "period",
    None,
    decode.optional(decode.float),
  )
  use frequency_max <- decode.optional_field(
    "frequencyMax",
    None,
    decode.optional(decode.int),
  )
  use frequency <- decode.optional_field(
    "frequency",
    None,
    decode.optional(decode.int),
  )
  use duration_unit <- decode.optional_field(
    "durationUnit",
    None,
    decode.optional(r4bvaluesets.unitsoftime_decoder()),
  )
  use duration_max <- decode.optional_field(
    "durationMax",
    None,
    decode.optional(decode.float),
  )
  use duration <- decode.optional_field(
    "duration",
    None,
    decode.optional(decode.float),
  )
  use count_max <- decode.optional_field(
    "countMax",
    None,
    decode.optional(decode.int),
  )
  use count <- decode.optional_field("count", None, decode.optional(decode.int))
  use bounds <- decode.then(none_if_omitted(timing_repeat_bounds_decoder()))
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(TimingRepeat(
    offset:,
    when:,
    time_of_day:,
    day_of_week:,
    period_unit:,
    period_max:,
    period:,
    frequency_max:,
    frequency:,
    duration_unit:,
    duration_max:,
    duration:,
    count_max:,
    count:,
    bounds:,
    extension:,
    id:,
  ))
}

pub fn timing_to_json(timing: Timing) -> Json {
  let Timing(code:, repeat:, event:, modifier_extension:, extension:, id:) =
    timing
  let fields = []
  let fields = case code {
    Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case repeat {
    Some(v) -> [#("repeat", timing_repeat_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case event {
    [] -> fields
    _ -> [#("event", json.array(event, json.string)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn timing_decoder() -> Decoder(Timing) {
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use repeat <- decode.optional_field(
    "repeat",
    None,
    decode.optional(timing_repeat_decoder()),
  )
  use event <- decode.optional_field("event", [], decode.list(decode.string))
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(Timing(
    code:,
    repeat:,
    event:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/TriggerDefinition#resource
pub type Triggerdefinition {
  Triggerdefinition(
    id: Option(String),
    extension: List(Extension),
    type_: r4bvaluesets.Triggertype,
    name: Option(String),
    timing: Option(TriggerdefinitionTiming),
    data: List(Datarequirement),
    condition: Option(Expression),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/TriggerDefinition#resource
pub type TriggerdefinitionTiming {
  TriggerdefinitionTimingTiming(timing: Timing)
  TriggerdefinitionTimingReference(timing: Reference)
  TriggerdefinitionTimingDate(timing: String)
  TriggerdefinitionTimingDatetime(timing: String)
}

pub fn triggerdefinition_timing_to_json(elt: TriggerdefinitionTiming) -> Json {
  case elt {
    TriggerdefinitionTimingTiming(v) -> timing_to_json(v)
    TriggerdefinitionTimingReference(v) -> reference_to_json(v)
    TriggerdefinitionTimingDate(v) -> json.string(v)
    TriggerdefinitionTimingDatetime(v) -> json.string(v)
  }
}

pub fn triggerdefinition_timing_decoder() -> Decoder(TriggerdefinitionTiming) {
  decode.one_of(
    decode.field("timingTiming", timing_decoder(), decode.success)
      |> decode.map(TriggerdefinitionTimingTiming),
    [
      decode.field("timingReference", reference_decoder(), decode.success)
        |> decode.map(TriggerdefinitionTimingReference),
      decode.field("timingDate", decode.string, decode.success)
        |> decode.map(TriggerdefinitionTimingDate),
      decode.field("timingDateTime", decode.string, decode.success)
        |> decode.map(TriggerdefinitionTimingDatetime),
    ],
  )
}

pub fn triggerdefinition_new(
  type_ type_: r4bvaluesets.Triggertype,
) -> Triggerdefinition {
  Triggerdefinition(
    condition: None,
    data: [],
    timing: None,
    name: None,
    type_:,
    extension: [],
    id: None,
  )
}

pub fn triggerdefinition_to_json(triggerdefinition: Triggerdefinition) -> Json {
  let Triggerdefinition(
    condition:,
    data:,
    timing:,
    name:,
    type_:,
    extension:,
    id:,
  ) = triggerdefinition
  let fields = [
    #("type", r4bvaluesets.triggertype_to_json(type_)),
  ]
  let fields = case condition {
    Some(v) -> [#("condition", expression_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case data {
    [] -> fields
    _ -> [#("data", json.array(data, datarequirement_to_json)), ..fields]
  }
  let fields = case timing {
    Some(v) -> [
      #(
        "timing"
          <> case v {
          TriggerdefinitionTimingTiming(_) -> "Timing"
          TriggerdefinitionTimingReference(_) -> "Reference"
          TriggerdefinitionTimingDate(_) -> "Date"
          TriggerdefinitionTimingDatetime(_) -> "Datetime"
        },
        triggerdefinition_timing_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn triggerdefinition_decoder() -> Decoder(Triggerdefinition) {
  use condition <- decode.optional_field(
    "condition",
    None,
    decode.optional(expression_decoder()),
  )
  use data <- decode.optional_field(
    "data",
    [],
    decode.list(datarequirement_decoder()),
  )
  use timing <- decode.then(none_if_omitted(triggerdefinition_timing_decoder()))
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use type_ <- decode.field("type", r4bvaluesets.triggertype_decoder())
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(Triggerdefinition(
    condition:,
    data:,
    timing:,
    name:,
    type_:,
    extension:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/UsageContext#resource
pub type Usagecontext {
  Usagecontext(
    id: Option(String),
    extension: List(Extension),
    code: Coding,
    value: UsagecontextValue,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/UsageContext#resource
pub type UsagecontextValue {
  UsagecontextValueCodeableconcept(value: Codeableconcept)
  UsagecontextValueQuantity(value: Quantity)
  UsagecontextValueRange(value: Range)
  UsagecontextValueReference(value: Reference)
}

pub fn usagecontext_value_to_json(elt: UsagecontextValue) -> Json {
  case elt {
    UsagecontextValueCodeableconcept(v) -> codeableconcept_to_json(v)
    UsagecontextValueQuantity(v) -> quantity_to_json(v)
    UsagecontextValueRange(v) -> range_to_json(v)
    UsagecontextValueReference(v) -> reference_to_json(v)
  }
}

pub fn usagecontext_value_decoder() -> Decoder(UsagecontextValue) {
  decode.one_of(
    decode.field(
      "valueCodeableConcept",
      codeableconcept_decoder(),
      decode.success,
    )
      |> decode.map(UsagecontextValueCodeableconcept),
    [
      decode.field("valueQuantity", quantity_decoder(), decode.success)
        |> decode.map(UsagecontextValueQuantity),
      decode.field("valueRange", range_decoder(), decode.success)
        |> decode.map(UsagecontextValueRange),
      decode.field("valueReference", reference_decoder(), decode.success)
        |> decode.map(UsagecontextValueReference),
    ],
  )
}

pub fn usagecontext_new(
  value value: UsagecontextValue,
  code code: Coding,
) -> Usagecontext {
  Usagecontext(value:, code:, extension: [], id: None)
}

pub fn usagecontext_to_json(usagecontext: Usagecontext) -> Json {
  let Usagecontext(value:, code:, extension:, id:) = usagecontext
  let fields = [
    #("value", usagecontext_value_to_json(value)),
    #("code", coding_to_json(code)),
  ]
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn usagecontext_decoder() -> Decoder(Usagecontext) {
  use value <- decode.then(usagecontext_value_decoder())
  use code <- decode.field("code", coding_decoder())
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(Usagecontext(value:, code:, extension:, id:))
}

///http://hl7.org/fhir/r4b/StructureDefinition/MoneyQuantity#resource
pub type Moneyquantity {
  Moneyquantity(
    id: Option(String),
    extension: List(Extension),
    value: Option(Float),
    comparator: Option(r4bvaluesets.Quantitycomparator),
    unit: Option(String),
    system: Option(String),
    code: Option(String),
  )
}

pub fn moneyquantity_new() -> Moneyquantity {
  Moneyquantity(
    code: None,
    system: None,
    unit: None,
    comparator: None,
    value: None,
    extension: [],
    id: None,
  )
}

pub fn moneyquantity_to_json(moneyquantity: Moneyquantity) -> Json {
  let Moneyquantity(code:, system:, unit:, comparator:, value:, extension:, id:) =
    moneyquantity
  let fields = []
  let fields = case code {
    Some(v) -> [#("code", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case system {
    Some(v) -> [#("system", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case unit {
    Some(v) -> [#("unit", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case comparator {
    Some(v) -> [
      #("comparator", r4bvaluesets.quantitycomparator_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case value {
    Some(v) -> [#("value", json.float(v)), ..fields]
    None -> fields
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn moneyquantity_decoder() -> Decoder(Moneyquantity) {
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(decode.string),
  )
  use system <- decode.optional_field(
    "system",
    None,
    decode.optional(decode.string),
  )
  use unit <- decode.optional_field(
    "unit",
    None,
    decode.optional(decode.string),
  )
  use comparator <- decode.optional_field(
    "comparator",
    None,
    decode.optional(r4bvaluesets.quantitycomparator_decoder()),
  )
  use value <- decode.optional_field(
    "value",
    None,
    decode.optional(decode.float),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(Moneyquantity(
    code:,
    system:,
    unit:,
    comparator:,
    value:,
    extension:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/SimpleQuantity#resource
pub type Simplequantity {
  Simplequantity(
    id: Option(String),
    extension: List(Extension),
    value: Option(Float),
    unit: Option(String),
    system: Option(String),
    code: Option(String),
  )
}

pub fn simplequantity_new() -> Simplequantity {
  Simplequantity(
    code: None,
    system: None,
    unit: None,
    value: None,
    extension: [],
    id: None,
  )
}

pub fn simplequantity_to_json(simplequantity: Simplequantity) -> Json {
  let Simplequantity(code:, system:, unit:, value:, extension:, id:) =
    simplequantity
  let fields = []
  let fields = case code {
    Some(v) -> [#("code", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case system {
    Some(v) -> [#("system", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case unit {
    Some(v) -> [#("unit", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case value {
    Some(v) -> [#("value", json.float(v)), ..fields]
    None -> fields
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn simplequantity_decoder() -> Decoder(Simplequantity) {
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(decode.string),
  )
  use system <- decode.optional_field(
    "system",
    None,
    decode.optional(decode.string),
  )
  use unit <- decode.optional_field(
    "unit",
    None,
    decode.optional(decode.string),
  )
  use value <- decode.optional_field(
    "value",
    None,
    decode.optional(decode.float),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(Simplequantity(code:, system:, unit:, value:, extension:, id:))
}

///http://hl7.org/fhir/r4b/StructureDefinition/Account#resource
pub type Account {
  Account(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    status: r4bvaluesets.Accountstatus,
    type_: Option(Codeableconcept),
    name: Option(String),
    subject: List(Reference),
    service_period: Option(Period),
    coverage: List(AccountCoverage),
    owner: Option(Reference),
    description: Option(String),
    guarantor: List(AccountGuarantor),
    part_of: Option(Reference),
  )
}

pub fn account_new(status status: r4bvaluesets.Accountstatus) -> Account {
  Account(
    part_of: None,
    guarantor: [],
    description: None,
    owner: None,
    coverage: [],
    service_period: None,
    subject: [],
    name: None,
    type_: None,
    status:,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Account#resource
pub type AccountCoverage {
  AccountCoverage(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    coverage: Reference,
    priority: Option(Int),
  )
}

pub fn account_coverage_new(coverage coverage: Reference) -> AccountCoverage {
  AccountCoverage(
    priority: None,
    coverage:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Account#resource
pub type AccountGuarantor {
  AccountGuarantor(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    party: Reference,
    on_hold: Option(Bool),
    period: Option(Period),
  )
}

pub fn account_guarantor_new(party party: Reference) -> AccountGuarantor {
  AccountGuarantor(
    period: None,
    on_hold: None,
    party:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn account_guarantor_to_json(account_guarantor: AccountGuarantor) -> Json {
  let AccountGuarantor(
    period:,
    on_hold:,
    party:,
    modifier_extension:,
    extension:,
    id:,
  ) = account_guarantor
  let fields = [
    #("party", reference_to_json(party)),
  ]
  let fields = case period {
    Some(v) -> [#("period", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case on_hold {
    Some(v) -> [#("onHold", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn account_guarantor_decoder() -> Decoder(AccountGuarantor) {
  use period <- decode.optional_field(
    "period",
    None,
    decode.optional(period_decoder()),
  )
  use on_hold <- decode.optional_field(
    "onHold",
    None,
    decode.optional(decode.bool),
  )
  use party <- decode.field("party", reference_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(AccountGuarantor(
    period:,
    on_hold:,
    party:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn account_coverage_to_json(account_coverage: AccountCoverage) -> Json {
  let AccountCoverage(
    priority:,
    coverage:,
    modifier_extension:,
    extension:,
    id:,
  ) = account_coverage
  let fields = [
    #("coverage", reference_to_json(coverage)),
  ]
  let fields = case priority {
    Some(v) -> [#("priority", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn account_coverage_decoder() -> Decoder(AccountCoverage) {
  use priority <- decode.optional_field(
    "priority",
    None,
    decode.optional(decode.int),
  )
  use coverage <- decode.field("coverage", reference_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(AccountCoverage(
    priority:,
    coverage:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn account_to_json(account: Account) -> Json {
  let Account(
    part_of:,
    guarantor:,
    description:,
    owner:,
    coverage:,
    service_period:,
    subject:,
    name:,
    type_:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = account
  let fields = [
    #("status", r4bvaluesets.accountstatus_to_json(status)),
  ]
  let fields = case part_of {
    Some(v) -> [#("partOf", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case guarantor {
    [] -> fields
    _ -> [
      #("guarantor", json.array(guarantor, account_guarantor_to_json)),
      ..fields
    ]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case owner {
    Some(v) -> [#("owner", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case coverage {
    [] -> fields
    _ -> [
      #("coverage", json.array(coverage, account_coverage_to_json)),
      ..fields
    ]
  }
  let fields = case service_period {
    Some(v) -> [#("servicePeriod", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case subject {
    [] -> fields
    _ -> [#("subject", json.array(subject, reference_to_json)), ..fields]
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Account")), ..fields]
  json.object(fields)
}

pub fn account_decoder() -> Decoder(Account) {
  use part_of <- decode.optional_field(
    "partOf",
    None,
    decode.optional(reference_decoder()),
  )
  use guarantor <- decode.optional_field(
    "guarantor",
    [],
    decode.list(account_guarantor_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use owner <- decode.optional_field(
    "owner",
    None,
    decode.optional(reference_decoder()),
  )
  use coverage <- decode.optional_field(
    "coverage",
    [],
    decode.list(account_coverage_decoder()),
  )
  use service_period <- decode.optional_field(
    "servicePeriod",
    None,
    decode.optional(period_decoder()),
  )
  use subject <- decode.optional_field(
    "subject",
    [],
    decode.list(reference_decoder()),
  )
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use status <- decode.field("status", r4bvaluesets.accountstatus_decoder())
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Account",
    decode.failure(account_new(status:), "resourceType"),
  )
  decode.success(Account(
    part_of:,
    guarantor:,
    description:,
    owner:,
    coverage:,
    service_period:,
    subject:,
    name:,
    type_:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/ActivityDefinition#resource
pub type Activitydefinition {
  Activitydefinition(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    url: Option(String),
    identifier: List(Identifier),
    version: Option(String),
    name: Option(String),
    title: Option(String),
    subtitle: Option(String),
    status: r4bvaluesets.Publicationstatus,
    experimental: Option(Bool),
    subject: Option(ActivitydefinitionSubject),
    date: Option(String),
    publisher: Option(String),
    contact: List(Contactdetail),
    description: Option(String),
    use_context: List(Usagecontext),
    jurisdiction: List(Codeableconcept),
    purpose: Option(String),
    usage: Option(String),
    copyright: Option(String),
    approval_date: Option(String),
    last_review_date: Option(String),
    effective_period: Option(Period),
    topic: List(Codeableconcept),
    author: List(Contactdetail),
    editor: List(Contactdetail),
    reviewer: List(Contactdetail),
    endorser: List(Contactdetail),
    related_artifact: List(Relatedartifact),
    library: List(String),
    kind: Option(r4bvaluesets.Requestresourcetypes),
    profile: Option(String),
    code: Option(Codeableconcept),
    intent: Option(r4bvaluesets.Requestintent),
    priority: Option(r4bvaluesets.Requestpriority),
    do_not_perform: Option(Bool),
    timing: Option(ActivitydefinitionTiming),
    location: Option(Reference),
    participant: List(ActivitydefinitionParticipant),
    product: Option(ActivitydefinitionProduct),
    quantity: Option(Quantity),
    dosage: List(Dosage),
    body_site: List(Codeableconcept),
    specimen_requirement: List(Reference),
    observation_requirement: List(Reference),
    observation_result_requirement: List(Reference),
    transform: Option(String),
    dynamic_value: List(ActivitydefinitionDynamicvalue),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ActivityDefinition#resource
pub type ActivitydefinitionSubject {
  ActivitydefinitionSubjectCodeableconcept(subject: Codeableconcept)
  ActivitydefinitionSubjectReference(subject: Reference)
  ActivitydefinitionSubjectCanonical(subject: String)
}

pub fn activitydefinition_subject_to_json(
  elt: ActivitydefinitionSubject,
) -> Json {
  case elt {
    ActivitydefinitionSubjectCodeableconcept(v) -> codeableconcept_to_json(v)
    ActivitydefinitionSubjectReference(v) -> reference_to_json(v)
    ActivitydefinitionSubjectCanonical(v) -> json.string(v)
  }
}

pub fn activitydefinition_subject_decoder() -> Decoder(
  ActivitydefinitionSubject,
) {
  decode.one_of(
    decode.field(
      "subjectCodeableConcept",
      codeableconcept_decoder(),
      decode.success,
    )
      |> decode.map(ActivitydefinitionSubjectCodeableconcept),
    [
      decode.field("subjectReference", reference_decoder(), decode.success)
        |> decode.map(ActivitydefinitionSubjectReference),
      decode.field("subjectCanonical", decode.string, decode.success)
        |> decode.map(ActivitydefinitionSubjectCanonical),
    ],
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ActivityDefinition#resource
pub type ActivitydefinitionTiming {
  ActivitydefinitionTimingTiming(timing: Timing)
  ActivitydefinitionTimingDatetime(timing: String)
  ActivitydefinitionTimingAge(timing: Age)
  ActivitydefinitionTimingPeriod(timing: Period)
  ActivitydefinitionTimingRange(timing: Range)
  ActivitydefinitionTimingDuration(timing: Duration)
}

pub fn activitydefinition_timing_to_json(elt: ActivitydefinitionTiming) -> Json {
  case elt {
    ActivitydefinitionTimingTiming(v) -> timing_to_json(v)
    ActivitydefinitionTimingDatetime(v) -> json.string(v)
    ActivitydefinitionTimingAge(v) -> age_to_json(v)
    ActivitydefinitionTimingPeriod(v) -> period_to_json(v)
    ActivitydefinitionTimingRange(v) -> range_to_json(v)
    ActivitydefinitionTimingDuration(v) -> duration_to_json(v)
  }
}

pub fn activitydefinition_timing_decoder() -> Decoder(ActivitydefinitionTiming) {
  decode.one_of(
    decode.field("timingTiming", timing_decoder(), decode.success)
      |> decode.map(ActivitydefinitionTimingTiming),
    [
      decode.field("timingDateTime", decode.string, decode.success)
        |> decode.map(ActivitydefinitionTimingDatetime),
      decode.field("timingAge", age_decoder(), decode.success)
        |> decode.map(ActivitydefinitionTimingAge),
      decode.field("timingPeriod", period_decoder(), decode.success)
        |> decode.map(ActivitydefinitionTimingPeriod),
      decode.field("timingRange", range_decoder(), decode.success)
        |> decode.map(ActivitydefinitionTimingRange),
      decode.field("timingDuration", duration_decoder(), decode.success)
        |> decode.map(ActivitydefinitionTimingDuration),
    ],
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ActivityDefinition#resource
pub type ActivitydefinitionProduct {
  ActivitydefinitionProductReference(product: Reference)
  ActivitydefinitionProductCodeableconcept(product: Codeableconcept)
}

pub fn activitydefinition_product_to_json(
  elt: ActivitydefinitionProduct,
) -> Json {
  case elt {
    ActivitydefinitionProductReference(v) -> reference_to_json(v)
    ActivitydefinitionProductCodeableconcept(v) -> codeableconcept_to_json(v)
  }
}

pub fn activitydefinition_product_decoder() -> Decoder(
  ActivitydefinitionProduct,
) {
  decode.one_of(
    decode.field("productReference", reference_decoder(), decode.success)
      |> decode.map(ActivitydefinitionProductReference),
    [
      decode.field(
        "productCodeableConcept",
        codeableconcept_decoder(),
        decode.success,
      )
      |> decode.map(ActivitydefinitionProductCodeableconcept),
    ],
  )
}

pub fn activitydefinition_new(
  status status: r4bvaluesets.Publicationstatus,
) -> Activitydefinition {
  Activitydefinition(
    dynamic_value: [],
    transform: None,
    observation_result_requirement: [],
    observation_requirement: [],
    specimen_requirement: [],
    body_site: [],
    dosage: [],
    quantity: None,
    product: None,
    participant: [],
    location: None,
    timing: None,
    do_not_perform: None,
    priority: None,
    intent: None,
    code: None,
    profile: None,
    kind: None,
    library: [],
    related_artifact: [],
    endorser: [],
    reviewer: [],
    editor: [],
    author: [],
    topic: [],
    effective_period: None,
    last_review_date: None,
    approval_date: None,
    copyright: None,
    usage: None,
    purpose: None,
    jurisdiction: [],
    use_context: [],
    description: None,
    contact: [],
    publisher: None,
    date: None,
    subject: None,
    experimental: None,
    status:,
    subtitle: None,
    title: None,
    name: None,
    version: None,
    identifier: [],
    url: None,
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ActivityDefinition#resource
pub type ActivitydefinitionParticipant {
  ActivitydefinitionParticipant(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: r4bvaluesets.Actionparticipanttype,
    role: Option(Codeableconcept),
  )
}

pub fn activitydefinition_participant_new(
  type_ type_: r4bvaluesets.Actionparticipanttype,
) -> ActivitydefinitionParticipant {
  ActivitydefinitionParticipant(
    role: None,
    type_:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ActivityDefinition#resource
pub type ActivitydefinitionDynamicvalue {
  ActivitydefinitionDynamicvalue(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    path: String,
    expression: Expression,
  )
}

pub fn activitydefinition_dynamicvalue_new(
  expression expression: Expression,
  path path: String,
) -> ActivitydefinitionDynamicvalue {
  ActivitydefinitionDynamicvalue(
    expression:,
    path:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn activitydefinition_dynamicvalue_to_json(
  activitydefinition_dynamicvalue: ActivitydefinitionDynamicvalue,
) -> Json {
  let ActivitydefinitionDynamicvalue(
    expression:,
    path:,
    modifier_extension:,
    extension:,
    id:,
  ) = activitydefinition_dynamicvalue
  let fields = [
    #("expression", expression_to_json(expression)),
    #("path", json.string(path)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn activitydefinition_dynamicvalue_decoder() -> Decoder(
  ActivitydefinitionDynamicvalue,
) {
  use expression <- decode.field("expression", expression_decoder())
  use path <- decode.field("path", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ActivitydefinitionDynamicvalue(
    expression:,
    path:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn activitydefinition_participant_to_json(
  activitydefinition_participant: ActivitydefinitionParticipant,
) -> Json {
  let ActivitydefinitionParticipant(
    role:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = activitydefinition_participant
  let fields = [
    #("type", r4bvaluesets.actionparticipanttype_to_json(type_)),
  ]
  let fields = case role {
    Some(v) -> [#("role", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn activitydefinition_participant_decoder() -> Decoder(
  ActivitydefinitionParticipant,
) {
  use role <- decode.optional_field(
    "role",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use type_ <- decode.field(
    "type",
    r4bvaluesets.actionparticipanttype_decoder(),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ActivitydefinitionParticipant(
    role:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn activitydefinition_to_json(
  activitydefinition: Activitydefinition,
) -> Json {
  let Activitydefinition(
    dynamic_value:,
    transform:,
    observation_result_requirement:,
    observation_requirement:,
    specimen_requirement:,
    body_site:,
    dosage:,
    quantity:,
    product:,
    participant:,
    location:,
    timing:,
    do_not_perform:,
    priority:,
    intent:,
    code:,
    profile:,
    kind:,
    library:,
    related_artifact:,
    endorser:,
    reviewer:,
    editor:,
    author:,
    topic:,
    effective_period:,
    last_review_date:,
    approval_date:,
    copyright:,
    usage:,
    purpose:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    subject:,
    experimental:,
    status:,
    subtitle:,
    title:,
    name:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = activitydefinition
  let fields = [
    #("status", r4bvaluesets.publicationstatus_to_json(status)),
  ]
  let fields = case dynamic_value {
    [] -> fields
    _ -> [
      #(
        "dynamicValue",
        json.array(dynamic_value, activitydefinition_dynamicvalue_to_json),
      ),
      ..fields
    ]
  }
  let fields = case transform {
    Some(v) -> [#("transform", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case observation_result_requirement {
    [] -> fields
    _ -> [
      #(
        "observationResultRequirement",
        json.array(observation_result_requirement, reference_to_json),
      ),
      ..fields
    ]
  }
  let fields = case observation_requirement {
    [] -> fields
    _ -> [
      #(
        "observationRequirement",
        json.array(observation_requirement, reference_to_json),
      ),
      ..fields
    ]
  }
  let fields = case specimen_requirement {
    [] -> fields
    _ -> [
      #(
        "specimenRequirement",
        json.array(specimen_requirement, reference_to_json),
      ),
      ..fields
    ]
  }
  let fields = case body_site {
    [] -> fields
    _ -> [
      #("bodySite", json.array(body_site, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case dosage {
    [] -> fields
    _ -> [#("dosage", json.array(dosage, dosage_to_json)), ..fields]
  }
  let fields = case quantity {
    Some(v) -> [#("quantity", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case product {
    Some(v) -> [
      #(
        "product"
          <> case v {
          ActivitydefinitionProductReference(_) -> "Reference"
          ActivitydefinitionProductCodeableconcept(_) -> "Codeableconcept"
        },
        activitydefinition_product_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case participant {
    [] -> fields
    _ -> [
      #(
        "participant",
        json.array(participant, activitydefinition_participant_to_json),
      ),
      ..fields
    ]
  }
  let fields = case location {
    Some(v) -> [#("location", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case timing {
    Some(v) -> [
      #(
        "timing"
          <> case v {
          ActivitydefinitionTimingTiming(_) -> "Timing"
          ActivitydefinitionTimingDatetime(_) -> "Datetime"
          ActivitydefinitionTimingAge(_) -> "Age"
          ActivitydefinitionTimingPeriod(_) -> "Period"
          ActivitydefinitionTimingRange(_) -> "Range"
          ActivitydefinitionTimingDuration(_) -> "Duration"
        },
        activitydefinition_timing_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case do_not_perform {
    Some(v) -> [#("doNotPerform", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case priority {
    Some(v) -> [
      #("priority", r4bvaluesets.requestpriority_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case intent {
    Some(v) -> [#("intent", r4bvaluesets.requestintent_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case code {
    Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case profile {
    Some(v) -> [#("profile", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case kind {
    Some(v) -> [
      #("kind", r4bvaluesets.requestresourcetypes_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case library {
    [] -> fields
    _ -> [#("library", json.array(library, json.string)), ..fields]
  }
  let fields = case related_artifact {
    [] -> fields
    _ -> [
      #(
        "relatedArtifact",
        json.array(related_artifact, relatedartifact_to_json),
      ),
      ..fields
    ]
  }
  let fields = case endorser {
    [] -> fields
    _ -> [#("endorser", json.array(endorser, contactdetail_to_json)), ..fields]
  }
  let fields = case reviewer {
    [] -> fields
    _ -> [#("reviewer", json.array(reviewer, contactdetail_to_json)), ..fields]
  }
  let fields = case editor {
    [] -> fields
    _ -> [#("editor", json.array(editor, contactdetail_to_json)), ..fields]
  }
  let fields = case author {
    [] -> fields
    _ -> [#("author", json.array(author, contactdetail_to_json)), ..fields]
  }
  let fields = case topic {
    [] -> fields
    _ -> [#("topic", json.array(topic, codeableconcept_to_json)), ..fields]
  }
  let fields = case effective_period {
    Some(v) -> [#("effectivePeriod", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case last_review_date {
    Some(v) -> [#("lastReviewDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case approval_date {
    Some(v) -> [#("approvalDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case copyright {
    Some(v) -> [#("copyright", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case usage {
    Some(v) -> [#("usage", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case purpose {
    Some(v) -> [#("purpose", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case jurisdiction {
    [] -> fields
    _ -> [
      #("jurisdiction", json.array(jurisdiction, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case use_context {
    [] -> fields
    _ -> [
      #("useContext", json.array(use_context, usagecontext_to_json)),
      ..fields
    ]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case contact {
    [] -> fields
    _ -> [#("contact", json.array(contact, contactdetail_to_json)), ..fields]
  }
  let fields = case publisher {
    Some(v) -> [#("publisher", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case date {
    Some(v) -> [#("date", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case subject {
    Some(v) -> [
      #(
        "subject"
          <> case v {
          ActivitydefinitionSubjectCodeableconcept(_) -> "Codeableconcept"
          ActivitydefinitionSubjectReference(_) -> "Reference"
          ActivitydefinitionSubjectCanonical(_) -> "Canonical"
        },
        activitydefinition_subject_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case experimental {
    Some(v) -> [#("experimental", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case subtitle {
    Some(v) -> [#("subtitle", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case title {
    Some(v) -> [#("title", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case version {
    Some(v) -> [#("version", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case url {
    Some(v) -> [#("url", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Activitydefinition")), ..fields]
  json.object(fields)
}

pub fn activitydefinition_decoder() -> Decoder(Activitydefinition) {
  use dynamic_value <- decode.optional_field(
    "dynamicValue",
    [],
    decode.list(activitydefinition_dynamicvalue_decoder()),
  )
  use transform <- decode.optional_field(
    "transform",
    None,
    decode.optional(decode.string),
  )
  use observation_result_requirement <- decode.optional_field(
    "observationResultRequirement",
    [],
    decode.list(reference_decoder()),
  )
  use observation_requirement <- decode.optional_field(
    "observationRequirement",
    [],
    decode.list(reference_decoder()),
  )
  use specimen_requirement <- decode.optional_field(
    "specimenRequirement",
    [],
    decode.list(reference_decoder()),
  )
  use body_site <- decode.optional_field(
    "bodySite",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use dosage <- decode.optional_field(
    "dosage",
    [],
    decode.list(dosage_decoder()),
  )
  use quantity <- decode.optional_field(
    "quantity",
    None,
    decode.optional(quantity_decoder()),
  )
  use product <- decode.then(
    none_if_omitted(activitydefinition_product_decoder()),
  )
  use participant <- decode.optional_field(
    "participant",
    [],
    decode.list(activitydefinition_participant_decoder()),
  )
  use location <- decode.optional_field(
    "location",
    None,
    decode.optional(reference_decoder()),
  )
  use timing <- decode.then(
    none_if_omitted(activitydefinition_timing_decoder()),
  )
  use do_not_perform <- decode.optional_field(
    "doNotPerform",
    None,
    decode.optional(decode.bool),
  )
  use priority <- decode.optional_field(
    "priority",
    None,
    decode.optional(r4bvaluesets.requestpriority_decoder()),
  )
  use intent <- decode.optional_field(
    "intent",
    None,
    decode.optional(r4bvaluesets.requestintent_decoder()),
  )
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use profile <- decode.optional_field(
    "profile",
    None,
    decode.optional(decode.string),
  )
  use kind <- decode.optional_field(
    "kind",
    None,
    decode.optional(r4bvaluesets.requestresourcetypes_decoder()),
  )
  use library <- decode.optional_field(
    "library",
    [],
    decode.list(decode.string),
  )
  use related_artifact <- decode.optional_field(
    "relatedArtifact",
    [],
    decode.list(relatedartifact_decoder()),
  )
  use endorser <- decode.optional_field(
    "endorser",
    [],
    decode.list(contactdetail_decoder()),
  )
  use reviewer <- decode.optional_field(
    "reviewer",
    [],
    decode.list(contactdetail_decoder()),
  )
  use editor <- decode.optional_field(
    "editor",
    [],
    decode.list(contactdetail_decoder()),
  )
  use author <- decode.optional_field(
    "author",
    [],
    decode.list(contactdetail_decoder()),
  )
  use topic <- decode.optional_field(
    "topic",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use effective_period <- decode.optional_field(
    "effectivePeriod",
    None,
    decode.optional(period_decoder()),
  )
  use last_review_date <- decode.optional_field(
    "lastReviewDate",
    None,
    decode.optional(decode.string),
  )
  use approval_date <- decode.optional_field(
    "approvalDate",
    None,
    decode.optional(decode.string),
  )
  use copyright <- decode.optional_field(
    "copyright",
    None,
    decode.optional(decode.string),
  )
  use usage <- decode.optional_field(
    "usage",
    None,
    decode.optional(decode.string),
  )
  use purpose <- decode.optional_field(
    "purpose",
    None,
    decode.optional(decode.string),
  )
  use jurisdiction <- decode.optional_field(
    "jurisdiction",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use use_context <- decode.optional_field(
    "useContext",
    [],
    decode.list(usagecontext_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use contact <- decode.optional_field(
    "contact",
    [],
    decode.list(contactdetail_decoder()),
  )
  use publisher <- decode.optional_field(
    "publisher",
    None,
    decode.optional(decode.string),
  )
  use date <- decode.optional_field(
    "date",
    None,
    decode.optional(decode.string),
  )
  use subject <- decode.then(
    none_if_omitted(activitydefinition_subject_decoder()),
  )
  use experimental <- decode.optional_field(
    "experimental",
    None,
    decode.optional(decode.bool),
  )
  use status <- decode.field("status", r4bvaluesets.publicationstatus_decoder())
  use subtitle <- decode.optional_field(
    "subtitle",
    None,
    decode.optional(decode.string),
  )
  use title <- decode.optional_field(
    "title",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use version <- decode.optional_field(
    "version",
    None,
    decode.optional(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use url <- decode.optional_field("url", None, decode.optional(decode.string))
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Activitydefinition",
    decode.failure(activitydefinition_new(status:), "resourceType"),
  )
  decode.success(Activitydefinition(
    dynamic_value:,
    transform:,
    observation_result_requirement:,
    observation_requirement:,
    specimen_requirement:,
    body_site:,
    dosage:,
    quantity:,
    product:,
    participant:,
    location:,
    timing:,
    do_not_perform:,
    priority:,
    intent:,
    code:,
    profile:,
    kind:,
    library:,
    related_artifact:,
    endorser:,
    reviewer:,
    editor:,
    author:,
    topic:,
    effective_period:,
    last_review_date:,
    approval_date:,
    copyright:,
    usage:,
    purpose:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    subject:,
    experimental:,
    status:,
    subtitle:,
    title:,
    name:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/AdministrableProductDefinition#resource
pub type Administrableproductdefinition {
  Administrableproductdefinition(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    status: r4bvaluesets.Publicationstatus,
    form_of: List(Reference),
    administrable_dose_form: Option(Codeableconcept),
    unit_of_presentation: Option(Codeableconcept),
    produced_from: List(Reference),
    ingredient: List(Codeableconcept),
    device: Option(Reference),
    property: List(AdministrableproductdefinitionProperty),
    route_of_administration: List(
      AdministrableproductdefinitionRouteofadministration,
    ),
  )
}

pub fn administrableproductdefinition_new(
  status status: r4bvaluesets.Publicationstatus,
) -> Administrableproductdefinition {
  Administrableproductdefinition(
    route_of_administration: [],
    property: [],
    device: None,
    ingredient: [],
    produced_from: [],
    unit_of_presentation: None,
    administrable_dose_form: None,
    form_of: [],
    status:,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/AdministrableProductDefinition#resource
pub type AdministrableproductdefinitionProperty {
  AdministrableproductdefinitionProperty(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Codeableconcept,
    value: Option(AdministrableproductdefinitionPropertyValue),
    status: Option(Codeableconcept),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/AdministrableProductDefinition#resource
pub type AdministrableproductdefinitionPropertyValue {
  AdministrableproductdefinitionPropertyValueCodeableconcept(
    value: Codeableconcept,
  )
  AdministrableproductdefinitionPropertyValueQuantity(value: Quantity)
  AdministrableproductdefinitionPropertyValueDate(value: String)
  AdministrableproductdefinitionPropertyValueBoolean(value: Bool)
  AdministrableproductdefinitionPropertyValueAttachment(value: Attachment)
}

pub fn administrableproductdefinition_property_value_to_json(
  elt: AdministrableproductdefinitionPropertyValue,
) -> Json {
  case elt {
    AdministrableproductdefinitionPropertyValueCodeableconcept(v) ->
      codeableconcept_to_json(v)
    AdministrableproductdefinitionPropertyValueQuantity(v) ->
      quantity_to_json(v)
    AdministrableproductdefinitionPropertyValueDate(v) -> json.string(v)
    AdministrableproductdefinitionPropertyValueBoolean(v) -> json.bool(v)
    AdministrableproductdefinitionPropertyValueAttachment(v) ->
      attachment_to_json(v)
  }
}

pub fn administrableproductdefinition_property_value_decoder() -> Decoder(
  AdministrableproductdefinitionPropertyValue,
) {
  decode.one_of(
    decode.field(
      "valueCodeableConcept",
      codeableconcept_decoder(),
      decode.success,
    )
      |> decode.map(AdministrableproductdefinitionPropertyValueCodeableconcept),
    [
      decode.field("valueQuantity", quantity_decoder(), decode.success)
        |> decode.map(AdministrableproductdefinitionPropertyValueQuantity),
      decode.field("valueDate", decode.string, decode.success)
        |> decode.map(AdministrableproductdefinitionPropertyValueDate),
      decode.field("valueBoolean", decode.bool, decode.success)
        |> decode.map(AdministrableproductdefinitionPropertyValueBoolean),
      decode.field("valueAttachment", attachment_decoder(), decode.success)
        |> decode.map(AdministrableproductdefinitionPropertyValueAttachment),
    ],
  )
}

pub fn administrableproductdefinition_property_new(
  type_ type_: Codeableconcept,
) -> AdministrableproductdefinitionProperty {
  AdministrableproductdefinitionProperty(
    status: None,
    value: None,
    type_:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/AdministrableProductDefinition#resource
pub type AdministrableproductdefinitionRouteofadministration {
  AdministrableproductdefinitionRouteofadministration(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    code: Codeableconcept,
    first_dose: Option(Quantity),
    max_single_dose: Option(Quantity),
    max_dose_per_day: Option(Quantity),
    max_dose_per_treatment_period: Option(Ratio),
    max_treatment_period: Option(Duration),
    target_species: List(
      AdministrableproductdefinitionRouteofadministrationTargetspecies,
    ),
  )
}

pub fn administrableproductdefinition_routeofadministration_new(
  code code: Codeableconcept,
) -> AdministrableproductdefinitionRouteofadministration {
  AdministrableproductdefinitionRouteofadministration(
    target_species: [],
    max_treatment_period: None,
    max_dose_per_treatment_period: None,
    max_dose_per_day: None,
    max_single_dose: None,
    first_dose: None,
    code:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/AdministrableProductDefinition#resource
pub type AdministrableproductdefinitionRouteofadministrationTargetspecies {
  AdministrableproductdefinitionRouteofadministrationTargetspecies(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    code: Codeableconcept,
    withdrawal_period: List(
      AdministrableproductdefinitionRouteofadministrationTargetspeciesWithdrawalperiod,
    ),
  )
}

pub fn administrableproductdefinition_routeofadministration_targetspecies_new(
  code code: Codeableconcept,
) -> AdministrableproductdefinitionRouteofadministrationTargetspecies {
  AdministrableproductdefinitionRouteofadministrationTargetspecies(
    withdrawal_period: [],
    code:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/AdministrableProductDefinition#resource
pub type AdministrableproductdefinitionRouteofadministrationTargetspeciesWithdrawalperiod {
  AdministrableproductdefinitionRouteofadministrationTargetspeciesWithdrawalperiod(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    tissue: Codeableconcept,
    value: Quantity,
    supporting_information: Option(String),
  )
}

pub fn administrableproductdefinition_routeofadministration_targetspecies_withdrawalperiod_new(
  value value: Quantity,
  tissue tissue: Codeableconcept,
) -> AdministrableproductdefinitionRouteofadministrationTargetspeciesWithdrawalperiod {
  AdministrableproductdefinitionRouteofadministrationTargetspeciesWithdrawalperiod(
    supporting_information: None,
    value:,
    tissue:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn administrableproductdefinition_routeofadministration_targetspecies_withdrawalperiod_to_json(
  administrableproductdefinition_routeofadministration_targetspecies_withdrawalperiod: AdministrableproductdefinitionRouteofadministrationTargetspeciesWithdrawalperiod,
) -> Json {
  let AdministrableproductdefinitionRouteofadministrationTargetspeciesWithdrawalperiod(
    supporting_information:,
    value:,
    tissue:,
    modifier_extension:,
    extension:,
    id:,
  ) =
    administrableproductdefinition_routeofadministration_targetspecies_withdrawalperiod
  let fields = [
    #("value", quantity_to_json(value)),
    #("tissue", codeableconcept_to_json(tissue)),
  ]
  let fields = case supporting_information {
    Some(v) -> [#("supportingInformation", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn administrableproductdefinition_routeofadministration_targetspecies_withdrawalperiod_decoder() -> Decoder(
  AdministrableproductdefinitionRouteofadministrationTargetspeciesWithdrawalperiod,
) {
  use supporting_information <- decode.optional_field(
    "supportingInformation",
    None,
    decode.optional(decode.string),
  )
  use value <- decode.field("value", quantity_decoder())
  use tissue <- decode.field("tissue", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(
    AdministrableproductdefinitionRouteofadministrationTargetspeciesWithdrawalperiod(
      supporting_information:,
      value:,
      tissue:,
      modifier_extension:,
      extension:,
      id:,
    ),
  )
}

pub fn administrableproductdefinition_routeofadministration_targetspecies_to_json(
  administrableproductdefinition_routeofadministration_targetspecies: AdministrableproductdefinitionRouteofadministrationTargetspecies,
) -> Json {
  let AdministrableproductdefinitionRouteofadministrationTargetspecies(
    withdrawal_period:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ) = administrableproductdefinition_routeofadministration_targetspecies
  let fields = [
    #("code", codeableconcept_to_json(code)),
  ]
  let fields = case withdrawal_period {
    [] -> fields
    _ -> [
      #(
        "withdrawalPeriod",
        json.array(
          withdrawal_period,
          administrableproductdefinition_routeofadministration_targetspecies_withdrawalperiod_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn administrableproductdefinition_routeofadministration_targetspecies_decoder() -> Decoder(
  AdministrableproductdefinitionRouteofadministrationTargetspecies,
) {
  use withdrawal_period <- decode.optional_field(
    "withdrawalPeriod",
    [],
    decode.list(
      administrableproductdefinition_routeofadministration_targetspecies_withdrawalperiod_decoder(),
    ),
  )
  use code <- decode.field("code", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(
    AdministrableproductdefinitionRouteofadministrationTargetspecies(
      withdrawal_period:,
      code:,
      modifier_extension:,
      extension:,
      id:,
    ),
  )
}

pub fn administrableproductdefinition_routeofadministration_to_json(
  administrableproductdefinition_routeofadministration: AdministrableproductdefinitionRouteofadministration,
) -> Json {
  let AdministrableproductdefinitionRouteofadministration(
    target_species:,
    max_treatment_period:,
    max_dose_per_treatment_period:,
    max_dose_per_day:,
    max_single_dose:,
    first_dose:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ) = administrableproductdefinition_routeofadministration
  let fields = [
    #("code", codeableconcept_to_json(code)),
  ]
  let fields = case target_species {
    [] -> fields
    _ -> [
      #(
        "targetSpecies",
        json.array(
          target_species,
          administrableproductdefinition_routeofadministration_targetspecies_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case max_treatment_period {
    Some(v) -> [#("maxTreatmentPeriod", duration_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case max_dose_per_treatment_period {
    Some(v) -> [#("maxDosePerTreatmentPeriod", ratio_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case max_dose_per_day {
    Some(v) -> [#("maxDosePerDay", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case max_single_dose {
    Some(v) -> [#("maxSingleDose", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case first_dose {
    Some(v) -> [#("firstDose", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn administrableproductdefinition_routeofadministration_decoder() -> Decoder(
  AdministrableproductdefinitionRouteofadministration,
) {
  use target_species <- decode.optional_field(
    "targetSpecies",
    [],
    decode.list(
      administrableproductdefinition_routeofadministration_targetspecies_decoder(),
    ),
  )
  use max_treatment_period <- decode.optional_field(
    "maxTreatmentPeriod",
    None,
    decode.optional(duration_decoder()),
  )
  use max_dose_per_treatment_period <- decode.optional_field(
    "maxDosePerTreatmentPeriod",
    None,
    decode.optional(ratio_decoder()),
  )
  use max_dose_per_day <- decode.optional_field(
    "maxDosePerDay",
    None,
    decode.optional(quantity_decoder()),
  )
  use max_single_dose <- decode.optional_field(
    "maxSingleDose",
    None,
    decode.optional(quantity_decoder()),
  )
  use first_dose <- decode.optional_field(
    "firstDose",
    None,
    decode.optional(quantity_decoder()),
  )
  use code <- decode.field("code", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(AdministrableproductdefinitionRouteofadministration(
    target_species:,
    max_treatment_period:,
    max_dose_per_treatment_period:,
    max_dose_per_day:,
    max_single_dose:,
    first_dose:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn administrableproductdefinition_property_to_json(
  administrableproductdefinition_property: AdministrableproductdefinitionProperty,
) -> Json {
  let AdministrableproductdefinitionProperty(
    status:,
    value:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = administrableproductdefinition_property
  let fields = [
    #("type", codeableconcept_to_json(type_)),
  ]
  let fields = case status {
    Some(v) -> [#("status", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case value {
    Some(v) -> [
      #(
        "value"
          <> case v {
          AdministrableproductdefinitionPropertyValueCodeableconcept(_) ->
            "Codeableconcept"
          AdministrableproductdefinitionPropertyValueQuantity(_) -> "Quantity"
          AdministrableproductdefinitionPropertyValueDate(_) -> "Date"
          AdministrableproductdefinitionPropertyValueBoolean(_) -> "Boolean"
          AdministrableproductdefinitionPropertyValueAttachment(_) ->
            "Attachment"
        },
        administrableproductdefinition_property_value_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn administrableproductdefinition_property_decoder() -> Decoder(
  AdministrableproductdefinitionProperty,
) {
  use status <- decode.optional_field(
    "status",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use value <- decode.then(
    none_if_omitted(administrableproductdefinition_property_value_decoder()),
  )
  use type_ <- decode.field("type", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(AdministrableproductdefinitionProperty(
    status:,
    value:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn administrableproductdefinition_to_json(
  administrableproductdefinition: Administrableproductdefinition,
) -> Json {
  let Administrableproductdefinition(
    route_of_administration:,
    property:,
    device:,
    ingredient:,
    produced_from:,
    unit_of_presentation:,
    administrable_dose_form:,
    form_of:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = administrableproductdefinition
  let fields = [
    #("status", r4bvaluesets.publicationstatus_to_json(status)),
  ]
  let fields = case route_of_administration {
    [] -> fields
    _ -> [
      #(
        "routeOfAdministration",
        json.array(
          route_of_administration,
          administrableproductdefinition_routeofadministration_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case property {
    [] -> fields
    _ -> [
      #(
        "property",
        json.array(property, administrableproductdefinition_property_to_json),
      ),
      ..fields
    ]
  }
  let fields = case device {
    Some(v) -> [#("device", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case ingredient {
    [] -> fields
    _ -> [
      #("ingredient", json.array(ingredient, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case produced_from {
    [] -> fields
    _ -> [
      #("producedFrom", json.array(produced_from, reference_to_json)),
      ..fields
    ]
  }
  let fields = case unit_of_presentation {
    Some(v) -> [#("unitOfPresentation", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case administrable_dose_form {
    Some(v) -> [
      #("administrableDoseForm", codeableconcept_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case form_of {
    [] -> fields
    _ -> [#("formOf", json.array(form_of, reference_to_json)), ..fields]
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [
    #("resourceType", json.string("Administrableproductdefinition")),
    ..fields
  ]
  json.object(fields)
}

pub fn administrableproductdefinition_decoder() -> Decoder(
  Administrableproductdefinition,
) {
  use route_of_administration <- decode.optional_field(
    "routeOfAdministration",
    [],
    decode.list(administrableproductdefinition_routeofadministration_decoder()),
  )
  use property <- decode.optional_field(
    "property",
    [],
    decode.list(administrableproductdefinition_property_decoder()),
  )
  use device <- decode.optional_field(
    "device",
    None,
    decode.optional(reference_decoder()),
  )
  use ingredient <- decode.optional_field(
    "ingredient",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use produced_from <- decode.optional_field(
    "producedFrom",
    [],
    decode.list(reference_decoder()),
  )
  use unit_of_presentation <- decode.optional_field(
    "unitOfPresentation",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use administrable_dose_form <- decode.optional_field(
    "administrableDoseForm",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use form_of <- decode.optional_field(
    "formOf",
    [],
    decode.list(reference_decoder()),
  )
  use status <- decode.field("status", r4bvaluesets.publicationstatus_decoder())
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Administrableproductdefinition",
    decode.failure(administrableproductdefinition_new(status:), "resourceType"),
  )
  decode.success(Administrableproductdefinition(
    route_of_administration:,
    property:,
    device:,
    ingredient:,
    produced_from:,
    unit_of_presentation:,
    administrable_dose_form:,
    form_of:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/AdverseEvent#resource
pub type Adverseevent {
  Adverseevent(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: Option(Identifier),
    actuality: r4bvaluesets.Adverseeventactuality,
    category: List(Codeableconcept),
    event: Option(Codeableconcept),
    subject: Reference,
    encounter: Option(Reference),
    date: Option(String),
    detected: Option(String),
    recorded_date: Option(String),
    resulting_condition: List(Reference),
    location: Option(Reference),
    seriousness: Option(Codeableconcept),
    severity: Option(Codeableconcept),
    outcome: Option(Codeableconcept),
    recorder: Option(Reference),
    contributor: List(Reference),
    suspect_entity: List(AdverseeventSuspectentity),
    subject_medical_history: List(Reference),
    reference_document: List(Reference),
    study: List(Reference),
  )
}

pub fn adverseevent_new(
  subject subject: Reference,
  actuality actuality: r4bvaluesets.Adverseeventactuality,
) -> Adverseevent {
  Adverseevent(
    study: [],
    reference_document: [],
    subject_medical_history: [],
    suspect_entity: [],
    contributor: [],
    recorder: None,
    outcome: None,
    severity: None,
    seriousness: None,
    location: None,
    resulting_condition: [],
    recorded_date: None,
    detected: None,
    date: None,
    encounter: None,
    subject:,
    event: None,
    category: [],
    actuality:,
    identifier: None,
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/AdverseEvent#resource
pub type AdverseeventSuspectentity {
  AdverseeventSuspectentity(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    instance: Reference,
    causality: List(AdverseeventSuspectentityCausality),
  )
}

pub fn adverseevent_suspectentity_new(
  instance instance: Reference,
) -> AdverseeventSuspectentity {
  AdverseeventSuspectentity(
    causality: [],
    instance:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/AdverseEvent#resource
pub type AdverseeventSuspectentityCausality {
  AdverseeventSuspectentityCausality(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    assessment: Option(Codeableconcept),
    product_relatedness: Option(String),
    author: Option(Reference),
    method: Option(Codeableconcept),
  )
}

pub fn adverseevent_suspectentity_causality_new() -> AdverseeventSuspectentityCausality {
  AdverseeventSuspectentityCausality(
    method: None,
    author: None,
    product_relatedness: None,
    assessment: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn adverseevent_suspectentity_causality_to_json(
  adverseevent_suspectentity_causality: AdverseeventSuspectentityCausality,
) -> Json {
  let AdverseeventSuspectentityCausality(
    method:,
    author:,
    product_relatedness:,
    assessment:,
    modifier_extension:,
    extension:,
    id:,
  ) = adverseevent_suspectentity_causality
  let fields = []
  let fields = case method {
    Some(v) -> [#("method", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case author {
    Some(v) -> [#("author", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case product_relatedness {
    Some(v) -> [#("productRelatedness", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case assessment {
    Some(v) -> [#("assessment", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn adverseevent_suspectentity_causality_decoder() -> Decoder(
  AdverseeventSuspectentityCausality,
) {
  use method <- decode.optional_field(
    "method",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use author <- decode.optional_field(
    "author",
    None,
    decode.optional(reference_decoder()),
  )
  use product_relatedness <- decode.optional_field(
    "productRelatedness",
    None,
    decode.optional(decode.string),
  )
  use assessment <- decode.optional_field(
    "assessment",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(AdverseeventSuspectentityCausality(
    method:,
    author:,
    product_relatedness:,
    assessment:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn adverseevent_suspectentity_to_json(
  adverseevent_suspectentity: AdverseeventSuspectentity,
) -> Json {
  let AdverseeventSuspectentity(
    causality:,
    instance:,
    modifier_extension:,
    extension:,
    id:,
  ) = adverseevent_suspectentity
  let fields = [
    #("instance", reference_to_json(instance)),
  ]
  let fields = case causality {
    [] -> fields
    _ -> [
      #(
        "causality",
        json.array(causality, adverseevent_suspectentity_causality_to_json),
      ),
      ..fields
    ]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn adverseevent_suspectentity_decoder() -> Decoder(
  AdverseeventSuspectentity,
) {
  use causality <- decode.optional_field(
    "causality",
    [],
    decode.list(adverseevent_suspectentity_causality_decoder()),
  )
  use instance <- decode.field("instance", reference_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(AdverseeventSuspectentity(
    causality:,
    instance:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn adverseevent_to_json(adverseevent: Adverseevent) -> Json {
  let Adverseevent(
    study:,
    reference_document:,
    subject_medical_history:,
    suspect_entity:,
    contributor:,
    recorder:,
    outcome:,
    severity:,
    seriousness:,
    location:,
    resulting_condition:,
    recorded_date:,
    detected:,
    date:,
    encounter:,
    subject:,
    event:,
    category:,
    actuality:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = adverseevent
  let fields = [
    #("subject", reference_to_json(subject)),
    #("actuality", r4bvaluesets.adverseeventactuality_to_json(actuality)),
  ]
  let fields = case study {
    [] -> fields
    _ -> [#("study", json.array(study, reference_to_json)), ..fields]
  }
  let fields = case reference_document {
    [] -> fields
    _ -> [
      #("referenceDocument", json.array(reference_document, reference_to_json)),
      ..fields
    ]
  }
  let fields = case subject_medical_history {
    [] -> fields
    _ -> [
      #(
        "subjectMedicalHistory",
        json.array(subject_medical_history, reference_to_json),
      ),
      ..fields
    ]
  }
  let fields = case suspect_entity {
    [] -> fields
    _ -> [
      #(
        "suspectEntity",
        json.array(suspect_entity, adverseevent_suspectentity_to_json),
      ),
      ..fields
    ]
  }
  let fields = case contributor {
    [] -> fields
    _ -> [
      #("contributor", json.array(contributor, reference_to_json)),
      ..fields
    ]
  }
  let fields = case recorder {
    Some(v) -> [#("recorder", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case outcome {
    Some(v) -> [#("outcome", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case severity {
    Some(v) -> [#("severity", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case seriousness {
    Some(v) -> [#("seriousness", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case location {
    Some(v) -> [#("location", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case resulting_condition {
    [] -> fields
    _ -> [
      #(
        "resultingCondition",
        json.array(resulting_condition, reference_to_json),
      ),
      ..fields
    ]
  }
  let fields = case recorded_date {
    Some(v) -> [#("recordedDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case detected {
    Some(v) -> [#("detected", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case date {
    Some(v) -> [#("date", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case encounter {
    Some(v) -> [#("encounter", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case event {
    Some(v) -> [#("event", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case category {
    [] -> fields
    _ -> [
      #("category", json.array(category, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case identifier {
    Some(v) -> [#("identifier", identifier_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Adverseevent")), ..fields]
  json.object(fields)
}

pub fn adverseevent_decoder() -> Decoder(Adverseevent) {
  use study <- decode.optional_field(
    "study",
    [],
    decode.list(reference_decoder()),
  )
  use reference_document <- decode.optional_field(
    "referenceDocument",
    [],
    decode.list(reference_decoder()),
  )
  use subject_medical_history <- decode.optional_field(
    "subjectMedicalHistory",
    [],
    decode.list(reference_decoder()),
  )
  use suspect_entity <- decode.optional_field(
    "suspectEntity",
    [],
    decode.list(adverseevent_suspectentity_decoder()),
  )
  use contributor <- decode.optional_field(
    "contributor",
    [],
    decode.list(reference_decoder()),
  )
  use recorder <- decode.optional_field(
    "recorder",
    None,
    decode.optional(reference_decoder()),
  )
  use outcome <- decode.optional_field(
    "outcome",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use severity <- decode.optional_field(
    "severity",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use seriousness <- decode.optional_field(
    "seriousness",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use location <- decode.optional_field(
    "location",
    None,
    decode.optional(reference_decoder()),
  )
  use resulting_condition <- decode.optional_field(
    "resultingCondition",
    [],
    decode.list(reference_decoder()),
  )
  use recorded_date <- decode.optional_field(
    "recordedDate",
    None,
    decode.optional(decode.string),
  )
  use detected <- decode.optional_field(
    "detected",
    None,
    decode.optional(decode.string),
  )
  use date <- decode.optional_field(
    "date",
    None,
    decode.optional(decode.string),
  )
  use encounter <- decode.optional_field(
    "encounter",
    None,
    decode.optional(reference_decoder()),
  )
  use subject <- decode.field("subject", reference_decoder())
  use event <- decode.optional_field(
    "event",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use category <- decode.optional_field(
    "category",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use actuality <- decode.field(
    "actuality",
    r4bvaluesets.adverseeventactuality_decoder(),
  )
  use identifier <- decode.optional_field(
    "identifier",
    None,
    decode.optional(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Adverseevent",
    decode.failure(adverseevent_new(subject:, actuality:), "resourceType"),
  )
  decode.success(Adverseevent(
    study:,
    reference_document:,
    subject_medical_history:,
    suspect_entity:,
    contributor:,
    recorder:,
    outcome:,
    severity:,
    seriousness:,
    location:,
    resulting_condition:,
    recorded_date:,
    detected:,
    date:,
    encounter:,
    subject:,
    event:,
    category:,
    actuality:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/AllergyIntolerance#resource
pub type Allergyintolerance {
  Allergyintolerance(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    clinical_status: Option(Codeableconcept),
    verification_status: Option(Codeableconcept),
    type_: Option(r4bvaluesets.Allergyintolerancetype),
    category: List(r4bvaluesets.Allergyintolerancecategory),
    criticality: Option(r4bvaluesets.Allergyintolerancecriticality),
    code: Option(Codeableconcept),
    patient: Reference,
    encounter: Option(Reference),
    onset: Option(AllergyintoleranceOnset),
    recorded_date: Option(String),
    recorder: Option(Reference),
    asserter: Option(Reference),
    last_occurrence: Option(String),
    note: List(Annotation),
    reaction: List(AllergyintoleranceReaction),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/AllergyIntolerance#resource
pub type AllergyintoleranceOnset {
  AllergyintoleranceOnsetDatetime(onset: String)
  AllergyintoleranceOnsetAge(onset: Age)
  AllergyintoleranceOnsetPeriod(onset: Period)
  AllergyintoleranceOnsetRange(onset: Range)
  AllergyintoleranceOnsetString(onset: String)
}

pub fn allergyintolerance_onset_to_json(elt: AllergyintoleranceOnset) -> Json {
  case elt {
    AllergyintoleranceOnsetDatetime(v) -> json.string(v)
    AllergyintoleranceOnsetAge(v) -> age_to_json(v)
    AllergyintoleranceOnsetPeriod(v) -> period_to_json(v)
    AllergyintoleranceOnsetRange(v) -> range_to_json(v)
    AllergyintoleranceOnsetString(v) -> json.string(v)
  }
}

pub fn allergyintolerance_onset_decoder() -> Decoder(AllergyintoleranceOnset) {
  decode.one_of(
    decode.field("onsetDateTime", decode.string, decode.success)
      |> decode.map(AllergyintoleranceOnsetDatetime),
    [
      decode.field("onsetAge", age_decoder(), decode.success)
        |> decode.map(AllergyintoleranceOnsetAge),
      decode.field("onsetPeriod", period_decoder(), decode.success)
        |> decode.map(AllergyintoleranceOnsetPeriod),
      decode.field("onsetRange", range_decoder(), decode.success)
        |> decode.map(AllergyintoleranceOnsetRange),
      decode.field("onsetString", decode.string, decode.success)
        |> decode.map(AllergyintoleranceOnsetString),
    ],
  )
}

pub fn allergyintolerance_new(patient patient: Reference) -> Allergyintolerance {
  Allergyintolerance(
    reaction: [],
    note: [],
    last_occurrence: None,
    asserter: None,
    recorder: None,
    recorded_date: None,
    onset: None,
    encounter: None,
    patient:,
    code: None,
    criticality: None,
    category: [],
    type_: None,
    verification_status: None,
    clinical_status: None,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/AllergyIntolerance#resource
pub type AllergyintoleranceReaction {
  AllergyintoleranceReaction(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    substance: Option(Codeableconcept),
    manifestation: List(Codeableconcept),
    description: Option(String),
    onset: Option(String),
    severity: Option(r4bvaluesets.Reactioneventseverity),
    exposure_route: Option(Codeableconcept),
    note: List(Annotation),
  )
}

pub fn allergyintolerance_reaction_new() -> AllergyintoleranceReaction {
  AllergyintoleranceReaction(
    note: [],
    exposure_route: None,
    severity: None,
    onset: None,
    description: None,
    manifestation: [],
    substance: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn allergyintolerance_reaction_to_json(
  allergyintolerance_reaction: AllergyintoleranceReaction,
) -> Json {
  let AllergyintoleranceReaction(
    note:,
    exposure_route:,
    severity:,
    onset:,
    description:,
    manifestation:,
    substance:,
    modifier_extension:,
    extension:,
    id:,
  ) = allergyintolerance_reaction
  let fields = []
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case exposure_route {
    Some(v) -> [#("exposureRoute", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case severity {
    Some(v) -> [
      #("severity", r4bvaluesets.reactioneventseverity_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case onset {
    Some(v) -> [#("onset", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case manifestation {
    [] -> fields
    _ -> [
      #("manifestation", json.array(manifestation, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case substance {
    Some(v) -> [#("substance", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn allergyintolerance_reaction_decoder() -> Decoder(
  AllergyintoleranceReaction,
) {
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use exposure_route <- decode.optional_field(
    "exposureRoute",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use severity <- decode.optional_field(
    "severity",
    None,
    decode.optional(r4bvaluesets.reactioneventseverity_decoder()),
  )
  use onset <- decode.optional_field(
    "onset",
    None,
    decode.optional(decode.string),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use manifestation <- decode.optional_field(
    "manifestation",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use substance <- decode.optional_field(
    "substance",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(AllergyintoleranceReaction(
    note:,
    exposure_route:,
    severity:,
    onset:,
    description:,
    manifestation:,
    substance:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn allergyintolerance_to_json(
  allergyintolerance: Allergyintolerance,
) -> Json {
  let Allergyintolerance(
    reaction:,
    note:,
    last_occurrence:,
    asserter:,
    recorder:,
    recorded_date:,
    onset:,
    encounter:,
    patient:,
    code:,
    criticality:,
    category:,
    type_:,
    verification_status:,
    clinical_status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = allergyintolerance
  let fields = [
    #("patient", reference_to_json(patient)),
  ]
  let fields = case reaction {
    [] -> fields
    _ -> [
      #("reaction", json.array(reaction, allergyintolerance_reaction_to_json)),
      ..fields
    ]
  }
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case last_occurrence {
    Some(v) -> [#("lastOccurrence", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case asserter {
    Some(v) -> [#("asserter", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case recorder {
    Some(v) -> [#("recorder", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case recorded_date {
    Some(v) -> [#("recordedDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case onset {
    Some(v) -> [
      #(
        "onset"
          <> case v {
          AllergyintoleranceOnsetDatetime(_) -> "Datetime"
          AllergyintoleranceOnsetAge(_) -> "Age"
          AllergyintoleranceOnsetPeriod(_) -> "Period"
          AllergyintoleranceOnsetRange(_) -> "Range"
          AllergyintoleranceOnsetString(_) -> "String"
        },
        allergyintolerance_onset_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case encounter {
    Some(v) -> [#("encounter", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case code {
    Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case criticality {
    Some(v) -> [
      #("criticality", r4bvaluesets.allergyintolerancecriticality_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case category {
    [] -> fields
    _ -> [
      #(
        "category",
        json.array(category, r4bvaluesets.allergyintolerancecategory_to_json),
      ),
      ..fields
    ]
  }
  let fields = case type_ {
    Some(v) -> [
      #("type", r4bvaluesets.allergyintolerancetype_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case verification_status {
    Some(v) -> [#("verificationStatus", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case clinical_status {
    Some(v) -> [#("clinicalStatus", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Allergyintolerance")), ..fields]
  json.object(fields)
}

pub fn allergyintolerance_decoder() -> Decoder(Allergyintolerance) {
  use reaction <- decode.optional_field(
    "reaction",
    [],
    decode.list(allergyintolerance_reaction_decoder()),
  )
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use last_occurrence <- decode.optional_field(
    "lastOccurrence",
    None,
    decode.optional(decode.string),
  )
  use asserter <- decode.optional_field(
    "asserter",
    None,
    decode.optional(reference_decoder()),
  )
  use recorder <- decode.optional_field(
    "recorder",
    None,
    decode.optional(reference_decoder()),
  )
  use recorded_date <- decode.optional_field(
    "recordedDate",
    None,
    decode.optional(decode.string),
  )
  use onset <- decode.then(none_if_omitted(allergyintolerance_onset_decoder()))
  use encounter <- decode.optional_field(
    "encounter",
    None,
    decode.optional(reference_decoder()),
  )
  use patient <- decode.field("patient", reference_decoder())
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use criticality <- decode.optional_field(
    "criticality",
    None,
    decode.optional(r4bvaluesets.allergyintolerancecriticality_decoder()),
  )
  use category <- decode.optional_field(
    "category",
    [],
    decode.list(r4bvaluesets.allergyintolerancecategory_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(r4bvaluesets.allergyintolerancetype_decoder()),
  )
  use verification_status <- decode.optional_field(
    "verificationStatus",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use clinical_status <- decode.optional_field(
    "clinicalStatus",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Allergyintolerance",
    decode.failure(allergyintolerance_new(patient:), "resourceType"),
  )
  decode.success(Allergyintolerance(
    reaction:,
    note:,
    last_occurrence:,
    asserter:,
    recorder:,
    recorded_date:,
    onset:,
    encounter:,
    patient:,
    code:,
    criticality:,
    category:,
    type_:,
    verification_status:,
    clinical_status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/Appointment#resource
pub type Appointment {
  Appointment(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    status: r4bvaluesets.Appointmentstatus,
    cancelation_reason: Option(Codeableconcept),
    service_category: List(Codeableconcept),
    service_type: List(Codeableconcept),
    specialty: List(Codeableconcept),
    appointment_type: Option(Codeableconcept),
    reason_code: List(Codeableconcept),
    reason_reference: List(Reference),
    priority: Option(Int),
    description: Option(String),
    supporting_information: List(Reference),
    start: Option(String),
    end: Option(String),
    minutes_duration: Option(Int),
    slot: List(Reference),
    created: Option(String),
    comment: Option(String),
    patient_instruction: Option(String),
    based_on: List(Reference),
    participant: List(AppointmentParticipant),
    requested_period: List(Period),
  )
}

pub fn appointment_new(
  status status: r4bvaluesets.Appointmentstatus,
) -> Appointment {
  Appointment(
    requested_period: [],
    participant: [],
    based_on: [],
    patient_instruction: None,
    comment: None,
    created: None,
    slot: [],
    minutes_duration: None,
    end: None,
    start: None,
    supporting_information: [],
    description: None,
    priority: None,
    reason_reference: [],
    reason_code: [],
    appointment_type: None,
    specialty: [],
    service_type: [],
    service_category: [],
    cancelation_reason: None,
    status:,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Appointment#resource
pub type AppointmentParticipant {
  AppointmentParticipant(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: List(Codeableconcept),
    actor: Option(Reference),
    required: Option(r4bvaluesets.Participantrequired),
    status: r4bvaluesets.Participationstatus,
    period: Option(Period),
  )
}

pub fn appointment_participant_new(
  status status: r4bvaluesets.Participationstatus,
) -> AppointmentParticipant {
  AppointmentParticipant(
    period: None,
    status:,
    required: None,
    actor: None,
    type_: [],
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn appointment_participant_to_json(
  appointment_participant: AppointmentParticipant,
) -> Json {
  let AppointmentParticipant(
    period:,
    status:,
    required:,
    actor:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = appointment_participant
  let fields = [
    #("status", r4bvaluesets.participationstatus_to_json(status)),
  ]
  let fields = case period {
    Some(v) -> [#("period", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case required {
    Some(v) -> [
      #("required", r4bvaluesets.participantrequired_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case actor {
    Some(v) -> [#("actor", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    [] -> fields
    _ -> [#("type", json.array(type_, codeableconcept_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn appointment_participant_decoder() -> Decoder(AppointmentParticipant) {
  use period <- decode.optional_field(
    "period",
    None,
    decode.optional(period_decoder()),
  )
  use status <- decode.field(
    "status",
    r4bvaluesets.participationstatus_decoder(),
  )
  use required <- decode.optional_field(
    "required",
    None,
    decode.optional(r4bvaluesets.participantrequired_decoder()),
  )
  use actor <- decode.optional_field(
    "actor",
    None,
    decode.optional(reference_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(AppointmentParticipant(
    period:,
    status:,
    required:,
    actor:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn appointment_to_json(appointment: Appointment) -> Json {
  let Appointment(
    requested_period:,
    participant:,
    based_on:,
    patient_instruction:,
    comment:,
    created:,
    slot:,
    minutes_duration:,
    end:,
    start:,
    supporting_information:,
    description:,
    priority:,
    reason_reference:,
    reason_code:,
    appointment_type:,
    specialty:,
    service_type:,
    service_category:,
    cancelation_reason:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = appointment
  let fields = [
    #("status", r4bvaluesets.appointmentstatus_to_json(status)),
  ]
  let fields = case requested_period {
    [] -> fields
    _ -> [
      #("requestedPeriod", json.array(requested_period, period_to_json)),
      ..fields
    ]
  }
  let fields = case participant {
    [] -> fields
    _ -> [
      #("participant", json.array(participant, appointment_participant_to_json)),
      ..fields
    ]
  }
  let fields = case based_on {
    [] -> fields
    _ -> [#("basedOn", json.array(based_on, reference_to_json)), ..fields]
  }
  let fields = case patient_instruction {
    Some(v) -> [#("patientInstruction", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case comment {
    Some(v) -> [#("comment", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case created {
    Some(v) -> [#("created", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case slot {
    [] -> fields
    _ -> [#("slot", json.array(slot, reference_to_json)), ..fields]
  }
  let fields = case minutes_duration {
    Some(v) -> [#("minutesDuration", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case end {
    Some(v) -> [#("end", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case start {
    Some(v) -> [#("start", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case supporting_information {
    [] -> fields
    _ -> [
      #(
        "supportingInformation",
        json.array(supporting_information, reference_to_json),
      ),
      ..fields
    ]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case priority {
    Some(v) -> [#("priority", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case reason_reference {
    [] -> fields
    _ -> [
      #("reasonReference", json.array(reason_reference, reference_to_json)),
      ..fields
    ]
  }
  let fields = case reason_code {
    [] -> fields
    _ -> [
      #("reasonCode", json.array(reason_code, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case appointment_type {
    Some(v) -> [#("appointmentType", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case specialty {
    [] -> fields
    _ -> [
      #("specialty", json.array(specialty, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case service_type {
    [] -> fields
    _ -> [
      #("serviceType", json.array(service_type, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case service_category {
    [] -> fields
    _ -> [
      #(
        "serviceCategory",
        json.array(service_category, codeableconcept_to_json),
      ),
      ..fields
    ]
  }
  let fields = case cancelation_reason {
    Some(v) -> [#("cancelationReason", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Appointment")), ..fields]
  json.object(fields)
}

pub fn appointment_decoder() -> Decoder(Appointment) {
  use requested_period <- decode.optional_field(
    "requestedPeriod",
    [],
    decode.list(period_decoder()),
  )
  use participant <- decode.optional_field(
    "participant",
    [],
    decode.list(appointment_participant_decoder()),
  )
  use based_on <- decode.optional_field(
    "basedOn",
    [],
    decode.list(reference_decoder()),
  )
  use patient_instruction <- decode.optional_field(
    "patientInstruction",
    None,
    decode.optional(decode.string),
  )
  use comment <- decode.optional_field(
    "comment",
    None,
    decode.optional(decode.string),
  )
  use created <- decode.optional_field(
    "created",
    None,
    decode.optional(decode.string),
  )
  use slot <- decode.optional_field(
    "slot",
    [],
    decode.list(reference_decoder()),
  )
  use minutes_duration <- decode.optional_field(
    "minutesDuration",
    None,
    decode.optional(decode.int),
  )
  use end <- decode.optional_field("end", None, decode.optional(decode.string))
  use start <- decode.optional_field(
    "start",
    None,
    decode.optional(decode.string),
  )
  use supporting_information <- decode.optional_field(
    "supportingInformation",
    [],
    decode.list(reference_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use priority <- decode.optional_field(
    "priority",
    None,
    decode.optional(decode.int),
  )
  use reason_reference <- decode.optional_field(
    "reasonReference",
    [],
    decode.list(reference_decoder()),
  )
  use reason_code <- decode.optional_field(
    "reasonCode",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use appointment_type <- decode.optional_field(
    "appointmentType",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use specialty <- decode.optional_field(
    "specialty",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use service_type <- decode.optional_field(
    "serviceType",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use service_category <- decode.optional_field(
    "serviceCategory",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use cancelation_reason <- decode.optional_field(
    "cancelationReason",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use status <- decode.field("status", r4bvaluesets.appointmentstatus_decoder())
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Appointment",
    decode.failure(appointment_new(status:), "resourceType"),
  )
  decode.success(Appointment(
    requested_period:,
    participant:,
    based_on:,
    patient_instruction:,
    comment:,
    created:,
    slot:,
    minutes_duration:,
    end:,
    start:,
    supporting_information:,
    description:,
    priority:,
    reason_reference:,
    reason_code:,
    appointment_type:,
    specialty:,
    service_type:,
    service_category:,
    cancelation_reason:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/AppointmentResponse#resource
pub type Appointmentresponse {
  Appointmentresponse(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    appointment: Reference,
    start: Option(String),
    end: Option(String),
    participant_type: List(Codeableconcept),
    actor: Option(Reference),
    participant_status: r4bvaluesets.Participationstatus,
    comment: Option(String),
  )
}

pub fn appointmentresponse_new(
  participant_status participant_status: r4bvaluesets.Participationstatus,
  appointment appointment: Reference,
) -> Appointmentresponse {
  Appointmentresponse(
    comment: None,
    participant_status:,
    actor: None,
    participant_type: [],
    end: None,
    start: None,
    appointment:,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

pub fn appointmentresponse_to_json(
  appointmentresponse: Appointmentresponse,
) -> Json {
  let Appointmentresponse(
    comment:,
    participant_status:,
    actor:,
    participant_type:,
    end:,
    start:,
    appointment:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = appointmentresponse
  let fields = [
    #(
      "participantStatus",
      r4bvaluesets.participationstatus_to_json(participant_status),
    ),
    #("appointment", reference_to_json(appointment)),
  ]
  let fields = case comment {
    Some(v) -> [#("comment", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case actor {
    Some(v) -> [#("actor", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case participant_type {
    [] -> fields
    _ -> [
      #(
        "participantType",
        json.array(participant_type, codeableconcept_to_json),
      ),
      ..fields
    ]
  }
  let fields = case end {
    Some(v) -> [#("end", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case start {
    Some(v) -> [#("start", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Appointmentresponse")), ..fields]
  json.object(fields)
}

pub fn appointmentresponse_decoder() -> Decoder(Appointmentresponse) {
  use comment <- decode.optional_field(
    "comment",
    None,
    decode.optional(decode.string),
  )
  use participant_status <- decode.field(
    "participantStatus",
    r4bvaluesets.participationstatus_decoder(),
  )
  use actor <- decode.optional_field(
    "actor",
    None,
    decode.optional(reference_decoder()),
  )
  use participant_type <- decode.optional_field(
    "participantType",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use end <- decode.optional_field("end", None, decode.optional(decode.string))
  use start <- decode.optional_field(
    "start",
    None,
    decode.optional(decode.string),
  )
  use appointment <- decode.field("appointment", reference_decoder())
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Appointmentresponse",
    decode.failure(
      appointmentresponse_new(participant_status:, appointment:),
      "resourceType",
    ),
  )
  decode.success(Appointmentresponse(
    comment:,
    participant_status:,
    actor:,
    participant_type:,
    end:,
    start:,
    appointment:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/AuditEvent#resource
pub type Auditevent {
  Auditevent(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Coding,
    subtype: List(Coding),
    action: Option(r4bvaluesets.Auditeventaction),
    period: Option(Period),
    recorded: String,
    outcome: Option(r4bvaluesets.Auditeventoutcome),
    outcome_desc: Option(String),
    purpose_of_event: List(Codeableconcept),
    agent: List(AuditeventAgent),
    source: AuditeventSource,
    entity: List(AuditeventEntity),
  )
}

pub fn auditevent_new(
  source source: AuditeventSource,
  recorded recorded: String,
  type_ type_: Coding,
) -> Auditevent {
  Auditevent(
    entity: [],
    source:,
    agent: [],
    purpose_of_event: [],
    outcome_desc: None,
    outcome: None,
    recorded:,
    period: None,
    action: None,
    subtype: [],
    type_:,
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/AuditEvent#resource
pub type AuditeventAgent {
  AuditeventAgent(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Option(Codeableconcept),
    role: List(Codeableconcept),
    who: Option(Reference),
    alt_id: Option(String),
    name: Option(String),
    requestor: Bool,
    location: Option(Reference),
    policy: List(String),
    media: Option(Coding),
    network: Option(AuditeventAgentNetwork),
    purpose_of_use: List(Codeableconcept),
  )
}

pub fn auditevent_agent_new(requestor requestor: Bool) -> AuditeventAgent {
  AuditeventAgent(
    purpose_of_use: [],
    network: None,
    media: None,
    policy: [],
    location: None,
    requestor:,
    name: None,
    alt_id: None,
    who: None,
    role: [],
    type_: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/AuditEvent#resource
pub type AuditeventAgentNetwork {
  AuditeventAgentNetwork(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    address: Option(String),
    type_: Option(r4bvaluesets.Networktype),
  )
}

pub fn auditevent_agent_network_new() -> AuditeventAgentNetwork {
  AuditeventAgentNetwork(
    type_: None,
    address: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/AuditEvent#resource
pub type AuditeventSource {
  AuditeventSource(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    site: Option(String),
    observer: Reference,
    type_: List(Coding),
  )
}

pub fn auditevent_source_new(observer observer: Reference) -> AuditeventSource {
  AuditeventSource(
    type_: [],
    observer:,
    site: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/AuditEvent#resource
pub type AuditeventEntity {
  AuditeventEntity(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    what: Option(Reference),
    type_: Option(Coding),
    role: Option(Coding),
    lifecycle: Option(Coding),
    security_label: List(Coding),
    name: Option(String),
    description: Option(String),
    query: Option(String),
    detail: List(AuditeventEntityDetail),
  )
}

pub fn auditevent_entity_new() -> AuditeventEntity {
  AuditeventEntity(
    detail: [],
    query: None,
    description: None,
    name: None,
    security_label: [],
    lifecycle: None,
    role: None,
    type_: None,
    what: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/AuditEvent#resource
pub type AuditeventEntityDetail {
  AuditeventEntityDetail(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: String,
    value: AuditeventEntityDetailValue,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/AuditEvent#resource
pub type AuditeventEntityDetailValue {
  AuditeventEntityDetailValueString(value: String)
  AuditeventEntityDetailValueBase64binary(value: String)
}

pub fn auditevent_entity_detail_value_to_json(
  elt: AuditeventEntityDetailValue,
) -> Json {
  case elt {
    AuditeventEntityDetailValueString(v) -> json.string(v)
    AuditeventEntityDetailValueBase64binary(v) -> json.string(v)
  }
}

pub fn auditevent_entity_detail_value_decoder() -> Decoder(
  AuditeventEntityDetailValue,
) {
  decode.one_of(
    decode.field("valueString", decode.string, decode.success)
      |> decode.map(AuditeventEntityDetailValueString),
    [
      decode.field("valueBase64Binary", decode.string, decode.success)
      |> decode.map(AuditeventEntityDetailValueBase64binary),
    ],
  )
}

pub fn auditevent_entity_detail_new(
  value value: AuditeventEntityDetailValue,
  type_ type_: String,
) -> AuditeventEntityDetail {
  AuditeventEntityDetail(
    value:,
    type_:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn auditevent_entity_detail_to_json(
  auditevent_entity_detail: AuditeventEntityDetail,
) -> Json {
  let AuditeventEntityDetail(
    value:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = auditevent_entity_detail
  let fields = [
    #("value", auditevent_entity_detail_value_to_json(value)),
    #("type", json.string(type_)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn auditevent_entity_detail_decoder() -> Decoder(AuditeventEntityDetail) {
  use value <- decode.then(auditevent_entity_detail_value_decoder())
  use type_ <- decode.field("type", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(AuditeventEntityDetail(
    value:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn auditevent_entity_to_json(auditevent_entity: AuditeventEntity) -> Json {
  let AuditeventEntity(
    detail:,
    query:,
    description:,
    name:,
    security_label:,
    lifecycle:,
    role:,
    type_:,
    what:,
    modifier_extension:,
    extension:,
    id:,
  ) = auditevent_entity
  let fields = []
  let fields = case detail {
    [] -> fields
    _ -> [
      #("detail", json.array(detail, auditevent_entity_detail_to_json)),
      ..fields
    ]
  }
  let fields = case query {
    Some(v) -> [#("query", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case security_label {
    [] -> fields
    _ -> [
      #("securityLabel", json.array(security_label, coding_to_json)),
      ..fields
    ]
  }
  let fields = case lifecycle {
    Some(v) -> [#("lifecycle", coding_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case role {
    Some(v) -> [#("role", coding_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", coding_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case what {
    Some(v) -> [#("what", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn auditevent_entity_decoder() -> Decoder(AuditeventEntity) {
  use detail <- decode.optional_field(
    "detail",
    [],
    decode.list(auditevent_entity_detail_decoder()),
  )
  use query <- decode.optional_field(
    "query",
    None,
    decode.optional(decode.string),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use security_label <- decode.optional_field(
    "securityLabel",
    [],
    decode.list(coding_decoder()),
  )
  use lifecycle <- decode.optional_field(
    "lifecycle",
    None,
    decode.optional(coding_decoder()),
  )
  use role <- decode.optional_field(
    "role",
    None,
    decode.optional(coding_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(coding_decoder()),
  )
  use what <- decode.optional_field(
    "what",
    None,
    decode.optional(reference_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(AuditeventEntity(
    detail:,
    query:,
    description:,
    name:,
    security_label:,
    lifecycle:,
    role:,
    type_:,
    what:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn auditevent_source_to_json(auditevent_source: AuditeventSource) -> Json {
  let AuditeventSource(
    type_:,
    observer:,
    site:,
    modifier_extension:,
    extension:,
    id:,
  ) = auditevent_source
  let fields = [
    #("observer", reference_to_json(observer)),
  ]
  let fields = case type_ {
    [] -> fields
    _ -> [#("type", json.array(type_, coding_to_json)), ..fields]
  }
  let fields = case site {
    Some(v) -> [#("site", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn auditevent_source_decoder() -> Decoder(AuditeventSource) {
  use type_ <- decode.optional_field("type", [], decode.list(coding_decoder()))
  use observer <- decode.field("observer", reference_decoder())
  use site <- decode.optional_field(
    "site",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(AuditeventSource(
    type_:,
    observer:,
    site:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn auditevent_agent_network_to_json(
  auditevent_agent_network: AuditeventAgentNetwork,
) -> Json {
  let AuditeventAgentNetwork(
    type_:,
    address:,
    modifier_extension:,
    extension:,
    id:,
  ) = auditevent_agent_network
  let fields = []
  let fields = case type_ {
    Some(v) -> [#("type", r4bvaluesets.networktype_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case address {
    Some(v) -> [#("address", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn auditevent_agent_network_decoder() -> Decoder(AuditeventAgentNetwork) {
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(r4bvaluesets.networktype_decoder()),
  )
  use address <- decode.optional_field(
    "address",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(AuditeventAgentNetwork(
    type_:,
    address:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn auditevent_agent_to_json(auditevent_agent: AuditeventAgent) -> Json {
  let AuditeventAgent(
    purpose_of_use:,
    network:,
    media:,
    policy:,
    location:,
    requestor:,
    name:,
    alt_id:,
    who:,
    role:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = auditevent_agent
  let fields = [
    #("requestor", json.bool(requestor)),
  ]
  let fields = case purpose_of_use {
    [] -> fields
    _ -> [
      #("purposeOfUse", json.array(purpose_of_use, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case network {
    Some(v) -> [#("network", auditevent_agent_network_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case media {
    Some(v) -> [#("media", coding_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case policy {
    [] -> fields
    _ -> [#("policy", json.array(policy, json.string)), ..fields]
  }
  let fields = case location {
    Some(v) -> [#("location", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case alt_id {
    Some(v) -> [#("altId", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case who {
    Some(v) -> [#("who", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case role {
    [] -> fields
    _ -> [#("role", json.array(role, codeableconcept_to_json)), ..fields]
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn auditevent_agent_decoder() -> Decoder(AuditeventAgent) {
  use purpose_of_use <- decode.optional_field(
    "purposeOfUse",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use network <- decode.optional_field(
    "network",
    None,
    decode.optional(auditevent_agent_network_decoder()),
  )
  use media <- decode.optional_field(
    "media",
    None,
    decode.optional(coding_decoder()),
  )
  use policy <- decode.optional_field("policy", [], decode.list(decode.string))
  use location <- decode.optional_field(
    "location",
    None,
    decode.optional(reference_decoder()),
  )
  use requestor <- decode.field("requestor", decode.bool)
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use alt_id <- decode.optional_field(
    "altId",
    None,
    decode.optional(decode.string),
  )
  use who <- decode.optional_field(
    "who",
    None,
    decode.optional(reference_decoder()),
  )
  use role <- decode.optional_field(
    "role",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(AuditeventAgent(
    purpose_of_use:,
    network:,
    media:,
    policy:,
    location:,
    requestor:,
    name:,
    alt_id:,
    who:,
    role:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn auditevent_to_json(auditevent: Auditevent) -> Json {
  let Auditevent(
    entity:,
    source:,
    agent:,
    purpose_of_event:,
    outcome_desc:,
    outcome:,
    recorded:,
    period:,
    action:,
    subtype:,
    type_:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = auditevent
  let fields = [
    #("source", auditevent_source_to_json(source)),
    #("recorded", json.string(recorded)),
    #("type", coding_to_json(type_)),
  ]
  let fields = case entity {
    [] -> fields
    _ -> [#("entity", json.array(entity, auditevent_entity_to_json)), ..fields]
  }
  let fields = case agent {
    [] -> fields
    _ -> [#("agent", json.array(agent, auditevent_agent_to_json)), ..fields]
  }
  let fields = case purpose_of_event {
    [] -> fields
    _ -> [
      #("purposeOfEvent", json.array(purpose_of_event, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case outcome_desc {
    Some(v) -> [#("outcomeDesc", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case outcome {
    Some(v) -> [
      #("outcome", r4bvaluesets.auditeventoutcome_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case period {
    Some(v) -> [#("period", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case action {
    Some(v) -> [#("action", r4bvaluesets.auditeventaction_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case subtype {
    [] -> fields
    _ -> [#("subtype", json.array(subtype, coding_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Auditevent")), ..fields]
  json.object(fields)
}

pub fn auditevent_decoder() -> Decoder(Auditevent) {
  use entity <- decode.optional_field(
    "entity",
    [],
    decode.list(auditevent_entity_decoder()),
  )
  use source <- decode.field("source", auditevent_source_decoder())
  use agent <- decode.optional_field(
    "agent",
    [],
    decode.list(auditevent_agent_decoder()),
  )
  use purpose_of_event <- decode.optional_field(
    "purposeOfEvent",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use outcome_desc <- decode.optional_field(
    "outcomeDesc",
    None,
    decode.optional(decode.string),
  )
  use outcome <- decode.optional_field(
    "outcome",
    None,
    decode.optional(r4bvaluesets.auditeventoutcome_decoder()),
  )
  use recorded <- decode.field("recorded", decode.string)
  use period <- decode.optional_field(
    "period",
    None,
    decode.optional(period_decoder()),
  )
  use action <- decode.optional_field(
    "action",
    None,
    decode.optional(r4bvaluesets.auditeventaction_decoder()),
  )
  use subtype <- decode.optional_field(
    "subtype",
    [],
    decode.list(coding_decoder()),
  )
  use type_ <- decode.field("type", coding_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Auditevent",
    decode.failure(auditevent_new(source:, recorded:, type_:), "resourceType"),
  )
  decode.success(Auditevent(
    entity:,
    source:,
    agent:,
    purpose_of_event:,
    outcome_desc:,
    outcome:,
    recorded:,
    period:,
    action:,
    subtype:,
    type_:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/Basic#resource
pub type Basic {
  Basic(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    code: Codeableconcept,
    subject: Option(Reference),
    created: Option(String),
    author: Option(Reference),
  )
}

pub fn basic_new(code code: Codeableconcept) -> Basic {
  Basic(
    author: None,
    created: None,
    subject: None,
    code:,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

pub fn basic_to_json(basic: Basic) -> Json {
  let Basic(
    author:,
    created:,
    subject:,
    code:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = basic
  let fields = [
    #("code", codeableconcept_to_json(code)),
  ]
  let fields = case author {
    Some(v) -> [#("author", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case created {
    Some(v) -> [#("created", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case subject {
    Some(v) -> [#("subject", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Basic")), ..fields]
  json.object(fields)
}

pub fn basic_decoder() -> Decoder(Basic) {
  use author <- decode.optional_field(
    "author",
    None,
    decode.optional(reference_decoder()),
  )
  use created <- decode.optional_field(
    "created",
    None,
    decode.optional(decode.string),
  )
  use subject <- decode.optional_field(
    "subject",
    None,
    decode.optional(reference_decoder()),
  )
  use code <- decode.field("code", codeableconcept_decoder())
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Basic",
    decode.failure(basic_new(code:), "resourceType"),
  )
  decode.success(Basic(
    author:,
    created:,
    subject:,
    code:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/Binary#resource
pub type Binary {
  Binary(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    content_type: String,
    security_context: Option(Reference),
    data: Option(String),
  )
}

pub fn binary_new(content_type content_type: String) -> Binary {
  Binary(
    data: None,
    security_context: None,
    content_type:,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

pub fn binary_to_json(binary: Binary) -> Json {
  let Binary(
    data:,
    security_context:,
    content_type:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = binary
  let fields = [
    #("contentType", json.string(content_type)),
  ]
  let fields = case data {
    Some(v) -> [#("data", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case security_context {
    Some(v) -> [#("securityContext", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Binary")), ..fields]
  json.object(fields)
}

pub fn binary_decoder() -> Decoder(Binary) {
  use data <- decode.optional_field(
    "data",
    None,
    decode.optional(decode.string),
  )
  use security_context <- decode.optional_field(
    "securityContext",
    None,
    decode.optional(reference_decoder()),
  )
  use content_type <- decode.field("contentType", decode.string)
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Binary",
    decode.failure(binary_new(content_type:), "resourceType"),
  )
  decode.success(Binary(
    data:,
    security_context:,
    content_type:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/BiologicallyDerivedProduct#resource
pub type Biologicallyderivedproduct {
  Biologicallyderivedproduct(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    product_category: Option(r4bvaluesets.Productcategory),
    product_code: Option(Codeableconcept),
    status: Option(r4bvaluesets.Productstatus),
    request: List(Reference),
    quantity: Option(Int),
    parent: List(Reference),
    collection: Option(BiologicallyderivedproductCollection),
    processing: List(BiologicallyderivedproductProcessing),
    manipulation: Option(BiologicallyderivedproductManipulation),
    storage: List(BiologicallyderivedproductStorage),
  )
}

pub fn biologicallyderivedproduct_new() -> Biologicallyderivedproduct {
  Biologicallyderivedproduct(
    storage: [],
    manipulation: None,
    processing: [],
    collection: None,
    parent: [],
    quantity: None,
    request: [],
    status: None,
    product_code: None,
    product_category: None,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/BiologicallyDerivedProduct#resource
pub type BiologicallyderivedproductCollection {
  BiologicallyderivedproductCollection(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    collector: Option(Reference),
    source: Option(Reference),
    collected: Option(BiologicallyderivedproductCollectionCollected),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/BiologicallyDerivedProduct#resource
pub type BiologicallyderivedproductCollectionCollected {
  BiologicallyderivedproductCollectionCollectedDatetime(collected: String)
  BiologicallyderivedproductCollectionCollectedPeriod(collected: Period)
}

pub fn biologicallyderivedproduct_collection_collected_to_json(
  elt: BiologicallyderivedproductCollectionCollected,
) -> Json {
  case elt {
    BiologicallyderivedproductCollectionCollectedDatetime(v) -> json.string(v)
    BiologicallyderivedproductCollectionCollectedPeriod(v) -> period_to_json(v)
  }
}

pub fn biologicallyderivedproduct_collection_collected_decoder() -> Decoder(
  BiologicallyderivedproductCollectionCollected,
) {
  decode.one_of(
    decode.field("collectedDateTime", decode.string, decode.success)
      |> decode.map(BiologicallyderivedproductCollectionCollectedDatetime),
    [
      decode.field("collectedPeriod", period_decoder(), decode.success)
      |> decode.map(BiologicallyderivedproductCollectionCollectedPeriod),
    ],
  )
}

pub fn biologicallyderivedproduct_collection_new() -> BiologicallyderivedproductCollection {
  BiologicallyderivedproductCollection(
    collected: None,
    source: None,
    collector: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/BiologicallyDerivedProduct#resource
pub type BiologicallyderivedproductProcessing {
  BiologicallyderivedproductProcessing(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    description: Option(String),
    procedure: Option(Codeableconcept),
    additive: Option(Reference),
    time: Option(BiologicallyderivedproductProcessingTime),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/BiologicallyDerivedProduct#resource
pub type BiologicallyderivedproductProcessingTime {
  BiologicallyderivedproductProcessingTimeDatetime(time: String)
  BiologicallyderivedproductProcessingTimePeriod(time: Period)
}

pub fn biologicallyderivedproduct_processing_time_to_json(
  elt: BiologicallyderivedproductProcessingTime,
) -> Json {
  case elt {
    BiologicallyderivedproductProcessingTimeDatetime(v) -> json.string(v)
    BiologicallyderivedproductProcessingTimePeriod(v) -> period_to_json(v)
  }
}

pub fn biologicallyderivedproduct_processing_time_decoder() -> Decoder(
  BiologicallyderivedproductProcessingTime,
) {
  decode.one_of(
    decode.field("timeDateTime", decode.string, decode.success)
      |> decode.map(BiologicallyderivedproductProcessingTimeDatetime),
    [
      decode.field("timePeriod", period_decoder(), decode.success)
      |> decode.map(BiologicallyderivedproductProcessingTimePeriod),
    ],
  )
}

pub fn biologicallyderivedproduct_processing_new() -> BiologicallyderivedproductProcessing {
  BiologicallyderivedproductProcessing(
    time: None,
    additive: None,
    procedure: None,
    description: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/BiologicallyDerivedProduct#resource
pub type BiologicallyderivedproductManipulation {
  BiologicallyderivedproductManipulation(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    description: Option(String),
    time: Option(BiologicallyderivedproductManipulationTime),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/BiologicallyDerivedProduct#resource
pub type BiologicallyderivedproductManipulationTime {
  BiologicallyderivedproductManipulationTimeDatetime(time: String)
  BiologicallyderivedproductManipulationTimePeriod(time: Period)
}

pub fn biologicallyderivedproduct_manipulation_time_to_json(
  elt: BiologicallyderivedproductManipulationTime,
) -> Json {
  case elt {
    BiologicallyderivedproductManipulationTimeDatetime(v) -> json.string(v)
    BiologicallyderivedproductManipulationTimePeriod(v) -> period_to_json(v)
  }
}

pub fn biologicallyderivedproduct_manipulation_time_decoder() -> Decoder(
  BiologicallyderivedproductManipulationTime,
) {
  decode.one_of(
    decode.field("timeDateTime", decode.string, decode.success)
      |> decode.map(BiologicallyderivedproductManipulationTimeDatetime),
    [
      decode.field("timePeriod", period_decoder(), decode.success)
      |> decode.map(BiologicallyderivedproductManipulationTimePeriod),
    ],
  )
}

pub fn biologicallyderivedproduct_manipulation_new() -> BiologicallyderivedproductManipulation {
  BiologicallyderivedproductManipulation(
    time: None,
    description: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/BiologicallyDerivedProduct#resource
pub type BiologicallyderivedproductStorage {
  BiologicallyderivedproductStorage(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    description: Option(String),
    temperature: Option(Float),
    scale: Option(r4bvaluesets.Productstoragescale),
    duration: Option(Period),
  )
}

pub fn biologicallyderivedproduct_storage_new() -> BiologicallyderivedproductStorage {
  BiologicallyderivedproductStorage(
    duration: None,
    scale: None,
    temperature: None,
    description: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn biologicallyderivedproduct_storage_to_json(
  biologicallyderivedproduct_storage: BiologicallyderivedproductStorage,
) -> Json {
  let BiologicallyderivedproductStorage(
    duration:,
    scale:,
    temperature:,
    description:,
    modifier_extension:,
    extension:,
    id:,
  ) = biologicallyderivedproduct_storage
  let fields = []
  let fields = case duration {
    Some(v) -> [#("duration", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case scale {
    Some(v) -> [
      #("scale", r4bvaluesets.productstoragescale_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case temperature {
    Some(v) -> [#("temperature", json.float(v)), ..fields]
    None -> fields
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn biologicallyderivedproduct_storage_decoder() -> Decoder(
  BiologicallyderivedproductStorage,
) {
  use duration <- decode.optional_field(
    "duration",
    None,
    decode.optional(period_decoder()),
  )
  use scale <- decode.optional_field(
    "scale",
    None,
    decode.optional(r4bvaluesets.productstoragescale_decoder()),
  )
  use temperature <- decode.optional_field(
    "temperature",
    None,
    decode.optional(decode.float),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(BiologicallyderivedproductStorage(
    duration:,
    scale:,
    temperature:,
    description:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn biologicallyderivedproduct_manipulation_to_json(
  biologicallyderivedproduct_manipulation: BiologicallyderivedproductManipulation,
) -> Json {
  let BiologicallyderivedproductManipulation(
    time:,
    description:,
    modifier_extension:,
    extension:,
    id:,
  ) = biologicallyderivedproduct_manipulation
  let fields = []
  let fields = case time {
    Some(v) -> [
      #(
        "time"
          <> case v {
          BiologicallyderivedproductManipulationTimeDatetime(_) -> "Datetime"
          BiologicallyderivedproductManipulationTimePeriod(_) -> "Period"
        },
        biologicallyderivedproduct_manipulation_time_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn biologicallyderivedproduct_manipulation_decoder() -> Decoder(
  BiologicallyderivedproductManipulation,
) {
  use time <- decode.then(
    none_if_omitted(biologicallyderivedproduct_manipulation_time_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(BiologicallyderivedproductManipulation(
    time:,
    description:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn biologicallyderivedproduct_processing_to_json(
  biologicallyderivedproduct_processing: BiologicallyderivedproductProcessing,
) -> Json {
  let BiologicallyderivedproductProcessing(
    time:,
    additive:,
    procedure:,
    description:,
    modifier_extension:,
    extension:,
    id:,
  ) = biologicallyderivedproduct_processing
  let fields = []
  let fields = case time {
    Some(v) -> [
      #(
        "time"
          <> case v {
          BiologicallyderivedproductProcessingTimeDatetime(_) -> "Datetime"
          BiologicallyderivedproductProcessingTimePeriod(_) -> "Period"
        },
        biologicallyderivedproduct_processing_time_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case additive {
    Some(v) -> [#("additive", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case procedure {
    Some(v) -> [#("procedure", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn biologicallyderivedproduct_processing_decoder() -> Decoder(
  BiologicallyderivedproductProcessing,
) {
  use time <- decode.then(
    none_if_omitted(biologicallyderivedproduct_processing_time_decoder()),
  )
  use additive <- decode.optional_field(
    "additive",
    None,
    decode.optional(reference_decoder()),
  )
  use procedure <- decode.optional_field(
    "procedure",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(BiologicallyderivedproductProcessing(
    time:,
    additive:,
    procedure:,
    description:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn biologicallyderivedproduct_collection_to_json(
  biologicallyderivedproduct_collection: BiologicallyderivedproductCollection,
) -> Json {
  let BiologicallyderivedproductCollection(
    collected:,
    source:,
    collector:,
    modifier_extension:,
    extension:,
    id:,
  ) = biologicallyderivedproduct_collection
  let fields = []
  let fields = case collected {
    Some(v) -> [
      #(
        "collected"
          <> case v {
          BiologicallyderivedproductCollectionCollectedDatetime(_) -> "Datetime"
          BiologicallyderivedproductCollectionCollectedPeriod(_) -> "Period"
        },
        biologicallyderivedproduct_collection_collected_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case source {
    Some(v) -> [#("source", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case collector {
    Some(v) -> [#("collector", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn biologicallyderivedproduct_collection_decoder() -> Decoder(
  BiologicallyderivedproductCollection,
) {
  use collected <- decode.then(
    none_if_omitted(biologicallyderivedproduct_collection_collected_decoder()),
  )
  use source <- decode.optional_field(
    "source",
    None,
    decode.optional(reference_decoder()),
  )
  use collector <- decode.optional_field(
    "collector",
    None,
    decode.optional(reference_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(BiologicallyderivedproductCollection(
    collected:,
    source:,
    collector:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn biologicallyderivedproduct_to_json(
  biologicallyderivedproduct: Biologicallyderivedproduct,
) -> Json {
  let Biologicallyderivedproduct(
    storage:,
    manipulation:,
    processing:,
    collection:,
    parent:,
    quantity:,
    request:,
    status:,
    product_code:,
    product_category:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = biologicallyderivedproduct
  let fields = []
  let fields = case storage {
    [] -> fields
    _ -> [
      #(
        "storage",
        json.array(storage, biologicallyderivedproduct_storage_to_json),
      ),
      ..fields
    ]
  }
  let fields = case manipulation {
    Some(v) -> [
      #("manipulation", biologicallyderivedproduct_manipulation_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case processing {
    [] -> fields
    _ -> [
      #(
        "processing",
        json.array(processing, biologicallyderivedproduct_processing_to_json),
      ),
      ..fields
    ]
  }
  let fields = case collection {
    Some(v) -> [
      #("collection", biologicallyderivedproduct_collection_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case parent {
    [] -> fields
    _ -> [#("parent", json.array(parent, reference_to_json)), ..fields]
  }
  let fields = case quantity {
    Some(v) -> [#("quantity", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case request {
    [] -> fields
    _ -> [#("request", json.array(request, reference_to_json)), ..fields]
  }
  let fields = case status {
    Some(v) -> [#("status", r4bvaluesets.productstatus_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case product_code {
    Some(v) -> [#("productCode", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case product_category {
    Some(v) -> [
      #("productCategory", r4bvaluesets.productcategory_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [
    #("resourceType", json.string("Biologicallyderivedproduct")),
    ..fields
  ]
  json.object(fields)
}

pub fn biologicallyderivedproduct_decoder() -> Decoder(
  Biologicallyderivedproduct,
) {
  use storage <- decode.optional_field(
    "storage",
    [],
    decode.list(biologicallyderivedproduct_storage_decoder()),
  )
  use manipulation <- decode.optional_field(
    "manipulation",
    None,
    decode.optional(biologicallyderivedproduct_manipulation_decoder()),
  )
  use processing <- decode.optional_field(
    "processing",
    [],
    decode.list(biologicallyderivedproduct_processing_decoder()),
  )
  use collection <- decode.optional_field(
    "collection",
    None,
    decode.optional(biologicallyderivedproduct_collection_decoder()),
  )
  use parent <- decode.optional_field(
    "parent",
    [],
    decode.list(reference_decoder()),
  )
  use quantity <- decode.optional_field(
    "quantity",
    None,
    decode.optional(decode.int),
  )
  use request <- decode.optional_field(
    "request",
    [],
    decode.list(reference_decoder()),
  )
  use status <- decode.optional_field(
    "status",
    None,
    decode.optional(r4bvaluesets.productstatus_decoder()),
  )
  use product_code <- decode.optional_field(
    "productCode",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use product_category <- decode.optional_field(
    "productCategory",
    None,
    decode.optional(r4bvaluesets.productcategory_decoder()),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Biologicallyderivedproduct",
    decode.failure(biologicallyderivedproduct_new(), "resourceType"),
  )
  decode.success(Biologicallyderivedproduct(
    storage:,
    manipulation:,
    processing:,
    collection:,
    parent:,
    quantity:,
    request:,
    status:,
    product_code:,
    product_category:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/BodyStructure#resource
pub type Bodystructure {
  Bodystructure(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    active: Option(Bool),
    morphology: Option(Codeableconcept),
    location: Option(Codeableconcept),
    location_qualifier: List(Codeableconcept),
    description: Option(String),
    image: List(Attachment),
    patient: Reference,
  )
}

pub fn bodystructure_new(patient patient: Reference) -> Bodystructure {
  Bodystructure(
    patient:,
    image: [],
    description: None,
    location_qualifier: [],
    location: None,
    morphology: None,
    active: None,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

pub fn bodystructure_to_json(bodystructure: Bodystructure) -> Json {
  let Bodystructure(
    patient:,
    image:,
    description:,
    location_qualifier:,
    location:,
    morphology:,
    active:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = bodystructure
  let fields = [
    #("patient", reference_to_json(patient)),
  ]
  let fields = case image {
    [] -> fields
    _ -> [#("image", json.array(image, attachment_to_json)), ..fields]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case location_qualifier {
    [] -> fields
    _ -> [
      #(
        "locationQualifier",
        json.array(location_qualifier, codeableconcept_to_json),
      ),
      ..fields
    ]
  }
  let fields = case location {
    Some(v) -> [#("location", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case morphology {
    Some(v) -> [#("morphology", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case active {
    Some(v) -> [#("active", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Bodystructure")), ..fields]
  json.object(fields)
}

pub fn bodystructure_decoder() -> Decoder(Bodystructure) {
  use patient <- decode.field("patient", reference_decoder())
  use image <- decode.optional_field(
    "image",
    [],
    decode.list(attachment_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use location_qualifier <- decode.optional_field(
    "locationQualifier",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use location <- decode.optional_field(
    "location",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use morphology <- decode.optional_field(
    "morphology",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use active <- decode.optional_field(
    "active",
    None,
    decode.optional(decode.bool),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Bodystructure",
    decode.failure(bodystructure_new(patient:), "resourceType"),
  )
  decode.success(Bodystructure(
    patient:,
    image:,
    description:,
    location_qualifier:,
    location:,
    morphology:,
    active:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/Bundle#resource
pub type Bundle {
  Bundle(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    identifier: Option(Identifier),
    type_: r4bvaluesets.Bundletype,
    timestamp: Option(String),
    total: Option(Int),
    link: List(BundleLink),
    entry: List(BundleEntry),
    signature: Option(Signature),
  )
}

pub fn bundle_new(type_ type_: r4bvaluesets.Bundletype) -> Bundle {
  Bundle(
    signature: None,
    entry: [],
    link: [],
    total: None,
    timestamp: None,
    type_:,
    identifier: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Bundle#resource
pub type BundleLink {
  BundleLink(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    relation: String,
    url: String,
  )
}

pub fn bundle_link_new(url url: String, relation relation: String) -> BundleLink {
  BundleLink(url:, relation:, modifier_extension: [], extension: [], id: None)
}

///http://hl7.org/fhir/r4b/StructureDefinition/Bundle#resource
pub type BundleEntry {
  BundleEntry(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    full_url: Option(String),
    resource: Option(Resource),
    search: Option(BundleEntrySearch),
    request: Option(BundleEntryRequest),
    response: Option(BundleEntryResponse),
  )
}

pub fn bundle_entry_new() -> BundleEntry {
  BundleEntry(
    response: None,
    request: None,
    search: None,
    resource: None,
    full_url: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Bundle#resource
pub type BundleEntrySearch {
  BundleEntrySearch(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    mode: Option(r4bvaluesets.Searchentrymode),
    score: Option(Float),
  )
}

pub fn bundle_entry_search_new() -> BundleEntrySearch {
  BundleEntrySearch(
    score: None,
    mode: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Bundle#resource
pub type BundleEntryRequest {
  BundleEntryRequest(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    method: r4bvaluesets.Httpverb,
    url: String,
    if_none_match: Option(String),
    if_modified_since: Option(String),
    if_match: Option(String),
    if_none_exist: Option(String),
  )
}

pub fn bundle_entry_request_new(
  url url: String,
  method method: r4bvaluesets.Httpverb,
) -> BundleEntryRequest {
  BundleEntryRequest(
    if_none_exist: None,
    if_match: None,
    if_modified_since: None,
    if_none_match: None,
    url:,
    method:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Bundle#resource
pub type BundleEntryResponse {
  BundleEntryResponse(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    status: String,
    location: Option(String),
    etag: Option(String),
    last_modified: Option(String),
    outcome: Option(Resource),
  )
}

pub fn bundle_entry_response_new(status status: String) -> BundleEntryResponse {
  BundleEntryResponse(
    outcome: None,
    last_modified: None,
    etag: None,
    location: None,
    status:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn bundle_entry_response_to_json(
  bundle_entry_response: BundleEntryResponse,
) -> Json {
  let BundleEntryResponse(
    outcome:,
    last_modified:,
    etag:,
    location:,
    status:,
    modifier_extension:,
    extension:,
    id:,
  ) = bundle_entry_response
  let fields = [
    #("status", json.string(status)),
  ]
  let fields = case outcome {
    Some(v) -> [#("outcome", resource_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case last_modified {
    Some(v) -> [#("lastModified", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case etag {
    Some(v) -> [#("etag", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case location {
    Some(v) -> [#("location", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn bundle_entry_response_decoder() -> Decoder(BundleEntryResponse) {
  use outcome <- decode.optional_field(
    "outcome",
    None,
    decode.optional(resource_decoder()),
  )
  use last_modified <- decode.optional_field(
    "lastModified",
    None,
    decode.optional(decode.string),
  )
  use etag <- decode.optional_field(
    "etag",
    None,
    decode.optional(decode.string),
  )
  use location <- decode.optional_field(
    "location",
    None,
    decode.optional(decode.string),
  )
  use status <- decode.field("status", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(BundleEntryResponse(
    outcome:,
    last_modified:,
    etag:,
    location:,
    status:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn bundle_entry_request_to_json(
  bundle_entry_request: BundleEntryRequest,
) -> Json {
  let BundleEntryRequest(
    if_none_exist:,
    if_match:,
    if_modified_since:,
    if_none_match:,
    url:,
    method:,
    modifier_extension:,
    extension:,
    id:,
  ) = bundle_entry_request
  let fields = [
    #("url", json.string(url)),
    #("method", r4bvaluesets.httpverb_to_json(method)),
  ]
  let fields = case if_none_exist {
    Some(v) -> [#("ifNoneExist", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case if_match {
    Some(v) -> [#("ifMatch", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case if_modified_since {
    Some(v) -> [#("ifModifiedSince", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case if_none_match {
    Some(v) -> [#("ifNoneMatch", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn bundle_entry_request_decoder() -> Decoder(BundleEntryRequest) {
  use if_none_exist <- decode.optional_field(
    "ifNoneExist",
    None,
    decode.optional(decode.string),
  )
  use if_match <- decode.optional_field(
    "ifMatch",
    None,
    decode.optional(decode.string),
  )
  use if_modified_since <- decode.optional_field(
    "ifModifiedSince",
    None,
    decode.optional(decode.string),
  )
  use if_none_match <- decode.optional_field(
    "ifNoneMatch",
    None,
    decode.optional(decode.string),
  )
  use url <- decode.field("url", decode.string)
  use method <- decode.field("method", r4bvaluesets.httpverb_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(BundleEntryRequest(
    if_none_exist:,
    if_match:,
    if_modified_since:,
    if_none_match:,
    url:,
    method:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn bundle_entry_search_to_json(
  bundle_entry_search: BundleEntrySearch,
) -> Json {
  let BundleEntrySearch(score:, mode:, modifier_extension:, extension:, id:) =
    bundle_entry_search
  let fields = []
  let fields = case score {
    Some(v) -> [#("score", json.float(v)), ..fields]
    None -> fields
  }
  let fields = case mode {
    Some(v) -> [#("mode", r4bvaluesets.searchentrymode_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn bundle_entry_search_decoder() -> Decoder(BundleEntrySearch) {
  use score <- decode.optional_field(
    "score",
    None,
    decode.optional(decode.float),
  )
  use mode <- decode.optional_field(
    "mode",
    None,
    decode.optional(r4bvaluesets.searchentrymode_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(BundleEntrySearch(
    score:,
    mode:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn bundle_entry_to_json(bundle_entry: BundleEntry) -> Json {
  let BundleEntry(
    response:,
    request:,
    search:,
    resource:,
    full_url:,
    modifier_extension:,
    extension:,
    id:,
  ) = bundle_entry
  let fields = []
  let fields = case response {
    Some(v) -> [#("response", bundle_entry_response_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case request {
    Some(v) -> [#("request", bundle_entry_request_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case search {
    Some(v) -> [#("search", bundle_entry_search_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case resource {
    Some(v) -> [#("resource", resource_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case full_url {
    Some(v) -> [#("fullUrl", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn bundle_entry_decoder() -> Decoder(BundleEntry) {
  use response <- decode.optional_field(
    "response",
    None,
    decode.optional(bundle_entry_response_decoder()),
  )
  use request <- decode.optional_field(
    "request",
    None,
    decode.optional(bundle_entry_request_decoder()),
  )
  use search <- decode.optional_field(
    "search",
    None,
    decode.optional(bundle_entry_search_decoder()),
  )
  use resource <- decode.optional_field(
    "resource",
    None,
    decode.optional(resource_decoder()),
  )
  use full_url <- decode.optional_field(
    "fullUrl",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(BundleEntry(
    response:,
    request:,
    search:,
    resource:,
    full_url:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn bundle_link_to_json(bundle_link: BundleLink) -> Json {
  let BundleLink(url:, relation:, modifier_extension:, extension:, id:) =
    bundle_link
  let fields = [
    #("url", json.string(url)),
    #("relation", json.string(relation)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn bundle_link_decoder() -> Decoder(BundleLink) {
  use url <- decode.field("url", decode.string)
  use relation <- decode.field("relation", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(BundleLink(
    url:,
    relation:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn bundle_to_json(bundle: Bundle) -> Json {
  let Bundle(
    signature:,
    entry:,
    link:,
    total:,
    timestamp:,
    type_:,
    identifier:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = bundle
  let fields = [
    #("type", r4bvaluesets.bundletype_to_json(type_)),
  ]
  let fields = case signature {
    Some(v) -> [#("signature", signature_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case entry {
    [] -> fields
    _ -> [#("entry", json.array(entry, bundle_entry_to_json)), ..fields]
  }
  let fields = case link {
    [] -> fields
    _ -> [#("link", json.array(link, bundle_link_to_json)), ..fields]
  }
  let fields = case total {
    Some(v) -> [#("total", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case timestamp {
    Some(v) -> [#("timestamp", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    Some(v) -> [#("identifier", identifier_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Bundle")), ..fields]
  json.object(fields)
}

pub fn bundle_decoder() -> Decoder(Bundle) {
  use signature <- decode.optional_field(
    "signature",
    None,
    decode.optional(signature_decoder()),
  )
  use entry <- decode.optional_field(
    "entry",
    [],
    decode.list(bundle_entry_decoder()),
  )
  use link <- decode.optional_field(
    "link",
    [],
    decode.list(bundle_link_decoder()),
  )
  use total <- decode.optional_field("total", None, decode.optional(decode.int))
  use timestamp <- decode.optional_field(
    "timestamp",
    None,
    decode.optional(decode.string),
  )
  use type_ <- decode.field("type", r4bvaluesets.bundletype_decoder())
  use identifier <- decode.optional_field(
    "identifier",
    None,
    decode.optional(identifier_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Bundle",
    decode.failure(bundle_new(type_:), "resourceType"),
  )
  decode.success(Bundle(
    signature:,
    entry:,
    link:,
    total:,
    timestamp:,
    type_:,
    identifier:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/CapabilityStatement#resource
pub type Capabilitystatement {
  Capabilitystatement(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    url: Option(String),
    version: Option(String),
    name: Option(String),
    title: Option(String),
    status: r4bvaluesets.Publicationstatus,
    experimental: Option(Bool),
    date: String,
    publisher: Option(String),
    contact: List(Contactdetail),
    description: Option(String),
    use_context: List(Usagecontext),
    jurisdiction: List(Codeableconcept),
    purpose: Option(String),
    copyright: Option(String),
    kind: r4bvaluesets.Capabilitystatementkind,
    instantiates: List(String),
    imports: List(String),
    software: Option(CapabilitystatementSoftware),
    implementation: Option(CapabilitystatementImplementation),
    fhir_version: r4bvaluesets.Fhirversion,
    format: List(String),
    patch_format: List(String),
    implementation_guide: List(String),
    rest: List(CapabilitystatementRest),
    messaging: List(CapabilitystatementMessaging),
    document: List(CapabilitystatementDocument),
  )
}

pub fn capabilitystatement_new(
  fhir_version fhir_version: r4bvaluesets.Fhirversion,
  kind kind: r4bvaluesets.Capabilitystatementkind,
  date date: String,
  status status: r4bvaluesets.Publicationstatus,
) -> Capabilitystatement {
  Capabilitystatement(
    document: [],
    messaging: [],
    rest: [],
    implementation_guide: [],
    patch_format: [],
    format: [],
    fhir_version:,
    implementation: None,
    software: None,
    imports: [],
    instantiates: [],
    kind:,
    copyright: None,
    purpose: None,
    jurisdiction: [],
    use_context: [],
    description: None,
    contact: [],
    publisher: None,
    date:,
    experimental: None,
    status:,
    title: None,
    name: None,
    version: None,
    url: None,
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/CapabilityStatement#resource
pub type CapabilitystatementSoftware {
  CapabilitystatementSoftware(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    name: String,
    version: Option(String),
    release_date: Option(String),
  )
}

pub fn capabilitystatement_software_new(
  name name: String,
) -> CapabilitystatementSoftware {
  CapabilitystatementSoftware(
    release_date: None,
    version: None,
    name:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/CapabilityStatement#resource
pub type CapabilitystatementImplementation {
  CapabilitystatementImplementation(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    description: String,
    url: Option(String),
    custodian: Option(Reference),
  )
}

pub fn capabilitystatement_implementation_new(
  description description: String,
) -> CapabilitystatementImplementation {
  CapabilitystatementImplementation(
    custodian: None,
    url: None,
    description:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/CapabilityStatement#resource
pub type CapabilitystatementRest {
  CapabilitystatementRest(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    mode: r4bvaluesets.Restfulcapabilitymode,
    documentation: Option(String),
    security: Option(CapabilitystatementRestSecurity),
    resource: List(CapabilitystatementRestResource),
    interaction: List(CapabilitystatementRestInteraction),
    compartment: List(String),
  )
}

pub fn capabilitystatement_rest_new(
  mode mode: r4bvaluesets.Restfulcapabilitymode,
) -> CapabilitystatementRest {
  CapabilitystatementRest(
    compartment: [],
    interaction: [],
    resource: [],
    security: None,
    documentation: None,
    mode:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/CapabilityStatement#resource
pub type CapabilitystatementRestSecurity {
  CapabilitystatementRestSecurity(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    cors: Option(Bool),
    service: List(Codeableconcept),
    description: Option(String),
  )
}

pub fn capabilitystatement_rest_security_new() -> CapabilitystatementRestSecurity {
  CapabilitystatementRestSecurity(
    description: None,
    service: [],
    cors: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/CapabilityStatement#resource
pub type CapabilitystatementRestResource {
  CapabilitystatementRestResource(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: r4bvaluesets.Resourcetypes,
    profile: Option(String),
    supported_profile: List(String),
    documentation: Option(String),
    interaction: List(CapabilitystatementRestResourceInteraction),
    versioning: Option(r4bvaluesets.Versioningpolicy),
    read_history: Option(Bool),
    update_create: Option(Bool),
    conditional_create: Option(Bool),
    conditional_read: Option(r4bvaluesets.Conditionalreadstatus),
    conditional_update: Option(Bool),
    conditional_delete: Option(r4bvaluesets.Conditionaldeletestatus),
    reference_policy: List(r4bvaluesets.Referencehandlingpolicy),
    search_include: List(String),
    search_rev_include: List(String),
    search_param: List(CapabilitystatementRestResourceSearchparam),
    operation: List(CapabilitystatementRestResourceOperation),
  )
}

pub fn capabilitystatement_rest_resource_new(
  type_ type_: r4bvaluesets.Resourcetypes,
) -> CapabilitystatementRestResource {
  CapabilitystatementRestResource(
    operation: [],
    search_param: [],
    search_rev_include: [],
    search_include: [],
    reference_policy: [],
    conditional_delete: None,
    conditional_update: None,
    conditional_read: None,
    conditional_create: None,
    update_create: None,
    read_history: None,
    versioning: None,
    interaction: [],
    documentation: None,
    supported_profile: [],
    profile: None,
    type_:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/CapabilityStatement#resource
pub type CapabilitystatementRestResourceInteraction {
  CapabilitystatementRestResourceInteraction(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    code: r4bvaluesets.Typerestfulinteraction,
    documentation: Option(String),
  )
}

pub fn capabilitystatement_rest_resource_interaction_new(
  code code: r4bvaluesets.Typerestfulinteraction,
) -> CapabilitystatementRestResourceInteraction {
  CapabilitystatementRestResourceInteraction(
    documentation: None,
    code:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/CapabilityStatement#resource
pub type CapabilitystatementRestResourceSearchparam {
  CapabilitystatementRestResourceSearchparam(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    name: String,
    definition: Option(String),
    type_: r4bvaluesets.Searchparamtype,
    documentation: Option(String),
  )
}

pub fn capabilitystatement_rest_resource_searchparam_new(
  type_ type_: r4bvaluesets.Searchparamtype,
  name name: String,
) -> CapabilitystatementRestResourceSearchparam {
  CapabilitystatementRestResourceSearchparam(
    documentation: None,
    type_:,
    definition: None,
    name:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/CapabilityStatement#resource
pub type CapabilitystatementRestResourceOperation {
  CapabilitystatementRestResourceOperation(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    name: String,
    definition: String,
    documentation: Option(String),
  )
}

pub fn capabilitystatement_rest_resource_operation_new(
  definition definition: String,
  name name: String,
) -> CapabilitystatementRestResourceOperation {
  CapabilitystatementRestResourceOperation(
    documentation: None,
    definition:,
    name:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/CapabilityStatement#resource
pub type CapabilitystatementRestInteraction {
  CapabilitystatementRestInteraction(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    code: r4bvaluesets.Systemrestfulinteraction,
    documentation: Option(String),
  )
}

pub fn capabilitystatement_rest_interaction_new(
  code code: r4bvaluesets.Systemrestfulinteraction,
) -> CapabilitystatementRestInteraction {
  CapabilitystatementRestInteraction(
    documentation: None,
    code:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/CapabilityStatement#resource
pub type CapabilitystatementMessaging {
  CapabilitystatementMessaging(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    endpoint: List(CapabilitystatementMessagingEndpoint),
    reliable_cache: Option(Int),
    documentation: Option(String),
    supported_message: List(CapabilitystatementMessagingSupportedmessage),
  )
}

pub fn capabilitystatement_messaging_new() -> CapabilitystatementMessaging {
  CapabilitystatementMessaging(
    supported_message: [],
    documentation: None,
    reliable_cache: None,
    endpoint: [],
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/CapabilityStatement#resource
pub type CapabilitystatementMessagingEndpoint {
  CapabilitystatementMessagingEndpoint(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    protocol: Coding,
    address: String,
  )
}

pub fn capabilitystatement_messaging_endpoint_new(
  address address: String,
  protocol protocol: Coding,
) -> CapabilitystatementMessagingEndpoint {
  CapabilitystatementMessagingEndpoint(
    address:,
    protocol:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/CapabilityStatement#resource
pub type CapabilitystatementMessagingSupportedmessage {
  CapabilitystatementMessagingSupportedmessage(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    mode: r4bvaluesets.Eventcapabilitymode,
    definition: String,
  )
}

pub fn capabilitystatement_messaging_supportedmessage_new(
  definition definition: String,
  mode mode: r4bvaluesets.Eventcapabilitymode,
) -> CapabilitystatementMessagingSupportedmessage {
  CapabilitystatementMessagingSupportedmessage(
    definition:,
    mode:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/CapabilityStatement#resource
pub type CapabilitystatementDocument {
  CapabilitystatementDocument(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    mode: r4bvaluesets.Documentmode,
    documentation: Option(String),
    profile: String,
  )
}

pub fn capabilitystatement_document_new(
  profile profile: String,
  mode mode: r4bvaluesets.Documentmode,
) -> CapabilitystatementDocument {
  CapabilitystatementDocument(
    profile:,
    documentation: None,
    mode:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn capabilitystatement_document_to_json(
  capabilitystatement_document: CapabilitystatementDocument,
) -> Json {
  let CapabilitystatementDocument(
    profile:,
    documentation:,
    mode:,
    modifier_extension:,
    extension:,
    id:,
  ) = capabilitystatement_document
  let fields = [
    #("profile", json.string(profile)),
    #("mode", r4bvaluesets.documentmode_to_json(mode)),
  ]
  let fields = case documentation {
    Some(v) -> [#("documentation", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn capabilitystatement_document_decoder() -> Decoder(
  CapabilitystatementDocument,
) {
  use profile <- decode.field("profile", decode.string)
  use documentation <- decode.optional_field(
    "documentation",
    None,
    decode.optional(decode.string),
  )
  use mode <- decode.field("mode", r4bvaluesets.documentmode_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CapabilitystatementDocument(
    profile:,
    documentation:,
    mode:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn capabilitystatement_messaging_supportedmessage_to_json(
  capabilitystatement_messaging_supportedmessage: CapabilitystatementMessagingSupportedmessage,
) -> Json {
  let CapabilitystatementMessagingSupportedmessage(
    definition:,
    mode:,
    modifier_extension:,
    extension:,
    id:,
  ) = capabilitystatement_messaging_supportedmessage
  let fields = [
    #("definition", json.string(definition)),
    #("mode", r4bvaluesets.eventcapabilitymode_to_json(mode)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn capabilitystatement_messaging_supportedmessage_decoder() -> Decoder(
  CapabilitystatementMessagingSupportedmessage,
) {
  use definition <- decode.field("definition", decode.string)
  use mode <- decode.field("mode", r4bvaluesets.eventcapabilitymode_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CapabilitystatementMessagingSupportedmessage(
    definition:,
    mode:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn capabilitystatement_messaging_endpoint_to_json(
  capabilitystatement_messaging_endpoint: CapabilitystatementMessagingEndpoint,
) -> Json {
  let CapabilitystatementMessagingEndpoint(
    address:,
    protocol:,
    modifier_extension:,
    extension:,
    id:,
  ) = capabilitystatement_messaging_endpoint
  let fields = [
    #("address", json.string(address)),
    #("protocol", coding_to_json(protocol)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn capabilitystatement_messaging_endpoint_decoder() -> Decoder(
  CapabilitystatementMessagingEndpoint,
) {
  use address <- decode.field("address", decode.string)
  use protocol <- decode.field("protocol", coding_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CapabilitystatementMessagingEndpoint(
    address:,
    protocol:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn capabilitystatement_messaging_to_json(
  capabilitystatement_messaging: CapabilitystatementMessaging,
) -> Json {
  let CapabilitystatementMessaging(
    supported_message:,
    documentation:,
    reliable_cache:,
    endpoint:,
    modifier_extension:,
    extension:,
    id:,
  ) = capabilitystatement_messaging
  let fields = []
  let fields = case supported_message {
    [] -> fields
    _ -> [
      #(
        "supportedMessage",
        json.array(
          supported_message,
          capabilitystatement_messaging_supportedmessage_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case documentation {
    Some(v) -> [#("documentation", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case reliable_cache {
    Some(v) -> [#("reliableCache", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case endpoint {
    [] -> fields
    _ -> [
      #(
        "endpoint",
        json.array(endpoint, capabilitystatement_messaging_endpoint_to_json),
      ),
      ..fields
    ]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn capabilitystatement_messaging_decoder() -> Decoder(
  CapabilitystatementMessaging,
) {
  use supported_message <- decode.optional_field(
    "supportedMessage",
    [],
    decode.list(capabilitystatement_messaging_supportedmessage_decoder()),
  )
  use documentation <- decode.optional_field(
    "documentation",
    None,
    decode.optional(decode.string),
  )
  use reliable_cache <- decode.optional_field(
    "reliableCache",
    None,
    decode.optional(decode.int),
  )
  use endpoint <- decode.optional_field(
    "endpoint",
    [],
    decode.list(capabilitystatement_messaging_endpoint_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CapabilitystatementMessaging(
    supported_message:,
    documentation:,
    reliable_cache:,
    endpoint:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn capabilitystatement_rest_interaction_to_json(
  capabilitystatement_rest_interaction: CapabilitystatementRestInteraction,
) -> Json {
  let CapabilitystatementRestInteraction(
    documentation:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ) = capabilitystatement_rest_interaction
  let fields = [
    #("code", r4bvaluesets.systemrestfulinteraction_to_json(code)),
  ]
  let fields = case documentation {
    Some(v) -> [#("documentation", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn capabilitystatement_rest_interaction_decoder() -> Decoder(
  CapabilitystatementRestInteraction,
) {
  use documentation <- decode.optional_field(
    "documentation",
    None,
    decode.optional(decode.string),
  )
  use code <- decode.field(
    "code",
    r4bvaluesets.systemrestfulinteraction_decoder(),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CapabilitystatementRestInteraction(
    documentation:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn capabilitystatement_rest_resource_operation_to_json(
  capabilitystatement_rest_resource_operation: CapabilitystatementRestResourceOperation,
) -> Json {
  let CapabilitystatementRestResourceOperation(
    documentation:,
    definition:,
    name:,
    modifier_extension:,
    extension:,
    id:,
  ) = capabilitystatement_rest_resource_operation
  let fields = [
    #("definition", json.string(definition)),
    #("name", json.string(name)),
  ]
  let fields = case documentation {
    Some(v) -> [#("documentation", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn capabilitystatement_rest_resource_operation_decoder() -> Decoder(
  CapabilitystatementRestResourceOperation,
) {
  use documentation <- decode.optional_field(
    "documentation",
    None,
    decode.optional(decode.string),
  )
  use definition <- decode.field("definition", decode.string)
  use name <- decode.field("name", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CapabilitystatementRestResourceOperation(
    documentation:,
    definition:,
    name:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn capabilitystatement_rest_resource_searchparam_to_json(
  capabilitystatement_rest_resource_searchparam: CapabilitystatementRestResourceSearchparam,
) -> Json {
  let CapabilitystatementRestResourceSearchparam(
    documentation:,
    type_:,
    definition:,
    name:,
    modifier_extension:,
    extension:,
    id:,
  ) = capabilitystatement_rest_resource_searchparam
  let fields = [
    #("type", r4bvaluesets.searchparamtype_to_json(type_)),
    #("name", json.string(name)),
  ]
  let fields = case documentation {
    Some(v) -> [#("documentation", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case definition {
    Some(v) -> [#("definition", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn capabilitystatement_rest_resource_searchparam_decoder() -> Decoder(
  CapabilitystatementRestResourceSearchparam,
) {
  use documentation <- decode.optional_field(
    "documentation",
    None,
    decode.optional(decode.string),
  )
  use type_ <- decode.field("type", r4bvaluesets.searchparamtype_decoder())
  use definition <- decode.optional_field(
    "definition",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.field("name", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CapabilitystatementRestResourceSearchparam(
    documentation:,
    type_:,
    definition:,
    name:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn capabilitystatement_rest_resource_interaction_to_json(
  capabilitystatement_rest_resource_interaction: CapabilitystatementRestResourceInteraction,
) -> Json {
  let CapabilitystatementRestResourceInteraction(
    documentation:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ) = capabilitystatement_rest_resource_interaction
  let fields = [
    #("code", r4bvaluesets.typerestfulinteraction_to_json(code)),
  ]
  let fields = case documentation {
    Some(v) -> [#("documentation", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn capabilitystatement_rest_resource_interaction_decoder() -> Decoder(
  CapabilitystatementRestResourceInteraction,
) {
  use documentation <- decode.optional_field(
    "documentation",
    None,
    decode.optional(decode.string),
  )
  use code <- decode.field(
    "code",
    r4bvaluesets.typerestfulinteraction_decoder(),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CapabilitystatementRestResourceInteraction(
    documentation:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn capabilitystatement_rest_resource_to_json(
  capabilitystatement_rest_resource: CapabilitystatementRestResource,
) -> Json {
  let CapabilitystatementRestResource(
    operation:,
    search_param:,
    search_rev_include:,
    search_include:,
    reference_policy:,
    conditional_delete:,
    conditional_update:,
    conditional_read:,
    conditional_create:,
    update_create:,
    read_history:,
    versioning:,
    interaction:,
    documentation:,
    supported_profile:,
    profile:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = capabilitystatement_rest_resource
  let fields = [
    #("type", r4bvaluesets.resourcetypes_to_json(type_)),
  ]
  let fields = case operation {
    [] -> fields
    _ -> [
      #(
        "operation",
        json.array(
          operation,
          capabilitystatement_rest_resource_operation_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case search_param {
    [] -> fields
    _ -> [
      #(
        "searchParam",
        json.array(
          search_param,
          capabilitystatement_rest_resource_searchparam_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case search_rev_include {
    [] -> fields
    _ -> [
      #("searchRevInclude", json.array(search_rev_include, json.string)),
      ..fields
    ]
  }
  let fields = case search_include {
    [] -> fields
    _ -> [#("searchInclude", json.array(search_include, json.string)), ..fields]
  }
  let fields = case reference_policy {
    [] -> fields
    _ -> [
      #(
        "referencePolicy",
        json.array(
          reference_policy,
          r4bvaluesets.referencehandlingpolicy_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case conditional_delete {
    Some(v) -> [
      #("conditionalDelete", r4bvaluesets.conditionaldeletestatus_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case conditional_update {
    Some(v) -> [#("conditionalUpdate", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case conditional_read {
    Some(v) -> [
      #("conditionalRead", r4bvaluesets.conditionalreadstatus_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case conditional_create {
    Some(v) -> [#("conditionalCreate", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case update_create {
    Some(v) -> [#("updateCreate", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case read_history {
    Some(v) -> [#("readHistory", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case versioning {
    Some(v) -> [
      #("versioning", r4bvaluesets.versioningpolicy_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case interaction {
    [] -> fields
    _ -> [
      #(
        "interaction",
        json.array(
          interaction,
          capabilitystatement_rest_resource_interaction_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case documentation {
    Some(v) -> [#("documentation", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case supported_profile {
    [] -> fields
    _ -> [
      #("supportedProfile", json.array(supported_profile, json.string)),
      ..fields
    ]
  }
  let fields = case profile {
    Some(v) -> [#("profile", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn capabilitystatement_rest_resource_decoder() -> Decoder(
  CapabilitystatementRestResource,
) {
  use operation <- decode.optional_field(
    "operation",
    [],
    decode.list(capabilitystatement_rest_resource_operation_decoder()),
  )
  use search_param <- decode.optional_field(
    "searchParam",
    [],
    decode.list(capabilitystatement_rest_resource_searchparam_decoder()),
  )
  use search_rev_include <- decode.optional_field(
    "searchRevInclude",
    [],
    decode.list(decode.string),
  )
  use search_include <- decode.optional_field(
    "searchInclude",
    [],
    decode.list(decode.string),
  )
  use reference_policy <- decode.optional_field(
    "referencePolicy",
    [],
    decode.list(r4bvaluesets.referencehandlingpolicy_decoder()),
  )
  use conditional_delete <- decode.optional_field(
    "conditionalDelete",
    None,
    decode.optional(r4bvaluesets.conditionaldeletestatus_decoder()),
  )
  use conditional_update <- decode.optional_field(
    "conditionalUpdate",
    None,
    decode.optional(decode.bool),
  )
  use conditional_read <- decode.optional_field(
    "conditionalRead",
    None,
    decode.optional(r4bvaluesets.conditionalreadstatus_decoder()),
  )
  use conditional_create <- decode.optional_field(
    "conditionalCreate",
    None,
    decode.optional(decode.bool),
  )
  use update_create <- decode.optional_field(
    "updateCreate",
    None,
    decode.optional(decode.bool),
  )
  use read_history <- decode.optional_field(
    "readHistory",
    None,
    decode.optional(decode.bool),
  )
  use versioning <- decode.optional_field(
    "versioning",
    None,
    decode.optional(r4bvaluesets.versioningpolicy_decoder()),
  )
  use interaction <- decode.optional_field(
    "interaction",
    [],
    decode.list(capabilitystatement_rest_resource_interaction_decoder()),
  )
  use documentation <- decode.optional_field(
    "documentation",
    None,
    decode.optional(decode.string),
  )
  use supported_profile <- decode.optional_field(
    "supportedProfile",
    [],
    decode.list(decode.string),
  )
  use profile <- decode.optional_field(
    "profile",
    None,
    decode.optional(decode.string),
  )
  use type_ <- decode.field("type", r4bvaluesets.resourcetypes_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CapabilitystatementRestResource(
    operation:,
    search_param:,
    search_rev_include:,
    search_include:,
    reference_policy:,
    conditional_delete:,
    conditional_update:,
    conditional_read:,
    conditional_create:,
    update_create:,
    read_history:,
    versioning:,
    interaction:,
    documentation:,
    supported_profile:,
    profile:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn capabilitystatement_rest_security_to_json(
  capabilitystatement_rest_security: CapabilitystatementRestSecurity,
) -> Json {
  let CapabilitystatementRestSecurity(
    description:,
    service:,
    cors:,
    modifier_extension:,
    extension:,
    id:,
  ) = capabilitystatement_rest_security
  let fields = []
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case service {
    [] -> fields
    _ -> [#("service", json.array(service, codeableconcept_to_json)), ..fields]
  }
  let fields = case cors {
    Some(v) -> [#("cors", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn capabilitystatement_rest_security_decoder() -> Decoder(
  CapabilitystatementRestSecurity,
) {
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use service <- decode.optional_field(
    "service",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use cors <- decode.optional_field("cors", None, decode.optional(decode.bool))
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CapabilitystatementRestSecurity(
    description:,
    service:,
    cors:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn capabilitystatement_rest_to_json(
  capabilitystatement_rest: CapabilitystatementRest,
) -> Json {
  let CapabilitystatementRest(
    compartment:,
    interaction:,
    resource:,
    security:,
    documentation:,
    mode:,
    modifier_extension:,
    extension:,
    id:,
  ) = capabilitystatement_rest
  let fields = [
    #("mode", r4bvaluesets.restfulcapabilitymode_to_json(mode)),
  ]
  let fields = case compartment {
    [] -> fields
    _ -> [#("compartment", json.array(compartment, json.string)), ..fields]
  }
  let fields = case interaction {
    [] -> fields
    _ -> [
      #(
        "interaction",
        json.array(interaction, capabilitystatement_rest_interaction_to_json),
      ),
      ..fields
    ]
  }
  let fields = case resource {
    [] -> fields
    _ -> [
      #(
        "resource",
        json.array(resource, capabilitystatement_rest_resource_to_json),
      ),
      ..fields
    ]
  }
  let fields = case security {
    Some(v) -> [
      #("security", capabilitystatement_rest_security_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case documentation {
    Some(v) -> [#("documentation", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn capabilitystatement_rest_decoder() -> Decoder(CapabilitystatementRest) {
  use compartment <- decode.optional_field(
    "compartment",
    [],
    decode.list(decode.string),
  )
  use interaction <- decode.optional_field(
    "interaction",
    [],
    decode.list(capabilitystatement_rest_interaction_decoder()),
  )
  use resource <- decode.optional_field(
    "resource",
    [],
    decode.list(capabilitystatement_rest_resource_decoder()),
  )
  use security <- decode.optional_field(
    "security",
    None,
    decode.optional(capabilitystatement_rest_security_decoder()),
  )
  use documentation <- decode.optional_field(
    "documentation",
    None,
    decode.optional(decode.string),
  )
  use mode <- decode.field("mode", r4bvaluesets.restfulcapabilitymode_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CapabilitystatementRest(
    compartment:,
    interaction:,
    resource:,
    security:,
    documentation:,
    mode:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn capabilitystatement_implementation_to_json(
  capabilitystatement_implementation: CapabilitystatementImplementation,
) -> Json {
  let CapabilitystatementImplementation(
    custodian:,
    url:,
    description:,
    modifier_extension:,
    extension:,
    id:,
  ) = capabilitystatement_implementation
  let fields = [
    #("description", json.string(description)),
  ]
  let fields = case custodian {
    Some(v) -> [#("custodian", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case url {
    Some(v) -> [#("url", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn capabilitystatement_implementation_decoder() -> Decoder(
  CapabilitystatementImplementation,
) {
  use custodian <- decode.optional_field(
    "custodian",
    None,
    decode.optional(reference_decoder()),
  )
  use url <- decode.optional_field("url", None, decode.optional(decode.string))
  use description <- decode.field("description", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CapabilitystatementImplementation(
    custodian:,
    url:,
    description:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn capabilitystatement_software_to_json(
  capabilitystatement_software: CapabilitystatementSoftware,
) -> Json {
  let CapabilitystatementSoftware(
    release_date:,
    version:,
    name:,
    modifier_extension:,
    extension:,
    id:,
  ) = capabilitystatement_software
  let fields = [
    #("name", json.string(name)),
  ]
  let fields = case release_date {
    Some(v) -> [#("releaseDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case version {
    Some(v) -> [#("version", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn capabilitystatement_software_decoder() -> Decoder(
  CapabilitystatementSoftware,
) {
  use release_date <- decode.optional_field(
    "releaseDate",
    None,
    decode.optional(decode.string),
  )
  use version <- decode.optional_field(
    "version",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.field("name", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CapabilitystatementSoftware(
    release_date:,
    version:,
    name:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn capabilitystatement_to_json(
  capabilitystatement: Capabilitystatement,
) -> Json {
  let Capabilitystatement(
    document:,
    messaging:,
    rest:,
    implementation_guide:,
    patch_format:,
    format:,
    fhir_version:,
    implementation:,
    software:,
    imports:,
    instantiates:,
    kind:,
    copyright:,
    purpose:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    experimental:,
    status:,
    title:,
    name:,
    version:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = capabilitystatement
  let fields = [
    #("fhirVersion", r4bvaluesets.fhirversion_to_json(fhir_version)),
    #("kind", r4bvaluesets.capabilitystatementkind_to_json(kind)),
    #("date", json.string(date)),
    #("status", r4bvaluesets.publicationstatus_to_json(status)),
  ]
  let fields = case document {
    [] -> fields
    _ -> [
      #("document", json.array(document, capabilitystatement_document_to_json)),
      ..fields
    ]
  }
  let fields = case messaging {
    [] -> fields
    _ -> [
      #(
        "messaging",
        json.array(messaging, capabilitystatement_messaging_to_json),
      ),
      ..fields
    ]
  }
  let fields = case rest {
    [] -> fields
    _ -> [
      #("rest", json.array(rest, capabilitystatement_rest_to_json)),
      ..fields
    ]
  }
  let fields = case implementation_guide {
    [] -> fields
    _ -> [
      #("implementationGuide", json.array(implementation_guide, json.string)),
      ..fields
    ]
  }
  let fields = case patch_format {
    [] -> fields
    _ -> [#("patchFormat", json.array(patch_format, json.string)), ..fields]
  }
  let fields = case format {
    [] -> fields
    _ -> [#("format", json.array(format, json.string)), ..fields]
  }
  let fields = case implementation {
    Some(v) -> [
      #("implementation", capabilitystatement_implementation_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case software {
    Some(v) -> [
      #("software", capabilitystatement_software_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case imports {
    [] -> fields
    _ -> [#("imports", json.array(imports, json.string)), ..fields]
  }
  let fields = case instantiates {
    [] -> fields
    _ -> [#("instantiates", json.array(instantiates, json.string)), ..fields]
  }
  let fields = case copyright {
    Some(v) -> [#("copyright", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case purpose {
    Some(v) -> [#("purpose", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case jurisdiction {
    [] -> fields
    _ -> [
      #("jurisdiction", json.array(jurisdiction, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case use_context {
    [] -> fields
    _ -> [
      #("useContext", json.array(use_context, usagecontext_to_json)),
      ..fields
    ]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case contact {
    [] -> fields
    _ -> [#("contact", json.array(contact, contactdetail_to_json)), ..fields]
  }
  let fields = case publisher {
    Some(v) -> [#("publisher", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case experimental {
    Some(v) -> [#("experimental", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case title {
    Some(v) -> [#("title", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case version {
    Some(v) -> [#("version", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case url {
    Some(v) -> [#("url", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Capabilitystatement")), ..fields]
  json.object(fields)
}

pub fn capabilitystatement_decoder() -> Decoder(Capabilitystatement) {
  use document <- decode.optional_field(
    "document",
    [],
    decode.list(capabilitystatement_document_decoder()),
  )
  use messaging <- decode.optional_field(
    "messaging",
    [],
    decode.list(capabilitystatement_messaging_decoder()),
  )
  use rest <- decode.optional_field(
    "rest",
    [],
    decode.list(capabilitystatement_rest_decoder()),
  )
  use implementation_guide <- decode.optional_field(
    "implementationGuide",
    [],
    decode.list(decode.string),
  )
  use patch_format <- decode.optional_field(
    "patchFormat",
    [],
    decode.list(decode.string),
  )
  use format <- decode.optional_field("format", [], decode.list(decode.string))
  use fhir_version <- decode.field(
    "fhirVersion",
    r4bvaluesets.fhirversion_decoder(),
  )
  use implementation <- decode.optional_field(
    "implementation",
    None,
    decode.optional(capabilitystatement_implementation_decoder()),
  )
  use software <- decode.optional_field(
    "software",
    None,
    decode.optional(capabilitystatement_software_decoder()),
  )
  use imports <- decode.optional_field(
    "imports",
    [],
    decode.list(decode.string),
  )
  use instantiates <- decode.optional_field(
    "instantiates",
    [],
    decode.list(decode.string),
  )
  use kind <- decode.field(
    "kind",
    r4bvaluesets.capabilitystatementkind_decoder(),
  )
  use copyright <- decode.optional_field(
    "copyright",
    None,
    decode.optional(decode.string),
  )
  use purpose <- decode.optional_field(
    "purpose",
    None,
    decode.optional(decode.string),
  )
  use jurisdiction <- decode.optional_field(
    "jurisdiction",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use use_context <- decode.optional_field(
    "useContext",
    [],
    decode.list(usagecontext_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use contact <- decode.optional_field(
    "contact",
    [],
    decode.list(contactdetail_decoder()),
  )
  use publisher <- decode.optional_field(
    "publisher",
    None,
    decode.optional(decode.string),
  )
  use date <- decode.field("date", decode.string)
  use experimental <- decode.optional_field(
    "experimental",
    None,
    decode.optional(decode.bool),
  )
  use status <- decode.field("status", r4bvaluesets.publicationstatus_decoder())
  use title <- decode.optional_field(
    "title",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use version <- decode.optional_field(
    "version",
    None,
    decode.optional(decode.string),
  )
  use url <- decode.optional_field("url", None, decode.optional(decode.string))
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Capabilitystatement",
    decode.failure(
      capabilitystatement_new(fhir_version:, kind:, date:, status:),
      "resourceType",
    ),
  )
  decode.success(Capabilitystatement(
    document:,
    messaging:,
    rest:,
    implementation_guide:,
    patch_format:,
    format:,
    fhir_version:,
    implementation:,
    software:,
    imports:,
    instantiates:,
    kind:,
    copyright:,
    purpose:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    experimental:,
    status:,
    title:,
    name:,
    version:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/CarePlan#resource
pub type Careplan {
  Careplan(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    instantiates_canonical: List(String),
    instantiates_uri: List(String),
    based_on: List(Reference),
    replaces: List(Reference),
    part_of: List(Reference),
    status: r4bvaluesets.Requeststatus,
    intent: r4bvaluesets.Careplanintent,
    category: List(Codeableconcept),
    title: Option(String),
    description: Option(String),
    subject: Reference,
    encounter: Option(Reference),
    period: Option(Period),
    created: Option(String),
    author: Option(Reference),
    contributor: List(Reference),
    care_team: List(Reference),
    addresses: List(Reference),
    supporting_info: List(Reference),
    goal: List(Reference),
    activity: List(CareplanActivity),
    note: List(Annotation),
  )
}

pub fn careplan_new(
  subject subject: Reference,
  intent intent: r4bvaluesets.Careplanintent,
  status status: r4bvaluesets.Requeststatus,
) -> Careplan {
  Careplan(
    note: [],
    activity: [],
    goal: [],
    supporting_info: [],
    addresses: [],
    care_team: [],
    contributor: [],
    author: None,
    created: None,
    period: None,
    encounter: None,
    subject:,
    description: None,
    title: None,
    category: [],
    intent:,
    status:,
    part_of: [],
    replaces: [],
    based_on: [],
    instantiates_uri: [],
    instantiates_canonical: [],
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/CarePlan#resource
pub type CareplanActivity {
  CareplanActivity(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    outcome_codeable_concept: List(Codeableconcept),
    outcome_reference: List(Reference),
    progress: List(Annotation),
    reference: Option(Reference),
    detail: Option(CareplanActivityDetail),
  )
}

pub fn careplan_activity_new() -> CareplanActivity {
  CareplanActivity(
    detail: None,
    reference: None,
    progress: [],
    outcome_reference: [],
    outcome_codeable_concept: [],
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/CarePlan#resource
pub type CareplanActivityDetail {
  CareplanActivityDetail(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    kind: Option(r4bvaluesets.Careplanactivitykind),
    instantiates_canonical: List(String),
    instantiates_uri: List(String),
    code: Option(Codeableconcept),
    reason_code: List(Codeableconcept),
    reason_reference: List(Reference),
    goal: List(Reference),
    status: r4bvaluesets.Careplanactivitystatus,
    status_reason: Option(Codeableconcept),
    do_not_perform: Option(Bool),
    scheduled: Option(CareplanActivityDetailScheduled),
    location: Option(Reference),
    performer: List(Reference),
    product: Option(CareplanActivityDetailProduct),
    daily_amount: Option(Quantity),
    quantity: Option(Quantity),
    description: Option(String),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/CarePlan#resource
pub type CareplanActivityDetailScheduled {
  CareplanActivityDetailScheduledTiming(scheduled: Timing)
  CareplanActivityDetailScheduledPeriod(scheduled: Period)
  CareplanActivityDetailScheduledString(scheduled: String)
}

pub fn careplan_activity_detail_scheduled_to_json(
  elt: CareplanActivityDetailScheduled,
) -> Json {
  case elt {
    CareplanActivityDetailScheduledTiming(v) -> timing_to_json(v)
    CareplanActivityDetailScheduledPeriod(v) -> period_to_json(v)
    CareplanActivityDetailScheduledString(v) -> json.string(v)
  }
}

pub fn careplan_activity_detail_scheduled_decoder() -> Decoder(
  CareplanActivityDetailScheduled,
) {
  decode.one_of(
    decode.field("scheduledTiming", timing_decoder(), decode.success)
      |> decode.map(CareplanActivityDetailScheduledTiming),
    [
      decode.field("scheduledPeriod", period_decoder(), decode.success)
        |> decode.map(CareplanActivityDetailScheduledPeriod),
      decode.field("scheduledString", decode.string, decode.success)
        |> decode.map(CareplanActivityDetailScheduledString),
    ],
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/CarePlan#resource
pub type CareplanActivityDetailProduct {
  CareplanActivityDetailProductCodeableconcept(product: Codeableconcept)
  CareplanActivityDetailProductReference(product: Reference)
}

pub fn careplan_activity_detail_product_to_json(
  elt: CareplanActivityDetailProduct,
) -> Json {
  case elt {
    CareplanActivityDetailProductCodeableconcept(v) ->
      codeableconcept_to_json(v)
    CareplanActivityDetailProductReference(v) -> reference_to_json(v)
  }
}

pub fn careplan_activity_detail_product_decoder() -> Decoder(
  CareplanActivityDetailProduct,
) {
  decode.one_of(
    decode.field(
      "productCodeableConcept",
      codeableconcept_decoder(),
      decode.success,
    )
      |> decode.map(CareplanActivityDetailProductCodeableconcept),
    [
      decode.field("productReference", reference_decoder(), decode.success)
      |> decode.map(CareplanActivityDetailProductReference),
    ],
  )
}

pub fn careplan_activity_detail_new(
  status status: r4bvaluesets.Careplanactivitystatus,
) -> CareplanActivityDetail {
  CareplanActivityDetail(
    description: None,
    quantity: None,
    daily_amount: None,
    product: None,
    performer: [],
    location: None,
    scheduled: None,
    do_not_perform: None,
    status_reason: None,
    status:,
    goal: [],
    reason_reference: [],
    reason_code: [],
    code: None,
    instantiates_uri: [],
    instantiates_canonical: [],
    kind: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn careplan_activity_detail_to_json(
  careplan_activity_detail: CareplanActivityDetail,
) -> Json {
  let CareplanActivityDetail(
    description:,
    quantity:,
    daily_amount:,
    product:,
    performer:,
    location:,
    scheduled:,
    do_not_perform:,
    status_reason:,
    status:,
    goal:,
    reason_reference:,
    reason_code:,
    code:,
    instantiates_uri:,
    instantiates_canonical:,
    kind:,
    modifier_extension:,
    extension:,
    id:,
  ) = careplan_activity_detail
  let fields = [
    #("status", r4bvaluesets.careplanactivitystatus_to_json(status)),
  ]
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case quantity {
    Some(v) -> [#("quantity", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case daily_amount {
    Some(v) -> [#("dailyAmount", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case product {
    Some(v) -> [
      #(
        "product"
          <> case v {
          CareplanActivityDetailProductCodeableconcept(_) -> "Codeableconcept"
          CareplanActivityDetailProductReference(_) -> "Reference"
        },
        careplan_activity_detail_product_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case performer {
    [] -> fields
    _ -> [#("performer", json.array(performer, reference_to_json)), ..fields]
  }
  let fields = case location {
    Some(v) -> [#("location", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case scheduled {
    Some(v) -> [
      #(
        "scheduled"
          <> case v {
          CareplanActivityDetailScheduledTiming(_) -> "Timing"
          CareplanActivityDetailScheduledPeriod(_) -> "Period"
          CareplanActivityDetailScheduledString(_) -> "String"
        },
        careplan_activity_detail_scheduled_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case do_not_perform {
    Some(v) -> [#("doNotPerform", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case status_reason {
    Some(v) -> [#("statusReason", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case goal {
    [] -> fields
    _ -> [#("goal", json.array(goal, reference_to_json)), ..fields]
  }
  let fields = case reason_reference {
    [] -> fields
    _ -> [
      #("reasonReference", json.array(reason_reference, reference_to_json)),
      ..fields
    ]
  }
  let fields = case reason_code {
    [] -> fields
    _ -> [
      #("reasonCode", json.array(reason_code, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case code {
    Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case instantiates_uri {
    [] -> fields
    _ -> [
      #("instantiatesUri", json.array(instantiates_uri, json.string)),
      ..fields
    ]
  }
  let fields = case instantiates_canonical {
    [] -> fields
    _ -> [
      #(
        "instantiatesCanonical",
        json.array(instantiates_canonical, json.string),
      ),
      ..fields
    ]
  }
  let fields = case kind {
    Some(v) -> [
      #("kind", r4bvaluesets.careplanactivitykind_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn careplan_activity_detail_decoder() -> Decoder(CareplanActivityDetail) {
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use quantity <- decode.optional_field(
    "quantity",
    None,
    decode.optional(quantity_decoder()),
  )
  use daily_amount <- decode.optional_field(
    "dailyAmount",
    None,
    decode.optional(quantity_decoder()),
  )
  use product <- decode.then(
    none_if_omitted(careplan_activity_detail_product_decoder()),
  )
  use performer <- decode.optional_field(
    "performer",
    [],
    decode.list(reference_decoder()),
  )
  use location <- decode.optional_field(
    "location",
    None,
    decode.optional(reference_decoder()),
  )
  use scheduled <- decode.then(
    none_if_omitted(careplan_activity_detail_scheduled_decoder()),
  )
  use do_not_perform <- decode.optional_field(
    "doNotPerform",
    None,
    decode.optional(decode.bool),
  )
  use status_reason <- decode.optional_field(
    "statusReason",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use status <- decode.field(
    "status",
    r4bvaluesets.careplanactivitystatus_decoder(),
  )
  use goal <- decode.optional_field(
    "goal",
    [],
    decode.list(reference_decoder()),
  )
  use reason_reference <- decode.optional_field(
    "reasonReference",
    [],
    decode.list(reference_decoder()),
  )
  use reason_code <- decode.optional_field(
    "reasonCode",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use instantiates_uri <- decode.optional_field(
    "instantiatesUri",
    [],
    decode.list(decode.string),
  )
  use instantiates_canonical <- decode.optional_field(
    "instantiatesCanonical",
    [],
    decode.list(decode.string),
  )
  use kind <- decode.optional_field(
    "kind",
    None,
    decode.optional(r4bvaluesets.careplanactivitykind_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CareplanActivityDetail(
    description:,
    quantity:,
    daily_amount:,
    product:,
    performer:,
    location:,
    scheduled:,
    do_not_perform:,
    status_reason:,
    status:,
    goal:,
    reason_reference:,
    reason_code:,
    code:,
    instantiates_uri:,
    instantiates_canonical:,
    kind:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn careplan_activity_to_json(careplan_activity: CareplanActivity) -> Json {
  let CareplanActivity(
    detail:,
    reference:,
    progress:,
    outcome_reference:,
    outcome_codeable_concept:,
    modifier_extension:,
    extension:,
    id:,
  ) = careplan_activity
  let fields = []
  let fields = case detail {
    Some(v) -> [#("detail", careplan_activity_detail_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case reference {
    Some(v) -> [#("reference", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case progress {
    [] -> fields
    _ -> [#("progress", json.array(progress, annotation_to_json)), ..fields]
  }
  let fields = case outcome_reference {
    [] -> fields
    _ -> [
      #("outcomeReference", json.array(outcome_reference, reference_to_json)),
      ..fields
    ]
  }
  let fields = case outcome_codeable_concept {
    [] -> fields
    _ -> [
      #(
        "outcomeCodeableConcept",
        json.array(outcome_codeable_concept, codeableconcept_to_json),
      ),
      ..fields
    ]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn careplan_activity_decoder() -> Decoder(CareplanActivity) {
  use detail <- decode.optional_field(
    "detail",
    None,
    decode.optional(careplan_activity_detail_decoder()),
  )
  use reference <- decode.optional_field(
    "reference",
    None,
    decode.optional(reference_decoder()),
  )
  use progress <- decode.optional_field(
    "progress",
    [],
    decode.list(annotation_decoder()),
  )
  use outcome_reference <- decode.optional_field(
    "outcomeReference",
    [],
    decode.list(reference_decoder()),
  )
  use outcome_codeable_concept <- decode.optional_field(
    "outcomeCodeableConcept",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CareplanActivity(
    detail:,
    reference:,
    progress:,
    outcome_reference:,
    outcome_codeable_concept:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn careplan_to_json(careplan: Careplan) -> Json {
  let Careplan(
    note:,
    activity:,
    goal:,
    supporting_info:,
    addresses:,
    care_team:,
    contributor:,
    author:,
    created:,
    period:,
    encounter:,
    subject:,
    description:,
    title:,
    category:,
    intent:,
    status:,
    part_of:,
    replaces:,
    based_on:,
    instantiates_uri:,
    instantiates_canonical:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = careplan
  let fields = [
    #("subject", reference_to_json(subject)),
    #("intent", r4bvaluesets.careplanintent_to_json(intent)),
    #("status", r4bvaluesets.requeststatus_to_json(status)),
  ]
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case activity {
    [] -> fields
    _ -> [
      #("activity", json.array(activity, careplan_activity_to_json)),
      ..fields
    ]
  }
  let fields = case goal {
    [] -> fields
    _ -> [#("goal", json.array(goal, reference_to_json)), ..fields]
  }
  let fields = case supporting_info {
    [] -> fields
    _ -> [
      #("supportingInfo", json.array(supporting_info, reference_to_json)),
      ..fields
    ]
  }
  let fields = case addresses {
    [] -> fields
    _ -> [#("addresses", json.array(addresses, reference_to_json)), ..fields]
  }
  let fields = case care_team {
    [] -> fields
    _ -> [#("careTeam", json.array(care_team, reference_to_json)), ..fields]
  }
  let fields = case contributor {
    [] -> fields
    _ -> [
      #("contributor", json.array(contributor, reference_to_json)),
      ..fields
    ]
  }
  let fields = case author {
    Some(v) -> [#("author", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case created {
    Some(v) -> [#("created", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case period {
    Some(v) -> [#("period", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case encounter {
    Some(v) -> [#("encounter", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case title {
    Some(v) -> [#("title", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case category {
    [] -> fields
    _ -> [
      #("category", json.array(category, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case part_of {
    [] -> fields
    _ -> [#("partOf", json.array(part_of, reference_to_json)), ..fields]
  }
  let fields = case replaces {
    [] -> fields
    _ -> [#("replaces", json.array(replaces, reference_to_json)), ..fields]
  }
  let fields = case based_on {
    [] -> fields
    _ -> [#("basedOn", json.array(based_on, reference_to_json)), ..fields]
  }
  let fields = case instantiates_uri {
    [] -> fields
    _ -> [
      #("instantiatesUri", json.array(instantiates_uri, json.string)),
      ..fields
    ]
  }
  let fields = case instantiates_canonical {
    [] -> fields
    _ -> [
      #(
        "instantiatesCanonical",
        json.array(instantiates_canonical, json.string),
      ),
      ..fields
    ]
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Careplan")), ..fields]
  json.object(fields)
}

pub fn careplan_decoder() -> Decoder(Careplan) {
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use activity <- decode.optional_field(
    "activity",
    [],
    decode.list(careplan_activity_decoder()),
  )
  use goal <- decode.optional_field(
    "goal",
    [],
    decode.list(reference_decoder()),
  )
  use supporting_info <- decode.optional_field(
    "supportingInfo",
    [],
    decode.list(reference_decoder()),
  )
  use addresses <- decode.optional_field(
    "addresses",
    [],
    decode.list(reference_decoder()),
  )
  use care_team <- decode.optional_field(
    "careTeam",
    [],
    decode.list(reference_decoder()),
  )
  use contributor <- decode.optional_field(
    "contributor",
    [],
    decode.list(reference_decoder()),
  )
  use author <- decode.optional_field(
    "author",
    None,
    decode.optional(reference_decoder()),
  )
  use created <- decode.optional_field(
    "created",
    None,
    decode.optional(decode.string),
  )
  use period <- decode.optional_field(
    "period",
    None,
    decode.optional(period_decoder()),
  )
  use encounter <- decode.optional_field(
    "encounter",
    None,
    decode.optional(reference_decoder()),
  )
  use subject <- decode.field("subject", reference_decoder())
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use title <- decode.optional_field(
    "title",
    None,
    decode.optional(decode.string),
  )
  use category <- decode.optional_field(
    "category",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use intent <- decode.field("intent", r4bvaluesets.careplanintent_decoder())
  use status <- decode.field("status", r4bvaluesets.requeststatus_decoder())
  use part_of <- decode.optional_field(
    "partOf",
    [],
    decode.list(reference_decoder()),
  )
  use replaces <- decode.optional_field(
    "replaces",
    [],
    decode.list(reference_decoder()),
  )
  use based_on <- decode.optional_field(
    "basedOn",
    [],
    decode.list(reference_decoder()),
  )
  use instantiates_uri <- decode.optional_field(
    "instantiatesUri",
    [],
    decode.list(decode.string),
  )
  use instantiates_canonical <- decode.optional_field(
    "instantiatesCanonical",
    [],
    decode.list(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Careplan",
    decode.failure(careplan_new(subject:, intent:, status:), "resourceType"),
  )
  decode.success(Careplan(
    note:,
    activity:,
    goal:,
    supporting_info:,
    addresses:,
    care_team:,
    contributor:,
    author:,
    created:,
    period:,
    encounter:,
    subject:,
    description:,
    title:,
    category:,
    intent:,
    status:,
    part_of:,
    replaces:,
    based_on:,
    instantiates_uri:,
    instantiates_canonical:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/CareTeam#resource
pub type Careteam {
  Careteam(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    status: Option(r4bvaluesets.Careteamstatus),
    category: List(Codeableconcept),
    name: Option(String),
    subject: Option(Reference),
    encounter: Option(Reference),
    period: Option(Period),
    participant: List(CareteamParticipant),
    reason_code: List(Codeableconcept),
    reason_reference: List(Reference),
    managing_organization: List(Reference),
    telecom: List(Contactpoint),
    note: List(Annotation),
  )
}

pub fn careteam_new() -> Careteam {
  Careteam(
    note: [],
    telecom: [],
    managing_organization: [],
    reason_reference: [],
    reason_code: [],
    participant: [],
    period: None,
    encounter: None,
    subject: None,
    name: None,
    category: [],
    status: None,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/CareTeam#resource
pub type CareteamParticipant {
  CareteamParticipant(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    role: List(Codeableconcept),
    member: Option(Reference),
    on_behalf_of: Option(Reference),
    period: Option(Period),
  )
}

pub fn careteam_participant_new() -> CareteamParticipant {
  CareteamParticipant(
    period: None,
    on_behalf_of: None,
    member: None,
    role: [],
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn careteam_participant_to_json(
  careteam_participant: CareteamParticipant,
) -> Json {
  let CareteamParticipant(
    period:,
    on_behalf_of:,
    member:,
    role:,
    modifier_extension:,
    extension:,
    id:,
  ) = careteam_participant
  let fields = []
  let fields = case period {
    Some(v) -> [#("period", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case on_behalf_of {
    Some(v) -> [#("onBehalfOf", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case member {
    Some(v) -> [#("member", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case role {
    [] -> fields
    _ -> [#("role", json.array(role, codeableconcept_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn careteam_participant_decoder() -> Decoder(CareteamParticipant) {
  use period <- decode.optional_field(
    "period",
    None,
    decode.optional(period_decoder()),
  )
  use on_behalf_of <- decode.optional_field(
    "onBehalfOf",
    None,
    decode.optional(reference_decoder()),
  )
  use member <- decode.optional_field(
    "member",
    None,
    decode.optional(reference_decoder()),
  )
  use role <- decode.optional_field(
    "role",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CareteamParticipant(
    period:,
    on_behalf_of:,
    member:,
    role:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn careteam_to_json(careteam: Careteam) -> Json {
  let Careteam(
    note:,
    telecom:,
    managing_organization:,
    reason_reference:,
    reason_code:,
    participant:,
    period:,
    encounter:,
    subject:,
    name:,
    category:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = careteam
  let fields = []
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case telecom {
    [] -> fields
    _ -> [#("telecom", json.array(telecom, contactpoint_to_json)), ..fields]
  }
  let fields = case managing_organization {
    [] -> fields
    _ -> [
      #(
        "managingOrganization",
        json.array(managing_organization, reference_to_json),
      ),
      ..fields
    ]
  }
  let fields = case reason_reference {
    [] -> fields
    _ -> [
      #("reasonReference", json.array(reason_reference, reference_to_json)),
      ..fields
    ]
  }
  let fields = case reason_code {
    [] -> fields
    _ -> [
      #("reasonCode", json.array(reason_code, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case participant {
    [] -> fields
    _ -> [
      #("participant", json.array(participant, careteam_participant_to_json)),
      ..fields
    ]
  }
  let fields = case period {
    Some(v) -> [#("period", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case encounter {
    Some(v) -> [#("encounter", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case subject {
    Some(v) -> [#("subject", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case category {
    [] -> fields
    _ -> [
      #("category", json.array(category, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case status {
    Some(v) -> [#("status", r4bvaluesets.careteamstatus_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Careteam")), ..fields]
  json.object(fields)
}

pub fn careteam_decoder() -> Decoder(Careteam) {
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use telecom <- decode.optional_field(
    "telecom",
    [],
    decode.list(contactpoint_decoder()),
  )
  use managing_organization <- decode.optional_field(
    "managingOrganization",
    [],
    decode.list(reference_decoder()),
  )
  use reason_reference <- decode.optional_field(
    "reasonReference",
    [],
    decode.list(reference_decoder()),
  )
  use reason_code <- decode.optional_field(
    "reasonCode",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use participant <- decode.optional_field(
    "participant",
    [],
    decode.list(careteam_participant_decoder()),
  )
  use period <- decode.optional_field(
    "period",
    None,
    decode.optional(period_decoder()),
  )
  use encounter <- decode.optional_field(
    "encounter",
    None,
    decode.optional(reference_decoder()),
  )
  use subject <- decode.optional_field(
    "subject",
    None,
    decode.optional(reference_decoder()),
  )
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use category <- decode.optional_field(
    "category",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use status <- decode.optional_field(
    "status",
    None,
    decode.optional(r4bvaluesets.careteamstatus_decoder()),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Careteam",
    decode.failure(careteam_new(), "resourceType"),
  )
  decode.success(Careteam(
    note:,
    telecom:,
    managing_organization:,
    reason_reference:,
    reason_code:,
    participant:,
    period:,
    encounter:,
    subject:,
    name:,
    category:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/CatalogEntry#resource
pub type Catalogentry {
  Catalogentry(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    type_: Option(Codeableconcept),
    orderable: Bool,
    referenced_item: Reference,
    additional_identifier: List(Identifier),
    classification: List(Codeableconcept),
    status: Option(r4bvaluesets.Publicationstatus),
    validity_period: Option(Period),
    valid_to: Option(String),
    last_updated: Option(String),
    additional_characteristic: List(Codeableconcept),
    additional_classification: List(Codeableconcept),
    related_entry: List(CatalogentryRelatedentry),
  )
}

pub fn catalogentry_new(
  referenced_item referenced_item: Reference,
  orderable orderable: Bool,
) -> Catalogentry {
  Catalogentry(
    related_entry: [],
    additional_classification: [],
    additional_characteristic: [],
    last_updated: None,
    valid_to: None,
    validity_period: None,
    status: None,
    classification: [],
    additional_identifier: [],
    referenced_item:,
    orderable:,
    type_: None,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/CatalogEntry#resource
pub type CatalogentryRelatedentry {
  CatalogentryRelatedentry(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    relationtype: r4bvaluesets.Relationtype,
    item: Reference,
  )
}

pub fn catalogentry_relatedentry_new(
  item item: Reference,
  relationtype relationtype: r4bvaluesets.Relationtype,
) -> CatalogentryRelatedentry {
  CatalogentryRelatedentry(
    item:,
    relationtype:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn catalogentry_relatedentry_to_json(
  catalogentry_relatedentry: CatalogentryRelatedentry,
) -> Json {
  let CatalogentryRelatedentry(
    item:,
    relationtype:,
    modifier_extension:,
    extension:,
    id:,
  ) = catalogentry_relatedentry
  let fields = [
    #("item", reference_to_json(item)),
    #("relationtype", r4bvaluesets.relationtype_to_json(relationtype)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn catalogentry_relatedentry_decoder() -> Decoder(CatalogentryRelatedentry) {
  use item <- decode.field("item", reference_decoder())
  use relationtype <- decode.field(
    "relationtype",
    r4bvaluesets.relationtype_decoder(),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CatalogentryRelatedentry(
    item:,
    relationtype:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn catalogentry_to_json(catalogentry: Catalogentry) -> Json {
  let Catalogentry(
    related_entry:,
    additional_classification:,
    additional_characteristic:,
    last_updated:,
    valid_to:,
    validity_period:,
    status:,
    classification:,
    additional_identifier:,
    referenced_item:,
    orderable:,
    type_:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = catalogentry
  let fields = [
    #("referencedItem", reference_to_json(referenced_item)),
    #("orderable", json.bool(orderable)),
  ]
  let fields = case related_entry {
    [] -> fields
    _ -> [
      #(
        "relatedEntry",
        json.array(related_entry, catalogentry_relatedentry_to_json),
      ),
      ..fields
    ]
  }
  let fields = case additional_classification {
    [] -> fields
    _ -> [
      #(
        "additionalClassification",
        json.array(additional_classification, codeableconcept_to_json),
      ),
      ..fields
    ]
  }
  let fields = case additional_characteristic {
    [] -> fields
    _ -> [
      #(
        "additionalCharacteristic",
        json.array(additional_characteristic, codeableconcept_to_json),
      ),
      ..fields
    ]
  }
  let fields = case last_updated {
    Some(v) -> [#("lastUpdated", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case valid_to {
    Some(v) -> [#("validTo", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case validity_period {
    Some(v) -> [#("validityPeriod", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case status {
    Some(v) -> [
      #("status", r4bvaluesets.publicationstatus_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case classification {
    [] -> fields
    _ -> [
      #("classification", json.array(classification, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case additional_identifier {
    [] -> fields
    _ -> [
      #(
        "additionalIdentifier",
        json.array(additional_identifier, identifier_to_json),
      ),
      ..fields
    ]
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Catalogentry")), ..fields]
  json.object(fields)
}

pub fn catalogentry_decoder() -> Decoder(Catalogentry) {
  use related_entry <- decode.optional_field(
    "relatedEntry",
    [],
    decode.list(catalogentry_relatedentry_decoder()),
  )
  use additional_classification <- decode.optional_field(
    "additionalClassification",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use additional_characteristic <- decode.optional_field(
    "additionalCharacteristic",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use last_updated <- decode.optional_field(
    "lastUpdated",
    None,
    decode.optional(decode.string),
  )
  use valid_to <- decode.optional_field(
    "validTo",
    None,
    decode.optional(decode.string),
  )
  use validity_period <- decode.optional_field(
    "validityPeriod",
    None,
    decode.optional(period_decoder()),
  )
  use status <- decode.optional_field(
    "status",
    None,
    decode.optional(r4bvaluesets.publicationstatus_decoder()),
  )
  use classification <- decode.optional_field(
    "classification",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use additional_identifier <- decode.optional_field(
    "additionalIdentifier",
    [],
    decode.list(identifier_decoder()),
  )
  use referenced_item <- decode.field("referencedItem", reference_decoder())
  use orderable <- decode.field("orderable", decode.bool)
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Catalogentry",
    decode.failure(
      catalogentry_new(referenced_item:, orderable:),
      "resourceType",
    ),
  )
  decode.success(Catalogentry(
    related_entry:,
    additional_classification:,
    additional_characteristic:,
    last_updated:,
    valid_to:,
    validity_period:,
    status:,
    classification:,
    additional_identifier:,
    referenced_item:,
    orderable:,
    type_:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/ChargeItem#resource
pub type Chargeitem {
  Chargeitem(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    definition_uri: List(String),
    definition_canonical: List(String),
    status: r4bvaluesets.Chargeitemstatus,
    part_of: List(Reference),
    code: Codeableconcept,
    subject: Reference,
    context: Option(Reference),
    occurrence: Option(ChargeitemOccurrence),
    performer: List(ChargeitemPerformer),
    performing_organization: Option(Reference),
    requesting_organization: Option(Reference),
    cost_center: Option(Reference),
    quantity: Option(Quantity),
    bodysite: List(Codeableconcept),
    factor_override: Option(Float),
    price_override: Option(Money),
    override_reason: Option(String),
    enterer: Option(Reference),
    entered_date: Option(String),
    reason: List(Codeableconcept),
    service: List(Reference),
    product: Option(ChargeitemProduct),
    account: List(Reference),
    note: List(Annotation),
    supporting_information: List(Reference),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ChargeItem#resource
pub type ChargeitemOccurrence {
  ChargeitemOccurrenceDatetime(occurrence: String)
  ChargeitemOccurrencePeriod(occurrence: Period)
  ChargeitemOccurrenceTiming(occurrence: Timing)
}

pub fn chargeitem_occurrence_to_json(elt: ChargeitemOccurrence) -> Json {
  case elt {
    ChargeitemOccurrenceDatetime(v) -> json.string(v)
    ChargeitemOccurrencePeriod(v) -> period_to_json(v)
    ChargeitemOccurrenceTiming(v) -> timing_to_json(v)
  }
}

pub fn chargeitem_occurrence_decoder() -> Decoder(ChargeitemOccurrence) {
  decode.one_of(
    decode.field("occurrenceDateTime", decode.string, decode.success)
      |> decode.map(ChargeitemOccurrenceDatetime),
    [
      decode.field("occurrencePeriod", period_decoder(), decode.success)
        |> decode.map(ChargeitemOccurrencePeriod),
      decode.field("occurrenceTiming", timing_decoder(), decode.success)
        |> decode.map(ChargeitemOccurrenceTiming),
    ],
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ChargeItem#resource
pub type ChargeitemProduct {
  ChargeitemProductReference(product: Reference)
  ChargeitemProductCodeableconcept(product: Codeableconcept)
}

pub fn chargeitem_product_to_json(elt: ChargeitemProduct) -> Json {
  case elt {
    ChargeitemProductReference(v) -> reference_to_json(v)
    ChargeitemProductCodeableconcept(v) -> codeableconcept_to_json(v)
  }
}

pub fn chargeitem_product_decoder() -> Decoder(ChargeitemProduct) {
  decode.one_of(
    decode.field("productReference", reference_decoder(), decode.success)
      |> decode.map(ChargeitemProductReference),
    [
      decode.field(
        "productCodeableConcept",
        codeableconcept_decoder(),
        decode.success,
      )
      |> decode.map(ChargeitemProductCodeableconcept),
    ],
  )
}

pub fn chargeitem_new(
  subject subject: Reference,
  code code: Codeableconcept,
  status status: r4bvaluesets.Chargeitemstatus,
) -> Chargeitem {
  Chargeitem(
    supporting_information: [],
    note: [],
    account: [],
    product: None,
    service: [],
    reason: [],
    entered_date: None,
    enterer: None,
    override_reason: None,
    price_override: None,
    factor_override: None,
    bodysite: [],
    quantity: None,
    cost_center: None,
    requesting_organization: None,
    performing_organization: None,
    performer: [],
    occurrence: None,
    context: None,
    subject:,
    code:,
    part_of: [],
    status:,
    definition_canonical: [],
    definition_uri: [],
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ChargeItem#resource
pub type ChargeitemPerformer {
  ChargeitemPerformer(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    function: Option(Codeableconcept),
    actor: Reference,
  )
}

pub fn chargeitem_performer_new(actor actor: Reference) -> ChargeitemPerformer {
  ChargeitemPerformer(
    actor:,
    function: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn chargeitem_performer_to_json(
  chargeitem_performer: ChargeitemPerformer,
) -> Json {
  let ChargeitemPerformer(
    actor:,
    function:,
    modifier_extension:,
    extension:,
    id:,
  ) = chargeitem_performer
  let fields = [
    #("actor", reference_to_json(actor)),
  ]
  let fields = case function {
    Some(v) -> [#("function", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn chargeitem_performer_decoder() -> Decoder(ChargeitemPerformer) {
  use actor <- decode.field("actor", reference_decoder())
  use function <- decode.optional_field(
    "function",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ChargeitemPerformer(
    actor:,
    function:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn chargeitem_to_json(chargeitem: Chargeitem) -> Json {
  let Chargeitem(
    supporting_information:,
    note:,
    account:,
    product:,
    service:,
    reason:,
    entered_date:,
    enterer:,
    override_reason:,
    price_override:,
    factor_override:,
    bodysite:,
    quantity:,
    cost_center:,
    requesting_organization:,
    performing_organization:,
    performer:,
    occurrence:,
    context:,
    subject:,
    code:,
    part_of:,
    status:,
    definition_canonical:,
    definition_uri:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = chargeitem
  let fields = [
    #("subject", reference_to_json(subject)),
    #("code", codeableconcept_to_json(code)),
    #("status", r4bvaluesets.chargeitemstatus_to_json(status)),
  ]
  let fields = case supporting_information {
    [] -> fields
    _ -> [
      #(
        "supportingInformation",
        json.array(supporting_information, reference_to_json),
      ),
      ..fields
    ]
  }
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case account {
    [] -> fields
    _ -> [#("account", json.array(account, reference_to_json)), ..fields]
  }
  let fields = case product {
    Some(v) -> [
      #(
        "product"
          <> case v {
          ChargeitemProductReference(_) -> "Reference"
          ChargeitemProductCodeableconcept(_) -> "Codeableconcept"
        },
        chargeitem_product_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case service {
    [] -> fields
    _ -> [#("service", json.array(service, reference_to_json)), ..fields]
  }
  let fields = case reason {
    [] -> fields
    _ -> [#("reason", json.array(reason, codeableconcept_to_json)), ..fields]
  }
  let fields = case entered_date {
    Some(v) -> [#("enteredDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case enterer {
    Some(v) -> [#("enterer", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case override_reason {
    Some(v) -> [#("overrideReason", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case price_override {
    Some(v) -> [#("priceOverride", money_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case factor_override {
    Some(v) -> [#("factorOverride", json.float(v)), ..fields]
    None -> fields
  }
  let fields = case bodysite {
    [] -> fields
    _ -> [
      #("bodysite", json.array(bodysite, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case quantity {
    Some(v) -> [#("quantity", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case cost_center {
    Some(v) -> [#("costCenter", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case requesting_organization {
    Some(v) -> [#("requestingOrganization", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case performing_organization {
    Some(v) -> [#("performingOrganization", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case performer {
    [] -> fields
    _ -> [
      #("performer", json.array(performer, chargeitem_performer_to_json)),
      ..fields
    ]
  }
  let fields = case occurrence {
    Some(v) -> [
      #(
        "occurrence"
          <> case v {
          ChargeitemOccurrenceDatetime(_) -> "Datetime"
          ChargeitemOccurrencePeriod(_) -> "Period"
          ChargeitemOccurrenceTiming(_) -> "Timing"
        },
        chargeitem_occurrence_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case context {
    Some(v) -> [#("context", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case part_of {
    [] -> fields
    _ -> [#("partOf", json.array(part_of, reference_to_json)), ..fields]
  }
  let fields = case definition_canonical {
    [] -> fields
    _ -> [
      #("definitionCanonical", json.array(definition_canonical, json.string)),
      ..fields
    ]
  }
  let fields = case definition_uri {
    [] -> fields
    _ -> [#("definitionUri", json.array(definition_uri, json.string)), ..fields]
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Chargeitem")), ..fields]
  json.object(fields)
}

pub fn chargeitem_decoder() -> Decoder(Chargeitem) {
  use supporting_information <- decode.optional_field(
    "supportingInformation",
    [],
    decode.list(reference_decoder()),
  )
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use account <- decode.optional_field(
    "account",
    [],
    decode.list(reference_decoder()),
  )
  use product <- decode.then(none_if_omitted(chargeitem_product_decoder()))
  use service <- decode.optional_field(
    "service",
    [],
    decode.list(reference_decoder()),
  )
  use reason <- decode.optional_field(
    "reason",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use entered_date <- decode.optional_field(
    "enteredDate",
    None,
    decode.optional(decode.string),
  )
  use enterer <- decode.optional_field(
    "enterer",
    None,
    decode.optional(reference_decoder()),
  )
  use override_reason <- decode.optional_field(
    "overrideReason",
    None,
    decode.optional(decode.string),
  )
  use price_override <- decode.optional_field(
    "priceOverride",
    None,
    decode.optional(money_decoder()),
  )
  use factor_override <- decode.optional_field(
    "factorOverride",
    None,
    decode.optional(decode.float),
  )
  use bodysite <- decode.optional_field(
    "bodysite",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use quantity <- decode.optional_field(
    "quantity",
    None,
    decode.optional(quantity_decoder()),
  )
  use cost_center <- decode.optional_field(
    "costCenter",
    None,
    decode.optional(reference_decoder()),
  )
  use requesting_organization <- decode.optional_field(
    "requestingOrganization",
    None,
    decode.optional(reference_decoder()),
  )
  use performing_organization <- decode.optional_field(
    "performingOrganization",
    None,
    decode.optional(reference_decoder()),
  )
  use performer <- decode.optional_field(
    "performer",
    [],
    decode.list(chargeitem_performer_decoder()),
  )
  use occurrence <- decode.then(
    none_if_omitted(chargeitem_occurrence_decoder()),
  )
  use context <- decode.optional_field(
    "context",
    None,
    decode.optional(reference_decoder()),
  )
  use subject <- decode.field("subject", reference_decoder())
  use code <- decode.field("code", codeableconcept_decoder())
  use part_of <- decode.optional_field(
    "partOf",
    [],
    decode.list(reference_decoder()),
  )
  use status <- decode.field("status", r4bvaluesets.chargeitemstatus_decoder())
  use definition_canonical <- decode.optional_field(
    "definitionCanonical",
    [],
    decode.list(decode.string),
  )
  use definition_uri <- decode.optional_field(
    "definitionUri",
    [],
    decode.list(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Chargeitem",
    decode.failure(chargeitem_new(subject:, code:, status:), "resourceType"),
  )
  decode.success(Chargeitem(
    supporting_information:,
    note:,
    account:,
    product:,
    service:,
    reason:,
    entered_date:,
    enterer:,
    override_reason:,
    price_override:,
    factor_override:,
    bodysite:,
    quantity:,
    cost_center:,
    requesting_organization:,
    performing_organization:,
    performer:,
    occurrence:,
    context:,
    subject:,
    code:,
    part_of:,
    status:,
    definition_canonical:,
    definition_uri:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/ChargeItemDefinition#resource
pub type Chargeitemdefinition {
  Chargeitemdefinition(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    url: String,
    identifier: List(Identifier),
    version: Option(String),
    title: Option(String),
    derived_from_uri: List(String),
    part_of: List(String),
    replaces: List(String),
    status: r4bvaluesets.Publicationstatus,
    experimental: Option(Bool),
    date: Option(String),
    publisher: Option(String),
    contact: List(Contactdetail),
    description: Option(String),
    use_context: List(Usagecontext),
    jurisdiction: List(Codeableconcept),
    copyright: Option(String),
    approval_date: Option(String),
    last_review_date: Option(String),
    effective_period: Option(Period),
    code: Option(Codeableconcept),
    instance: List(Reference),
    applicability: List(ChargeitemdefinitionApplicability),
    property_group: List(ChargeitemdefinitionPropertygroup),
  )
}

pub fn chargeitemdefinition_new(
  status status: r4bvaluesets.Publicationstatus,
  url url: String,
) -> Chargeitemdefinition {
  Chargeitemdefinition(
    property_group: [],
    applicability: [],
    instance: [],
    code: None,
    effective_period: None,
    last_review_date: None,
    approval_date: None,
    copyright: None,
    jurisdiction: [],
    use_context: [],
    description: None,
    contact: [],
    publisher: None,
    date: None,
    experimental: None,
    status:,
    replaces: [],
    part_of: [],
    derived_from_uri: [],
    title: None,
    version: None,
    identifier: [],
    url:,
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ChargeItemDefinition#resource
pub type ChargeitemdefinitionApplicability {
  ChargeitemdefinitionApplicability(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    description: Option(String),
    language: Option(String),
    expression: Option(String),
  )
}

pub fn chargeitemdefinition_applicability_new() -> ChargeitemdefinitionApplicability {
  ChargeitemdefinitionApplicability(
    expression: None,
    language: None,
    description: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ChargeItemDefinition#resource
pub type ChargeitemdefinitionPropertygroup {
  ChargeitemdefinitionPropertygroup(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    price_component: List(ChargeitemdefinitionPropertygroupPricecomponent),
  )
}

pub fn chargeitemdefinition_propertygroup_new() -> ChargeitemdefinitionPropertygroup {
  ChargeitemdefinitionPropertygroup(
    price_component: [],
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ChargeItemDefinition#resource
pub type ChargeitemdefinitionPropertygroupPricecomponent {
  ChargeitemdefinitionPropertygroupPricecomponent(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: r4bvaluesets.Invoicepricecomponenttype,
    code: Option(Codeableconcept),
    factor: Option(Float),
    amount: Option(Money),
  )
}

pub fn chargeitemdefinition_propertygroup_pricecomponent_new(
  type_ type_: r4bvaluesets.Invoicepricecomponenttype,
) -> ChargeitemdefinitionPropertygroupPricecomponent {
  ChargeitemdefinitionPropertygroupPricecomponent(
    amount: None,
    factor: None,
    code: None,
    type_:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn chargeitemdefinition_propertygroup_pricecomponent_to_json(
  chargeitemdefinition_propertygroup_pricecomponent: ChargeitemdefinitionPropertygroupPricecomponent,
) -> Json {
  let ChargeitemdefinitionPropertygroupPricecomponent(
    amount:,
    factor:,
    code:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = chargeitemdefinition_propertygroup_pricecomponent
  let fields = [
    #("type", r4bvaluesets.invoicepricecomponenttype_to_json(type_)),
  ]
  let fields = case amount {
    Some(v) -> [#("amount", money_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case factor {
    Some(v) -> [#("factor", json.float(v)), ..fields]
    None -> fields
  }
  let fields = case code {
    Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn chargeitemdefinition_propertygroup_pricecomponent_decoder() -> Decoder(
  ChargeitemdefinitionPropertygroupPricecomponent,
) {
  use amount <- decode.optional_field(
    "amount",
    None,
    decode.optional(money_decoder()),
  )
  use factor <- decode.optional_field(
    "factor",
    None,
    decode.optional(decode.float),
  )
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use type_ <- decode.field(
    "type",
    r4bvaluesets.invoicepricecomponenttype_decoder(),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ChargeitemdefinitionPropertygroupPricecomponent(
    amount:,
    factor:,
    code:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn chargeitemdefinition_propertygroup_to_json(
  chargeitemdefinition_propertygroup: ChargeitemdefinitionPropertygroup,
) -> Json {
  let ChargeitemdefinitionPropertygroup(
    price_component:,
    modifier_extension:,
    extension:,
    id:,
  ) = chargeitemdefinition_propertygroup
  let fields = []
  let fields = case price_component {
    [] -> fields
    _ -> [
      #(
        "priceComponent",
        json.array(
          price_component,
          chargeitemdefinition_propertygroup_pricecomponent_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn chargeitemdefinition_propertygroup_decoder() -> Decoder(
  ChargeitemdefinitionPropertygroup,
) {
  use price_component <- decode.optional_field(
    "priceComponent",
    [],
    decode.list(chargeitemdefinition_propertygroup_pricecomponent_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ChargeitemdefinitionPropertygroup(
    price_component:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn chargeitemdefinition_applicability_to_json(
  chargeitemdefinition_applicability: ChargeitemdefinitionApplicability,
) -> Json {
  let ChargeitemdefinitionApplicability(
    expression:,
    language:,
    description:,
    modifier_extension:,
    extension:,
    id:,
  ) = chargeitemdefinition_applicability
  let fields = []
  let fields = case expression {
    Some(v) -> [#("expression", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn chargeitemdefinition_applicability_decoder() -> Decoder(
  ChargeitemdefinitionApplicability,
) {
  use expression <- decode.optional_field(
    "expression",
    None,
    decode.optional(decode.string),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ChargeitemdefinitionApplicability(
    expression:,
    language:,
    description:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn chargeitemdefinition_to_json(
  chargeitemdefinition: Chargeitemdefinition,
) -> Json {
  let Chargeitemdefinition(
    property_group:,
    applicability:,
    instance:,
    code:,
    effective_period:,
    last_review_date:,
    approval_date:,
    copyright:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    experimental:,
    status:,
    replaces:,
    part_of:,
    derived_from_uri:,
    title:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = chargeitemdefinition
  let fields = [
    #("status", r4bvaluesets.publicationstatus_to_json(status)),
    #("url", json.string(url)),
  ]
  let fields = case property_group {
    [] -> fields
    _ -> [
      #(
        "propertyGroup",
        json.array(property_group, chargeitemdefinition_propertygroup_to_json),
      ),
      ..fields
    ]
  }
  let fields = case applicability {
    [] -> fields
    _ -> [
      #(
        "applicability",
        json.array(applicability, chargeitemdefinition_applicability_to_json),
      ),
      ..fields
    ]
  }
  let fields = case instance {
    [] -> fields
    _ -> [#("instance", json.array(instance, reference_to_json)), ..fields]
  }
  let fields = case code {
    Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case effective_period {
    Some(v) -> [#("effectivePeriod", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case last_review_date {
    Some(v) -> [#("lastReviewDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case approval_date {
    Some(v) -> [#("approvalDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case copyright {
    Some(v) -> [#("copyright", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case jurisdiction {
    [] -> fields
    _ -> [
      #("jurisdiction", json.array(jurisdiction, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case use_context {
    [] -> fields
    _ -> [
      #("useContext", json.array(use_context, usagecontext_to_json)),
      ..fields
    ]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case contact {
    [] -> fields
    _ -> [#("contact", json.array(contact, contactdetail_to_json)), ..fields]
  }
  let fields = case publisher {
    Some(v) -> [#("publisher", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case date {
    Some(v) -> [#("date", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case experimental {
    Some(v) -> [#("experimental", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case replaces {
    [] -> fields
    _ -> [#("replaces", json.array(replaces, json.string)), ..fields]
  }
  let fields = case part_of {
    [] -> fields
    _ -> [#("partOf", json.array(part_of, json.string)), ..fields]
  }
  let fields = case derived_from_uri {
    [] -> fields
    _ -> [
      #("derivedFromUri", json.array(derived_from_uri, json.string)),
      ..fields
    ]
  }
  let fields = case title {
    Some(v) -> [#("title", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case version {
    Some(v) -> [#("version", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [
    #("resourceType", json.string("Chargeitemdefinition")),
    ..fields
  ]
  json.object(fields)
}

pub fn chargeitemdefinition_decoder() -> Decoder(Chargeitemdefinition) {
  use property_group <- decode.optional_field(
    "propertyGroup",
    [],
    decode.list(chargeitemdefinition_propertygroup_decoder()),
  )
  use applicability <- decode.optional_field(
    "applicability",
    [],
    decode.list(chargeitemdefinition_applicability_decoder()),
  )
  use instance <- decode.optional_field(
    "instance",
    [],
    decode.list(reference_decoder()),
  )
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use effective_period <- decode.optional_field(
    "effectivePeriod",
    None,
    decode.optional(period_decoder()),
  )
  use last_review_date <- decode.optional_field(
    "lastReviewDate",
    None,
    decode.optional(decode.string),
  )
  use approval_date <- decode.optional_field(
    "approvalDate",
    None,
    decode.optional(decode.string),
  )
  use copyright <- decode.optional_field(
    "copyright",
    None,
    decode.optional(decode.string),
  )
  use jurisdiction <- decode.optional_field(
    "jurisdiction",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use use_context <- decode.optional_field(
    "useContext",
    [],
    decode.list(usagecontext_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use contact <- decode.optional_field(
    "contact",
    [],
    decode.list(contactdetail_decoder()),
  )
  use publisher <- decode.optional_field(
    "publisher",
    None,
    decode.optional(decode.string),
  )
  use date <- decode.optional_field(
    "date",
    None,
    decode.optional(decode.string),
  )
  use experimental <- decode.optional_field(
    "experimental",
    None,
    decode.optional(decode.bool),
  )
  use status <- decode.field("status", r4bvaluesets.publicationstatus_decoder())
  use replaces <- decode.optional_field(
    "replaces",
    [],
    decode.list(decode.string),
  )
  use part_of <- decode.optional_field("partOf", [], decode.list(decode.string))
  use derived_from_uri <- decode.optional_field(
    "derivedFromUri",
    [],
    decode.list(decode.string),
  )
  use title <- decode.optional_field(
    "title",
    None,
    decode.optional(decode.string),
  )
  use version <- decode.optional_field(
    "version",
    None,
    decode.optional(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use url <- decode.field("url", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Chargeitemdefinition",
    decode.failure(chargeitemdefinition_new(status:, url:), "resourceType"),
  )
  decode.success(Chargeitemdefinition(
    property_group:,
    applicability:,
    instance:,
    code:,
    effective_period:,
    last_review_date:,
    approval_date:,
    copyright:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    experimental:,
    status:,
    replaces:,
    part_of:,
    derived_from_uri:,
    title:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/Citation#resource
pub type Citation {
  Citation(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    url: Option(String),
    identifier: List(Identifier),
    version: Option(String),
    name: Option(String),
    title: Option(String),
    status: r4bvaluesets.Publicationstatus,
    experimental: Option(Bool),
    date: Option(String),
    publisher: Option(String),
    contact: List(Contactdetail),
    description: Option(String),
    use_context: List(Usagecontext),
    jurisdiction: List(Codeableconcept),
    purpose: Option(String),
    copyright: Option(String),
    approval_date: Option(String),
    last_review_date: Option(String),
    effective_period: Option(Period),
    author: List(Contactdetail),
    editor: List(Contactdetail),
    reviewer: List(Contactdetail),
    endorser: List(Contactdetail),
    summary: List(CitationSummary),
    classification: List(CitationClassification),
    note: List(Annotation),
    current_state: List(Codeableconcept),
    status_date: List(CitationStatusdate),
    relates_to: List(CitationRelatesto),
    cited_artifact: Option(CitationCitedartifact),
  )
}

pub fn citation_new(status status: r4bvaluesets.Publicationstatus) -> Citation {
  Citation(
    cited_artifact: None,
    relates_to: [],
    status_date: [],
    current_state: [],
    note: [],
    classification: [],
    summary: [],
    endorser: [],
    reviewer: [],
    editor: [],
    author: [],
    effective_period: None,
    last_review_date: None,
    approval_date: None,
    copyright: None,
    purpose: None,
    jurisdiction: [],
    use_context: [],
    description: None,
    contact: [],
    publisher: None,
    date: None,
    experimental: None,
    status:,
    title: None,
    name: None,
    version: None,
    identifier: [],
    url: None,
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Citation#resource
pub type CitationSummary {
  CitationSummary(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    style: Option(Codeableconcept),
    text: String,
  )
}

pub fn citation_summary_new(text text: String) -> CitationSummary {
  CitationSummary(
    text:,
    style: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Citation#resource
pub type CitationClassification {
  CitationClassification(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Option(Codeableconcept),
    classifier: List(Codeableconcept),
  )
}

pub fn citation_classification_new() -> CitationClassification {
  CitationClassification(
    classifier: [],
    type_: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Citation#resource
pub type CitationStatusdate {
  CitationStatusdate(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    activity: Codeableconcept,
    actual: Option(Bool),
    period: Period,
  )
}

pub fn citation_statusdate_new(
  period period: Period,
  activity activity: Codeableconcept,
) -> CitationStatusdate {
  CitationStatusdate(
    period:,
    actual: None,
    activity:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Citation#resource
pub type CitationRelatesto {
  CitationRelatesto(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    relationship_type: Codeableconcept,
    target_classifier: List(Codeableconcept),
    target: CitationRelatestoTarget,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Citation#resource
pub type CitationRelatestoTarget {
  CitationRelatestoTargetUri(target: String)
  CitationRelatestoTargetIdentifier(target: Identifier)
  CitationRelatestoTargetReference(target: Reference)
  CitationRelatestoTargetAttachment(target: Attachment)
}

pub fn citation_relatesto_target_to_json(elt: CitationRelatestoTarget) -> Json {
  case elt {
    CitationRelatestoTargetUri(v) -> json.string(v)
    CitationRelatestoTargetIdentifier(v) -> identifier_to_json(v)
    CitationRelatestoTargetReference(v) -> reference_to_json(v)
    CitationRelatestoTargetAttachment(v) -> attachment_to_json(v)
  }
}

pub fn citation_relatesto_target_decoder() -> Decoder(CitationRelatestoTarget) {
  decode.one_of(
    decode.field("targetUri", decode.string, decode.success)
      |> decode.map(CitationRelatestoTargetUri),
    [
      decode.field("targetIdentifier", identifier_decoder(), decode.success)
        |> decode.map(CitationRelatestoTargetIdentifier),
      decode.field("targetReference", reference_decoder(), decode.success)
        |> decode.map(CitationRelatestoTargetReference),
      decode.field("targetAttachment", attachment_decoder(), decode.success)
        |> decode.map(CitationRelatestoTargetAttachment),
    ],
  )
}

pub fn citation_relatesto_new(
  target target: CitationRelatestoTarget,
  relationship_type relationship_type: Codeableconcept,
) -> CitationRelatesto {
  CitationRelatesto(
    target:,
    target_classifier: [],
    relationship_type:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Citation#resource
pub type CitationCitedartifact {
  CitationCitedartifact(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    related_identifier: List(Identifier),
    date_accessed: Option(String),
    version: Option(CitationCitedartifactVersion),
    current_state: List(Codeableconcept),
    status_date: List(CitationCitedartifactStatusdate),
    title: List(CitationCitedartifactTitle),
    abstract: List(CitationCitedartifactAbstract),
    part: Option(CitationCitedartifactPart),
    relates_to: List(CitationCitedartifactRelatesto),
    publication_form: List(CitationCitedartifactPublicationform),
    web_location: List(CitationCitedartifactWeblocation),
    classification: List(CitationCitedartifactClassification),
    contributorship: Option(CitationCitedartifactContributorship),
    note: List(Annotation),
  )
}

pub fn citation_citedartifact_new() -> CitationCitedartifact {
  CitationCitedartifact(
    note: [],
    contributorship: None,
    classification: [],
    web_location: [],
    publication_form: [],
    relates_to: [],
    part: None,
    abstract: [],
    title: [],
    status_date: [],
    current_state: [],
    version: None,
    date_accessed: None,
    related_identifier: [],
    identifier: [],
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Citation#resource
pub type CitationCitedartifactVersion {
  CitationCitedartifactVersion(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    value: String,
    base_citation: Option(Reference),
  )
}

pub fn citation_citedartifact_version_new(
  value value: String,
) -> CitationCitedartifactVersion {
  CitationCitedartifactVersion(
    base_citation: None,
    value:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Citation#resource
pub type CitationCitedartifactStatusdate {
  CitationCitedartifactStatusdate(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    activity: Codeableconcept,
    actual: Option(Bool),
    period: Period,
  )
}

pub fn citation_citedartifact_statusdate_new(
  period period: Period,
  activity activity: Codeableconcept,
) -> CitationCitedartifactStatusdate {
  CitationCitedartifactStatusdate(
    period:,
    actual: None,
    activity:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Citation#resource
pub type CitationCitedartifactTitle {
  CitationCitedartifactTitle(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: List(Codeableconcept),
    language: Option(Codeableconcept),
    text: String,
  )
}

pub fn citation_citedartifact_title_new(
  text text: String,
) -> CitationCitedartifactTitle {
  CitationCitedartifactTitle(
    text:,
    language: None,
    type_: [],
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Citation#resource
pub type CitationCitedartifactAbstract {
  CitationCitedartifactAbstract(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Option(Codeableconcept),
    language: Option(Codeableconcept),
    text: String,
    copyright: Option(String),
  )
}

pub fn citation_citedartifact_abstract_new(
  text text: String,
) -> CitationCitedartifactAbstract {
  CitationCitedartifactAbstract(
    copyright: None,
    text:,
    language: None,
    type_: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Citation#resource
pub type CitationCitedartifactPart {
  CitationCitedartifactPart(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Option(Codeableconcept),
    value: Option(String),
    base_citation: Option(Reference),
  )
}

pub fn citation_citedartifact_part_new() -> CitationCitedartifactPart {
  CitationCitedartifactPart(
    base_citation: None,
    value: None,
    type_: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Citation#resource
pub type CitationCitedartifactRelatesto {
  CitationCitedartifactRelatesto(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    relationship_type: Codeableconcept,
    target_classifier: List(Codeableconcept),
    target: CitationCitedartifactRelatestoTarget,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Citation#resource
pub type CitationCitedartifactRelatestoTarget {
  CitationCitedartifactRelatestoTargetUri(target: String)
  CitationCitedartifactRelatestoTargetIdentifier(target: Identifier)
  CitationCitedartifactRelatestoTargetReference(target: Reference)
  CitationCitedartifactRelatestoTargetAttachment(target: Attachment)
}

pub fn citation_citedartifact_relatesto_target_to_json(
  elt: CitationCitedartifactRelatestoTarget,
) -> Json {
  case elt {
    CitationCitedartifactRelatestoTargetUri(v) -> json.string(v)
    CitationCitedartifactRelatestoTargetIdentifier(v) -> identifier_to_json(v)
    CitationCitedartifactRelatestoTargetReference(v) -> reference_to_json(v)
    CitationCitedartifactRelatestoTargetAttachment(v) -> attachment_to_json(v)
  }
}

pub fn citation_citedartifact_relatesto_target_decoder() -> Decoder(
  CitationCitedartifactRelatestoTarget,
) {
  decode.one_of(
    decode.field("targetUri", decode.string, decode.success)
      |> decode.map(CitationCitedartifactRelatestoTargetUri),
    [
      decode.field("targetIdentifier", identifier_decoder(), decode.success)
        |> decode.map(CitationCitedartifactRelatestoTargetIdentifier),
      decode.field("targetReference", reference_decoder(), decode.success)
        |> decode.map(CitationCitedartifactRelatestoTargetReference),
      decode.field("targetAttachment", attachment_decoder(), decode.success)
        |> decode.map(CitationCitedartifactRelatestoTargetAttachment),
    ],
  )
}

pub fn citation_citedartifact_relatesto_new(
  target target: CitationCitedartifactRelatestoTarget,
  relationship_type relationship_type: Codeableconcept,
) -> CitationCitedartifactRelatesto {
  CitationCitedartifactRelatesto(
    target:,
    target_classifier: [],
    relationship_type:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Citation#resource
pub type CitationCitedartifactPublicationform {
  CitationCitedartifactPublicationform(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    published_in: Option(CitationCitedartifactPublicationformPublishedin),
    periodic_release: Option(
      CitationCitedartifactPublicationformPeriodicrelease,
    ),
    article_date: Option(String),
    last_revision_date: Option(String),
    language: List(Codeableconcept),
    accession_number: Option(String),
    page_string: Option(String),
    first_page: Option(String),
    last_page: Option(String),
    page_count: Option(String),
    copyright: Option(String),
  )
}

pub fn citation_citedartifact_publicationform_new() -> CitationCitedartifactPublicationform {
  CitationCitedartifactPublicationform(
    copyright: None,
    page_count: None,
    last_page: None,
    first_page: None,
    page_string: None,
    accession_number: None,
    language: [],
    last_revision_date: None,
    article_date: None,
    periodic_release: None,
    published_in: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Citation#resource
pub type CitationCitedartifactPublicationformPublishedin {
  CitationCitedartifactPublicationformPublishedin(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Option(Codeableconcept),
    identifier: List(Identifier),
    title: Option(String),
    publisher: Option(Reference),
    publisher_location: Option(String),
  )
}

pub fn citation_citedartifact_publicationform_publishedin_new() -> CitationCitedartifactPublicationformPublishedin {
  CitationCitedartifactPublicationformPublishedin(
    publisher_location: None,
    publisher: None,
    title: None,
    identifier: [],
    type_: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Citation#resource
pub type CitationCitedartifactPublicationformPeriodicrelease {
  CitationCitedartifactPublicationformPeriodicrelease(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    cited_medium: Option(Codeableconcept),
    volume: Option(String),
    issue: Option(String),
    date_of_publication: Option(
      CitationCitedartifactPublicationformPeriodicreleaseDateofpublication,
    ),
  )
}

pub fn citation_citedartifact_publicationform_periodicrelease_new() -> CitationCitedartifactPublicationformPeriodicrelease {
  CitationCitedartifactPublicationformPeriodicrelease(
    date_of_publication: None,
    issue: None,
    volume: None,
    cited_medium: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Citation#resource
pub type CitationCitedartifactPublicationformPeriodicreleaseDateofpublication {
  CitationCitedartifactPublicationformPeriodicreleaseDateofpublication(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    date: Option(String),
    year: Option(String),
    month: Option(String),
    day: Option(String),
    season: Option(String),
    text: Option(String),
  )
}

pub fn citation_citedartifact_publicationform_periodicrelease_dateofpublication_new() -> CitationCitedartifactPublicationformPeriodicreleaseDateofpublication {
  CitationCitedartifactPublicationformPeriodicreleaseDateofpublication(
    text: None,
    season: None,
    day: None,
    month: None,
    year: None,
    date: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Citation#resource
pub type CitationCitedartifactWeblocation {
  CitationCitedartifactWeblocation(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Option(Codeableconcept),
    url: Option(String),
  )
}

pub fn citation_citedartifact_weblocation_new() -> CitationCitedartifactWeblocation {
  CitationCitedartifactWeblocation(
    url: None,
    type_: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Citation#resource
pub type CitationCitedartifactClassification {
  CitationCitedartifactClassification(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Option(Codeableconcept),
    classifier: List(Codeableconcept),
    who_classified: Option(CitationCitedartifactClassificationWhoclassified),
  )
}

pub fn citation_citedartifact_classification_new() -> CitationCitedartifactClassification {
  CitationCitedartifactClassification(
    who_classified: None,
    classifier: [],
    type_: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Citation#resource
pub type CitationCitedartifactClassificationWhoclassified {
  CitationCitedartifactClassificationWhoclassified(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    person: Option(Reference),
    organization: Option(Reference),
    publisher: Option(Reference),
    classifier_copyright: Option(String),
    free_to_share: Option(Bool),
  )
}

pub fn citation_citedartifact_classification_whoclassified_new() -> CitationCitedartifactClassificationWhoclassified {
  CitationCitedartifactClassificationWhoclassified(
    free_to_share: None,
    classifier_copyright: None,
    publisher: None,
    organization: None,
    person: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Citation#resource
pub type CitationCitedartifactContributorship {
  CitationCitedartifactContributorship(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    complete: Option(Bool),
    entry: List(CitationCitedartifactContributorshipEntry),
    summary: List(CitationCitedartifactContributorshipSummary),
  )
}

pub fn citation_citedartifact_contributorship_new() -> CitationCitedartifactContributorship {
  CitationCitedartifactContributorship(
    summary: [],
    entry: [],
    complete: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Citation#resource
pub type CitationCitedartifactContributorshipEntry {
  CitationCitedartifactContributorshipEntry(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    name: Option(Humanname),
    initials: Option(String),
    collective_name: Option(String),
    identifier: List(Identifier),
    affiliation_info: List(
      CitationCitedartifactContributorshipEntryAffiliationinfo,
    ),
    address: List(Address),
    telecom: List(Contactpoint),
    contribution_type: List(Codeableconcept),
    role: Option(Codeableconcept),
    contribution_instance: List(
      CitationCitedartifactContributorshipEntryContributioninstance,
    ),
    corresponding_contact: Option(Bool),
    list_order: Option(Int),
  )
}

pub fn citation_citedartifact_contributorship_entry_new() -> CitationCitedartifactContributorshipEntry {
  CitationCitedartifactContributorshipEntry(
    list_order: None,
    corresponding_contact: None,
    contribution_instance: [],
    role: None,
    contribution_type: [],
    telecom: [],
    address: [],
    affiliation_info: [],
    identifier: [],
    collective_name: None,
    initials: None,
    name: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Citation#resource
pub type CitationCitedartifactContributorshipEntryAffiliationinfo {
  CitationCitedartifactContributorshipEntryAffiliationinfo(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    affiliation: Option(String),
    role: Option(String),
    identifier: List(Identifier),
  )
}

pub fn citation_citedartifact_contributorship_entry_affiliationinfo_new() -> CitationCitedartifactContributorshipEntryAffiliationinfo {
  CitationCitedartifactContributorshipEntryAffiliationinfo(
    identifier: [],
    role: None,
    affiliation: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Citation#resource
pub type CitationCitedartifactContributorshipEntryContributioninstance {
  CitationCitedartifactContributorshipEntryContributioninstance(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Codeableconcept,
    time: Option(String),
  )
}

pub fn citation_citedartifact_contributorship_entry_contributioninstance_new(
  type_ type_: Codeableconcept,
) -> CitationCitedartifactContributorshipEntryContributioninstance {
  CitationCitedartifactContributorshipEntryContributioninstance(
    time: None,
    type_:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Citation#resource
pub type CitationCitedartifactContributorshipSummary {
  CitationCitedartifactContributorshipSummary(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Option(Codeableconcept),
    style: Option(Codeableconcept),
    source: Option(Codeableconcept),
    value: String,
  )
}

pub fn citation_citedartifact_contributorship_summary_new(
  value value: String,
) -> CitationCitedartifactContributorshipSummary {
  CitationCitedartifactContributorshipSummary(
    value:,
    source: None,
    style: None,
    type_: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn citation_citedartifact_contributorship_summary_to_json(
  citation_citedartifact_contributorship_summary: CitationCitedartifactContributorshipSummary,
) -> Json {
  let CitationCitedartifactContributorshipSummary(
    value:,
    source:,
    style:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = citation_citedartifact_contributorship_summary
  let fields = [
    #("value", json.string(value)),
  ]
  let fields = case source {
    Some(v) -> [#("source", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case style {
    Some(v) -> [#("style", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn citation_citedartifact_contributorship_summary_decoder() -> Decoder(
  CitationCitedartifactContributorshipSummary,
) {
  use value <- decode.field("value", decode.string)
  use source <- decode.optional_field(
    "source",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use style <- decode.optional_field(
    "style",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CitationCitedartifactContributorshipSummary(
    value:,
    source:,
    style:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn citation_citedartifact_contributorship_entry_contributioninstance_to_json(
  citation_citedartifact_contributorship_entry_contributioninstance: CitationCitedartifactContributorshipEntryContributioninstance,
) -> Json {
  let CitationCitedartifactContributorshipEntryContributioninstance(
    time:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = citation_citedartifact_contributorship_entry_contributioninstance
  let fields = [
    #("type", codeableconcept_to_json(type_)),
  ]
  let fields = case time {
    Some(v) -> [#("time", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn citation_citedartifact_contributorship_entry_contributioninstance_decoder() -> Decoder(
  CitationCitedartifactContributorshipEntryContributioninstance,
) {
  use time <- decode.optional_field(
    "time",
    None,
    decode.optional(decode.string),
  )
  use type_ <- decode.field("type", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CitationCitedartifactContributorshipEntryContributioninstance(
    time:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn citation_citedartifact_contributorship_entry_affiliationinfo_to_json(
  citation_citedartifact_contributorship_entry_affiliationinfo: CitationCitedartifactContributorshipEntryAffiliationinfo,
) -> Json {
  let CitationCitedartifactContributorshipEntryAffiliationinfo(
    identifier:,
    role:,
    affiliation:,
    modifier_extension:,
    extension:,
    id:,
  ) = citation_citedartifact_contributorship_entry_affiliationinfo
  let fields = []
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case role {
    Some(v) -> [#("role", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case affiliation {
    Some(v) -> [#("affiliation", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn citation_citedartifact_contributorship_entry_affiliationinfo_decoder() -> Decoder(
  CitationCitedartifactContributorshipEntryAffiliationinfo,
) {
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use role <- decode.optional_field(
    "role",
    None,
    decode.optional(decode.string),
  )
  use affiliation <- decode.optional_field(
    "affiliation",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CitationCitedartifactContributorshipEntryAffiliationinfo(
    identifier:,
    role:,
    affiliation:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn citation_citedartifact_contributorship_entry_to_json(
  citation_citedartifact_contributorship_entry: CitationCitedartifactContributorshipEntry,
) -> Json {
  let CitationCitedartifactContributorshipEntry(
    list_order:,
    corresponding_contact:,
    contribution_instance:,
    role:,
    contribution_type:,
    telecom:,
    address:,
    affiliation_info:,
    identifier:,
    collective_name:,
    initials:,
    name:,
    modifier_extension:,
    extension:,
    id:,
  ) = citation_citedartifact_contributorship_entry
  let fields = []
  let fields = case list_order {
    Some(v) -> [#("listOrder", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case corresponding_contact {
    Some(v) -> [#("correspondingContact", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case contribution_instance {
    [] -> fields
    _ -> [
      #(
        "contributionInstance",
        json.array(
          contribution_instance,
          citation_citedartifact_contributorship_entry_contributioninstance_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case role {
    Some(v) -> [#("role", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case contribution_type {
    [] -> fields
    _ -> [
      #(
        "contributionType",
        json.array(contribution_type, codeableconcept_to_json),
      ),
      ..fields
    ]
  }
  let fields = case telecom {
    [] -> fields
    _ -> [#("telecom", json.array(telecom, contactpoint_to_json)), ..fields]
  }
  let fields = case address {
    [] -> fields
    _ -> [#("address", json.array(address, address_to_json)), ..fields]
  }
  let fields = case affiliation_info {
    [] -> fields
    _ -> [
      #(
        "affiliationInfo",
        json.array(
          affiliation_info,
          citation_citedartifact_contributorship_entry_affiliationinfo_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case collective_name {
    Some(v) -> [#("collectiveName", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case initials {
    Some(v) -> [#("initials", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case name {
    Some(v) -> [#("name", humanname_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn citation_citedartifact_contributorship_entry_decoder() -> Decoder(
  CitationCitedartifactContributorshipEntry,
) {
  use list_order <- decode.optional_field(
    "listOrder",
    None,
    decode.optional(decode.int),
  )
  use corresponding_contact <- decode.optional_field(
    "correspondingContact",
    None,
    decode.optional(decode.bool),
  )
  use contribution_instance <- decode.optional_field(
    "contributionInstance",
    [],
    decode.list(
      citation_citedartifact_contributorship_entry_contributioninstance_decoder(),
    ),
  )
  use role <- decode.optional_field(
    "role",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use contribution_type <- decode.optional_field(
    "contributionType",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use telecom <- decode.optional_field(
    "telecom",
    [],
    decode.list(contactpoint_decoder()),
  )
  use address <- decode.optional_field(
    "address",
    [],
    decode.list(address_decoder()),
  )
  use affiliation_info <- decode.optional_field(
    "affiliationInfo",
    [],
    decode.list(
      citation_citedartifact_contributorship_entry_affiliationinfo_decoder(),
    ),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use collective_name <- decode.optional_field(
    "collectiveName",
    None,
    decode.optional(decode.string),
  )
  use initials <- decode.optional_field(
    "initials",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(humanname_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CitationCitedartifactContributorshipEntry(
    list_order:,
    corresponding_contact:,
    contribution_instance:,
    role:,
    contribution_type:,
    telecom:,
    address:,
    affiliation_info:,
    identifier:,
    collective_name:,
    initials:,
    name:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn citation_citedartifact_contributorship_to_json(
  citation_citedartifact_contributorship: CitationCitedartifactContributorship,
) -> Json {
  let CitationCitedartifactContributorship(
    summary:,
    entry:,
    complete:,
    modifier_extension:,
    extension:,
    id:,
  ) = citation_citedartifact_contributorship
  let fields = []
  let fields = case summary {
    [] -> fields
    _ -> [
      #(
        "summary",
        json.array(
          summary,
          citation_citedartifact_contributorship_summary_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case entry {
    [] -> fields
    _ -> [
      #(
        "entry",
        json.array(entry, citation_citedartifact_contributorship_entry_to_json),
      ),
      ..fields
    ]
  }
  let fields = case complete {
    Some(v) -> [#("complete", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn citation_citedartifact_contributorship_decoder() -> Decoder(
  CitationCitedartifactContributorship,
) {
  use summary <- decode.optional_field(
    "summary",
    [],
    decode.list(citation_citedartifact_contributorship_summary_decoder()),
  )
  use entry <- decode.optional_field(
    "entry",
    [],
    decode.list(citation_citedartifact_contributorship_entry_decoder()),
  )
  use complete <- decode.optional_field(
    "complete",
    None,
    decode.optional(decode.bool),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CitationCitedartifactContributorship(
    summary:,
    entry:,
    complete:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn citation_citedartifact_classification_whoclassified_to_json(
  citation_citedartifact_classification_whoclassified: CitationCitedartifactClassificationWhoclassified,
) -> Json {
  let CitationCitedartifactClassificationWhoclassified(
    free_to_share:,
    classifier_copyright:,
    publisher:,
    organization:,
    person:,
    modifier_extension:,
    extension:,
    id:,
  ) = citation_citedartifact_classification_whoclassified
  let fields = []
  let fields = case free_to_share {
    Some(v) -> [#("freeToShare", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case classifier_copyright {
    Some(v) -> [#("classifierCopyright", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case publisher {
    Some(v) -> [#("publisher", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case organization {
    Some(v) -> [#("organization", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case person {
    Some(v) -> [#("person", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn citation_citedartifact_classification_whoclassified_decoder() -> Decoder(
  CitationCitedartifactClassificationWhoclassified,
) {
  use free_to_share <- decode.optional_field(
    "freeToShare",
    None,
    decode.optional(decode.bool),
  )
  use classifier_copyright <- decode.optional_field(
    "classifierCopyright",
    None,
    decode.optional(decode.string),
  )
  use publisher <- decode.optional_field(
    "publisher",
    None,
    decode.optional(reference_decoder()),
  )
  use organization <- decode.optional_field(
    "organization",
    None,
    decode.optional(reference_decoder()),
  )
  use person <- decode.optional_field(
    "person",
    None,
    decode.optional(reference_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CitationCitedartifactClassificationWhoclassified(
    free_to_share:,
    classifier_copyright:,
    publisher:,
    organization:,
    person:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn citation_citedartifact_classification_to_json(
  citation_citedartifact_classification: CitationCitedartifactClassification,
) -> Json {
  let CitationCitedartifactClassification(
    who_classified:,
    classifier:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = citation_citedartifact_classification
  let fields = []
  let fields = case who_classified {
    Some(v) -> [
      #(
        "whoClassified",
        citation_citedartifact_classification_whoclassified_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case classifier {
    [] -> fields
    _ -> [
      #("classifier", json.array(classifier, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn citation_citedartifact_classification_decoder() -> Decoder(
  CitationCitedartifactClassification,
) {
  use who_classified <- decode.optional_field(
    "whoClassified",
    None,
    decode.optional(
      citation_citedartifact_classification_whoclassified_decoder(),
    ),
  )
  use classifier <- decode.optional_field(
    "classifier",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CitationCitedartifactClassification(
    who_classified:,
    classifier:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn citation_citedartifact_weblocation_to_json(
  citation_citedartifact_weblocation: CitationCitedartifactWeblocation,
) -> Json {
  let CitationCitedartifactWeblocation(
    url:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = citation_citedartifact_weblocation
  let fields = []
  let fields = case url {
    Some(v) -> [#("url", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn citation_citedartifact_weblocation_decoder() -> Decoder(
  CitationCitedartifactWeblocation,
) {
  use url <- decode.optional_field("url", None, decode.optional(decode.string))
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CitationCitedartifactWeblocation(
    url:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn citation_citedartifact_publicationform_periodicrelease_dateofpublication_to_json(
  citation_citedartifact_publicationform_periodicrelease_dateofpublication: CitationCitedartifactPublicationformPeriodicreleaseDateofpublication,
) -> Json {
  let CitationCitedartifactPublicationformPeriodicreleaseDateofpublication(
    text:,
    season:,
    day:,
    month:,
    year:,
    date:,
    modifier_extension:,
    extension:,
    id:,
  ) = citation_citedartifact_publicationform_periodicrelease_dateofpublication
  let fields = []
  let fields = case text {
    Some(v) -> [#("text", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case season {
    Some(v) -> [#("season", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case day {
    Some(v) -> [#("day", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case month {
    Some(v) -> [#("month", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case year {
    Some(v) -> [#("year", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case date {
    Some(v) -> [#("date", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn citation_citedartifact_publicationform_periodicrelease_dateofpublication_decoder() -> Decoder(
  CitationCitedartifactPublicationformPeriodicreleaseDateofpublication,
) {
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(decode.string),
  )
  use season <- decode.optional_field(
    "season",
    None,
    decode.optional(decode.string),
  )
  use day <- decode.optional_field("day", None, decode.optional(decode.string))
  use month <- decode.optional_field(
    "month",
    None,
    decode.optional(decode.string),
  )
  use year <- decode.optional_field(
    "year",
    None,
    decode.optional(decode.string),
  )
  use date <- decode.optional_field(
    "date",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(
    CitationCitedartifactPublicationformPeriodicreleaseDateofpublication(
      text:,
      season:,
      day:,
      month:,
      year:,
      date:,
      modifier_extension:,
      extension:,
      id:,
    ),
  )
}

pub fn citation_citedartifact_publicationform_periodicrelease_to_json(
  citation_citedartifact_publicationform_periodicrelease: CitationCitedartifactPublicationformPeriodicrelease,
) -> Json {
  let CitationCitedartifactPublicationformPeriodicrelease(
    date_of_publication:,
    issue:,
    volume:,
    cited_medium:,
    modifier_extension:,
    extension:,
    id:,
  ) = citation_citedartifact_publicationform_periodicrelease
  let fields = []
  let fields = case date_of_publication {
    Some(v) -> [
      #(
        "dateOfPublication",
        citation_citedartifact_publicationform_periodicrelease_dateofpublication_to_json(
          v,
        ),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case issue {
    Some(v) -> [#("issue", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case volume {
    Some(v) -> [#("volume", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case cited_medium {
    Some(v) -> [#("citedMedium", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn citation_citedartifact_publicationform_periodicrelease_decoder() -> Decoder(
  CitationCitedartifactPublicationformPeriodicrelease,
) {
  use date_of_publication <- decode.optional_field(
    "dateOfPublication",
    None,
    decode.optional(
      citation_citedartifact_publicationform_periodicrelease_dateofpublication_decoder(),
    ),
  )
  use issue <- decode.optional_field(
    "issue",
    None,
    decode.optional(decode.string),
  )
  use volume <- decode.optional_field(
    "volume",
    None,
    decode.optional(decode.string),
  )
  use cited_medium <- decode.optional_field(
    "citedMedium",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CitationCitedartifactPublicationformPeriodicrelease(
    date_of_publication:,
    issue:,
    volume:,
    cited_medium:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn citation_citedartifact_publicationform_publishedin_to_json(
  citation_citedartifact_publicationform_publishedin: CitationCitedartifactPublicationformPublishedin,
) -> Json {
  let CitationCitedartifactPublicationformPublishedin(
    publisher_location:,
    publisher:,
    title:,
    identifier:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = citation_citedartifact_publicationform_publishedin
  let fields = []
  let fields = case publisher_location {
    Some(v) -> [#("publisherLocation", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case publisher {
    Some(v) -> [#("publisher", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case title {
    Some(v) -> [#("title", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn citation_citedartifact_publicationform_publishedin_decoder() -> Decoder(
  CitationCitedartifactPublicationformPublishedin,
) {
  use publisher_location <- decode.optional_field(
    "publisherLocation",
    None,
    decode.optional(decode.string),
  )
  use publisher <- decode.optional_field(
    "publisher",
    None,
    decode.optional(reference_decoder()),
  )
  use title <- decode.optional_field(
    "title",
    None,
    decode.optional(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CitationCitedartifactPublicationformPublishedin(
    publisher_location:,
    publisher:,
    title:,
    identifier:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn citation_citedartifact_publicationform_to_json(
  citation_citedartifact_publicationform: CitationCitedartifactPublicationform,
) -> Json {
  let CitationCitedartifactPublicationform(
    copyright:,
    page_count:,
    last_page:,
    first_page:,
    page_string:,
    accession_number:,
    language:,
    last_revision_date:,
    article_date:,
    periodic_release:,
    published_in:,
    modifier_extension:,
    extension:,
    id:,
  ) = citation_citedartifact_publicationform
  let fields = []
  let fields = case copyright {
    Some(v) -> [#("copyright", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case page_count {
    Some(v) -> [#("pageCount", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case last_page {
    Some(v) -> [#("lastPage", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case first_page {
    Some(v) -> [#("firstPage", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case page_string {
    Some(v) -> [#("pageString", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case accession_number {
    Some(v) -> [#("accessionNumber", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    [] -> fields
    _ -> [
      #("language", json.array(language, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case last_revision_date {
    Some(v) -> [#("lastRevisionDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case article_date {
    Some(v) -> [#("articleDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case periodic_release {
    Some(v) -> [
      #(
        "periodicRelease",
        citation_citedartifact_publicationform_periodicrelease_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case published_in {
    Some(v) -> [
      #(
        "publishedIn",
        citation_citedartifact_publicationform_publishedin_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn citation_citedartifact_publicationform_decoder() -> Decoder(
  CitationCitedartifactPublicationform,
) {
  use copyright <- decode.optional_field(
    "copyright",
    None,
    decode.optional(decode.string),
  )
  use page_count <- decode.optional_field(
    "pageCount",
    None,
    decode.optional(decode.string),
  )
  use last_page <- decode.optional_field(
    "lastPage",
    None,
    decode.optional(decode.string),
  )
  use first_page <- decode.optional_field(
    "firstPage",
    None,
    decode.optional(decode.string),
  )
  use page_string <- decode.optional_field(
    "pageString",
    None,
    decode.optional(decode.string),
  )
  use accession_number <- decode.optional_field(
    "accessionNumber",
    None,
    decode.optional(decode.string),
  )
  use language <- decode.optional_field(
    "language",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use last_revision_date <- decode.optional_field(
    "lastRevisionDate",
    None,
    decode.optional(decode.string),
  )
  use article_date <- decode.optional_field(
    "articleDate",
    None,
    decode.optional(decode.string),
  )
  use periodic_release <- decode.optional_field(
    "periodicRelease",
    None,
    decode.optional(
      citation_citedartifact_publicationform_periodicrelease_decoder(),
    ),
  )
  use published_in <- decode.optional_field(
    "publishedIn",
    None,
    decode.optional(
      citation_citedartifact_publicationform_publishedin_decoder(),
    ),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CitationCitedartifactPublicationform(
    copyright:,
    page_count:,
    last_page:,
    first_page:,
    page_string:,
    accession_number:,
    language:,
    last_revision_date:,
    article_date:,
    periodic_release:,
    published_in:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn citation_citedartifact_relatesto_to_json(
  citation_citedartifact_relatesto: CitationCitedartifactRelatesto,
) -> Json {
  let CitationCitedartifactRelatesto(
    target:,
    target_classifier:,
    relationship_type:,
    modifier_extension:,
    extension:,
    id:,
  ) = citation_citedartifact_relatesto
  let fields = [
    #("target", citation_citedartifact_relatesto_target_to_json(target)),
    #("relationshipType", codeableconcept_to_json(relationship_type)),
  ]
  let fields = case target_classifier {
    [] -> fields
    _ -> [
      #(
        "targetClassifier",
        json.array(target_classifier, codeableconcept_to_json),
      ),
      ..fields
    ]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn citation_citedartifact_relatesto_decoder() -> Decoder(
  CitationCitedartifactRelatesto,
) {
  use target <- decode.then(citation_citedartifact_relatesto_target_decoder())
  use target_classifier <- decode.optional_field(
    "targetClassifier",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use relationship_type <- decode.field(
    "relationshipType",
    codeableconcept_decoder(),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CitationCitedartifactRelatesto(
    target:,
    target_classifier:,
    relationship_type:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn citation_citedartifact_part_to_json(
  citation_citedartifact_part: CitationCitedartifactPart,
) -> Json {
  let CitationCitedartifactPart(
    base_citation:,
    value:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = citation_citedartifact_part
  let fields = []
  let fields = case base_citation {
    Some(v) -> [#("baseCitation", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case value {
    Some(v) -> [#("value", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn citation_citedartifact_part_decoder() -> Decoder(
  CitationCitedartifactPart,
) {
  use base_citation <- decode.optional_field(
    "baseCitation",
    None,
    decode.optional(reference_decoder()),
  )
  use value <- decode.optional_field(
    "value",
    None,
    decode.optional(decode.string),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CitationCitedartifactPart(
    base_citation:,
    value:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn citation_citedartifact_abstract_to_json(
  citation_citedartifact_abstract: CitationCitedartifactAbstract,
) -> Json {
  let CitationCitedartifactAbstract(
    copyright:,
    text:,
    language:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = citation_citedartifact_abstract
  let fields = [
    #("text", json.string(text)),
  ]
  let fields = case copyright {
    Some(v) -> [#("copyright", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn citation_citedartifact_abstract_decoder() -> Decoder(
  CitationCitedartifactAbstract,
) {
  use copyright <- decode.optional_field(
    "copyright",
    None,
    decode.optional(decode.string),
  )
  use text <- decode.field("text", decode.string)
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CitationCitedartifactAbstract(
    copyright:,
    text:,
    language:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn citation_citedartifact_title_to_json(
  citation_citedartifact_title: CitationCitedartifactTitle,
) -> Json {
  let CitationCitedartifactTitle(
    text:,
    language:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = citation_citedartifact_title
  let fields = [
    #("text", json.string(text)),
  ]
  let fields = case language {
    Some(v) -> [#("language", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    [] -> fields
    _ -> [#("type", json.array(type_, codeableconcept_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn citation_citedartifact_title_decoder() -> Decoder(
  CitationCitedartifactTitle,
) {
  use text <- decode.field("text", decode.string)
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CitationCitedartifactTitle(
    text:,
    language:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn citation_citedartifact_statusdate_to_json(
  citation_citedartifact_statusdate: CitationCitedartifactStatusdate,
) -> Json {
  let CitationCitedartifactStatusdate(
    period:,
    actual:,
    activity:,
    modifier_extension:,
    extension:,
    id:,
  ) = citation_citedartifact_statusdate
  let fields = [
    #("period", period_to_json(period)),
    #("activity", codeableconcept_to_json(activity)),
  ]
  let fields = case actual {
    Some(v) -> [#("actual", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn citation_citedartifact_statusdate_decoder() -> Decoder(
  CitationCitedartifactStatusdate,
) {
  use period <- decode.field("period", period_decoder())
  use actual <- decode.optional_field(
    "actual",
    None,
    decode.optional(decode.bool),
  )
  use activity <- decode.field("activity", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CitationCitedartifactStatusdate(
    period:,
    actual:,
    activity:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn citation_citedartifact_version_to_json(
  citation_citedartifact_version: CitationCitedartifactVersion,
) -> Json {
  let CitationCitedartifactVersion(
    base_citation:,
    value:,
    modifier_extension:,
    extension:,
    id:,
  ) = citation_citedartifact_version
  let fields = [
    #("value", json.string(value)),
  ]
  let fields = case base_citation {
    Some(v) -> [#("baseCitation", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn citation_citedartifact_version_decoder() -> Decoder(
  CitationCitedartifactVersion,
) {
  use base_citation <- decode.optional_field(
    "baseCitation",
    None,
    decode.optional(reference_decoder()),
  )
  use value <- decode.field("value", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CitationCitedartifactVersion(
    base_citation:,
    value:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn citation_citedartifact_to_json(
  citation_citedartifact: CitationCitedartifact,
) -> Json {
  let CitationCitedartifact(
    note:,
    contributorship:,
    classification:,
    web_location:,
    publication_form:,
    relates_to:,
    part:,
    abstract:,
    title:,
    status_date:,
    current_state:,
    version:,
    date_accessed:,
    related_identifier:,
    identifier:,
    modifier_extension:,
    extension:,
    id:,
  ) = citation_citedartifact
  let fields = []
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case contributorship {
    Some(v) -> [
      #("contributorship", citation_citedartifact_contributorship_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case classification {
    [] -> fields
    _ -> [
      #(
        "classification",
        json.array(
          classification,
          citation_citedartifact_classification_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case web_location {
    [] -> fields
    _ -> [
      #(
        "webLocation",
        json.array(web_location, citation_citedartifact_weblocation_to_json),
      ),
      ..fields
    ]
  }
  let fields = case publication_form {
    [] -> fields
    _ -> [
      #(
        "publicationForm",
        json.array(
          publication_form,
          citation_citedartifact_publicationform_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case relates_to {
    [] -> fields
    _ -> [
      #(
        "relatesTo",
        json.array(relates_to, citation_citedartifact_relatesto_to_json),
      ),
      ..fields
    ]
  }
  let fields = case part {
    Some(v) -> [#("part", citation_citedartifact_part_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case abstract {
    [] -> fields
    _ -> [
      #(
        "abstract",
        json.array(abstract, citation_citedartifact_abstract_to_json),
      ),
      ..fields
    ]
  }
  let fields = case title {
    [] -> fields
    _ -> [
      #("title", json.array(title, citation_citedartifact_title_to_json)),
      ..fields
    ]
  }
  let fields = case status_date {
    [] -> fields
    _ -> [
      #(
        "statusDate",
        json.array(status_date, citation_citedartifact_statusdate_to_json),
      ),
      ..fields
    ]
  }
  let fields = case current_state {
    [] -> fields
    _ -> [
      #("currentState", json.array(current_state, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case version {
    Some(v) -> [
      #("version", citation_citedartifact_version_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case date_accessed {
    Some(v) -> [#("dateAccessed", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case related_identifier {
    [] -> fields
    _ -> [
      #("relatedIdentifier", json.array(related_identifier, identifier_to_json)),
      ..fields
    ]
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn citation_citedartifact_decoder() -> Decoder(CitationCitedartifact) {
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use contributorship <- decode.optional_field(
    "contributorship",
    None,
    decode.optional(citation_citedartifact_contributorship_decoder()),
  )
  use classification <- decode.optional_field(
    "classification",
    [],
    decode.list(citation_citedartifact_classification_decoder()),
  )
  use web_location <- decode.optional_field(
    "webLocation",
    [],
    decode.list(citation_citedartifact_weblocation_decoder()),
  )
  use publication_form <- decode.optional_field(
    "publicationForm",
    [],
    decode.list(citation_citedartifact_publicationform_decoder()),
  )
  use relates_to <- decode.optional_field(
    "relatesTo",
    [],
    decode.list(citation_citedartifact_relatesto_decoder()),
  )
  use part <- decode.optional_field(
    "part",
    None,
    decode.optional(citation_citedartifact_part_decoder()),
  )
  use abstract <- decode.optional_field(
    "abstract",
    [],
    decode.list(citation_citedartifact_abstract_decoder()),
  )
  use title <- decode.optional_field(
    "title",
    [],
    decode.list(citation_citedartifact_title_decoder()),
  )
  use status_date <- decode.optional_field(
    "statusDate",
    [],
    decode.list(citation_citedartifact_statusdate_decoder()),
  )
  use current_state <- decode.optional_field(
    "currentState",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use version <- decode.optional_field(
    "version",
    None,
    decode.optional(citation_citedartifact_version_decoder()),
  )
  use date_accessed <- decode.optional_field(
    "dateAccessed",
    None,
    decode.optional(decode.string),
  )
  use related_identifier <- decode.optional_field(
    "relatedIdentifier",
    [],
    decode.list(identifier_decoder()),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CitationCitedartifact(
    note:,
    contributorship:,
    classification:,
    web_location:,
    publication_form:,
    relates_to:,
    part:,
    abstract:,
    title:,
    status_date:,
    current_state:,
    version:,
    date_accessed:,
    related_identifier:,
    identifier:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn citation_relatesto_to_json(citation_relatesto: CitationRelatesto) -> Json {
  let CitationRelatesto(
    target:,
    target_classifier:,
    relationship_type:,
    modifier_extension:,
    extension:,
    id:,
  ) = citation_relatesto
  let fields = [
    #("target", citation_relatesto_target_to_json(target)),
    #("relationshipType", codeableconcept_to_json(relationship_type)),
  ]
  let fields = case target_classifier {
    [] -> fields
    _ -> [
      #(
        "targetClassifier",
        json.array(target_classifier, codeableconcept_to_json),
      ),
      ..fields
    ]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn citation_relatesto_decoder() -> Decoder(CitationRelatesto) {
  use target <- decode.then(citation_relatesto_target_decoder())
  use target_classifier <- decode.optional_field(
    "targetClassifier",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use relationship_type <- decode.field(
    "relationshipType",
    codeableconcept_decoder(),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CitationRelatesto(
    target:,
    target_classifier:,
    relationship_type:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn citation_statusdate_to_json(
  citation_statusdate: CitationStatusdate,
) -> Json {
  let CitationStatusdate(
    period:,
    actual:,
    activity:,
    modifier_extension:,
    extension:,
    id:,
  ) = citation_statusdate
  let fields = [
    #("period", period_to_json(period)),
    #("activity", codeableconcept_to_json(activity)),
  ]
  let fields = case actual {
    Some(v) -> [#("actual", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn citation_statusdate_decoder() -> Decoder(CitationStatusdate) {
  use period <- decode.field("period", period_decoder())
  use actual <- decode.optional_field(
    "actual",
    None,
    decode.optional(decode.bool),
  )
  use activity <- decode.field("activity", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CitationStatusdate(
    period:,
    actual:,
    activity:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn citation_classification_to_json(
  citation_classification: CitationClassification,
) -> Json {
  let CitationClassification(
    classifier:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = citation_classification
  let fields = []
  let fields = case classifier {
    [] -> fields
    _ -> [
      #("classifier", json.array(classifier, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn citation_classification_decoder() -> Decoder(CitationClassification) {
  use classifier <- decode.optional_field(
    "classifier",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CitationClassification(
    classifier:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn citation_summary_to_json(citation_summary: CitationSummary) -> Json {
  let CitationSummary(text:, style:, modifier_extension:, extension:, id:) =
    citation_summary
  let fields = [
    #("text", json.string(text)),
  ]
  let fields = case style {
    Some(v) -> [#("style", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn citation_summary_decoder() -> Decoder(CitationSummary) {
  use text <- decode.field("text", decode.string)
  use style <- decode.optional_field(
    "style",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CitationSummary(
    text:,
    style:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn citation_to_json(citation: Citation) -> Json {
  let Citation(
    cited_artifact:,
    relates_to:,
    status_date:,
    current_state:,
    note:,
    classification:,
    summary:,
    endorser:,
    reviewer:,
    editor:,
    author:,
    effective_period:,
    last_review_date:,
    approval_date:,
    copyright:,
    purpose:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    experimental:,
    status:,
    title:,
    name:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = citation
  let fields = [
    #("status", r4bvaluesets.publicationstatus_to_json(status)),
  ]
  let fields = case cited_artifact {
    Some(v) -> [#("citedArtifact", citation_citedartifact_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case relates_to {
    [] -> fields
    _ -> [
      #("relatesTo", json.array(relates_to, citation_relatesto_to_json)),
      ..fields
    ]
  }
  let fields = case status_date {
    [] -> fields
    _ -> [
      #("statusDate", json.array(status_date, citation_statusdate_to_json)),
      ..fields
    ]
  }
  let fields = case current_state {
    [] -> fields
    _ -> [
      #("currentState", json.array(current_state, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case classification {
    [] -> fields
    _ -> [
      #(
        "classification",
        json.array(classification, citation_classification_to_json),
      ),
      ..fields
    ]
  }
  let fields = case summary {
    [] -> fields
    _ -> [#("summary", json.array(summary, citation_summary_to_json)), ..fields]
  }
  let fields = case endorser {
    [] -> fields
    _ -> [#("endorser", json.array(endorser, contactdetail_to_json)), ..fields]
  }
  let fields = case reviewer {
    [] -> fields
    _ -> [#("reviewer", json.array(reviewer, contactdetail_to_json)), ..fields]
  }
  let fields = case editor {
    [] -> fields
    _ -> [#("editor", json.array(editor, contactdetail_to_json)), ..fields]
  }
  let fields = case author {
    [] -> fields
    _ -> [#("author", json.array(author, contactdetail_to_json)), ..fields]
  }
  let fields = case effective_period {
    Some(v) -> [#("effectivePeriod", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case last_review_date {
    Some(v) -> [#("lastReviewDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case approval_date {
    Some(v) -> [#("approvalDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case copyright {
    Some(v) -> [#("copyright", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case purpose {
    Some(v) -> [#("purpose", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case jurisdiction {
    [] -> fields
    _ -> [
      #("jurisdiction", json.array(jurisdiction, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case use_context {
    [] -> fields
    _ -> [
      #("useContext", json.array(use_context, usagecontext_to_json)),
      ..fields
    ]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case contact {
    [] -> fields
    _ -> [#("contact", json.array(contact, contactdetail_to_json)), ..fields]
  }
  let fields = case publisher {
    Some(v) -> [#("publisher", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case date {
    Some(v) -> [#("date", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case experimental {
    Some(v) -> [#("experimental", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case title {
    Some(v) -> [#("title", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case version {
    Some(v) -> [#("version", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case url {
    Some(v) -> [#("url", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Citation")), ..fields]
  json.object(fields)
}

pub fn citation_decoder() -> Decoder(Citation) {
  use cited_artifact <- decode.optional_field(
    "citedArtifact",
    None,
    decode.optional(citation_citedartifact_decoder()),
  )
  use relates_to <- decode.optional_field(
    "relatesTo",
    [],
    decode.list(citation_relatesto_decoder()),
  )
  use status_date <- decode.optional_field(
    "statusDate",
    [],
    decode.list(citation_statusdate_decoder()),
  )
  use current_state <- decode.optional_field(
    "currentState",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use classification <- decode.optional_field(
    "classification",
    [],
    decode.list(citation_classification_decoder()),
  )
  use summary <- decode.optional_field(
    "summary",
    [],
    decode.list(citation_summary_decoder()),
  )
  use endorser <- decode.optional_field(
    "endorser",
    [],
    decode.list(contactdetail_decoder()),
  )
  use reviewer <- decode.optional_field(
    "reviewer",
    [],
    decode.list(contactdetail_decoder()),
  )
  use editor <- decode.optional_field(
    "editor",
    [],
    decode.list(contactdetail_decoder()),
  )
  use author <- decode.optional_field(
    "author",
    [],
    decode.list(contactdetail_decoder()),
  )
  use effective_period <- decode.optional_field(
    "effectivePeriod",
    None,
    decode.optional(period_decoder()),
  )
  use last_review_date <- decode.optional_field(
    "lastReviewDate",
    None,
    decode.optional(decode.string),
  )
  use approval_date <- decode.optional_field(
    "approvalDate",
    None,
    decode.optional(decode.string),
  )
  use copyright <- decode.optional_field(
    "copyright",
    None,
    decode.optional(decode.string),
  )
  use purpose <- decode.optional_field(
    "purpose",
    None,
    decode.optional(decode.string),
  )
  use jurisdiction <- decode.optional_field(
    "jurisdiction",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use use_context <- decode.optional_field(
    "useContext",
    [],
    decode.list(usagecontext_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use contact <- decode.optional_field(
    "contact",
    [],
    decode.list(contactdetail_decoder()),
  )
  use publisher <- decode.optional_field(
    "publisher",
    None,
    decode.optional(decode.string),
  )
  use date <- decode.optional_field(
    "date",
    None,
    decode.optional(decode.string),
  )
  use experimental <- decode.optional_field(
    "experimental",
    None,
    decode.optional(decode.bool),
  )
  use status <- decode.field("status", r4bvaluesets.publicationstatus_decoder())
  use title <- decode.optional_field(
    "title",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use version <- decode.optional_field(
    "version",
    None,
    decode.optional(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use url <- decode.optional_field("url", None, decode.optional(decode.string))
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Citation",
    decode.failure(citation_new(status:), "resourceType"),
  )
  decode.success(Citation(
    cited_artifact:,
    relates_to:,
    status_date:,
    current_state:,
    note:,
    classification:,
    summary:,
    endorser:,
    reviewer:,
    editor:,
    author:,
    effective_period:,
    last_review_date:,
    approval_date:,
    copyright:,
    purpose:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    experimental:,
    status:,
    title:,
    name:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/Claim#resource
pub type Claim {
  Claim(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    status: r4bvaluesets.Fmstatus,
    type_: Codeableconcept,
    sub_type: Option(Codeableconcept),
    use_: r4bvaluesets.Claimuse,
    patient: Reference,
    billable_period: Option(Period),
    created: String,
    enterer: Option(Reference),
    insurer: Option(Reference),
    provider: Reference,
    priority: Codeableconcept,
    funds_reserve: Option(Codeableconcept),
    related: List(ClaimRelated),
    prescription: Option(Reference),
    original_prescription: Option(Reference),
    payee: Option(ClaimPayee),
    referral: Option(Reference),
    facility: Option(Reference),
    care_team: List(ClaimCareteam),
    supporting_info: List(ClaimSupportinginfo),
    diagnosis: List(ClaimDiagnosis),
    procedure: List(ClaimProcedure),
    insurance: List(ClaimInsurance),
    accident: Option(ClaimAccident),
    item: List(ClaimItem),
    total: Option(Money),
  )
}

pub fn claim_new(
  priority priority: Codeableconcept,
  provider provider: Reference,
  created created: String,
  patient patient: Reference,
  use_ use_: r4bvaluesets.Claimuse,
  type_ type_: Codeableconcept,
  status status: r4bvaluesets.Fmstatus,
) -> Claim {
  Claim(
    total: None,
    item: [],
    accident: None,
    insurance: [],
    procedure: [],
    diagnosis: [],
    supporting_info: [],
    care_team: [],
    facility: None,
    referral: None,
    payee: None,
    original_prescription: None,
    prescription: None,
    related: [],
    funds_reserve: None,
    priority:,
    provider:,
    insurer: None,
    enterer: None,
    created:,
    billable_period: None,
    patient:,
    use_:,
    sub_type: None,
    type_:,
    status:,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Claim#resource
pub type ClaimRelated {
  ClaimRelated(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    claim: Option(Reference),
    relationship: Option(Codeableconcept),
    reference: Option(Identifier),
  )
}

pub fn claim_related_new() -> ClaimRelated {
  ClaimRelated(
    reference: None,
    relationship: None,
    claim: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Claim#resource
pub type ClaimPayee {
  ClaimPayee(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Codeableconcept,
    party: Option(Reference),
  )
}

pub fn claim_payee_new(type_ type_: Codeableconcept) -> ClaimPayee {
  ClaimPayee(
    party: None,
    type_:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Claim#resource
pub type ClaimCareteam {
  ClaimCareteam(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    sequence: Int,
    provider: Reference,
    responsible: Option(Bool),
    role: Option(Codeableconcept),
    qualification: Option(Codeableconcept),
  )
}

pub fn claim_careteam_new(
  provider provider: Reference,
  sequence sequence: Int,
) -> ClaimCareteam {
  ClaimCareteam(
    qualification: None,
    role: None,
    responsible: None,
    provider:,
    sequence:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Claim#resource
pub type ClaimSupportinginfo {
  ClaimSupportinginfo(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    sequence: Int,
    category: Codeableconcept,
    code: Option(Codeableconcept),
    timing: Option(ClaimSupportinginfoTiming),
    value: Option(ClaimSupportinginfoValue),
    reason: Option(Codeableconcept),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Claim#resource
pub type ClaimSupportinginfoTiming {
  ClaimSupportinginfoTimingDate(timing: String)
  ClaimSupportinginfoTimingPeriod(timing: Period)
}

pub fn claim_supportinginfo_timing_to_json(
  elt: ClaimSupportinginfoTiming,
) -> Json {
  case elt {
    ClaimSupportinginfoTimingDate(v) -> json.string(v)
    ClaimSupportinginfoTimingPeriod(v) -> period_to_json(v)
  }
}

pub fn claim_supportinginfo_timing_decoder() -> Decoder(
  ClaimSupportinginfoTiming,
) {
  decode.one_of(
    decode.field("timingDate", decode.string, decode.success)
      |> decode.map(ClaimSupportinginfoTimingDate),
    [
      decode.field("timingPeriod", period_decoder(), decode.success)
      |> decode.map(ClaimSupportinginfoTimingPeriod),
    ],
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Claim#resource
pub type ClaimSupportinginfoValue {
  ClaimSupportinginfoValueBoolean(value: Bool)
  ClaimSupportinginfoValueString(value: String)
  ClaimSupportinginfoValueQuantity(value: Quantity)
  ClaimSupportinginfoValueAttachment(value: Attachment)
  ClaimSupportinginfoValueReference(value: Reference)
}

pub fn claim_supportinginfo_value_to_json(elt: ClaimSupportinginfoValue) -> Json {
  case elt {
    ClaimSupportinginfoValueBoolean(v) -> json.bool(v)
    ClaimSupportinginfoValueString(v) -> json.string(v)
    ClaimSupportinginfoValueQuantity(v) -> quantity_to_json(v)
    ClaimSupportinginfoValueAttachment(v) -> attachment_to_json(v)
    ClaimSupportinginfoValueReference(v) -> reference_to_json(v)
  }
}

pub fn claim_supportinginfo_value_decoder() -> Decoder(ClaimSupportinginfoValue) {
  decode.one_of(
    decode.field("valueBoolean", decode.bool, decode.success)
      |> decode.map(ClaimSupportinginfoValueBoolean),
    [
      decode.field("valueString", decode.string, decode.success)
        |> decode.map(ClaimSupportinginfoValueString),
      decode.field("valueQuantity", quantity_decoder(), decode.success)
        |> decode.map(ClaimSupportinginfoValueQuantity),
      decode.field("valueAttachment", attachment_decoder(), decode.success)
        |> decode.map(ClaimSupportinginfoValueAttachment),
      decode.field("valueReference", reference_decoder(), decode.success)
        |> decode.map(ClaimSupportinginfoValueReference),
    ],
  )
}

pub fn claim_supportinginfo_new(
  category category: Codeableconcept,
  sequence sequence: Int,
) -> ClaimSupportinginfo {
  ClaimSupportinginfo(
    reason: None,
    value: None,
    timing: None,
    code: None,
    category:,
    sequence:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Claim#resource
pub type ClaimDiagnosis {
  ClaimDiagnosis(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    sequence: Int,
    diagnosis: ClaimDiagnosisDiagnosis,
    type_: List(Codeableconcept),
    on_admission: Option(Codeableconcept),
    package_code: Option(Codeableconcept),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Claim#resource
pub type ClaimDiagnosisDiagnosis {
  ClaimDiagnosisDiagnosisCodeableconcept(diagnosis: Codeableconcept)
  ClaimDiagnosisDiagnosisReference(diagnosis: Reference)
}

pub fn claim_diagnosis_diagnosis_to_json(elt: ClaimDiagnosisDiagnosis) -> Json {
  case elt {
    ClaimDiagnosisDiagnosisCodeableconcept(v) -> codeableconcept_to_json(v)
    ClaimDiagnosisDiagnosisReference(v) -> reference_to_json(v)
  }
}

pub fn claim_diagnosis_diagnosis_decoder() -> Decoder(ClaimDiagnosisDiagnosis) {
  decode.one_of(
    decode.field(
      "diagnosisCodeableConcept",
      codeableconcept_decoder(),
      decode.success,
    )
      |> decode.map(ClaimDiagnosisDiagnosisCodeableconcept),
    [
      decode.field("diagnosisReference", reference_decoder(), decode.success)
      |> decode.map(ClaimDiagnosisDiagnosisReference),
    ],
  )
}

pub fn claim_diagnosis_new(
  diagnosis diagnosis: ClaimDiagnosisDiagnosis,
  sequence sequence: Int,
) -> ClaimDiagnosis {
  ClaimDiagnosis(
    package_code: None,
    on_admission: None,
    type_: [],
    diagnosis:,
    sequence:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Claim#resource
pub type ClaimProcedure {
  ClaimProcedure(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    sequence: Int,
    type_: List(Codeableconcept),
    date: Option(String),
    procedure: ClaimProcedureProcedure,
    udi: List(Reference),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Claim#resource
pub type ClaimProcedureProcedure {
  ClaimProcedureProcedureCodeableconcept(procedure: Codeableconcept)
  ClaimProcedureProcedureReference(procedure: Reference)
}

pub fn claim_procedure_procedure_to_json(elt: ClaimProcedureProcedure) -> Json {
  case elt {
    ClaimProcedureProcedureCodeableconcept(v) -> codeableconcept_to_json(v)
    ClaimProcedureProcedureReference(v) -> reference_to_json(v)
  }
}

pub fn claim_procedure_procedure_decoder() -> Decoder(ClaimProcedureProcedure) {
  decode.one_of(
    decode.field(
      "procedureCodeableConcept",
      codeableconcept_decoder(),
      decode.success,
    )
      |> decode.map(ClaimProcedureProcedureCodeableconcept),
    [
      decode.field("procedureReference", reference_decoder(), decode.success)
      |> decode.map(ClaimProcedureProcedureReference),
    ],
  )
}

pub fn claim_procedure_new(
  procedure procedure: ClaimProcedureProcedure,
  sequence sequence: Int,
) -> ClaimProcedure {
  ClaimProcedure(
    udi: [],
    procedure:,
    date: None,
    type_: [],
    sequence:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Claim#resource
pub type ClaimInsurance {
  ClaimInsurance(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    sequence: Int,
    focal: Bool,
    identifier: Option(Identifier),
    coverage: Reference,
    business_arrangement: Option(String),
    pre_auth_ref: List(String),
    claim_response: Option(Reference),
  )
}

pub fn claim_insurance_new(
  coverage coverage: Reference,
  focal focal: Bool,
  sequence sequence: Int,
) -> ClaimInsurance {
  ClaimInsurance(
    claim_response: None,
    pre_auth_ref: [],
    business_arrangement: None,
    coverage:,
    identifier: None,
    focal:,
    sequence:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Claim#resource
pub type ClaimAccident {
  ClaimAccident(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    date: String,
    type_: Option(Codeableconcept),
    location: Option(ClaimAccidentLocation),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Claim#resource
pub type ClaimAccidentLocation {
  ClaimAccidentLocationAddress(location: Address)
  ClaimAccidentLocationReference(location: Reference)
}

pub fn claim_accident_location_to_json(elt: ClaimAccidentLocation) -> Json {
  case elt {
    ClaimAccidentLocationAddress(v) -> address_to_json(v)
    ClaimAccidentLocationReference(v) -> reference_to_json(v)
  }
}

pub fn claim_accident_location_decoder() -> Decoder(ClaimAccidentLocation) {
  decode.one_of(
    decode.field("locationAddress", address_decoder(), decode.success)
      |> decode.map(ClaimAccidentLocationAddress),
    [
      decode.field("locationReference", reference_decoder(), decode.success)
      |> decode.map(ClaimAccidentLocationReference),
    ],
  )
}

pub fn claim_accident_new(date date: String) -> ClaimAccident {
  ClaimAccident(
    location: None,
    type_: None,
    date:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Claim#resource
pub type ClaimItem {
  ClaimItem(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    sequence: Int,
    care_team_sequence: List(Int),
    diagnosis_sequence: List(Int),
    procedure_sequence: List(Int),
    information_sequence: List(Int),
    revenue: Option(Codeableconcept),
    category: Option(Codeableconcept),
    product_or_service: Codeableconcept,
    modifier: List(Codeableconcept),
    program_code: List(Codeableconcept),
    serviced: Option(ClaimItemServiced),
    location: Option(ClaimItemLocation),
    quantity: Option(Quantity),
    unit_price: Option(Money),
    factor: Option(Float),
    net: Option(Money),
    udi: List(Reference),
    body_site: Option(Codeableconcept),
    sub_site: List(Codeableconcept),
    encounter: List(Reference),
    detail: List(ClaimItemDetail),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Claim#resource
pub type ClaimItemServiced {
  ClaimItemServicedDate(serviced: String)
  ClaimItemServicedPeriod(serviced: Period)
}

pub fn claim_item_serviced_to_json(elt: ClaimItemServiced) -> Json {
  case elt {
    ClaimItemServicedDate(v) -> json.string(v)
    ClaimItemServicedPeriod(v) -> period_to_json(v)
  }
}

pub fn claim_item_serviced_decoder() -> Decoder(ClaimItemServiced) {
  decode.one_of(
    decode.field("servicedDate", decode.string, decode.success)
      |> decode.map(ClaimItemServicedDate),
    [
      decode.field("servicedPeriod", period_decoder(), decode.success)
      |> decode.map(ClaimItemServicedPeriod),
    ],
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Claim#resource
pub type ClaimItemLocation {
  ClaimItemLocationCodeableconcept(location: Codeableconcept)
  ClaimItemLocationAddress(location: Address)
  ClaimItemLocationReference(location: Reference)
}

pub fn claim_item_location_to_json(elt: ClaimItemLocation) -> Json {
  case elt {
    ClaimItemLocationCodeableconcept(v) -> codeableconcept_to_json(v)
    ClaimItemLocationAddress(v) -> address_to_json(v)
    ClaimItemLocationReference(v) -> reference_to_json(v)
  }
}

pub fn claim_item_location_decoder() -> Decoder(ClaimItemLocation) {
  decode.one_of(
    decode.field(
      "locationCodeableConcept",
      codeableconcept_decoder(),
      decode.success,
    )
      |> decode.map(ClaimItemLocationCodeableconcept),
    [
      decode.field("locationAddress", address_decoder(), decode.success)
        |> decode.map(ClaimItemLocationAddress),
      decode.field("locationReference", reference_decoder(), decode.success)
        |> decode.map(ClaimItemLocationReference),
    ],
  )
}

pub fn claim_item_new(
  product_or_service product_or_service: Codeableconcept,
  sequence sequence: Int,
) -> ClaimItem {
  ClaimItem(
    detail: [],
    encounter: [],
    sub_site: [],
    body_site: None,
    udi: [],
    net: None,
    factor: None,
    unit_price: None,
    quantity: None,
    location: None,
    serviced: None,
    program_code: [],
    modifier: [],
    product_or_service:,
    category: None,
    revenue: None,
    information_sequence: [],
    procedure_sequence: [],
    diagnosis_sequence: [],
    care_team_sequence: [],
    sequence:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Claim#resource
pub type ClaimItemDetail {
  ClaimItemDetail(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    sequence: Int,
    revenue: Option(Codeableconcept),
    category: Option(Codeableconcept),
    product_or_service: Codeableconcept,
    modifier: List(Codeableconcept),
    program_code: List(Codeableconcept),
    quantity: Option(Quantity),
    unit_price: Option(Money),
    factor: Option(Float),
    net: Option(Money),
    udi: List(Reference),
    sub_detail: List(ClaimItemDetailSubdetail),
  )
}

pub fn claim_item_detail_new(
  product_or_service product_or_service: Codeableconcept,
  sequence sequence: Int,
) -> ClaimItemDetail {
  ClaimItemDetail(
    sub_detail: [],
    udi: [],
    net: None,
    factor: None,
    unit_price: None,
    quantity: None,
    program_code: [],
    modifier: [],
    product_or_service:,
    category: None,
    revenue: None,
    sequence:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Claim#resource
pub type ClaimItemDetailSubdetail {
  ClaimItemDetailSubdetail(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    sequence: Int,
    revenue: Option(Codeableconcept),
    category: Option(Codeableconcept),
    product_or_service: Codeableconcept,
    modifier: List(Codeableconcept),
    program_code: List(Codeableconcept),
    quantity: Option(Quantity),
    unit_price: Option(Money),
    factor: Option(Float),
    net: Option(Money),
    udi: List(Reference),
  )
}

pub fn claim_item_detail_subdetail_new(
  product_or_service product_or_service: Codeableconcept,
  sequence sequence: Int,
) -> ClaimItemDetailSubdetail {
  ClaimItemDetailSubdetail(
    udi: [],
    net: None,
    factor: None,
    unit_price: None,
    quantity: None,
    program_code: [],
    modifier: [],
    product_or_service:,
    category: None,
    revenue: None,
    sequence:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn claim_item_detail_subdetail_to_json(
  claim_item_detail_subdetail: ClaimItemDetailSubdetail,
) -> Json {
  let ClaimItemDetailSubdetail(
    udi:,
    net:,
    factor:,
    unit_price:,
    quantity:,
    program_code:,
    modifier:,
    product_or_service:,
    category:,
    revenue:,
    sequence:,
    modifier_extension:,
    extension:,
    id:,
  ) = claim_item_detail_subdetail
  let fields = [
    #("productOrService", codeableconcept_to_json(product_or_service)),
    #("sequence", json.int(sequence)),
  ]
  let fields = case udi {
    [] -> fields
    _ -> [#("udi", json.array(udi, reference_to_json)), ..fields]
  }
  let fields = case net {
    Some(v) -> [#("net", money_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case factor {
    Some(v) -> [#("factor", json.float(v)), ..fields]
    None -> fields
  }
  let fields = case unit_price {
    Some(v) -> [#("unitPrice", money_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case quantity {
    Some(v) -> [#("quantity", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case program_code {
    [] -> fields
    _ -> [
      #("programCode", json.array(program_code, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case modifier {
    [] -> fields
    _ -> [
      #("modifier", json.array(modifier, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case category {
    Some(v) -> [#("category", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case revenue {
    Some(v) -> [#("revenue", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn claim_item_detail_subdetail_decoder() -> Decoder(
  ClaimItemDetailSubdetail,
) {
  use udi <- decode.optional_field("udi", [], decode.list(reference_decoder()))
  use net <- decode.optional_field(
    "net",
    None,
    decode.optional(money_decoder()),
  )
  use factor <- decode.optional_field(
    "factor",
    None,
    decode.optional(decode.float),
  )
  use unit_price <- decode.optional_field(
    "unitPrice",
    None,
    decode.optional(money_decoder()),
  )
  use quantity <- decode.optional_field(
    "quantity",
    None,
    decode.optional(quantity_decoder()),
  )
  use program_code <- decode.optional_field(
    "programCode",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use modifier <- decode.optional_field(
    "modifier",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use product_or_service <- decode.field(
    "productOrService",
    codeableconcept_decoder(),
  )
  use category <- decode.optional_field(
    "category",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use revenue <- decode.optional_field(
    "revenue",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use sequence <- decode.field("sequence", decode.int)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ClaimItemDetailSubdetail(
    udi:,
    net:,
    factor:,
    unit_price:,
    quantity:,
    program_code:,
    modifier:,
    product_or_service:,
    category:,
    revenue:,
    sequence:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn claim_item_detail_to_json(claim_item_detail: ClaimItemDetail) -> Json {
  let ClaimItemDetail(
    sub_detail:,
    udi:,
    net:,
    factor:,
    unit_price:,
    quantity:,
    program_code:,
    modifier:,
    product_or_service:,
    category:,
    revenue:,
    sequence:,
    modifier_extension:,
    extension:,
    id:,
  ) = claim_item_detail
  let fields = [
    #("productOrService", codeableconcept_to_json(product_or_service)),
    #("sequence", json.int(sequence)),
  ]
  let fields = case sub_detail {
    [] -> fields
    _ -> [
      #(
        "subDetail",
        json.array(sub_detail, claim_item_detail_subdetail_to_json),
      ),
      ..fields
    ]
  }
  let fields = case udi {
    [] -> fields
    _ -> [#("udi", json.array(udi, reference_to_json)), ..fields]
  }
  let fields = case net {
    Some(v) -> [#("net", money_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case factor {
    Some(v) -> [#("factor", json.float(v)), ..fields]
    None -> fields
  }
  let fields = case unit_price {
    Some(v) -> [#("unitPrice", money_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case quantity {
    Some(v) -> [#("quantity", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case program_code {
    [] -> fields
    _ -> [
      #("programCode", json.array(program_code, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case modifier {
    [] -> fields
    _ -> [
      #("modifier", json.array(modifier, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case category {
    Some(v) -> [#("category", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case revenue {
    Some(v) -> [#("revenue", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn claim_item_detail_decoder() -> Decoder(ClaimItemDetail) {
  use sub_detail <- decode.optional_field(
    "subDetail",
    [],
    decode.list(claim_item_detail_subdetail_decoder()),
  )
  use udi <- decode.optional_field("udi", [], decode.list(reference_decoder()))
  use net <- decode.optional_field(
    "net",
    None,
    decode.optional(money_decoder()),
  )
  use factor <- decode.optional_field(
    "factor",
    None,
    decode.optional(decode.float),
  )
  use unit_price <- decode.optional_field(
    "unitPrice",
    None,
    decode.optional(money_decoder()),
  )
  use quantity <- decode.optional_field(
    "quantity",
    None,
    decode.optional(quantity_decoder()),
  )
  use program_code <- decode.optional_field(
    "programCode",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use modifier <- decode.optional_field(
    "modifier",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use product_or_service <- decode.field(
    "productOrService",
    codeableconcept_decoder(),
  )
  use category <- decode.optional_field(
    "category",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use revenue <- decode.optional_field(
    "revenue",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use sequence <- decode.field("sequence", decode.int)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ClaimItemDetail(
    sub_detail:,
    udi:,
    net:,
    factor:,
    unit_price:,
    quantity:,
    program_code:,
    modifier:,
    product_or_service:,
    category:,
    revenue:,
    sequence:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn claim_item_to_json(claim_item: ClaimItem) -> Json {
  let ClaimItem(
    detail:,
    encounter:,
    sub_site:,
    body_site:,
    udi:,
    net:,
    factor:,
    unit_price:,
    quantity:,
    location:,
    serviced:,
    program_code:,
    modifier:,
    product_or_service:,
    category:,
    revenue:,
    information_sequence:,
    procedure_sequence:,
    diagnosis_sequence:,
    care_team_sequence:,
    sequence:,
    modifier_extension:,
    extension:,
    id:,
  ) = claim_item
  let fields = [
    #("productOrService", codeableconcept_to_json(product_or_service)),
    #("sequence", json.int(sequence)),
  ]
  let fields = case detail {
    [] -> fields
    _ -> [#("detail", json.array(detail, claim_item_detail_to_json)), ..fields]
  }
  let fields = case encounter {
    [] -> fields
    _ -> [#("encounter", json.array(encounter, reference_to_json)), ..fields]
  }
  let fields = case sub_site {
    [] -> fields
    _ -> [#("subSite", json.array(sub_site, codeableconcept_to_json)), ..fields]
  }
  let fields = case body_site {
    Some(v) -> [#("bodySite", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case udi {
    [] -> fields
    _ -> [#("udi", json.array(udi, reference_to_json)), ..fields]
  }
  let fields = case net {
    Some(v) -> [#("net", money_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case factor {
    Some(v) -> [#("factor", json.float(v)), ..fields]
    None -> fields
  }
  let fields = case unit_price {
    Some(v) -> [#("unitPrice", money_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case quantity {
    Some(v) -> [#("quantity", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case location {
    Some(v) -> [
      #(
        "location"
          <> case v {
          ClaimItemLocationCodeableconcept(_) -> "Codeableconcept"
          ClaimItemLocationAddress(_) -> "Address"
          ClaimItemLocationReference(_) -> "Reference"
        },
        claim_item_location_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case serviced {
    Some(v) -> [
      #(
        "serviced"
          <> case v {
          ClaimItemServicedDate(_) -> "Date"
          ClaimItemServicedPeriod(_) -> "Period"
        },
        claim_item_serviced_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case program_code {
    [] -> fields
    _ -> [
      #("programCode", json.array(program_code, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case modifier {
    [] -> fields
    _ -> [
      #("modifier", json.array(modifier, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case category {
    Some(v) -> [#("category", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case revenue {
    Some(v) -> [#("revenue", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case information_sequence {
    [] -> fields
    _ -> [
      #("informationSequence", json.array(information_sequence, json.int)),
      ..fields
    ]
  }
  let fields = case procedure_sequence {
    [] -> fields
    _ -> [
      #("procedureSequence", json.array(procedure_sequence, json.int)),
      ..fields
    ]
  }
  let fields = case diagnosis_sequence {
    [] -> fields
    _ -> [
      #("diagnosisSequence", json.array(diagnosis_sequence, json.int)),
      ..fields
    ]
  }
  let fields = case care_team_sequence {
    [] -> fields
    _ -> [
      #("careTeamSequence", json.array(care_team_sequence, json.int)),
      ..fields
    ]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn claim_item_decoder() -> Decoder(ClaimItem) {
  use detail <- decode.optional_field(
    "detail",
    [],
    decode.list(claim_item_detail_decoder()),
  )
  use encounter <- decode.optional_field(
    "encounter",
    [],
    decode.list(reference_decoder()),
  )
  use sub_site <- decode.optional_field(
    "subSite",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use body_site <- decode.optional_field(
    "bodySite",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use udi <- decode.optional_field("udi", [], decode.list(reference_decoder()))
  use net <- decode.optional_field(
    "net",
    None,
    decode.optional(money_decoder()),
  )
  use factor <- decode.optional_field(
    "factor",
    None,
    decode.optional(decode.float),
  )
  use unit_price <- decode.optional_field(
    "unitPrice",
    None,
    decode.optional(money_decoder()),
  )
  use quantity <- decode.optional_field(
    "quantity",
    None,
    decode.optional(quantity_decoder()),
  )
  use location <- decode.then(none_if_omitted(claim_item_location_decoder()))
  use serviced <- decode.then(none_if_omitted(claim_item_serviced_decoder()))
  use program_code <- decode.optional_field(
    "programCode",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use modifier <- decode.optional_field(
    "modifier",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use product_or_service <- decode.field(
    "productOrService",
    codeableconcept_decoder(),
  )
  use category <- decode.optional_field(
    "category",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use revenue <- decode.optional_field(
    "revenue",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use information_sequence <- decode.optional_field(
    "informationSequence",
    [],
    decode.list(decode.int),
  )
  use procedure_sequence <- decode.optional_field(
    "procedureSequence",
    [],
    decode.list(decode.int),
  )
  use diagnosis_sequence <- decode.optional_field(
    "diagnosisSequence",
    [],
    decode.list(decode.int),
  )
  use care_team_sequence <- decode.optional_field(
    "careTeamSequence",
    [],
    decode.list(decode.int),
  )
  use sequence <- decode.field("sequence", decode.int)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ClaimItem(
    detail:,
    encounter:,
    sub_site:,
    body_site:,
    udi:,
    net:,
    factor:,
    unit_price:,
    quantity:,
    location:,
    serviced:,
    program_code:,
    modifier:,
    product_or_service:,
    category:,
    revenue:,
    information_sequence:,
    procedure_sequence:,
    diagnosis_sequence:,
    care_team_sequence:,
    sequence:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn claim_accident_to_json(claim_accident: ClaimAccident) -> Json {
  let ClaimAccident(
    location:,
    type_:,
    date:,
    modifier_extension:,
    extension:,
    id:,
  ) = claim_accident
  let fields = [
    #("date", json.string(date)),
  ]
  let fields = case location {
    Some(v) -> [
      #(
        "location"
          <> case v {
          ClaimAccidentLocationAddress(_) -> "Address"
          ClaimAccidentLocationReference(_) -> "Reference"
        },
        claim_accident_location_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn claim_accident_decoder() -> Decoder(ClaimAccident) {
  use location <- decode.then(
    none_if_omitted(claim_accident_location_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use date <- decode.field("date", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ClaimAccident(
    location:,
    type_:,
    date:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn claim_insurance_to_json(claim_insurance: ClaimInsurance) -> Json {
  let ClaimInsurance(
    claim_response:,
    pre_auth_ref:,
    business_arrangement:,
    coverage:,
    identifier:,
    focal:,
    sequence:,
    modifier_extension:,
    extension:,
    id:,
  ) = claim_insurance
  let fields = [
    #("coverage", reference_to_json(coverage)),
    #("focal", json.bool(focal)),
    #("sequence", json.int(sequence)),
  ]
  let fields = case claim_response {
    Some(v) -> [#("claimResponse", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case pre_auth_ref {
    [] -> fields
    _ -> [#("preAuthRef", json.array(pre_auth_ref, json.string)), ..fields]
  }
  let fields = case business_arrangement {
    Some(v) -> [#("businessArrangement", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    Some(v) -> [#("identifier", identifier_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn claim_insurance_decoder() -> Decoder(ClaimInsurance) {
  use claim_response <- decode.optional_field(
    "claimResponse",
    None,
    decode.optional(reference_decoder()),
  )
  use pre_auth_ref <- decode.optional_field(
    "preAuthRef",
    [],
    decode.list(decode.string),
  )
  use business_arrangement <- decode.optional_field(
    "businessArrangement",
    None,
    decode.optional(decode.string),
  )
  use coverage <- decode.field("coverage", reference_decoder())
  use identifier <- decode.optional_field(
    "identifier",
    None,
    decode.optional(identifier_decoder()),
  )
  use focal <- decode.field("focal", decode.bool)
  use sequence <- decode.field("sequence", decode.int)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ClaimInsurance(
    claim_response:,
    pre_auth_ref:,
    business_arrangement:,
    coverage:,
    identifier:,
    focal:,
    sequence:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn claim_procedure_to_json(claim_procedure: ClaimProcedure) -> Json {
  let ClaimProcedure(
    udi:,
    procedure:,
    date:,
    type_:,
    sequence:,
    modifier_extension:,
    extension:,
    id:,
  ) = claim_procedure
  let fields = [
    #("procedure", claim_procedure_procedure_to_json(procedure)),
    #("sequence", json.int(sequence)),
  ]
  let fields = case udi {
    [] -> fields
    _ -> [#("udi", json.array(udi, reference_to_json)), ..fields]
  }
  let fields = case date {
    Some(v) -> [#("date", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    [] -> fields
    _ -> [#("type", json.array(type_, codeableconcept_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn claim_procedure_decoder() -> Decoder(ClaimProcedure) {
  use udi <- decode.optional_field("udi", [], decode.list(reference_decoder()))
  use procedure <- decode.then(claim_procedure_procedure_decoder())
  use date <- decode.optional_field(
    "date",
    None,
    decode.optional(decode.string),
  )
  use type_ <- decode.optional_field(
    "type",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use sequence <- decode.field("sequence", decode.int)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ClaimProcedure(
    udi:,
    procedure:,
    date:,
    type_:,
    sequence:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn claim_diagnosis_to_json(claim_diagnosis: ClaimDiagnosis) -> Json {
  let ClaimDiagnosis(
    package_code:,
    on_admission:,
    type_:,
    diagnosis:,
    sequence:,
    modifier_extension:,
    extension:,
    id:,
  ) = claim_diagnosis
  let fields = [
    #("diagnosis", claim_diagnosis_diagnosis_to_json(diagnosis)),
    #("sequence", json.int(sequence)),
  ]
  let fields = case package_code {
    Some(v) -> [#("packageCode", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case on_admission {
    Some(v) -> [#("onAdmission", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    [] -> fields
    _ -> [#("type", json.array(type_, codeableconcept_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn claim_diagnosis_decoder() -> Decoder(ClaimDiagnosis) {
  use package_code <- decode.optional_field(
    "packageCode",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use on_admission <- decode.optional_field(
    "onAdmission",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use diagnosis <- decode.then(claim_diagnosis_diagnosis_decoder())
  use sequence <- decode.field("sequence", decode.int)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ClaimDiagnosis(
    package_code:,
    on_admission:,
    type_:,
    diagnosis:,
    sequence:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn claim_supportinginfo_to_json(
  claim_supportinginfo: ClaimSupportinginfo,
) -> Json {
  let ClaimSupportinginfo(
    reason:,
    value:,
    timing:,
    code:,
    category:,
    sequence:,
    modifier_extension:,
    extension:,
    id:,
  ) = claim_supportinginfo
  let fields = [
    #("category", codeableconcept_to_json(category)),
    #("sequence", json.int(sequence)),
  ]
  let fields = case reason {
    Some(v) -> [#("reason", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case value {
    Some(v) -> [
      #(
        "value"
          <> case v {
          ClaimSupportinginfoValueBoolean(_) -> "Boolean"
          ClaimSupportinginfoValueString(_) -> "String"
          ClaimSupportinginfoValueQuantity(_) -> "Quantity"
          ClaimSupportinginfoValueAttachment(_) -> "Attachment"
          ClaimSupportinginfoValueReference(_) -> "Reference"
        },
        claim_supportinginfo_value_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case timing {
    Some(v) -> [
      #(
        "timing"
          <> case v {
          ClaimSupportinginfoTimingDate(_) -> "Date"
          ClaimSupportinginfoTimingPeriod(_) -> "Period"
        },
        claim_supportinginfo_timing_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case code {
    Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn claim_supportinginfo_decoder() -> Decoder(ClaimSupportinginfo) {
  use reason <- decode.optional_field(
    "reason",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use value <- decode.then(
    none_if_omitted(claim_supportinginfo_value_decoder()),
  )
  use timing <- decode.then(
    none_if_omitted(claim_supportinginfo_timing_decoder()),
  )
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use category <- decode.field("category", codeableconcept_decoder())
  use sequence <- decode.field("sequence", decode.int)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ClaimSupportinginfo(
    reason:,
    value:,
    timing:,
    code:,
    category:,
    sequence:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn claim_careteam_to_json(claim_careteam: ClaimCareteam) -> Json {
  let ClaimCareteam(
    qualification:,
    role:,
    responsible:,
    provider:,
    sequence:,
    modifier_extension:,
    extension:,
    id:,
  ) = claim_careteam
  let fields = [
    #("provider", reference_to_json(provider)),
    #("sequence", json.int(sequence)),
  ]
  let fields = case qualification {
    Some(v) -> [#("qualification", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case role {
    Some(v) -> [#("role", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case responsible {
    Some(v) -> [#("responsible", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn claim_careteam_decoder() -> Decoder(ClaimCareteam) {
  use qualification <- decode.optional_field(
    "qualification",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use role <- decode.optional_field(
    "role",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use responsible <- decode.optional_field(
    "responsible",
    None,
    decode.optional(decode.bool),
  )
  use provider <- decode.field("provider", reference_decoder())
  use sequence <- decode.field("sequence", decode.int)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ClaimCareteam(
    qualification:,
    role:,
    responsible:,
    provider:,
    sequence:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn claim_payee_to_json(claim_payee: ClaimPayee) -> Json {
  let ClaimPayee(party:, type_:, modifier_extension:, extension:, id:) =
    claim_payee
  let fields = [
    #("type", codeableconcept_to_json(type_)),
  ]
  let fields = case party {
    Some(v) -> [#("party", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn claim_payee_decoder() -> Decoder(ClaimPayee) {
  use party <- decode.optional_field(
    "party",
    None,
    decode.optional(reference_decoder()),
  )
  use type_ <- decode.field("type", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ClaimPayee(
    party:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn claim_related_to_json(claim_related: ClaimRelated) -> Json {
  let ClaimRelated(
    reference:,
    relationship:,
    claim:,
    modifier_extension:,
    extension:,
    id:,
  ) = claim_related
  let fields = []
  let fields = case reference {
    Some(v) -> [#("reference", identifier_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case relationship {
    Some(v) -> [#("relationship", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case claim {
    Some(v) -> [#("claim", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn claim_related_decoder() -> Decoder(ClaimRelated) {
  use reference <- decode.optional_field(
    "reference",
    None,
    decode.optional(identifier_decoder()),
  )
  use relationship <- decode.optional_field(
    "relationship",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use claim <- decode.optional_field(
    "claim",
    None,
    decode.optional(reference_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ClaimRelated(
    reference:,
    relationship:,
    claim:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn claim_to_json(claim: Claim) -> Json {
  let Claim(
    total:,
    item:,
    accident:,
    insurance:,
    procedure:,
    diagnosis:,
    supporting_info:,
    care_team:,
    facility:,
    referral:,
    payee:,
    original_prescription:,
    prescription:,
    related:,
    funds_reserve:,
    priority:,
    provider:,
    insurer:,
    enterer:,
    created:,
    billable_period:,
    patient:,
    use_:,
    sub_type:,
    type_:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = claim
  let fields = [
    #("priority", codeableconcept_to_json(priority)),
    #("provider", reference_to_json(provider)),
    #("created", json.string(created)),
    #("patient", reference_to_json(patient)),
    #("use", r4bvaluesets.claimuse_to_json(use_)),
    #("type", codeableconcept_to_json(type_)),
    #("status", r4bvaluesets.fmstatus_to_json(status)),
  ]
  let fields = case total {
    Some(v) -> [#("total", money_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case item {
    [] -> fields
    _ -> [#("item", json.array(item, claim_item_to_json)), ..fields]
  }
  let fields = case accident {
    Some(v) -> [#("accident", claim_accident_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case insurance {
    [] -> fields
    _ -> [
      #("insurance", json.array(insurance, claim_insurance_to_json)),
      ..fields
    ]
  }
  let fields = case procedure {
    [] -> fields
    _ -> [
      #("procedure", json.array(procedure, claim_procedure_to_json)),
      ..fields
    ]
  }
  let fields = case diagnosis {
    [] -> fields
    _ -> [
      #("diagnosis", json.array(diagnosis, claim_diagnosis_to_json)),
      ..fields
    ]
  }
  let fields = case supporting_info {
    [] -> fields
    _ -> [
      #(
        "supportingInfo",
        json.array(supporting_info, claim_supportinginfo_to_json),
      ),
      ..fields
    ]
  }
  let fields = case care_team {
    [] -> fields
    _ -> [
      #("careTeam", json.array(care_team, claim_careteam_to_json)),
      ..fields
    ]
  }
  let fields = case facility {
    Some(v) -> [#("facility", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case referral {
    Some(v) -> [#("referral", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case payee {
    Some(v) -> [#("payee", claim_payee_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case original_prescription {
    Some(v) -> [#("originalPrescription", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case prescription {
    Some(v) -> [#("prescription", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case related {
    [] -> fields
    _ -> [#("related", json.array(related, claim_related_to_json)), ..fields]
  }
  let fields = case funds_reserve {
    Some(v) -> [#("fundsReserve", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case insurer {
    Some(v) -> [#("insurer", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case enterer {
    Some(v) -> [#("enterer", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case billable_period {
    Some(v) -> [#("billablePeriod", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case sub_type {
    Some(v) -> [#("subType", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Claim")), ..fields]
  json.object(fields)
}

pub fn claim_decoder() -> Decoder(Claim) {
  use total <- decode.optional_field(
    "total",
    None,
    decode.optional(money_decoder()),
  )
  use item <- decode.optional_field(
    "item",
    [],
    decode.list(claim_item_decoder()),
  )
  use accident <- decode.optional_field(
    "accident",
    None,
    decode.optional(claim_accident_decoder()),
  )
  use insurance <- decode.optional_field(
    "insurance",
    [],
    decode.list(claim_insurance_decoder()),
  )
  use procedure <- decode.optional_field(
    "procedure",
    [],
    decode.list(claim_procedure_decoder()),
  )
  use diagnosis <- decode.optional_field(
    "diagnosis",
    [],
    decode.list(claim_diagnosis_decoder()),
  )
  use supporting_info <- decode.optional_field(
    "supportingInfo",
    [],
    decode.list(claim_supportinginfo_decoder()),
  )
  use care_team <- decode.optional_field(
    "careTeam",
    [],
    decode.list(claim_careteam_decoder()),
  )
  use facility <- decode.optional_field(
    "facility",
    None,
    decode.optional(reference_decoder()),
  )
  use referral <- decode.optional_field(
    "referral",
    None,
    decode.optional(reference_decoder()),
  )
  use payee <- decode.optional_field(
    "payee",
    None,
    decode.optional(claim_payee_decoder()),
  )
  use original_prescription <- decode.optional_field(
    "originalPrescription",
    None,
    decode.optional(reference_decoder()),
  )
  use prescription <- decode.optional_field(
    "prescription",
    None,
    decode.optional(reference_decoder()),
  )
  use related <- decode.optional_field(
    "related",
    [],
    decode.list(claim_related_decoder()),
  )
  use funds_reserve <- decode.optional_field(
    "fundsReserve",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use priority <- decode.field("priority", codeableconcept_decoder())
  use provider <- decode.field("provider", reference_decoder())
  use insurer <- decode.optional_field(
    "insurer",
    None,
    decode.optional(reference_decoder()),
  )
  use enterer <- decode.optional_field(
    "enterer",
    None,
    decode.optional(reference_decoder()),
  )
  use created <- decode.field("created", decode.string)
  use billable_period <- decode.optional_field(
    "billablePeriod",
    None,
    decode.optional(period_decoder()),
  )
  use patient <- decode.field("patient", reference_decoder())
  use use_ <- decode.field("use", r4bvaluesets.claimuse_decoder())
  use sub_type <- decode.optional_field(
    "subType",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use type_ <- decode.field("type", codeableconcept_decoder())
  use status <- decode.field("status", r4bvaluesets.fmstatus_decoder())
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Claim",
    decode.failure(
      claim_new(
        priority:,
        provider:,
        created:,
        patient:,
        use_:,
        type_:,
        status:,
      ),
      "resourceType",
    ),
  )
  decode.success(Claim(
    total:,
    item:,
    accident:,
    insurance:,
    procedure:,
    diagnosis:,
    supporting_info:,
    care_team:,
    facility:,
    referral:,
    payee:,
    original_prescription:,
    prescription:,
    related:,
    funds_reserve:,
    priority:,
    provider:,
    insurer:,
    enterer:,
    created:,
    billable_period:,
    patient:,
    use_:,
    sub_type:,
    type_:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/ClaimResponse#resource
pub type Claimresponse {
  Claimresponse(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    status: r4bvaluesets.Fmstatus,
    type_: Codeableconcept,
    sub_type: Option(Codeableconcept),
    use_: r4bvaluesets.Claimuse,
    patient: Reference,
    created: String,
    insurer: Reference,
    requestor: Option(Reference),
    request: Option(Reference),
    outcome: r4bvaluesets.Remittanceoutcome,
    disposition: Option(String),
    pre_auth_ref: Option(String),
    pre_auth_period: Option(Period),
    payee_type: Option(Codeableconcept),
    item: List(ClaimresponseItem),
    add_item: List(ClaimresponseAdditem),
    total: List(ClaimresponseTotal),
    payment: Option(ClaimresponsePayment),
    funds_reserve: Option(Codeableconcept),
    form_code: Option(Codeableconcept),
    form: Option(Attachment),
    process_note: List(ClaimresponseProcessnote),
    communication_request: List(Reference),
    insurance: List(ClaimresponseInsurance),
    error: List(ClaimresponseError),
  )
}

pub fn claimresponse_new(
  outcome outcome: r4bvaluesets.Remittanceoutcome,
  insurer insurer: Reference,
  created created: String,
  patient patient: Reference,
  use_ use_: r4bvaluesets.Claimuse,
  type_ type_: Codeableconcept,
  status status: r4bvaluesets.Fmstatus,
) -> Claimresponse {
  Claimresponse(
    error: [],
    insurance: [],
    communication_request: [],
    process_note: [],
    form: None,
    form_code: None,
    funds_reserve: None,
    payment: None,
    total: [],
    add_item: [],
    item: [],
    payee_type: None,
    pre_auth_period: None,
    pre_auth_ref: None,
    disposition: None,
    outcome:,
    request: None,
    requestor: None,
    insurer:,
    created:,
    patient:,
    use_:,
    sub_type: None,
    type_:,
    status:,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ClaimResponse#resource
pub type ClaimresponseItem {
  ClaimresponseItem(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    item_sequence: Int,
    note_number: List(Int),
    adjudication: List(ClaimresponseItemAdjudication),
    detail: List(ClaimresponseItemDetail),
  )
}

pub fn claimresponse_item_new(
  item_sequence item_sequence: Int,
) -> ClaimresponseItem {
  ClaimresponseItem(
    detail: [],
    adjudication: [],
    note_number: [],
    item_sequence:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ClaimResponse#resource
pub type ClaimresponseItemAdjudication {
  ClaimresponseItemAdjudication(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    category: Codeableconcept,
    reason: Option(Codeableconcept),
    amount: Option(Money),
    value: Option(Float),
  )
}

pub fn claimresponse_item_adjudication_new(
  category category: Codeableconcept,
) -> ClaimresponseItemAdjudication {
  ClaimresponseItemAdjudication(
    value: None,
    amount: None,
    reason: None,
    category:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ClaimResponse#resource
pub type ClaimresponseItemDetail {
  ClaimresponseItemDetail(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    detail_sequence: Int,
    note_number: List(Int),
    sub_detail: List(ClaimresponseItemDetailSubdetail),
  )
}

pub fn claimresponse_item_detail_new(
  detail_sequence detail_sequence: Int,
) -> ClaimresponseItemDetail {
  ClaimresponseItemDetail(
    sub_detail: [],
    note_number: [],
    detail_sequence:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ClaimResponse#resource
pub type ClaimresponseItemDetailSubdetail {
  ClaimresponseItemDetailSubdetail(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    sub_detail_sequence: Int,
    note_number: List(Int),
  )
}

pub fn claimresponse_item_detail_subdetail_new(
  sub_detail_sequence sub_detail_sequence: Int,
) -> ClaimresponseItemDetailSubdetail {
  ClaimresponseItemDetailSubdetail(
    note_number: [],
    sub_detail_sequence:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ClaimResponse#resource
pub type ClaimresponseAdditem {
  ClaimresponseAdditem(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    item_sequence: List(Int),
    detail_sequence: List(Int),
    subdetail_sequence: List(Int),
    provider: List(Reference),
    product_or_service: Codeableconcept,
    modifier: List(Codeableconcept),
    program_code: List(Codeableconcept),
    serviced: Option(ClaimresponseAdditemServiced),
    location: Option(ClaimresponseAdditemLocation),
    quantity: Option(Quantity),
    unit_price: Option(Money),
    factor: Option(Float),
    net: Option(Money),
    body_site: Option(Codeableconcept),
    sub_site: List(Codeableconcept),
    note_number: List(Int),
    detail: List(ClaimresponseAdditemDetail),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ClaimResponse#resource
pub type ClaimresponseAdditemServiced {
  ClaimresponseAdditemServicedDate(serviced: String)
  ClaimresponseAdditemServicedPeriod(serviced: Period)
}

pub fn claimresponse_additem_serviced_to_json(
  elt: ClaimresponseAdditemServiced,
) -> Json {
  case elt {
    ClaimresponseAdditemServicedDate(v) -> json.string(v)
    ClaimresponseAdditemServicedPeriod(v) -> period_to_json(v)
  }
}

pub fn claimresponse_additem_serviced_decoder() -> Decoder(
  ClaimresponseAdditemServiced,
) {
  decode.one_of(
    decode.field("servicedDate", decode.string, decode.success)
      |> decode.map(ClaimresponseAdditemServicedDate),
    [
      decode.field("servicedPeriod", period_decoder(), decode.success)
      |> decode.map(ClaimresponseAdditemServicedPeriod),
    ],
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ClaimResponse#resource
pub type ClaimresponseAdditemLocation {
  ClaimresponseAdditemLocationCodeableconcept(location: Codeableconcept)
  ClaimresponseAdditemLocationAddress(location: Address)
  ClaimresponseAdditemLocationReference(location: Reference)
}

pub fn claimresponse_additem_location_to_json(
  elt: ClaimresponseAdditemLocation,
) -> Json {
  case elt {
    ClaimresponseAdditemLocationCodeableconcept(v) -> codeableconcept_to_json(v)
    ClaimresponseAdditemLocationAddress(v) -> address_to_json(v)
    ClaimresponseAdditemLocationReference(v) -> reference_to_json(v)
  }
}

pub fn claimresponse_additem_location_decoder() -> Decoder(
  ClaimresponseAdditemLocation,
) {
  decode.one_of(
    decode.field(
      "locationCodeableConcept",
      codeableconcept_decoder(),
      decode.success,
    )
      |> decode.map(ClaimresponseAdditemLocationCodeableconcept),
    [
      decode.field("locationAddress", address_decoder(), decode.success)
        |> decode.map(ClaimresponseAdditemLocationAddress),
      decode.field("locationReference", reference_decoder(), decode.success)
        |> decode.map(ClaimresponseAdditemLocationReference),
    ],
  )
}

pub fn claimresponse_additem_new(
  product_or_service product_or_service: Codeableconcept,
) -> ClaimresponseAdditem {
  ClaimresponseAdditem(
    detail: [],
    note_number: [],
    sub_site: [],
    body_site: None,
    net: None,
    factor: None,
    unit_price: None,
    quantity: None,
    location: None,
    serviced: None,
    program_code: [],
    modifier: [],
    product_or_service:,
    provider: [],
    subdetail_sequence: [],
    detail_sequence: [],
    item_sequence: [],
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ClaimResponse#resource
pub type ClaimresponseAdditemDetail {
  ClaimresponseAdditemDetail(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    product_or_service: Codeableconcept,
    modifier: List(Codeableconcept),
    quantity: Option(Quantity),
    unit_price: Option(Money),
    factor: Option(Float),
    net: Option(Money),
    note_number: List(Int),
    sub_detail: List(ClaimresponseAdditemDetailSubdetail),
  )
}

pub fn claimresponse_additem_detail_new(
  product_or_service product_or_service: Codeableconcept,
) -> ClaimresponseAdditemDetail {
  ClaimresponseAdditemDetail(
    sub_detail: [],
    note_number: [],
    net: None,
    factor: None,
    unit_price: None,
    quantity: None,
    modifier: [],
    product_or_service:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ClaimResponse#resource
pub type ClaimresponseAdditemDetailSubdetail {
  ClaimresponseAdditemDetailSubdetail(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    product_or_service: Codeableconcept,
    modifier: List(Codeableconcept),
    quantity: Option(Quantity),
    unit_price: Option(Money),
    factor: Option(Float),
    net: Option(Money),
    note_number: List(Int),
  )
}

pub fn claimresponse_additem_detail_subdetail_new(
  product_or_service product_or_service: Codeableconcept,
) -> ClaimresponseAdditemDetailSubdetail {
  ClaimresponseAdditemDetailSubdetail(
    note_number: [],
    net: None,
    factor: None,
    unit_price: None,
    quantity: None,
    modifier: [],
    product_or_service:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ClaimResponse#resource
pub type ClaimresponseTotal {
  ClaimresponseTotal(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    category: Codeableconcept,
    amount: Money,
  )
}

pub fn claimresponse_total_new(
  amount amount: Money,
  category category: Codeableconcept,
) -> ClaimresponseTotal {
  ClaimresponseTotal(
    amount:,
    category:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ClaimResponse#resource
pub type ClaimresponsePayment {
  ClaimresponsePayment(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Codeableconcept,
    adjustment: Option(Money),
    adjustment_reason: Option(Codeableconcept),
    date: Option(String),
    amount: Money,
    identifier: Option(Identifier),
  )
}

pub fn claimresponse_payment_new(
  amount amount: Money,
  type_ type_: Codeableconcept,
) -> ClaimresponsePayment {
  ClaimresponsePayment(
    identifier: None,
    amount:,
    date: None,
    adjustment_reason: None,
    adjustment: None,
    type_:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ClaimResponse#resource
pub type ClaimresponseProcessnote {
  ClaimresponseProcessnote(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    number: Option(Int),
    type_: Option(r4bvaluesets.Notetype),
    text: String,
    language: Option(Codeableconcept),
  )
}

pub fn claimresponse_processnote_new(
  text text: String,
) -> ClaimresponseProcessnote {
  ClaimresponseProcessnote(
    language: None,
    text:,
    type_: None,
    number: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ClaimResponse#resource
pub type ClaimresponseInsurance {
  ClaimresponseInsurance(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    sequence: Int,
    focal: Bool,
    coverage: Reference,
    business_arrangement: Option(String),
    claim_response: Option(Reference),
  )
}

pub fn claimresponse_insurance_new(
  coverage coverage: Reference,
  focal focal: Bool,
  sequence sequence: Int,
) -> ClaimresponseInsurance {
  ClaimresponseInsurance(
    claim_response: None,
    business_arrangement: None,
    coverage:,
    focal:,
    sequence:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ClaimResponse#resource
pub type ClaimresponseError {
  ClaimresponseError(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    item_sequence: Option(Int),
    detail_sequence: Option(Int),
    sub_detail_sequence: Option(Int),
    code: Codeableconcept,
  )
}

pub fn claimresponse_error_new(code code: Codeableconcept) -> ClaimresponseError {
  ClaimresponseError(
    code:,
    sub_detail_sequence: None,
    detail_sequence: None,
    item_sequence: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn claimresponse_error_to_json(
  claimresponse_error: ClaimresponseError,
) -> Json {
  let ClaimresponseError(
    code:,
    sub_detail_sequence:,
    detail_sequence:,
    item_sequence:,
    modifier_extension:,
    extension:,
    id:,
  ) = claimresponse_error
  let fields = [
    #("code", codeableconcept_to_json(code)),
  ]
  let fields = case sub_detail_sequence {
    Some(v) -> [#("subDetailSequence", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case detail_sequence {
    Some(v) -> [#("detailSequence", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case item_sequence {
    Some(v) -> [#("itemSequence", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn claimresponse_error_decoder() -> Decoder(ClaimresponseError) {
  use code <- decode.field("code", codeableconcept_decoder())
  use sub_detail_sequence <- decode.optional_field(
    "subDetailSequence",
    None,
    decode.optional(decode.int),
  )
  use detail_sequence <- decode.optional_field(
    "detailSequence",
    None,
    decode.optional(decode.int),
  )
  use item_sequence <- decode.optional_field(
    "itemSequence",
    None,
    decode.optional(decode.int),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ClaimresponseError(
    code:,
    sub_detail_sequence:,
    detail_sequence:,
    item_sequence:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn claimresponse_insurance_to_json(
  claimresponse_insurance: ClaimresponseInsurance,
) -> Json {
  let ClaimresponseInsurance(
    claim_response:,
    business_arrangement:,
    coverage:,
    focal:,
    sequence:,
    modifier_extension:,
    extension:,
    id:,
  ) = claimresponse_insurance
  let fields = [
    #("coverage", reference_to_json(coverage)),
    #("focal", json.bool(focal)),
    #("sequence", json.int(sequence)),
  ]
  let fields = case claim_response {
    Some(v) -> [#("claimResponse", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case business_arrangement {
    Some(v) -> [#("businessArrangement", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn claimresponse_insurance_decoder() -> Decoder(ClaimresponseInsurance) {
  use claim_response <- decode.optional_field(
    "claimResponse",
    None,
    decode.optional(reference_decoder()),
  )
  use business_arrangement <- decode.optional_field(
    "businessArrangement",
    None,
    decode.optional(decode.string),
  )
  use coverage <- decode.field("coverage", reference_decoder())
  use focal <- decode.field("focal", decode.bool)
  use sequence <- decode.field("sequence", decode.int)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ClaimresponseInsurance(
    claim_response:,
    business_arrangement:,
    coverage:,
    focal:,
    sequence:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn claimresponse_processnote_to_json(
  claimresponse_processnote: ClaimresponseProcessnote,
) -> Json {
  let ClaimresponseProcessnote(
    language:,
    text:,
    type_:,
    number:,
    modifier_extension:,
    extension:,
    id:,
  ) = claimresponse_processnote
  let fields = [
    #("text", json.string(text)),
  ]
  let fields = case language {
    Some(v) -> [#("language", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", r4bvaluesets.notetype_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case number {
    Some(v) -> [#("number", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn claimresponse_processnote_decoder() -> Decoder(ClaimresponseProcessnote) {
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use text <- decode.field("text", decode.string)
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(r4bvaluesets.notetype_decoder()),
  )
  use number <- decode.optional_field(
    "number",
    None,
    decode.optional(decode.int),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ClaimresponseProcessnote(
    language:,
    text:,
    type_:,
    number:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn claimresponse_payment_to_json(
  claimresponse_payment: ClaimresponsePayment,
) -> Json {
  let ClaimresponsePayment(
    identifier:,
    amount:,
    date:,
    adjustment_reason:,
    adjustment:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = claimresponse_payment
  let fields = [
    #("amount", money_to_json(amount)),
    #("type", codeableconcept_to_json(type_)),
  ]
  let fields = case identifier {
    Some(v) -> [#("identifier", identifier_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case date {
    Some(v) -> [#("date", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case adjustment_reason {
    Some(v) -> [#("adjustmentReason", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case adjustment {
    Some(v) -> [#("adjustment", money_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn claimresponse_payment_decoder() -> Decoder(ClaimresponsePayment) {
  use identifier <- decode.optional_field(
    "identifier",
    None,
    decode.optional(identifier_decoder()),
  )
  use amount <- decode.field("amount", money_decoder())
  use date <- decode.optional_field(
    "date",
    None,
    decode.optional(decode.string),
  )
  use adjustment_reason <- decode.optional_field(
    "adjustmentReason",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use adjustment <- decode.optional_field(
    "adjustment",
    None,
    decode.optional(money_decoder()),
  )
  use type_ <- decode.field("type", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ClaimresponsePayment(
    identifier:,
    amount:,
    date:,
    adjustment_reason:,
    adjustment:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn claimresponse_total_to_json(
  claimresponse_total: ClaimresponseTotal,
) -> Json {
  let ClaimresponseTotal(
    amount:,
    category:,
    modifier_extension:,
    extension:,
    id:,
  ) = claimresponse_total
  let fields = [
    #("amount", money_to_json(amount)),
    #("category", codeableconcept_to_json(category)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn claimresponse_total_decoder() -> Decoder(ClaimresponseTotal) {
  use amount <- decode.field("amount", money_decoder())
  use category <- decode.field("category", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ClaimresponseTotal(
    amount:,
    category:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn claimresponse_additem_detail_subdetail_to_json(
  claimresponse_additem_detail_subdetail: ClaimresponseAdditemDetailSubdetail,
) -> Json {
  let ClaimresponseAdditemDetailSubdetail(
    note_number:,
    net:,
    factor:,
    unit_price:,
    quantity:,
    modifier:,
    product_or_service:,
    modifier_extension:,
    extension:,
    id:,
  ) = claimresponse_additem_detail_subdetail
  let fields = [
    #("productOrService", codeableconcept_to_json(product_or_service)),
  ]
  let fields = case note_number {
    [] -> fields
    _ -> [#("noteNumber", json.array(note_number, json.int)), ..fields]
  }
  let fields = case net {
    Some(v) -> [#("net", money_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case factor {
    Some(v) -> [#("factor", json.float(v)), ..fields]
    None -> fields
  }
  let fields = case unit_price {
    Some(v) -> [#("unitPrice", money_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case quantity {
    Some(v) -> [#("quantity", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier {
    [] -> fields
    _ -> [
      #("modifier", json.array(modifier, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn claimresponse_additem_detail_subdetail_decoder() -> Decoder(
  ClaimresponseAdditemDetailSubdetail,
) {
  use note_number <- decode.optional_field(
    "noteNumber",
    [],
    decode.list(decode.int),
  )
  use net <- decode.optional_field(
    "net",
    None,
    decode.optional(money_decoder()),
  )
  use factor <- decode.optional_field(
    "factor",
    None,
    decode.optional(decode.float),
  )
  use unit_price <- decode.optional_field(
    "unitPrice",
    None,
    decode.optional(money_decoder()),
  )
  use quantity <- decode.optional_field(
    "quantity",
    None,
    decode.optional(quantity_decoder()),
  )
  use modifier <- decode.optional_field(
    "modifier",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use product_or_service <- decode.field(
    "productOrService",
    codeableconcept_decoder(),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ClaimresponseAdditemDetailSubdetail(
    note_number:,
    net:,
    factor:,
    unit_price:,
    quantity:,
    modifier:,
    product_or_service:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn claimresponse_additem_detail_to_json(
  claimresponse_additem_detail: ClaimresponseAdditemDetail,
) -> Json {
  let ClaimresponseAdditemDetail(
    sub_detail:,
    note_number:,
    net:,
    factor:,
    unit_price:,
    quantity:,
    modifier:,
    product_or_service:,
    modifier_extension:,
    extension:,
    id:,
  ) = claimresponse_additem_detail
  let fields = [
    #("productOrService", codeableconcept_to_json(product_or_service)),
  ]
  let fields = case sub_detail {
    [] -> fields
    _ -> [
      #(
        "subDetail",
        json.array(sub_detail, claimresponse_additem_detail_subdetail_to_json),
      ),
      ..fields
    ]
  }
  let fields = case note_number {
    [] -> fields
    _ -> [#("noteNumber", json.array(note_number, json.int)), ..fields]
  }
  let fields = case net {
    Some(v) -> [#("net", money_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case factor {
    Some(v) -> [#("factor", json.float(v)), ..fields]
    None -> fields
  }
  let fields = case unit_price {
    Some(v) -> [#("unitPrice", money_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case quantity {
    Some(v) -> [#("quantity", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier {
    [] -> fields
    _ -> [
      #("modifier", json.array(modifier, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn claimresponse_additem_detail_decoder() -> Decoder(
  ClaimresponseAdditemDetail,
) {
  use sub_detail <- decode.optional_field(
    "subDetail",
    [],
    decode.list(claimresponse_additem_detail_subdetail_decoder()),
  )
  use note_number <- decode.optional_field(
    "noteNumber",
    [],
    decode.list(decode.int),
  )
  use net <- decode.optional_field(
    "net",
    None,
    decode.optional(money_decoder()),
  )
  use factor <- decode.optional_field(
    "factor",
    None,
    decode.optional(decode.float),
  )
  use unit_price <- decode.optional_field(
    "unitPrice",
    None,
    decode.optional(money_decoder()),
  )
  use quantity <- decode.optional_field(
    "quantity",
    None,
    decode.optional(quantity_decoder()),
  )
  use modifier <- decode.optional_field(
    "modifier",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use product_or_service <- decode.field(
    "productOrService",
    codeableconcept_decoder(),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ClaimresponseAdditemDetail(
    sub_detail:,
    note_number:,
    net:,
    factor:,
    unit_price:,
    quantity:,
    modifier:,
    product_or_service:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn claimresponse_additem_to_json(
  claimresponse_additem: ClaimresponseAdditem,
) -> Json {
  let ClaimresponseAdditem(
    detail:,
    note_number:,
    sub_site:,
    body_site:,
    net:,
    factor:,
    unit_price:,
    quantity:,
    location:,
    serviced:,
    program_code:,
    modifier:,
    product_or_service:,
    provider:,
    subdetail_sequence:,
    detail_sequence:,
    item_sequence:,
    modifier_extension:,
    extension:,
    id:,
  ) = claimresponse_additem
  let fields = [
    #("productOrService", codeableconcept_to_json(product_or_service)),
  ]
  let fields = case detail {
    [] -> fields
    _ -> [
      #("detail", json.array(detail, claimresponse_additem_detail_to_json)),
      ..fields
    ]
  }
  let fields = case note_number {
    [] -> fields
    _ -> [#("noteNumber", json.array(note_number, json.int)), ..fields]
  }
  let fields = case sub_site {
    [] -> fields
    _ -> [#("subSite", json.array(sub_site, codeableconcept_to_json)), ..fields]
  }
  let fields = case body_site {
    Some(v) -> [#("bodySite", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case net {
    Some(v) -> [#("net", money_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case factor {
    Some(v) -> [#("factor", json.float(v)), ..fields]
    None -> fields
  }
  let fields = case unit_price {
    Some(v) -> [#("unitPrice", money_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case quantity {
    Some(v) -> [#("quantity", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case location {
    Some(v) -> [
      #(
        "location"
          <> case v {
          ClaimresponseAdditemLocationCodeableconcept(_) -> "Codeableconcept"
          ClaimresponseAdditemLocationAddress(_) -> "Address"
          ClaimresponseAdditemLocationReference(_) -> "Reference"
        },
        claimresponse_additem_location_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case serviced {
    Some(v) -> [
      #(
        "serviced"
          <> case v {
          ClaimresponseAdditemServicedDate(_) -> "Date"
          ClaimresponseAdditemServicedPeriod(_) -> "Period"
        },
        claimresponse_additem_serviced_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case program_code {
    [] -> fields
    _ -> [
      #("programCode", json.array(program_code, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case modifier {
    [] -> fields
    _ -> [
      #("modifier", json.array(modifier, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case provider {
    [] -> fields
    _ -> [#("provider", json.array(provider, reference_to_json)), ..fields]
  }
  let fields = case subdetail_sequence {
    [] -> fields
    _ -> [
      #("subdetailSequence", json.array(subdetail_sequence, json.int)),
      ..fields
    ]
  }
  let fields = case detail_sequence {
    [] -> fields
    _ -> [#("detailSequence", json.array(detail_sequence, json.int)), ..fields]
  }
  let fields = case item_sequence {
    [] -> fields
    _ -> [#("itemSequence", json.array(item_sequence, json.int)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn claimresponse_additem_decoder() -> Decoder(ClaimresponseAdditem) {
  use detail <- decode.optional_field(
    "detail",
    [],
    decode.list(claimresponse_additem_detail_decoder()),
  )
  use note_number <- decode.optional_field(
    "noteNumber",
    [],
    decode.list(decode.int),
  )
  use sub_site <- decode.optional_field(
    "subSite",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use body_site <- decode.optional_field(
    "bodySite",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use net <- decode.optional_field(
    "net",
    None,
    decode.optional(money_decoder()),
  )
  use factor <- decode.optional_field(
    "factor",
    None,
    decode.optional(decode.float),
  )
  use unit_price <- decode.optional_field(
    "unitPrice",
    None,
    decode.optional(money_decoder()),
  )
  use quantity <- decode.optional_field(
    "quantity",
    None,
    decode.optional(quantity_decoder()),
  )
  use location <- decode.then(
    none_if_omitted(claimresponse_additem_location_decoder()),
  )
  use serviced <- decode.then(
    none_if_omitted(claimresponse_additem_serviced_decoder()),
  )
  use program_code <- decode.optional_field(
    "programCode",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use modifier <- decode.optional_field(
    "modifier",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use product_or_service <- decode.field(
    "productOrService",
    codeableconcept_decoder(),
  )
  use provider <- decode.optional_field(
    "provider",
    [],
    decode.list(reference_decoder()),
  )
  use subdetail_sequence <- decode.optional_field(
    "subdetailSequence",
    [],
    decode.list(decode.int),
  )
  use detail_sequence <- decode.optional_field(
    "detailSequence",
    [],
    decode.list(decode.int),
  )
  use item_sequence <- decode.optional_field(
    "itemSequence",
    [],
    decode.list(decode.int),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ClaimresponseAdditem(
    detail:,
    note_number:,
    sub_site:,
    body_site:,
    net:,
    factor:,
    unit_price:,
    quantity:,
    location:,
    serviced:,
    program_code:,
    modifier:,
    product_or_service:,
    provider:,
    subdetail_sequence:,
    detail_sequence:,
    item_sequence:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn claimresponse_item_detail_subdetail_to_json(
  claimresponse_item_detail_subdetail: ClaimresponseItemDetailSubdetail,
) -> Json {
  let ClaimresponseItemDetailSubdetail(
    note_number:,
    sub_detail_sequence:,
    modifier_extension:,
    extension:,
    id:,
  ) = claimresponse_item_detail_subdetail
  let fields = [
    #("subDetailSequence", json.int(sub_detail_sequence)),
  ]
  let fields = case note_number {
    [] -> fields
    _ -> [#("noteNumber", json.array(note_number, json.int)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn claimresponse_item_detail_subdetail_decoder() -> Decoder(
  ClaimresponseItemDetailSubdetail,
) {
  use note_number <- decode.optional_field(
    "noteNumber",
    [],
    decode.list(decode.int),
  )
  use sub_detail_sequence <- decode.field("subDetailSequence", decode.int)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ClaimresponseItemDetailSubdetail(
    note_number:,
    sub_detail_sequence:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn claimresponse_item_detail_to_json(
  claimresponse_item_detail: ClaimresponseItemDetail,
) -> Json {
  let ClaimresponseItemDetail(
    sub_detail:,
    note_number:,
    detail_sequence:,
    modifier_extension:,
    extension:,
    id:,
  ) = claimresponse_item_detail
  let fields = [
    #("detailSequence", json.int(detail_sequence)),
  ]
  let fields = case sub_detail {
    [] -> fields
    _ -> [
      #(
        "subDetail",
        json.array(sub_detail, claimresponse_item_detail_subdetail_to_json),
      ),
      ..fields
    ]
  }
  let fields = case note_number {
    [] -> fields
    _ -> [#("noteNumber", json.array(note_number, json.int)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn claimresponse_item_detail_decoder() -> Decoder(ClaimresponseItemDetail) {
  use sub_detail <- decode.optional_field(
    "subDetail",
    [],
    decode.list(claimresponse_item_detail_subdetail_decoder()),
  )
  use note_number <- decode.optional_field(
    "noteNumber",
    [],
    decode.list(decode.int),
  )
  use detail_sequence <- decode.field("detailSequence", decode.int)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ClaimresponseItemDetail(
    sub_detail:,
    note_number:,
    detail_sequence:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn claimresponse_item_adjudication_to_json(
  claimresponse_item_adjudication: ClaimresponseItemAdjudication,
) -> Json {
  let ClaimresponseItemAdjudication(
    value:,
    amount:,
    reason:,
    category:,
    modifier_extension:,
    extension:,
    id:,
  ) = claimresponse_item_adjudication
  let fields = [
    #("category", codeableconcept_to_json(category)),
  ]
  let fields = case value {
    Some(v) -> [#("value", json.float(v)), ..fields]
    None -> fields
  }
  let fields = case amount {
    Some(v) -> [#("amount", money_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case reason {
    Some(v) -> [#("reason", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn claimresponse_item_adjudication_decoder() -> Decoder(
  ClaimresponseItemAdjudication,
) {
  use value <- decode.optional_field(
    "value",
    None,
    decode.optional(decode.float),
  )
  use amount <- decode.optional_field(
    "amount",
    None,
    decode.optional(money_decoder()),
  )
  use reason <- decode.optional_field(
    "reason",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use category <- decode.field("category", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ClaimresponseItemAdjudication(
    value:,
    amount:,
    reason:,
    category:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn claimresponse_item_to_json(claimresponse_item: ClaimresponseItem) -> Json {
  let ClaimresponseItem(
    detail:,
    adjudication:,
    note_number:,
    item_sequence:,
    modifier_extension:,
    extension:,
    id:,
  ) = claimresponse_item
  let fields = [
    #("itemSequence", json.int(item_sequence)),
  ]
  let fields = case detail {
    [] -> fields
    _ -> [
      #("detail", json.array(detail, claimresponse_item_detail_to_json)),
      ..fields
    ]
  }
  let fields = case adjudication {
    [] -> fields
    _ -> [
      #(
        "adjudication",
        json.array(adjudication, claimresponse_item_adjudication_to_json),
      ),
      ..fields
    ]
  }
  let fields = case note_number {
    [] -> fields
    _ -> [#("noteNumber", json.array(note_number, json.int)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn claimresponse_item_decoder() -> Decoder(ClaimresponseItem) {
  use detail <- decode.optional_field(
    "detail",
    [],
    decode.list(claimresponse_item_detail_decoder()),
  )
  use adjudication <- decode.optional_field(
    "adjudication",
    [],
    decode.list(claimresponse_item_adjudication_decoder()),
  )
  use note_number <- decode.optional_field(
    "noteNumber",
    [],
    decode.list(decode.int),
  )
  use item_sequence <- decode.field("itemSequence", decode.int)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ClaimresponseItem(
    detail:,
    adjudication:,
    note_number:,
    item_sequence:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn claimresponse_to_json(claimresponse: Claimresponse) -> Json {
  let Claimresponse(
    error:,
    insurance:,
    communication_request:,
    process_note:,
    form:,
    form_code:,
    funds_reserve:,
    payment:,
    total:,
    add_item:,
    item:,
    payee_type:,
    pre_auth_period:,
    pre_auth_ref:,
    disposition:,
    outcome:,
    request:,
    requestor:,
    insurer:,
    created:,
    patient:,
    use_:,
    sub_type:,
    type_:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = claimresponse
  let fields = [
    #("outcome", r4bvaluesets.remittanceoutcome_to_json(outcome)),
    #("insurer", reference_to_json(insurer)),
    #("created", json.string(created)),
    #("patient", reference_to_json(patient)),
    #("use", r4bvaluesets.claimuse_to_json(use_)),
    #("type", codeableconcept_to_json(type_)),
    #("status", r4bvaluesets.fmstatus_to_json(status)),
  ]
  let fields = case error {
    [] -> fields
    _ -> [#("error", json.array(error, claimresponse_error_to_json)), ..fields]
  }
  let fields = case insurance {
    [] -> fields
    _ -> [
      #("insurance", json.array(insurance, claimresponse_insurance_to_json)),
      ..fields
    ]
  }
  let fields = case communication_request {
    [] -> fields
    _ -> [
      #(
        "communicationRequest",
        json.array(communication_request, reference_to_json),
      ),
      ..fields
    ]
  }
  let fields = case process_note {
    [] -> fields
    _ -> [
      #(
        "processNote",
        json.array(process_note, claimresponse_processnote_to_json),
      ),
      ..fields
    ]
  }
  let fields = case form {
    Some(v) -> [#("form", attachment_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case form_code {
    Some(v) -> [#("formCode", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case funds_reserve {
    Some(v) -> [#("fundsReserve", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case payment {
    Some(v) -> [#("payment", claimresponse_payment_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case total {
    [] -> fields
    _ -> [#("total", json.array(total, claimresponse_total_to_json)), ..fields]
  }
  let fields = case add_item {
    [] -> fields
    _ -> [
      #("addItem", json.array(add_item, claimresponse_additem_to_json)),
      ..fields
    ]
  }
  let fields = case item {
    [] -> fields
    _ -> [#("item", json.array(item, claimresponse_item_to_json)), ..fields]
  }
  let fields = case payee_type {
    Some(v) -> [#("payeeType", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case pre_auth_period {
    Some(v) -> [#("preAuthPeriod", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case pre_auth_ref {
    Some(v) -> [#("preAuthRef", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case disposition {
    Some(v) -> [#("disposition", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case request {
    Some(v) -> [#("request", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case requestor {
    Some(v) -> [#("requestor", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case sub_type {
    Some(v) -> [#("subType", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Claimresponse")), ..fields]
  json.object(fields)
}

pub fn claimresponse_decoder() -> Decoder(Claimresponse) {
  use error <- decode.optional_field(
    "error",
    [],
    decode.list(claimresponse_error_decoder()),
  )
  use insurance <- decode.optional_field(
    "insurance",
    [],
    decode.list(claimresponse_insurance_decoder()),
  )
  use communication_request <- decode.optional_field(
    "communicationRequest",
    [],
    decode.list(reference_decoder()),
  )
  use process_note <- decode.optional_field(
    "processNote",
    [],
    decode.list(claimresponse_processnote_decoder()),
  )
  use form <- decode.optional_field(
    "form",
    None,
    decode.optional(attachment_decoder()),
  )
  use form_code <- decode.optional_field(
    "formCode",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use funds_reserve <- decode.optional_field(
    "fundsReserve",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use payment <- decode.optional_field(
    "payment",
    None,
    decode.optional(claimresponse_payment_decoder()),
  )
  use total <- decode.optional_field(
    "total",
    [],
    decode.list(claimresponse_total_decoder()),
  )
  use add_item <- decode.optional_field(
    "addItem",
    [],
    decode.list(claimresponse_additem_decoder()),
  )
  use item <- decode.optional_field(
    "item",
    [],
    decode.list(claimresponse_item_decoder()),
  )
  use payee_type <- decode.optional_field(
    "payeeType",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use pre_auth_period <- decode.optional_field(
    "preAuthPeriod",
    None,
    decode.optional(period_decoder()),
  )
  use pre_auth_ref <- decode.optional_field(
    "preAuthRef",
    None,
    decode.optional(decode.string),
  )
  use disposition <- decode.optional_field(
    "disposition",
    None,
    decode.optional(decode.string),
  )
  use outcome <- decode.field(
    "outcome",
    r4bvaluesets.remittanceoutcome_decoder(),
  )
  use request <- decode.optional_field(
    "request",
    None,
    decode.optional(reference_decoder()),
  )
  use requestor <- decode.optional_field(
    "requestor",
    None,
    decode.optional(reference_decoder()),
  )
  use insurer <- decode.field("insurer", reference_decoder())
  use created <- decode.field("created", decode.string)
  use patient <- decode.field("patient", reference_decoder())
  use use_ <- decode.field("use", r4bvaluesets.claimuse_decoder())
  use sub_type <- decode.optional_field(
    "subType",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use type_ <- decode.field("type", codeableconcept_decoder())
  use status <- decode.field("status", r4bvaluesets.fmstatus_decoder())
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Claimresponse",
    decode.failure(
      claimresponse_new(
        outcome:,
        insurer:,
        created:,
        patient:,
        use_:,
        type_:,
        status:,
      ),
      "resourceType",
    ),
  )
  decode.success(Claimresponse(
    error:,
    insurance:,
    communication_request:,
    process_note:,
    form:,
    form_code:,
    funds_reserve:,
    payment:,
    total:,
    add_item:,
    item:,
    payee_type:,
    pre_auth_period:,
    pre_auth_ref:,
    disposition:,
    outcome:,
    request:,
    requestor:,
    insurer:,
    created:,
    patient:,
    use_:,
    sub_type:,
    type_:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/ClinicalImpression#resource
pub type Clinicalimpression {
  Clinicalimpression(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    status: r4bvaluesets.Clinicalimpressionstatus,
    status_reason: Option(Codeableconcept),
    code: Option(Codeableconcept),
    description: Option(String),
    subject: Reference,
    encounter: Option(Reference),
    effective: Option(ClinicalimpressionEffective),
    date: Option(String),
    assessor: Option(Reference),
    previous: Option(Reference),
    problem: List(Reference),
    investigation: List(ClinicalimpressionInvestigation),
    protocol: List(String),
    summary: Option(String),
    finding: List(ClinicalimpressionFinding),
    prognosis_codeable_concept: List(Codeableconcept),
    prognosis_reference: List(Reference),
    supporting_info: List(Reference),
    note: List(Annotation),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ClinicalImpression#resource
pub type ClinicalimpressionEffective {
  ClinicalimpressionEffectiveDatetime(effective: String)
  ClinicalimpressionEffectivePeriod(effective: Period)
}

pub fn clinicalimpression_effective_to_json(
  elt: ClinicalimpressionEffective,
) -> Json {
  case elt {
    ClinicalimpressionEffectiveDatetime(v) -> json.string(v)
    ClinicalimpressionEffectivePeriod(v) -> period_to_json(v)
  }
}

pub fn clinicalimpression_effective_decoder() -> Decoder(
  ClinicalimpressionEffective,
) {
  decode.one_of(
    decode.field("effectiveDateTime", decode.string, decode.success)
      |> decode.map(ClinicalimpressionEffectiveDatetime),
    [
      decode.field("effectivePeriod", period_decoder(), decode.success)
      |> decode.map(ClinicalimpressionEffectivePeriod),
    ],
  )
}

pub fn clinicalimpression_new(
  subject subject: Reference,
  status status: r4bvaluesets.Clinicalimpressionstatus,
) -> Clinicalimpression {
  Clinicalimpression(
    note: [],
    supporting_info: [],
    prognosis_reference: [],
    prognosis_codeable_concept: [],
    finding: [],
    summary: None,
    protocol: [],
    investigation: [],
    problem: [],
    previous: None,
    assessor: None,
    date: None,
    effective: None,
    encounter: None,
    subject:,
    description: None,
    code: None,
    status_reason: None,
    status:,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ClinicalImpression#resource
pub type ClinicalimpressionInvestigation {
  ClinicalimpressionInvestigation(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    code: Codeableconcept,
    item: List(Reference),
  )
}

pub fn clinicalimpression_investigation_new(
  code code: Codeableconcept,
) -> ClinicalimpressionInvestigation {
  ClinicalimpressionInvestigation(
    item: [],
    code:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ClinicalImpression#resource
pub type ClinicalimpressionFinding {
  ClinicalimpressionFinding(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    item_codeable_concept: Option(Codeableconcept),
    item_reference: Option(Reference),
    basis: Option(String),
  )
}

pub fn clinicalimpression_finding_new() -> ClinicalimpressionFinding {
  ClinicalimpressionFinding(
    basis: None,
    item_reference: None,
    item_codeable_concept: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn clinicalimpression_finding_to_json(
  clinicalimpression_finding: ClinicalimpressionFinding,
) -> Json {
  let ClinicalimpressionFinding(
    basis:,
    item_reference:,
    item_codeable_concept:,
    modifier_extension:,
    extension:,
    id:,
  ) = clinicalimpression_finding
  let fields = []
  let fields = case basis {
    Some(v) -> [#("basis", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case item_reference {
    Some(v) -> [#("itemReference", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case item_codeable_concept {
    Some(v) -> [#("itemCodeableConcept", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn clinicalimpression_finding_decoder() -> Decoder(
  ClinicalimpressionFinding,
) {
  use basis <- decode.optional_field(
    "basis",
    None,
    decode.optional(decode.string),
  )
  use item_reference <- decode.optional_field(
    "itemReference",
    None,
    decode.optional(reference_decoder()),
  )
  use item_codeable_concept <- decode.optional_field(
    "itemCodeableConcept",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ClinicalimpressionFinding(
    basis:,
    item_reference:,
    item_codeable_concept:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn clinicalimpression_investigation_to_json(
  clinicalimpression_investigation: ClinicalimpressionInvestigation,
) -> Json {
  let ClinicalimpressionInvestigation(
    item:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ) = clinicalimpression_investigation
  let fields = [
    #("code", codeableconcept_to_json(code)),
  ]
  let fields = case item {
    [] -> fields
    _ -> [#("item", json.array(item, reference_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn clinicalimpression_investigation_decoder() -> Decoder(
  ClinicalimpressionInvestigation,
) {
  use item <- decode.optional_field(
    "item",
    [],
    decode.list(reference_decoder()),
  )
  use code <- decode.field("code", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ClinicalimpressionInvestigation(
    item:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn clinicalimpression_to_json(
  clinicalimpression: Clinicalimpression,
) -> Json {
  let Clinicalimpression(
    note:,
    supporting_info:,
    prognosis_reference:,
    prognosis_codeable_concept:,
    finding:,
    summary:,
    protocol:,
    investigation:,
    problem:,
    previous:,
    assessor:,
    date:,
    effective:,
    encounter:,
    subject:,
    description:,
    code:,
    status_reason:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = clinicalimpression
  let fields = [
    #("subject", reference_to_json(subject)),
    #("status", r4bvaluesets.clinicalimpressionstatus_to_json(status)),
  ]
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case supporting_info {
    [] -> fields
    _ -> [
      #("supportingInfo", json.array(supporting_info, reference_to_json)),
      ..fields
    ]
  }
  let fields = case prognosis_reference {
    [] -> fields
    _ -> [
      #(
        "prognosisReference",
        json.array(prognosis_reference, reference_to_json),
      ),
      ..fields
    ]
  }
  let fields = case prognosis_codeable_concept {
    [] -> fields
    _ -> [
      #(
        "prognosisCodeableConcept",
        json.array(prognosis_codeable_concept, codeableconcept_to_json),
      ),
      ..fields
    ]
  }
  let fields = case finding {
    [] -> fields
    _ -> [
      #("finding", json.array(finding, clinicalimpression_finding_to_json)),
      ..fields
    ]
  }
  let fields = case summary {
    Some(v) -> [#("summary", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case protocol {
    [] -> fields
    _ -> [#("protocol", json.array(protocol, json.string)), ..fields]
  }
  let fields = case investigation {
    [] -> fields
    _ -> [
      #(
        "investigation",
        json.array(investigation, clinicalimpression_investigation_to_json),
      ),
      ..fields
    ]
  }
  let fields = case problem {
    [] -> fields
    _ -> [#("problem", json.array(problem, reference_to_json)), ..fields]
  }
  let fields = case previous {
    Some(v) -> [#("previous", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case assessor {
    Some(v) -> [#("assessor", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case date {
    Some(v) -> [#("date", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case effective {
    Some(v) -> [
      #(
        "effective"
          <> case v {
          ClinicalimpressionEffectiveDatetime(_) -> "Datetime"
          ClinicalimpressionEffectivePeriod(_) -> "Period"
        },
        clinicalimpression_effective_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case encounter {
    Some(v) -> [#("encounter", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case code {
    Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case status_reason {
    Some(v) -> [#("statusReason", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Clinicalimpression")), ..fields]
  json.object(fields)
}

pub fn clinicalimpression_decoder() -> Decoder(Clinicalimpression) {
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use supporting_info <- decode.optional_field(
    "supportingInfo",
    [],
    decode.list(reference_decoder()),
  )
  use prognosis_reference <- decode.optional_field(
    "prognosisReference",
    [],
    decode.list(reference_decoder()),
  )
  use prognosis_codeable_concept <- decode.optional_field(
    "prognosisCodeableConcept",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use finding <- decode.optional_field(
    "finding",
    [],
    decode.list(clinicalimpression_finding_decoder()),
  )
  use summary <- decode.optional_field(
    "summary",
    None,
    decode.optional(decode.string),
  )
  use protocol <- decode.optional_field(
    "protocol",
    [],
    decode.list(decode.string),
  )
  use investigation <- decode.optional_field(
    "investigation",
    [],
    decode.list(clinicalimpression_investigation_decoder()),
  )
  use problem <- decode.optional_field(
    "problem",
    [],
    decode.list(reference_decoder()),
  )
  use previous <- decode.optional_field(
    "previous",
    None,
    decode.optional(reference_decoder()),
  )
  use assessor <- decode.optional_field(
    "assessor",
    None,
    decode.optional(reference_decoder()),
  )
  use date <- decode.optional_field(
    "date",
    None,
    decode.optional(decode.string),
  )
  use effective <- decode.then(
    none_if_omitted(clinicalimpression_effective_decoder()),
  )
  use encounter <- decode.optional_field(
    "encounter",
    None,
    decode.optional(reference_decoder()),
  )
  use subject <- decode.field("subject", reference_decoder())
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use status_reason <- decode.optional_field(
    "statusReason",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use status <- decode.field(
    "status",
    r4bvaluesets.clinicalimpressionstatus_decoder(),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Clinicalimpression",
    decode.failure(clinicalimpression_new(subject:, status:), "resourceType"),
  )
  decode.success(Clinicalimpression(
    note:,
    supporting_info:,
    prognosis_reference:,
    prognosis_codeable_concept:,
    finding:,
    summary:,
    protocol:,
    investigation:,
    problem:,
    previous:,
    assessor:,
    date:,
    effective:,
    encounter:,
    subject:,
    description:,
    code:,
    status_reason:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/ClinicalUseDefinition#resource
pub type Clinicalusedefinition {
  Clinicalusedefinition(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    type_: r4bvaluesets.Clinicalusedefinitiontype,
    category: List(Codeableconcept),
    subject: List(Reference),
    status: Option(Codeableconcept),
    contraindication: Option(ClinicalusedefinitionContraindication),
    indication: Option(ClinicalusedefinitionIndication),
    interaction: Option(ClinicalusedefinitionInteraction),
    population: List(Reference),
    undesirable_effect: Option(ClinicalusedefinitionUndesirableeffect),
    warning: Option(ClinicalusedefinitionWarning),
  )
}

pub fn clinicalusedefinition_new(
  type_ type_: r4bvaluesets.Clinicalusedefinitiontype,
) -> Clinicalusedefinition {
  Clinicalusedefinition(
    warning: None,
    undesirable_effect: None,
    population: [],
    interaction: None,
    indication: None,
    contraindication: None,
    status: None,
    subject: [],
    category: [],
    type_:,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ClinicalUseDefinition#resource
pub type ClinicalusedefinitionContraindication {
  ClinicalusedefinitionContraindication(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    disease_symptom_procedure: Option(Codeablereference),
    disease_status: Option(Codeablereference),
    comorbidity: List(Codeablereference),
    indication: List(Reference),
    other_therapy: List(ClinicalusedefinitionContraindicationOthertherapy),
  )
}

pub fn clinicalusedefinition_contraindication_new() -> ClinicalusedefinitionContraindication {
  ClinicalusedefinitionContraindication(
    other_therapy: [],
    indication: [],
    comorbidity: [],
    disease_status: None,
    disease_symptom_procedure: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ClinicalUseDefinition#resource
pub type ClinicalusedefinitionContraindicationOthertherapy {
  ClinicalusedefinitionContraindicationOthertherapy(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    relationship_type: Codeableconcept,
    therapy: Codeablereference,
  )
}

pub fn clinicalusedefinition_contraindication_othertherapy_new(
  therapy therapy: Codeablereference,
  relationship_type relationship_type: Codeableconcept,
) -> ClinicalusedefinitionContraindicationOthertherapy {
  ClinicalusedefinitionContraindicationOthertherapy(
    therapy:,
    relationship_type:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ClinicalUseDefinition#resource
pub type ClinicalusedefinitionIndication {
  ClinicalusedefinitionIndication(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    disease_symptom_procedure: Option(Codeablereference),
    disease_status: Option(Codeablereference),
    comorbidity: List(Codeablereference),
    intended_effect: Option(Codeablereference),
    duration: Option(ClinicalusedefinitionIndicationDuration),
    undesirable_effect: List(Reference),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ClinicalUseDefinition#resource
pub type ClinicalusedefinitionIndicationDuration {
  ClinicalusedefinitionIndicationDurationRange(duration: Range)
  ClinicalusedefinitionIndicationDurationString(duration: String)
}

pub fn clinicalusedefinition_indication_duration_to_json(
  elt: ClinicalusedefinitionIndicationDuration,
) -> Json {
  case elt {
    ClinicalusedefinitionIndicationDurationRange(v) -> range_to_json(v)
    ClinicalusedefinitionIndicationDurationString(v) -> json.string(v)
  }
}

pub fn clinicalusedefinition_indication_duration_decoder() -> Decoder(
  ClinicalusedefinitionIndicationDuration,
) {
  decode.one_of(
    decode.field("durationRange", range_decoder(), decode.success)
      |> decode.map(ClinicalusedefinitionIndicationDurationRange),
    [
      decode.field("durationString", decode.string, decode.success)
      |> decode.map(ClinicalusedefinitionIndicationDurationString),
    ],
  )
}

pub fn clinicalusedefinition_indication_new() -> ClinicalusedefinitionIndication {
  ClinicalusedefinitionIndication(
    undesirable_effect: [],
    duration: None,
    intended_effect: None,
    comorbidity: [],
    disease_status: None,
    disease_symptom_procedure: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ClinicalUseDefinition#resource
pub type ClinicalusedefinitionInteraction {
  ClinicalusedefinitionInteraction(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    interactant: List(ClinicalusedefinitionInteractionInteractant),
    type_: Option(Codeableconcept),
    effect: Option(Codeablereference),
    incidence: Option(Codeableconcept),
    management: List(Codeableconcept),
  )
}

pub fn clinicalusedefinition_interaction_new() -> ClinicalusedefinitionInteraction {
  ClinicalusedefinitionInteraction(
    management: [],
    incidence: None,
    effect: None,
    type_: None,
    interactant: [],
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ClinicalUseDefinition#resource
pub type ClinicalusedefinitionInteractionInteractant {
  ClinicalusedefinitionInteractionInteractant(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    item: ClinicalusedefinitionInteractionInteractantItem,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ClinicalUseDefinition#resource
pub type ClinicalusedefinitionInteractionInteractantItem {
  ClinicalusedefinitionInteractionInteractantItemReference(item: Reference)
  ClinicalusedefinitionInteractionInteractantItemCodeableconcept(
    item: Codeableconcept,
  )
}

pub fn clinicalusedefinition_interaction_interactant_item_to_json(
  elt: ClinicalusedefinitionInteractionInteractantItem,
) -> Json {
  case elt {
    ClinicalusedefinitionInteractionInteractantItemReference(v) ->
      reference_to_json(v)
    ClinicalusedefinitionInteractionInteractantItemCodeableconcept(v) ->
      codeableconcept_to_json(v)
  }
}

pub fn clinicalusedefinition_interaction_interactant_item_decoder() -> Decoder(
  ClinicalusedefinitionInteractionInteractantItem,
) {
  decode.one_of(
    decode.field("itemReference", reference_decoder(), decode.success)
      |> decode.map(ClinicalusedefinitionInteractionInteractantItemReference),
    [
      decode.field(
        "itemCodeableConcept",
        codeableconcept_decoder(),
        decode.success,
      )
      |> decode.map(
        ClinicalusedefinitionInteractionInteractantItemCodeableconcept,
      ),
    ],
  )
}

pub fn clinicalusedefinition_interaction_interactant_new(
  item item: ClinicalusedefinitionInteractionInteractantItem,
) -> ClinicalusedefinitionInteractionInteractant {
  ClinicalusedefinitionInteractionInteractant(
    item:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ClinicalUseDefinition#resource
pub type ClinicalusedefinitionUndesirableeffect {
  ClinicalusedefinitionUndesirableeffect(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    symptom_condition_effect: Option(Codeablereference),
    classification: Option(Codeableconcept),
    frequency_of_occurrence: Option(Codeableconcept),
  )
}

pub fn clinicalusedefinition_undesirableeffect_new() -> ClinicalusedefinitionUndesirableeffect {
  ClinicalusedefinitionUndesirableeffect(
    frequency_of_occurrence: None,
    classification: None,
    symptom_condition_effect: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ClinicalUseDefinition#resource
pub type ClinicalusedefinitionWarning {
  ClinicalusedefinitionWarning(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    description: Option(String),
    code: Option(Codeableconcept),
  )
}

pub fn clinicalusedefinition_warning_new() -> ClinicalusedefinitionWarning {
  ClinicalusedefinitionWarning(
    code: None,
    description: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn clinicalusedefinition_warning_to_json(
  clinicalusedefinition_warning: ClinicalusedefinitionWarning,
) -> Json {
  let ClinicalusedefinitionWarning(
    code:,
    description:,
    modifier_extension:,
    extension:,
    id:,
  ) = clinicalusedefinition_warning
  let fields = []
  let fields = case code {
    Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn clinicalusedefinition_warning_decoder() -> Decoder(
  ClinicalusedefinitionWarning,
) {
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ClinicalusedefinitionWarning(
    code:,
    description:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn clinicalusedefinition_undesirableeffect_to_json(
  clinicalusedefinition_undesirableeffect: ClinicalusedefinitionUndesirableeffect,
) -> Json {
  let ClinicalusedefinitionUndesirableeffect(
    frequency_of_occurrence:,
    classification:,
    symptom_condition_effect:,
    modifier_extension:,
    extension:,
    id:,
  ) = clinicalusedefinition_undesirableeffect
  let fields = []
  let fields = case frequency_of_occurrence {
    Some(v) -> [
      #("frequencyOfOccurrence", codeableconcept_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case classification {
    Some(v) -> [#("classification", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case symptom_condition_effect {
    Some(v) -> [
      #("symptomConditionEffect", codeablereference_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn clinicalusedefinition_undesirableeffect_decoder() -> Decoder(
  ClinicalusedefinitionUndesirableeffect,
) {
  use frequency_of_occurrence <- decode.optional_field(
    "frequencyOfOccurrence",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use classification <- decode.optional_field(
    "classification",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use symptom_condition_effect <- decode.optional_field(
    "symptomConditionEffect",
    None,
    decode.optional(codeablereference_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ClinicalusedefinitionUndesirableeffect(
    frequency_of_occurrence:,
    classification:,
    symptom_condition_effect:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn clinicalusedefinition_interaction_interactant_to_json(
  clinicalusedefinition_interaction_interactant: ClinicalusedefinitionInteractionInteractant,
) -> Json {
  let ClinicalusedefinitionInteractionInteractant(
    item:,
    modifier_extension:,
    extension:,
    id:,
  ) = clinicalusedefinition_interaction_interactant
  let fields = [
    #("item", clinicalusedefinition_interaction_interactant_item_to_json(item)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn clinicalusedefinition_interaction_interactant_decoder() -> Decoder(
  ClinicalusedefinitionInteractionInteractant,
) {
  use item <- decode.then(
    clinicalusedefinition_interaction_interactant_item_decoder(),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ClinicalusedefinitionInteractionInteractant(
    item:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn clinicalusedefinition_interaction_to_json(
  clinicalusedefinition_interaction: ClinicalusedefinitionInteraction,
) -> Json {
  let ClinicalusedefinitionInteraction(
    management:,
    incidence:,
    effect:,
    type_:,
    interactant:,
    modifier_extension:,
    extension:,
    id:,
  ) = clinicalusedefinition_interaction
  let fields = []
  let fields = case management {
    [] -> fields
    _ -> [
      #("management", json.array(management, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case incidence {
    Some(v) -> [#("incidence", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case effect {
    Some(v) -> [#("effect", codeablereference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case interactant {
    [] -> fields
    _ -> [
      #(
        "interactant",
        json.array(
          interactant,
          clinicalusedefinition_interaction_interactant_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn clinicalusedefinition_interaction_decoder() -> Decoder(
  ClinicalusedefinitionInteraction,
) {
  use management <- decode.optional_field(
    "management",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use incidence <- decode.optional_field(
    "incidence",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use effect <- decode.optional_field(
    "effect",
    None,
    decode.optional(codeablereference_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use interactant <- decode.optional_field(
    "interactant",
    [],
    decode.list(clinicalusedefinition_interaction_interactant_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ClinicalusedefinitionInteraction(
    management:,
    incidence:,
    effect:,
    type_:,
    interactant:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn clinicalusedefinition_indication_to_json(
  clinicalusedefinition_indication: ClinicalusedefinitionIndication,
) -> Json {
  let ClinicalusedefinitionIndication(
    undesirable_effect:,
    duration:,
    intended_effect:,
    comorbidity:,
    disease_status:,
    disease_symptom_procedure:,
    modifier_extension:,
    extension:,
    id:,
  ) = clinicalusedefinition_indication
  let fields = []
  let fields = case undesirable_effect {
    [] -> fields
    _ -> [
      #("undesirableEffect", json.array(undesirable_effect, reference_to_json)),
      ..fields
    ]
  }
  let fields = case duration {
    Some(v) -> [
      #(
        "duration"
          <> case v {
          ClinicalusedefinitionIndicationDurationRange(_) -> "Range"
          ClinicalusedefinitionIndicationDurationString(_) -> "String"
        },
        clinicalusedefinition_indication_duration_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case intended_effect {
    Some(v) -> [#("intendedEffect", codeablereference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case comorbidity {
    [] -> fields
    _ -> [
      #("comorbidity", json.array(comorbidity, codeablereference_to_json)),
      ..fields
    ]
  }
  let fields = case disease_status {
    Some(v) -> [#("diseaseStatus", codeablereference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case disease_symptom_procedure {
    Some(v) -> [
      #("diseaseSymptomProcedure", codeablereference_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn clinicalusedefinition_indication_decoder() -> Decoder(
  ClinicalusedefinitionIndication,
) {
  use undesirable_effect <- decode.optional_field(
    "undesirableEffect",
    [],
    decode.list(reference_decoder()),
  )
  use duration <- decode.then(
    none_if_omitted(clinicalusedefinition_indication_duration_decoder()),
  )
  use intended_effect <- decode.optional_field(
    "intendedEffect",
    None,
    decode.optional(codeablereference_decoder()),
  )
  use comorbidity <- decode.optional_field(
    "comorbidity",
    [],
    decode.list(codeablereference_decoder()),
  )
  use disease_status <- decode.optional_field(
    "diseaseStatus",
    None,
    decode.optional(codeablereference_decoder()),
  )
  use disease_symptom_procedure <- decode.optional_field(
    "diseaseSymptomProcedure",
    None,
    decode.optional(codeablereference_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ClinicalusedefinitionIndication(
    undesirable_effect:,
    duration:,
    intended_effect:,
    comorbidity:,
    disease_status:,
    disease_symptom_procedure:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn clinicalusedefinition_contraindication_othertherapy_to_json(
  clinicalusedefinition_contraindication_othertherapy: ClinicalusedefinitionContraindicationOthertherapy,
) -> Json {
  let ClinicalusedefinitionContraindicationOthertherapy(
    therapy:,
    relationship_type:,
    modifier_extension:,
    extension:,
    id:,
  ) = clinicalusedefinition_contraindication_othertherapy
  let fields = [
    #("therapy", codeablereference_to_json(therapy)),
    #("relationshipType", codeableconcept_to_json(relationship_type)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn clinicalusedefinition_contraindication_othertherapy_decoder() -> Decoder(
  ClinicalusedefinitionContraindicationOthertherapy,
) {
  use therapy <- decode.field("therapy", codeablereference_decoder())
  use relationship_type <- decode.field(
    "relationshipType",
    codeableconcept_decoder(),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ClinicalusedefinitionContraindicationOthertherapy(
    therapy:,
    relationship_type:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn clinicalusedefinition_contraindication_to_json(
  clinicalusedefinition_contraindication: ClinicalusedefinitionContraindication,
) -> Json {
  let ClinicalusedefinitionContraindication(
    other_therapy:,
    indication:,
    comorbidity:,
    disease_status:,
    disease_symptom_procedure:,
    modifier_extension:,
    extension:,
    id:,
  ) = clinicalusedefinition_contraindication
  let fields = []
  let fields = case other_therapy {
    [] -> fields
    _ -> [
      #(
        "otherTherapy",
        json.array(
          other_therapy,
          clinicalusedefinition_contraindication_othertherapy_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case indication {
    [] -> fields
    _ -> [#("indication", json.array(indication, reference_to_json)), ..fields]
  }
  let fields = case comorbidity {
    [] -> fields
    _ -> [
      #("comorbidity", json.array(comorbidity, codeablereference_to_json)),
      ..fields
    ]
  }
  let fields = case disease_status {
    Some(v) -> [#("diseaseStatus", codeablereference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case disease_symptom_procedure {
    Some(v) -> [
      #("diseaseSymptomProcedure", codeablereference_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn clinicalusedefinition_contraindication_decoder() -> Decoder(
  ClinicalusedefinitionContraindication,
) {
  use other_therapy <- decode.optional_field(
    "otherTherapy",
    [],
    decode.list(clinicalusedefinition_contraindication_othertherapy_decoder()),
  )
  use indication <- decode.optional_field(
    "indication",
    [],
    decode.list(reference_decoder()),
  )
  use comorbidity <- decode.optional_field(
    "comorbidity",
    [],
    decode.list(codeablereference_decoder()),
  )
  use disease_status <- decode.optional_field(
    "diseaseStatus",
    None,
    decode.optional(codeablereference_decoder()),
  )
  use disease_symptom_procedure <- decode.optional_field(
    "diseaseSymptomProcedure",
    None,
    decode.optional(codeablereference_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ClinicalusedefinitionContraindication(
    other_therapy:,
    indication:,
    comorbidity:,
    disease_status:,
    disease_symptom_procedure:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn clinicalusedefinition_to_json(
  clinicalusedefinition: Clinicalusedefinition,
) -> Json {
  let Clinicalusedefinition(
    warning:,
    undesirable_effect:,
    population:,
    interaction:,
    indication:,
    contraindication:,
    status:,
    subject:,
    category:,
    type_:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = clinicalusedefinition
  let fields = [
    #("type", r4bvaluesets.clinicalusedefinitiontype_to_json(type_)),
  ]
  let fields = case warning {
    Some(v) -> [
      #("warning", clinicalusedefinition_warning_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case undesirable_effect {
    Some(v) -> [
      #("undesirableEffect", clinicalusedefinition_undesirableeffect_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case population {
    [] -> fields
    _ -> [#("population", json.array(population, reference_to_json)), ..fields]
  }
  let fields = case interaction {
    Some(v) -> [
      #("interaction", clinicalusedefinition_interaction_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case indication {
    Some(v) -> [
      #("indication", clinicalusedefinition_indication_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case contraindication {
    Some(v) -> [
      #("contraindication", clinicalusedefinition_contraindication_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case status {
    Some(v) -> [#("status", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case subject {
    [] -> fields
    _ -> [#("subject", json.array(subject, reference_to_json)), ..fields]
  }
  let fields = case category {
    [] -> fields
    _ -> [
      #("category", json.array(category, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [
    #("resourceType", json.string("Clinicalusedefinition")),
    ..fields
  ]
  json.object(fields)
}

pub fn clinicalusedefinition_decoder() -> Decoder(Clinicalusedefinition) {
  use warning <- decode.optional_field(
    "warning",
    None,
    decode.optional(clinicalusedefinition_warning_decoder()),
  )
  use undesirable_effect <- decode.optional_field(
    "undesirableEffect",
    None,
    decode.optional(clinicalusedefinition_undesirableeffect_decoder()),
  )
  use population <- decode.optional_field(
    "population",
    [],
    decode.list(reference_decoder()),
  )
  use interaction <- decode.optional_field(
    "interaction",
    None,
    decode.optional(clinicalusedefinition_interaction_decoder()),
  )
  use indication <- decode.optional_field(
    "indication",
    None,
    decode.optional(clinicalusedefinition_indication_decoder()),
  )
  use contraindication <- decode.optional_field(
    "contraindication",
    None,
    decode.optional(clinicalusedefinition_contraindication_decoder()),
  )
  use status <- decode.optional_field(
    "status",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use subject <- decode.optional_field(
    "subject",
    [],
    decode.list(reference_decoder()),
  )
  use category <- decode.optional_field(
    "category",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use type_ <- decode.field(
    "type",
    r4bvaluesets.clinicalusedefinitiontype_decoder(),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Clinicalusedefinition",
    decode.failure(clinicalusedefinition_new(type_:), "resourceType"),
  )
  decode.success(Clinicalusedefinition(
    warning:,
    undesirable_effect:,
    population:,
    interaction:,
    indication:,
    contraindication:,
    status:,
    subject:,
    category:,
    type_:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/CodeSystem#resource
pub type Codesystem {
  Codesystem(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    url: Option(String),
    identifier: List(Identifier),
    version: Option(String),
    name: Option(String),
    title: Option(String),
    status: r4bvaluesets.Publicationstatus,
    experimental: Option(Bool),
    date: Option(String),
    publisher: Option(String),
    contact: List(Contactdetail),
    description: Option(String),
    use_context: List(Usagecontext),
    jurisdiction: List(Codeableconcept),
    purpose: Option(String),
    copyright: Option(String),
    case_sensitive: Option(Bool),
    value_set: Option(String),
    hierarchy_meaning: Option(r4bvaluesets.Codesystemhierarchymeaning),
    compositional: Option(Bool),
    version_needed: Option(Bool),
    content: r4bvaluesets.Codesystemcontentmode,
    supplements: Option(String),
    count: Option(Int),
    filter: List(CodesystemFilter),
    property: List(CodesystemProperty),
    concept: List(CodesystemConcept),
  )
}

pub fn codesystem_new(
  content content: r4bvaluesets.Codesystemcontentmode,
  status status: r4bvaluesets.Publicationstatus,
) -> Codesystem {
  Codesystem(
    concept: [],
    property: [],
    filter: [],
    count: None,
    supplements: None,
    content:,
    version_needed: None,
    compositional: None,
    hierarchy_meaning: None,
    value_set: None,
    case_sensitive: None,
    copyright: None,
    purpose: None,
    jurisdiction: [],
    use_context: [],
    description: None,
    contact: [],
    publisher: None,
    date: None,
    experimental: None,
    status:,
    title: None,
    name: None,
    version: None,
    identifier: [],
    url: None,
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/CodeSystem#resource
pub type CodesystemFilter {
  CodesystemFilter(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    code: String,
    description: Option(String),
    operator: List(r4bvaluesets.Filteroperator),
    value: String,
  )
}

pub fn codesystem_filter_new(
  value value: String,
  code code: String,
) -> CodesystemFilter {
  CodesystemFilter(
    value:,
    operator: [],
    description: None,
    code:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/CodeSystem#resource
pub type CodesystemProperty {
  CodesystemProperty(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    code: String,
    uri: Option(String),
    description: Option(String),
    type_: r4bvaluesets.Conceptpropertytype,
  )
}

pub fn codesystem_property_new(
  type_ type_: r4bvaluesets.Conceptpropertytype,
  code code: String,
) -> CodesystemProperty {
  CodesystemProperty(
    type_:,
    description: None,
    uri: None,
    code:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/CodeSystem#resource
pub type CodesystemConcept {
  CodesystemConcept(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    code: String,
    display: Option(String),
    definition: Option(String),
    designation: List(CodesystemConceptDesignation),
    property: List(CodesystemConceptProperty),
  )
}

pub fn codesystem_concept_new(code code: String) -> CodesystemConcept {
  CodesystemConcept(
    property: [],
    designation: [],
    definition: None,
    display: None,
    code:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/CodeSystem#resource
pub type CodesystemConceptDesignation {
  CodesystemConceptDesignation(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    language: Option(String),
    use_: Option(Coding),
    value: String,
  )
}

pub fn codesystem_concept_designation_new(
  value value: String,
) -> CodesystemConceptDesignation {
  CodesystemConceptDesignation(
    value:,
    use_: None,
    language: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/CodeSystem#resource
pub type CodesystemConceptProperty {
  CodesystemConceptProperty(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    code: String,
    value: CodesystemConceptPropertyValue,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/CodeSystem#resource
pub type CodesystemConceptPropertyValue {
  CodesystemConceptPropertyValueCode(value: String)
  CodesystemConceptPropertyValueCoding(value: Coding)
  CodesystemConceptPropertyValueString(value: String)
  CodesystemConceptPropertyValueInteger(value: Int)
  CodesystemConceptPropertyValueBoolean(value: Bool)
  CodesystemConceptPropertyValueDatetime(value: String)
  CodesystemConceptPropertyValueDecimal(value: Float)
}

pub fn codesystem_concept_property_value_to_json(
  elt: CodesystemConceptPropertyValue,
) -> Json {
  case elt {
    CodesystemConceptPropertyValueCode(v) -> json.string(v)
    CodesystemConceptPropertyValueCoding(v) -> coding_to_json(v)
    CodesystemConceptPropertyValueString(v) -> json.string(v)
    CodesystemConceptPropertyValueInteger(v) -> json.int(v)
    CodesystemConceptPropertyValueBoolean(v) -> json.bool(v)
    CodesystemConceptPropertyValueDatetime(v) -> json.string(v)
    CodesystemConceptPropertyValueDecimal(v) -> json.float(v)
  }
}

pub fn codesystem_concept_property_value_decoder() -> Decoder(
  CodesystemConceptPropertyValue,
) {
  decode.one_of(
    decode.field("valueCode", decode.string, decode.success)
      |> decode.map(CodesystemConceptPropertyValueCode),
    [
      decode.field("valueCoding", coding_decoder(), decode.success)
        |> decode.map(CodesystemConceptPropertyValueCoding),
      decode.field("valueString", decode.string, decode.success)
        |> decode.map(CodesystemConceptPropertyValueString),
      decode.field("valueInteger", decode.int, decode.success)
        |> decode.map(CodesystemConceptPropertyValueInteger),
      decode.field("valueBoolean", decode.bool, decode.success)
        |> decode.map(CodesystemConceptPropertyValueBoolean),
      decode.field("valueDateTime", decode.string, decode.success)
        |> decode.map(CodesystemConceptPropertyValueDatetime),
      decode.field("valueDecimal", decode.float, decode.success)
        |> decode.map(CodesystemConceptPropertyValueDecimal),
    ],
  )
}

pub fn codesystem_concept_property_new(
  value value: CodesystemConceptPropertyValue,
  code code: String,
) -> CodesystemConceptProperty {
  CodesystemConceptProperty(
    value:,
    code:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn codesystem_concept_property_to_json(
  codesystem_concept_property: CodesystemConceptProperty,
) -> Json {
  let CodesystemConceptProperty(
    value:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ) = codesystem_concept_property
  let fields = [
    #("value", codesystem_concept_property_value_to_json(value)),
    #("code", json.string(code)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn codesystem_concept_property_decoder() -> Decoder(
  CodesystemConceptProperty,
) {
  use value <- decode.then(codesystem_concept_property_value_decoder())
  use code <- decode.field("code", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CodesystemConceptProperty(
    value:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn codesystem_concept_designation_to_json(
  codesystem_concept_designation: CodesystemConceptDesignation,
) -> Json {
  let CodesystemConceptDesignation(
    value:,
    use_:,
    language:,
    modifier_extension:,
    extension:,
    id:,
  ) = codesystem_concept_designation
  let fields = [
    #("value", json.string(value)),
  ]
  let fields = case use_ {
    Some(v) -> [#("use", coding_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn codesystem_concept_designation_decoder() -> Decoder(
  CodesystemConceptDesignation,
) {
  use value <- decode.field("value", decode.string)
  use use_ <- decode.optional_field(
    "use",
    None,
    decode.optional(coding_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CodesystemConceptDesignation(
    value:,
    use_:,
    language:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn codesystem_concept_to_json(codesystem_concept: CodesystemConcept) -> Json {
  let CodesystemConcept(
    property:,
    designation:,
    definition:,
    display:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ) = codesystem_concept
  let fields = [
    #("code", json.string(code)),
  ]
  let fields = case property {
    [] -> fields
    _ -> [
      #("property", json.array(property, codesystem_concept_property_to_json)),
      ..fields
    ]
  }
  let fields = case designation {
    [] -> fields
    _ -> [
      #(
        "designation",
        json.array(designation, codesystem_concept_designation_to_json),
      ),
      ..fields
    ]
  }
  let fields = case definition {
    Some(v) -> [#("definition", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case display {
    Some(v) -> [#("display", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn codesystem_concept_decoder() -> Decoder(CodesystemConcept) {
  use property <- decode.optional_field(
    "property",
    [],
    decode.list(codesystem_concept_property_decoder()),
  )
  use designation <- decode.optional_field(
    "designation",
    [],
    decode.list(codesystem_concept_designation_decoder()),
  )
  use definition <- decode.optional_field(
    "definition",
    None,
    decode.optional(decode.string),
  )
  use display <- decode.optional_field(
    "display",
    None,
    decode.optional(decode.string),
  )
  use code <- decode.field("code", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CodesystemConcept(
    property:,
    designation:,
    definition:,
    display:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn codesystem_property_to_json(
  codesystem_property: CodesystemProperty,
) -> Json {
  let CodesystemProperty(
    type_:,
    description:,
    uri:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ) = codesystem_property
  let fields = [
    #("type", r4bvaluesets.conceptpropertytype_to_json(type_)),
    #("code", json.string(code)),
  ]
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case uri {
    Some(v) -> [#("uri", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn codesystem_property_decoder() -> Decoder(CodesystemProperty) {
  use type_ <- decode.field("type", r4bvaluesets.conceptpropertytype_decoder())
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use uri <- decode.optional_field("uri", None, decode.optional(decode.string))
  use code <- decode.field("code", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CodesystemProperty(
    type_:,
    description:,
    uri:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn codesystem_filter_to_json(codesystem_filter: CodesystemFilter) -> Json {
  let CodesystemFilter(
    value:,
    operator:,
    description:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ) = codesystem_filter
  let fields = [
    #("value", json.string(value)),
    #("code", json.string(code)),
  ]
  let fields = case operator {
    [] -> fields
    _ -> [
      #("operator", json.array(operator, r4bvaluesets.filteroperator_to_json)),
      ..fields
    ]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn codesystem_filter_decoder() -> Decoder(CodesystemFilter) {
  use value <- decode.field("value", decode.string)
  use operator <- decode.optional_field(
    "operator",
    [],
    decode.list(r4bvaluesets.filteroperator_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use code <- decode.field("code", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CodesystemFilter(
    value:,
    operator:,
    description:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn codesystem_to_json(codesystem: Codesystem) -> Json {
  let Codesystem(
    concept:,
    property:,
    filter:,
    count:,
    supplements:,
    content:,
    version_needed:,
    compositional:,
    hierarchy_meaning:,
    value_set:,
    case_sensitive:,
    copyright:,
    purpose:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    experimental:,
    status:,
    title:,
    name:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = codesystem
  let fields = [
    #("content", r4bvaluesets.codesystemcontentmode_to_json(content)),
    #("status", r4bvaluesets.publicationstatus_to_json(status)),
  ]
  let fields = case concept {
    [] -> fields
    _ -> [
      #("concept", json.array(concept, codesystem_concept_to_json)),
      ..fields
    ]
  }
  let fields = case property {
    [] -> fields
    _ -> [
      #("property", json.array(property, codesystem_property_to_json)),
      ..fields
    ]
  }
  let fields = case filter {
    [] -> fields
    _ -> [#("filter", json.array(filter, codesystem_filter_to_json)), ..fields]
  }
  let fields = case count {
    Some(v) -> [#("count", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case supplements {
    Some(v) -> [#("supplements", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case version_needed {
    Some(v) -> [#("versionNeeded", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case compositional {
    Some(v) -> [#("compositional", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case hierarchy_meaning {
    Some(v) -> [
      #("hierarchyMeaning", r4bvaluesets.codesystemhierarchymeaning_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case value_set {
    Some(v) -> [#("valueSet", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case case_sensitive {
    Some(v) -> [#("caseSensitive", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case copyright {
    Some(v) -> [#("copyright", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case purpose {
    Some(v) -> [#("purpose", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case jurisdiction {
    [] -> fields
    _ -> [
      #("jurisdiction", json.array(jurisdiction, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case use_context {
    [] -> fields
    _ -> [
      #("useContext", json.array(use_context, usagecontext_to_json)),
      ..fields
    ]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case contact {
    [] -> fields
    _ -> [#("contact", json.array(contact, contactdetail_to_json)), ..fields]
  }
  let fields = case publisher {
    Some(v) -> [#("publisher", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case date {
    Some(v) -> [#("date", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case experimental {
    Some(v) -> [#("experimental", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case title {
    Some(v) -> [#("title", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case version {
    Some(v) -> [#("version", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case url {
    Some(v) -> [#("url", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Codesystem")), ..fields]
  json.object(fields)
}

pub fn codesystem_decoder() -> Decoder(Codesystem) {
  use concept <- decode.optional_field(
    "concept",
    [],
    decode.list(codesystem_concept_decoder()),
  )
  use property <- decode.optional_field(
    "property",
    [],
    decode.list(codesystem_property_decoder()),
  )
  use filter <- decode.optional_field(
    "filter",
    [],
    decode.list(codesystem_filter_decoder()),
  )
  use count <- decode.optional_field("count", None, decode.optional(decode.int))
  use supplements <- decode.optional_field(
    "supplements",
    None,
    decode.optional(decode.string),
  )
  use content <- decode.field(
    "content",
    r4bvaluesets.codesystemcontentmode_decoder(),
  )
  use version_needed <- decode.optional_field(
    "versionNeeded",
    None,
    decode.optional(decode.bool),
  )
  use compositional <- decode.optional_field(
    "compositional",
    None,
    decode.optional(decode.bool),
  )
  use hierarchy_meaning <- decode.optional_field(
    "hierarchyMeaning",
    None,
    decode.optional(r4bvaluesets.codesystemhierarchymeaning_decoder()),
  )
  use value_set <- decode.optional_field(
    "valueSet",
    None,
    decode.optional(decode.string),
  )
  use case_sensitive <- decode.optional_field(
    "caseSensitive",
    None,
    decode.optional(decode.bool),
  )
  use copyright <- decode.optional_field(
    "copyright",
    None,
    decode.optional(decode.string),
  )
  use purpose <- decode.optional_field(
    "purpose",
    None,
    decode.optional(decode.string),
  )
  use jurisdiction <- decode.optional_field(
    "jurisdiction",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use use_context <- decode.optional_field(
    "useContext",
    [],
    decode.list(usagecontext_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use contact <- decode.optional_field(
    "contact",
    [],
    decode.list(contactdetail_decoder()),
  )
  use publisher <- decode.optional_field(
    "publisher",
    None,
    decode.optional(decode.string),
  )
  use date <- decode.optional_field(
    "date",
    None,
    decode.optional(decode.string),
  )
  use experimental <- decode.optional_field(
    "experimental",
    None,
    decode.optional(decode.bool),
  )
  use status <- decode.field("status", r4bvaluesets.publicationstatus_decoder())
  use title <- decode.optional_field(
    "title",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use version <- decode.optional_field(
    "version",
    None,
    decode.optional(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use url <- decode.optional_field("url", None, decode.optional(decode.string))
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Codesystem",
    decode.failure(codesystem_new(content:, status:), "resourceType"),
  )
  decode.success(Codesystem(
    concept:,
    property:,
    filter:,
    count:,
    supplements:,
    content:,
    version_needed:,
    compositional:,
    hierarchy_meaning:,
    value_set:,
    case_sensitive:,
    copyright:,
    purpose:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    experimental:,
    status:,
    title:,
    name:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/Communication#resource
pub type Communication {
  Communication(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    instantiates_canonical: List(String),
    instantiates_uri: List(String),
    based_on: List(Reference),
    part_of: List(Reference),
    in_response_to: List(Reference),
    status: r4bvaluesets.Eventstatus,
    status_reason: Option(Codeableconcept),
    category: List(Codeableconcept),
    priority: Option(r4bvaluesets.Requestpriority),
    medium: List(Codeableconcept),
    subject: Option(Reference),
    topic: Option(Codeableconcept),
    about: List(Reference),
    encounter: Option(Reference),
    sent: Option(String),
    received: Option(String),
    recipient: List(Reference),
    sender: Option(Reference),
    reason_code: List(Codeableconcept),
    reason_reference: List(Reference),
    payload: List(CommunicationPayload),
    note: List(Annotation),
  )
}

pub fn communication_new(
  status status: r4bvaluesets.Eventstatus,
) -> Communication {
  Communication(
    note: [],
    payload: [],
    reason_reference: [],
    reason_code: [],
    sender: None,
    recipient: [],
    received: None,
    sent: None,
    encounter: None,
    about: [],
    topic: None,
    subject: None,
    medium: [],
    priority: None,
    category: [],
    status_reason: None,
    status:,
    in_response_to: [],
    part_of: [],
    based_on: [],
    instantiates_uri: [],
    instantiates_canonical: [],
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Communication#resource
pub type CommunicationPayload {
  CommunicationPayload(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    content: CommunicationPayloadContent,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Communication#resource
pub type CommunicationPayloadContent {
  CommunicationPayloadContentString(content: String)
  CommunicationPayloadContentAttachment(content: Attachment)
  CommunicationPayloadContentReference(content: Reference)
}

pub fn communication_payload_content_to_json(
  elt: CommunicationPayloadContent,
) -> Json {
  case elt {
    CommunicationPayloadContentString(v) -> json.string(v)
    CommunicationPayloadContentAttachment(v) -> attachment_to_json(v)
    CommunicationPayloadContentReference(v) -> reference_to_json(v)
  }
}

pub fn communication_payload_content_decoder() -> Decoder(
  CommunicationPayloadContent,
) {
  decode.one_of(
    decode.field("contentString", decode.string, decode.success)
      |> decode.map(CommunicationPayloadContentString),
    [
      decode.field("contentAttachment", attachment_decoder(), decode.success)
        |> decode.map(CommunicationPayloadContentAttachment),
      decode.field("contentReference", reference_decoder(), decode.success)
        |> decode.map(CommunicationPayloadContentReference),
    ],
  )
}

pub fn communication_payload_new(
  content content: CommunicationPayloadContent,
) -> CommunicationPayload {
  CommunicationPayload(
    content:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn communication_payload_to_json(
  communication_payload: CommunicationPayload,
) -> Json {
  let CommunicationPayload(content:, modifier_extension:, extension:, id:) =
    communication_payload
  let fields = [
    #("content", communication_payload_content_to_json(content)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn communication_payload_decoder() -> Decoder(CommunicationPayload) {
  use content <- decode.then(communication_payload_content_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CommunicationPayload(
    content:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn communication_to_json(communication: Communication) -> Json {
  let Communication(
    note:,
    payload:,
    reason_reference:,
    reason_code:,
    sender:,
    recipient:,
    received:,
    sent:,
    encounter:,
    about:,
    topic:,
    subject:,
    medium:,
    priority:,
    category:,
    status_reason:,
    status:,
    in_response_to:,
    part_of:,
    based_on:,
    instantiates_uri:,
    instantiates_canonical:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = communication
  let fields = [
    #("status", r4bvaluesets.eventstatus_to_json(status)),
  ]
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case payload {
    [] -> fields
    _ -> [
      #("payload", json.array(payload, communication_payload_to_json)),
      ..fields
    ]
  }
  let fields = case reason_reference {
    [] -> fields
    _ -> [
      #("reasonReference", json.array(reason_reference, reference_to_json)),
      ..fields
    ]
  }
  let fields = case reason_code {
    [] -> fields
    _ -> [
      #("reasonCode", json.array(reason_code, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case sender {
    Some(v) -> [#("sender", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case recipient {
    [] -> fields
    _ -> [#("recipient", json.array(recipient, reference_to_json)), ..fields]
  }
  let fields = case received {
    Some(v) -> [#("received", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case sent {
    Some(v) -> [#("sent", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case encounter {
    Some(v) -> [#("encounter", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case about {
    [] -> fields
    _ -> [#("about", json.array(about, reference_to_json)), ..fields]
  }
  let fields = case topic {
    Some(v) -> [#("topic", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case subject {
    Some(v) -> [#("subject", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case medium {
    [] -> fields
    _ -> [#("medium", json.array(medium, codeableconcept_to_json)), ..fields]
  }
  let fields = case priority {
    Some(v) -> [
      #("priority", r4bvaluesets.requestpriority_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case category {
    [] -> fields
    _ -> [
      #("category", json.array(category, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case status_reason {
    Some(v) -> [#("statusReason", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case in_response_to {
    [] -> fields
    _ -> [
      #("inResponseTo", json.array(in_response_to, reference_to_json)),
      ..fields
    ]
  }
  let fields = case part_of {
    [] -> fields
    _ -> [#("partOf", json.array(part_of, reference_to_json)), ..fields]
  }
  let fields = case based_on {
    [] -> fields
    _ -> [#("basedOn", json.array(based_on, reference_to_json)), ..fields]
  }
  let fields = case instantiates_uri {
    [] -> fields
    _ -> [
      #("instantiatesUri", json.array(instantiates_uri, json.string)),
      ..fields
    ]
  }
  let fields = case instantiates_canonical {
    [] -> fields
    _ -> [
      #(
        "instantiatesCanonical",
        json.array(instantiates_canonical, json.string),
      ),
      ..fields
    ]
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Communication")), ..fields]
  json.object(fields)
}

pub fn communication_decoder() -> Decoder(Communication) {
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use payload <- decode.optional_field(
    "payload",
    [],
    decode.list(communication_payload_decoder()),
  )
  use reason_reference <- decode.optional_field(
    "reasonReference",
    [],
    decode.list(reference_decoder()),
  )
  use reason_code <- decode.optional_field(
    "reasonCode",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use sender <- decode.optional_field(
    "sender",
    None,
    decode.optional(reference_decoder()),
  )
  use recipient <- decode.optional_field(
    "recipient",
    [],
    decode.list(reference_decoder()),
  )
  use received <- decode.optional_field(
    "received",
    None,
    decode.optional(decode.string),
  )
  use sent <- decode.optional_field(
    "sent",
    None,
    decode.optional(decode.string),
  )
  use encounter <- decode.optional_field(
    "encounter",
    None,
    decode.optional(reference_decoder()),
  )
  use about <- decode.optional_field(
    "about",
    [],
    decode.list(reference_decoder()),
  )
  use topic <- decode.optional_field(
    "topic",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use subject <- decode.optional_field(
    "subject",
    None,
    decode.optional(reference_decoder()),
  )
  use medium <- decode.optional_field(
    "medium",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use priority <- decode.optional_field(
    "priority",
    None,
    decode.optional(r4bvaluesets.requestpriority_decoder()),
  )
  use category <- decode.optional_field(
    "category",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use status_reason <- decode.optional_field(
    "statusReason",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use status <- decode.field("status", r4bvaluesets.eventstatus_decoder())
  use in_response_to <- decode.optional_field(
    "inResponseTo",
    [],
    decode.list(reference_decoder()),
  )
  use part_of <- decode.optional_field(
    "partOf",
    [],
    decode.list(reference_decoder()),
  )
  use based_on <- decode.optional_field(
    "basedOn",
    [],
    decode.list(reference_decoder()),
  )
  use instantiates_uri <- decode.optional_field(
    "instantiatesUri",
    [],
    decode.list(decode.string),
  )
  use instantiates_canonical <- decode.optional_field(
    "instantiatesCanonical",
    [],
    decode.list(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Communication",
    decode.failure(communication_new(status:), "resourceType"),
  )
  decode.success(Communication(
    note:,
    payload:,
    reason_reference:,
    reason_code:,
    sender:,
    recipient:,
    received:,
    sent:,
    encounter:,
    about:,
    topic:,
    subject:,
    medium:,
    priority:,
    category:,
    status_reason:,
    status:,
    in_response_to:,
    part_of:,
    based_on:,
    instantiates_uri:,
    instantiates_canonical:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/CommunicationRequest#resource
pub type Communicationrequest {
  Communicationrequest(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    based_on: List(Reference),
    replaces: List(Reference),
    group_identifier: Option(Identifier),
    status: r4bvaluesets.Requeststatus,
    status_reason: Option(Codeableconcept),
    category: List(Codeableconcept),
    priority: Option(r4bvaluesets.Requestpriority),
    do_not_perform: Option(Bool),
    medium: List(Codeableconcept),
    subject: Option(Reference),
    about: List(Reference),
    encounter: Option(Reference),
    payload: List(CommunicationrequestPayload),
    occurrence: Option(CommunicationrequestOccurrence),
    authored_on: Option(String),
    requester: Option(Reference),
    recipient: List(Reference),
    sender: Option(Reference),
    reason_code: List(Codeableconcept),
    reason_reference: List(Reference),
    note: List(Annotation),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/CommunicationRequest#resource
pub type CommunicationrequestOccurrence {
  CommunicationrequestOccurrenceDatetime(occurrence: String)
  CommunicationrequestOccurrencePeriod(occurrence: Period)
}

pub fn communicationrequest_occurrence_to_json(
  elt: CommunicationrequestOccurrence,
) -> Json {
  case elt {
    CommunicationrequestOccurrenceDatetime(v) -> json.string(v)
    CommunicationrequestOccurrencePeriod(v) -> period_to_json(v)
  }
}

pub fn communicationrequest_occurrence_decoder() -> Decoder(
  CommunicationrequestOccurrence,
) {
  decode.one_of(
    decode.field("occurrenceDateTime", decode.string, decode.success)
      |> decode.map(CommunicationrequestOccurrenceDatetime),
    [
      decode.field("occurrencePeriod", period_decoder(), decode.success)
      |> decode.map(CommunicationrequestOccurrencePeriod),
    ],
  )
}

pub fn communicationrequest_new(
  status status: r4bvaluesets.Requeststatus,
) -> Communicationrequest {
  Communicationrequest(
    note: [],
    reason_reference: [],
    reason_code: [],
    sender: None,
    recipient: [],
    requester: None,
    authored_on: None,
    occurrence: None,
    payload: [],
    encounter: None,
    about: [],
    subject: None,
    medium: [],
    do_not_perform: None,
    priority: None,
    category: [],
    status_reason: None,
    status:,
    group_identifier: None,
    replaces: [],
    based_on: [],
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/CommunicationRequest#resource
pub type CommunicationrequestPayload {
  CommunicationrequestPayload(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    content: CommunicationrequestPayloadContent,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/CommunicationRequest#resource
pub type CommunicationrequestPayloadContent {
  CommunicationrequestPayloadContentString(content: String)
  CommunicationrequestPayloadContentAttachment(content: Attachment)
  CommunicationrequestPayloadContentReference(content: Reference)
}

pub fn communicationrequest_payload_content_to_json(
  elt: CommunicationrequestPayloadContent,
) -> Json {
  case elt {
    CommunicationrequestPayloadContentString(v) -> json.string(v)
    CommunicationrequestPayloadContentAttachment(v) -> attachment_to_json(v)
    CommunicationrequestPayloadContentReference(v) -> reference_to_json(v)
  }
}

pub fn communicationrequest_payload_content_decoder() -> Decoder(
  CommunicationrequestPayloadContent,
) {
  decode.one_of(
    decode.field("contentString", decode.string, decode.success)
      |> decode.map(CommunicationrequestPayloadContentString),
    [
      decode.field("contentAttachment", attachment_decoder(), decode.success)
        |> decode.map(CommunicationrequestPayloadContentAttachment),
      decode.field("contentReference", reference_decoder(), decode.success)
        |> decode.map(CommunicationrequestPayloadContentReference),
    ],
  )
}

pub fn communicationrequest_payload_new(
  content content: CommunicationrequestPayloadContent,
) -> CommunicationrequestPayload {
  CommunicationrequestPayload(
    content:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn communicationrequest_payload_to_json(
  communicationrequest_payload: CommunicationrequestPayload,
) -> Json {
  let CommunicationrequestPayload(
    content:,
    modifier_extension:,
    extension:,
    id:,
  ) = communicationrequest_payload
  let fields = [
    #("content", communicationrequest_payload_content_to_json(content)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn communicationrequest_payload_decoder() -> Decoder(
  CommunicationrequestPayload,
) {
  use content <- decode.then(communicationrequest_payload_content_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CommunicationrequestPayload(
    content:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn communicationrequest_to_json(
  communicationrequest: Communicationrequest,
) -> Json {
  let Communicationrequest(
    note:,
    reason_reference:,
    reason_code:,
    sender:,
    recipient:,
    requester:,
    authored_on:,
    occurrence:,
    payload:,
    encounter:,
    about:,
    subject:,
    medium:,
    do_not_perform:,
    priority:,
    category:,
    status_reason:,
    status:,
    group_identifier:,
    replaces:,
    based_on:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = communicationrequest
  let fields = [
    #("status", r4bvaluesets.requeststatus_to_json(status)),
  ]
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case reason_reference {
    [] -> fields
    _ -> [
      #("reasonReference", json.array(reason_reference, reference_to_json)),
      ..fields
    ]
  }
  let fields = case reason_code {
    [] -> fields
    _ -> [
      #("reasonCode", json.array(reason_code, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case sender {
    Some(v) -> [#("sender", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case recipient {
    [] -> fields
    _ -> [#("recipient", json.array(recipient, reference_to_json)), ..fields]
  }
  let fields = case requester {
    Some(v) -> [#("requester", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case authored_on {
    Some(v) -> [#("authoredOn", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case occurrence {
    Some(v) -> [
      #(
        "occurrence"
          <> case v {
          CommunicationrequestOccurrenceDatetime(_) -> "Datetime"
          CommunicationrequestOccurrencePeriod(_) -> "Period"
        },
        communicationrequest_occurrence_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case payload {
    [] -> fields
    _ -> [
      #("payload", json.array(payload, communicationrequest_payload_to_json)),
      ..fields
    ]
  }
  let fields = case encounter {
    Some(v) -> [#("encounter", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case about {
    [] -> fields
    _ -> [#("about", json.array(about, reference_to_json)), ..fields]
  }
  let fields = case subject {
    Some(v) -> [#("subject", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case medium {
    [] -> fields
    _ -> [#("medium", json.array(medium, codeableconcept_to_json)), ..fields]
  }
  let fields = case do_not_perform {
    Some(v) -> [#("doNotPerform", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case priority {
    Some(v) -> [
      #("priority", r4bvaluesets.requestpriority_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case category {
    [] -> fields
    _ -> [
      #("category", json.array(category, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case status_reason {
    Some(v) -> [#("statusReason", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case group_identifier {
    Some(v) -> [#("groupIdentifier", identifier_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case replaces {
    [] -> fields
    _ -> [#("replaces", json.array(replaces, reference_to_json)), ..fields]
  }
  let fields = case based_on {
    [] -> fields
    _ -> [#("basedOn", json.array(based_on, reference_to_json)), ..fields]
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [
    #("resourceType", json.string("Communicationrequest")),
    ..fields
  ]
  json.object(fields)
}

pub fn communicationrequest_decoder() -> Decoder(Communicationrequest) {
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use reason_reference <- decode.optional_field(
    "reasonReference",
    [],
    decode.list(reference_decoder()),
  )
  use reason_code <- decode.optional_field(
    "reasonCode",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use sender <- decode.optional_field(
    "sender",
    None,
    decode.optional(reference_decoder()),
  )
  use recipient <- decode.optional_field(
    "recipient",
    [],
    decode.list(reference_decoder()),
  )
  use requester <- decode.optional_field(
    "requester",
    None,
    decode.optional(reference_decoder()),
  )
  use authored_on <- decode.optional_field(
    "authoredOn",
    None,
    decode.optional(decode.string),
  )
  use occurrence <- decode.then(
    none_if_omitted(communicationrequest_occurrence_decoder()),
  )
  use payload <- decode.optional_field(
    "payload",
    [],
    decode.list(communicationrequest_payload_decoder()),
  )
  use encounter <- decode.optional_field(
    "encounter",
    None,
    decode.optional(reference_decoder()),
  )
  use about <- decode.optional_field(
    "about",
    [],
    decode.list(reference_decoder()),
  )
  use subject <- decode.optional_field(
    "subject",
    None,
    decode.optional(reference_decoder()),
  )
  use medium <- decode.optional_field(
    "medium",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use do_not_perform <- decode.optional_field(
    "doNotPerform",
    None,
    decode.optional(decode.bool),
  )
  use priority <- decode.optional_field(
    "priority",
    None,
    decode.optional(r4bvaluesets.requestpriority_decoder()),
  )
  use category <- decode.optional_field(
    "category",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use status_reason <- decode.optional_field(
    "statusReason",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use status <- decode.field("status", r4bvaluesets.requeststatus_decoder())
  use group_identifier <- decode.optional_field(
    "groupIdentifier",
    None,
    decode.optional(identifier_decoder()),
  )
  use replaces <- decode.optional_field(
    "replaces",
    [],
    decode.list(reference_decoder()),
  )
  use based_on <- decode.optional_field(
    "basedOn",
    [],
    decode.list(reference_decoder()),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Communicationrequest",
    decode.failure(communicationrequest_new(status:), "resourceType"),
  )
  decode.success(Communicationrequest(
    note:,
    reason_reference:,
    reason_code:,
    sender:,
    recipient:,
    requester:,
    authored_on:,
    occurrence:,
    payload:,
    encounter:,
    about:,
    subject:,
    medium:,
    do_not_perform:,
    priority:,
    category:,
    status_reason:,
    status:,
    group_identifier:,
    replaces:,
    based_on:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/CompartmentDefinition#resource
pub type Compartmentdefinition {
  Compartmentdefinition(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    url: String,
    version: Option(String),
    name: String,
    status: r4bvaluesets.Publicationstatus,
    experimental: Option(Bool),
    date: Option(String),
    publisher: Option(String),
    contact: List(Contactdetail),
    description: Option(String),
    use_context: List(Usagecontext),
    purpose: Option(String),
    code: r4bvaluesets.Compartmenttype,
    search: Bool,
    resource: List(CompartmentdefinitionResource),
  )
}

pub fn compartmentdefinition_new(
  search search: Bool,
  code code: r4bvaluesets.Compartmenttype,
  status status: r4bvaluesets.Publicationstatus,
  name name: String,
  url url: String,
) -> Compartmentdefinition {
  Compartmentdefinition(
    resource: [],
    search:,
    code:,
    purpose: None,
    use_context: [],
    description: None,
    contact: [],
    publisher: None,
    date: None,
    experimental: None,
    status:,
    name:,
    version: None,
    url:,
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/CompartmentDefinition#resource
pub type CompartmentdefinitionResource {
  CompartmentdefinitionResource(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    code: r4bvaluesets.Resourcetypes,
    param: List(String),
    documentation: Option(String),
  )
}

pub fn compartmentdefinition_resource_new(
  code code: r4bvaluesets.Resourcetypes,
) -> CompartmentdefinitionResource {
  CompartmentdefinitionResource(
    documentation: None,
    param: [],
    code:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn compartmentdefinition_resource_to_json(
  compartmentdefinition_resource: CompartmentdefinitionResource,
) -> Json {
  let CompartmentdefinitionResource(
    documentation:,
    param:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ) = compartmentdefinition_resource
  let fields = [
    #("code", r4bvaluesets.resourcetypes_to_json(code)),
  ]
  let fields = case documentation {
    Some(v) -> [#("documentation", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case param {
    [] -> fields
    _ -> [#("param", json.array(param, json.string)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn compartmentdefinition_resource_decoder() -> Decoder(
  CompartmentdefinitionResource,
) {
  use documentation <- decode.optional_field(
    "documentation",
    None,
    decode.optional(decode.string),
  )
  use param <- decode.optional_field("param", [], decode.list(decode.string))
  use code <- decode.field("code", r4bvaluesets.resourcetypes_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CompartmentdefinitionResource(
    documentation:,
    param:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn compartmentdefinition_to_json(
  compartmentdefinition: Compartmentdefinition,
) -> Json {
  let Compartmentdefinition(
    resource:,
    search:,
    code:,
    purpose:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    experimental:,
    status:,
    name:,
    version:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = compartmentdefinition
  let fields = [
    #("search", json.bool(search)),
    #("code", r4bvaluesets.compartmenttype_to_json(code)),
    #("status", r4bvaluesets.publicationstatus_to_json(status)),
    #("name", json.string(name)),
    #("url", json.string(url)),
  ]
  let fields = case resource {
    [] -> fields
    _ -> [
      #(
        "resource",
        json.array(resource, compartmentdefinition_resource_to_json),
      ),
      ..fields
    ]
  }
  let fields = case purpose {
    Some(v) -> [#("purpose", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case use_context {
    [] -> fields
    _ -> [
      #("useContext", json.array(use_context, usagecontext_to_json)),
      ..fields
    ]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case contact {
    [] -> fields
    _ -> [#("contact", json.array(contact, contactdetail_to_json)), ..fields]
  }
  let fields = case publisher {
    Some(v) -> [#("publisher", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case date {
    Some(v) -> [#("date", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case experimental {
    Some(v) -> [#("experimental", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case version {
    Some(v) -> [#("version", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [
    #("resourceType", json.string("Compartmentdefinition")),
    ..fields
  ]
  json.object(fields)
}

pub fn compartmentdefinition_decoder() -> Decoder(Compartmentdefinition) {
  use resource <- decode.optional_field(
    "resource",
    [],
    decode.list(compartmentdefinition_resource_decoder()),
  )
  use search <- decode.field("search", decode.bool)
  use code <- decode.field("code", r4bvaluesets.compartmenttype_decoder())
  use purpose <- decode.optional_field(
    "purpose",
    None,
    decode.optional(decode.string),
  )
  use use_context <- decode.optional_field(
    "useContext",
    [],
    decode.list(usagecontext_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use contact <- decode.optional_field(
    "contact",
    [],
    decode.list(contactdetail_decoder()),
  )
  use publisher <- decode.optional_field(
    "publisher",
    None,
    decode.optional(decode.string),
  )
  use date <- decode.optional_field(
    "date",
    None,
    decode.optional(decode.string),
  )
  use experimental <- decode.optional_field(
    "experimental",
    None,
    decode.optional(decode.bool),
  )
  use status <- decode.field("status", r4bvaluesets.publicationstatus_decoder())
  use name <- decode.field("name", decode.string)
  use version <- decode.optional_field(
    "version",
    None,
    decode.optional(decode.string),
  )
  use url <- decode.field("url", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Compartmentdefinition",
    decode.failure(
      compartmentdefinition_new(search:, code:, status:, name:, url:),
      "resourceType",
    ),
  )
  decode.success(Compartmentdefinition(
    resource:,
    search:,
    code:,
    purpose:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    experimental:,
    status:,
    name:,
    version:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/Composition#resource
pub type Composition {
  Composition(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: Option(Identifier),
    status: r4bvaluesets.Compositionstatus,
    type_: Codeableconcept,
    category: List(Codeableconcept),
    subject: Option(Reference),
    encounter: Option(Reference),
    date: String,
    author: List(Reference),
    title: String,
    confidentiality: Option(String),
    attester: List(CompositionAttester),
    custodian: Option(Reference),
    relates_to: List(CompositionRelatesto),
    event: List(CompositionEvent),
    section: List(CompositionSection),
  )
}

pub fn composition_new(
  title title: String,
  date date: String,
  type_ type_: Codeableconcept,
  status status: r4bvaluesets.Compositionstatus,
) -> Composition {
  Composition(
    section: [],
    event: [],
    relates_to: [],
    custodian: None,
    attester: [],
    confidentiality: None,
    title:,
    author: [],
    date:,
    encounter: None,
    subject: None,
    category: [],
    type_:,
    status:,
    identifier: None,
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Composition#resource
pub type CompositionAttester {
  CompositionAttester(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    mode: r4bvaluesets.Compositionattestationmode,
    time: Option(String),
    party: Option(Reference),
  )
}

pub fn composition_attester_new(
  mode mode: r4bvaluesets.Compositionattestationmode,
) -> CompositionAttester {
  CompositionAttester(
    party: None,
    time: None,
    mode:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Composition#resource
pub type CompositionRelatesto {
  CompositionRelatesto(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    code: r4bvaluesets.Documentrelationshiptype,
    target: CompositionRelatestoTarget,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Composition#resource
pub type CompositionRelatestoTarget {
  CompositionRelatestoTargetIdentifier(target: Identifier)
  CompositionRelatestoTargetReference(target: Reference)
}

pub fn composition_relatesto_target_to_json(
  elt: CompositionRelatestoTarget,
) -> Json {
  case elt {
    CompositionRelatestoTargetIdentifier(v) -> identifier_to_json(v)
    CompositionRelatestoTargetReference(v) -> reference_to_json(v)
  }
}

pub fn composition_relatesto_target_decoder() -> Decoder(
  CompositionRelatestoTarget,
) {
  decode.one_of(
    decode.field("targetIdentifier", identifier_decoder(), decode.success)
      |> decode.map(CompositionRelatestoTargetIdentifier),
    [
      decode.field("targetReference", reference_decoder(), decode.success)
      |> decode.map(CompositionRelatestoTargetReference),
    ],
  )
}

pub fn composition_relatesto_new(
  target target: CompositionRelatestoTarget,
  code code: r4bvaluesets.Documentrelationshiptype,
) -> CompositionRelatesto {
  CompositionRelatesto(
    target:,
    code:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Composition#resource
pub type CompositionEvent {
  CompositionEvent(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    code: List(Codeableconcept),
    period: Option(Period),
    detail: List(Reference),
  )
}

pub fn composition_event_new() -> CompositionEvent {
  CompositionEvent(
    detail: [],
    period: None,
    code: [],
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Composition#resource
pub type CompositionSection {
  CompositionSection(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    title: Option(String),
    code: Option(Codeableconcept),
    author: List(Reference),
    focus: Option(Reference),
    text: Option(Narrative),
    mode: Option(r4bvaluesets.Listmode),
    ordered_by: Option(Codeableconcept),
    entry: List(Reference),
    empty_reason: Option(Codeableconcept),
  )
}

pub fn composition_section_new() -> CompositionSection {
  CompositionSection(
    empty_reason: None,
    entry: [],
    ordered_by: None,
    mode: None,
    text: None,
    focus: None,
    author: [],
    code: None,
    title: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn composition_section_to_json(
  composition_section: CompositionSection,
) -> Json {
  let CompositionSection(
    empty_reason:,
    entry:,
    ordered_by:,
    mode:,
    text:,
    focus:,
    author:,
    code:,
    title:,
    modifier_extension:,
    extension:,
    id:,
  ) = composition_section
  let fields = []
  let fields = case empty_reason {
    Some(v) -> [#("emptyReason", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case entry {
    [] -> fields
    _ -> [#("entry", json.array(entry, reference_to_json)), ..fields]
  }
  let fields = case ordered_by {
    Some(v) -> [#("orderedBy", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case mode {
    Some(v) -> [#("mode", r4bvaluesets.listmode_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case focus {
    Some(v) -> [#("focus", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case author {
    [] -> fields
    _ -> [#("author", json.array(author, reference_to_json)), ..fields]
  }
  let fields = case code {
    Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case title {
    Some(v) -> [#("title", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn composition_section_decoder() -> Decoder(CompositionSection) {
  use empty_reason <- decode.optional_field(
    "emptyReason",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use entry <- decode.optional_field(
    "entry",
    [],
    decode.list(reference_decoder()),
  )
  use ordered_by <- decode.optional_field(
    "orderedBy",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use mode <- decode.optional_field(
    "mode",
    None,
    decode.optional(r4bvaluesets.listmode_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use focus <- decode.optional_field(
    "focus",
    None,
    decode.optional(reference_decoder()),
  )
  use author <- decode.optional_field(
    "author",
    [],
    decode.list(reference_decoder()),
  )
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use title <- decode.optional_field(
    "title",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CompositionSection(
    empty_reason:,
    entry:,
    ordered_by:,
    mode:,
    text:,
    focus:,
    author:,
    code:,
    title:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn composition_event_to_json(composition_event: CompositionEvent) -> Json {
  let CompositionEvent(
    detail:,
    period:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ) = composition_event
  let fields = []
  let fields = case detail {
    [] -> fields
    _ -> [#("detail", json.array(detail, reference_to_json)), ..fields]
  }
  let fields = case period {
    Some(v) -> [#("period", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case code {
    [] -> fields
    _ -> [#("code", json.array(code, codeableconcept_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn composition_event_decoder() -> Decoder(CompositionEvent) {
  use detail <- decode.optional_field(
    "detail",
    [],
    decode.list(reference_decoder()),
  )
  use period <- decode.optional_field(
    "period",
    None,
    decode.optional(period_decoder()),
  )
  use code <- decode.optional_field(
    "code",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CompositionEvent(
    detail:,
    period:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn composition_relatesto_to_json(
  composition_relatesto: CompositionRelatesto,
) -> Json {
  let CompositionRelatesto(target:, code:, modifier_extension:, extension:, id:) =
    composition_relatesto
  let fields = [
    #("target", composition_relatesto_target_to_json(target)),
    #("code", r4bvaluesets.documentrelationshiptype_to_json(code)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn composition_relatesto_decoder() -> Decoder(CompositionRelatesto) {
  use target <- decode.then(composition_relatesto_target_decoder())
  use code <- decode.field(
    "code",
    r4bvaluesets.documentrelationshiptype_decoder(),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CompositionRelatesto(
    target:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn composition_attester_to_json(
  composition_attester: CompositionAttester,
) -> Json {
  let CompositionAttester(
    party:,
    time:,
    mode:,
    modifier_extension:,
    extension:,
    id:,
  ) = composition_attester
  let fields = [
    #("mode", r4bvaluesets.compositionattestationmode_to_json(mode)),
  ]
  let fields = case party {
    Some(v) -> [#("party", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case time {
    Some(v) -> [#("time", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn composition_attester_decoder() -> Decoder(CompositionAttester) {
  use party <- decode.optional_field(
    "party",
    None,
    decode.optional(reference_decoder()),
  )
  use time <- decode.optional_field(
    "time",
    None,
    decode.optional(decode.string),
  )
  use mode <- decode.field(
    "mode",
    r4bvaluesets.compositionattestationmode_decoder(),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CompositionAttester(
    party:,
    time:,
    mode:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn composition_to_json(composition: Composition) -> Json {
  let Composition(
    section:,
    event:,
    relates_to:,
    custodian:,
    attester:,
    confidentiality:,
    title:,
    author:,
    date:,
    encounter:,
    subject:,
    category:,
    type_:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = composition
  let fields = [
    #("title", json.string(title)),
    #("date", json.string(date)),
    #("type", codeableconcept_to_json(type_)),
    #("status", r4bvaluesets.compositionstatus_to_json(status)),
  ]
  let fields = case section {
    [] -> fields
    _ -> [
      #("section", json.array(section, composition_section_to_json)),
      ..fields
    ]
  }
  let fields = case event {
    [] -> fields
    _ -> [#("event", json.array(event, composition_event_to_json)), ..fields]
  }
  let fields = case relates_to {
    [] -> fields
    _ -> [
      #("relatesTo", json.array(relates_to, composition_relatesto_to_json)),
      ..fields
    ]
  }
  let fields = case custodian {
    Some(v) -> [#("custodian", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case attester {
    [] -> fields
    _ -> [
      #("attester", json.array(attester, composition_attester_to_json)),
      ..fields
    ]
  }
  let fields = case confidentiality {
    Some(v) -> [#("confidentiality", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case author {
    [] -> fields
    _ -> [#("author", json.array(author, reference_to_json)), ..fields]
  }
  let fields = case encounter {
    Some(v) -> [#("encounter", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case subject {
    Some(v) -> [#("subject", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case category {
    [] -> fields
    _ -> [
      #("category", json.array(category, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case identifier {
    Some(v) -> [#("identifier", identifier_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Composition")), ..fields]
  json.object(fields)
}

pub fn composition_decoder() -> Decoder(Composition) {
  use section <- decode.optional_field(
    "section",
    [],
    decode.list(composition_section_decoder()),
  )
  use event <- decode.optional_field(
    "event",
    [],
    decode.list(composition_event_decoder()),
  )
  use relates_to <- decode.optional_field(
    "relatesTo",
    [],
    decode.list(composition_relatesto_decoder()),
  )
  use custodian <- decode.optional_field(
    "custodian",
    None,
    decode.optional(reference_decoder()),
  )
  use attester <- decode.optional_field(
    "attester",
    [],
    decode.list(composition_attester_decoder()),
  )
  use confidentiality <- decode.optional_field(
    "confidentiality",
    None,
    decode.optional(decode.string),
  )
  use title <- decode.field("title", decode.string)
  use author <- decode.optional_field(
    "author",
    [],
    decode.list(reference_decoder()),
  )
  use date <- decode.field("date", decode.string)
  use encounter <- decode.optional_field(
    "encounter",
    None,
    decode.optional(reference_decoder()),
  )
  use subject <- decode.optional_field(
    "subject",
    None,
    decode.optional(reference_decoder()),
  )
  use category <- decode.optional_field(
    "category",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use type_ <- decode.field("type", codeableconcept_decoder())
  use status <- decode.field("status", r4bvaluesets.compositionstatus_decoder())
  use identifier <- decode.optional_field(
    "identifier",
    None,
    decode.optional(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Composition",
    decode.failure(
      composition_new(title:, date:, type_:, status:),
      "resourceType",
    ),
  )
  decode.success(Composition(
    section:,
    event:,
    relates_to:,
    custodian:,
    attester:,
    confidentiality:,
    title:,
    author:,
    date:,
    encounter:,
    subject:,
    category:,
    type_:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/ConceptMap#resource
pub type Conceptmap {
  Conceptmap(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    url: Option(String),
    identifier: Option(Identifier),
    version: Option(String),
    name: Option(String),
    title: Option(String),
    status: r4bvaluesets.Publicationstatus,
    experimental: Option(Bool),
    date: Option(String),
    publisher: Option(String),
    contact: List(Contactdetail),
    description: Option(String),
    use_context: List(Usagecontext),
    jurisdiction: List(Codeableconcept),
    purpose: Option(String),
    copyright: Option(String),
    source: Option(ConceptmapSource),
    target: Option(ConceptmapTarget),
    group: List(ConceptmapGroup),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ConceptMap#resource
pub type ConceptmapSource {
  ConceptmapSourceUri(source: String)
  ConceptmapSourceCanonical(source: String)
}

pub fn conceptmap_source_to_json(elt: ConceptmapSource) -> Json {
  case elt {
    ConceptmapSourceUri(v) -> json.string(v)
    ConceptmapSourceCanonical(v) -> json.string(v)
  }
}

pub fn conceptmap_source_decoder() -> Decoder(ConceptmapSource) {
  decode.one_of(
    decode.field("sourceUri", decode.string, decode.success)
      |> decode.map(ConceptmapSourceUri),
    [
      decode.field("sourceCanonical", decode.string, decode.success)
      |> decode.map(ConceptmapSourceCanonical),
    ],
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ConceptMap#resource
pub type ConceptmapTarget {
  ConceptmapTargetUri(target: String)
  ConceptmapTargetCanonical(target: String)
}

pub fn conceptmap_target_to_json(elt: ConceptmapTarget) -> Json {
  case elt {
    ConceptmapTargetUri(v) -> json.string(v)
    ConceptmapTargetCanonical(v) -> json.string(v)
  }
}

pub fn conceptmap_target_decoder() -> Decoder(ConceptmapTarget) {
  decode.one_of(
    decode.field("targetUri", decode.string, decode.success)
      |> decode.map(ConceptmapTargetUri),
    [
      decode.field("targetCanonical", decode.string, decode.success)
      |> decode.map(ConceptmapTargetCanonical),
    ],
  )
}

pub fn conceptmap_new(
  status status: r4bvaluesets.Publicationstatus,
) -> Conceptmap {
  Conceptmap(
    group: [],
    target: None,
    source: None,
    copyright: None,
    purpose: None,
    jurisdiction: [],
    use_context: [],
    description: None,
    contact: [],
    publisher: None,
    date: None,
    experimental: None,
    status:,
    title: None,
    name: None,
    version: None,
    identifier: None,
    url: None,
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ConceptMap#resource
pub type ConceptmapGroup {
  ConceptmapGroup(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    source: Option(String),
    source_version: Option(String),
    target: Option(String),
    target_version: Option(String),
    element: List(ConceptmapGroupElement),
    unmapped: Option(ConceptmapGroupUnmapped),
  )
}

pub fn conceptmap_group_new() -> ConceptmapGroup {
  ConceptmapGroup(
    unmapped: None,
    element: [],
    target_version: None,
    target: None,
    source_version: None,
    source: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ConceptMap#resource
pub type ConceptmapGroupElement {
  ConceptmapGroupElement(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    code: Option(String),
    display: Option(String),
    target: List(ConceptmapGroupElementTarget),
  )
}

pub fn conceptmap_group_element_new() -> ConceptmapGroupElement {
  ConceptmapGroupElement(
    target: [],
    display: None,
    code: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ConceptMap#resource
pub type ConceptmapGroupElementTarget {
  ConceptmapGroupElementTarget(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    code: Option(String),
    display: Option(String),
    equivalence: r4bvaluesets.Conceptmapequivalence,
    comment: Option(String),
    depends_on: List(ConceptmapGroupElementTargetDependson),
  )
}

pub fn conceptmap_group_element_target_new(
  equivalence equivalence: r4bvaluesets.Conceptmapequivalence,
) -> ConceptmapGroupElementTarget {
  ConceptmapGroupElementTarget(
    depends_on: [],
    comment: None,
    equivalence:,
    display: None,
    code: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ConceptMap#resource
pub type ConceptmapGroupElementTargetDependson {
  ConceptmapGroupElementTargetDependson(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    property: String,
    system: Option(String),
    value: String,
    display: Option(String),
  )
}

pub fn conceptmap_group_element_target_dependson_new(
  value value: String,
  property property: String,
) -> ConceptmapGroupElementTargetDependson {
  ConceptmapGroupElementTargetDependson(
    display: None,
    value:,
    system: None,
    property:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ConceptMap#resource
pub type ConceptmapGroupUnmapped {
  ConceptmapGroupUnmapped(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    mode: r4bvaluesets.Conceptmapunmappedmode,
    code: Option(String),
    display: Option(String),
    url: Option(String),
  )
}

pub fn conceptmap_group_unmapped_new(
  mode mode: r4bvaluesets.Conceptmapunmappedmode,
) -> ConceptmapGroupUnmapped {
  ConceptmapGroupUnmapped(
    url: None,
    display: None,
    code: None,
    mode:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn conceptmap_group_unmapped_to_json(
  conceptmap_group_unmapped: ConceptmapGroupUnmapped,
) -> Json {
  let ConceptmapGroupUnmapped(
    url:,
    display:,
    code:,
    mode:,
    modifier_extension:,
    extension:,
    id:,
  ) = conceptmap_group_unmapped
  let fields = [
    #("mode", r4bvaluesets.conceptmapunmappedmode_to_json(mode)),
  ]
  let fields = case url {
    Some(v) -> [#("url", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case display {
    Some(v) -> [#("display", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case code {
    Some(v) -> [#("code", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn conceptmap_group_unmapped_decoder() -> Decoder(ConceptmapGroupUnmapped) {
  use url <- decode.optional_field("url", None, decode.optional(decode.string))
  use display <- decode.optional_field(
    "display",
    None,
    decode.optional(decode.string),
  )
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(decode.string),
  )
  use mode <- decode.field(
    "mode",
    r4bvaluesets.conceptmapunmappedmode_decoder(),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ConceptmapGroupUnmapped(
    url:,
    display:,
    code:,
    mode:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn conceptmap_group_element_target_dependson_to_json(
  conceptmap_group_element_target_dependson: ConceptmapGroupElementTargetDependson,
) -> Json {
  let ConceptmapGroupElementTargetDependson(
    display:,
    value:,
    system:,
    property:,
    modifier_extension:,
    extension:,
    id:,
  ) = conceptmap_group_element_target_dependson
  let fields = [
    #("value", json.string(value)),
    #("property", json.string(property)),
  ]
  let fields = case display {
    Some(v) -> [#("display", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case system {
    Some(v) -> [#("system", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn conceptmap_group_element_target_dependson_decoder() -> Decoder(
  ConceptmapGroupElementTargetDependson,
) {
  use display <- decode.optional_field(
    "display",
    None,
    decode.optional(decode.string),
  )
  use value <- decode.field("value", decode.string)
  use system <- decode.optional_field(
    "system",
    None,
    decode.optional(decode.string),
  )
  use property <- decode.field("property", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ConceptmapGroupElementTargetDependson(
    display:,
    value:,
    system:,
    property:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn conceptmap_group_element_target_to_json(
  conceptmap_group_element_target: ConceptmapGroupElementTarget,
) -> Json {
  let ConceptmapGroupElementTarget(
    depends_on:,
    comment:,
    equivalence:,
    display:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ) = conceptmap_group_element_target
  let fields = [
    #("equivalence", r4bvaluesets.conceptmapequivalence_to_json(equivalence)),
  ]
  let fields = case depends_on {
    [] -> fields
    _ -> [
      #(
        "dependsOn",
        json.array(
          depends_on,
          conceptmap_group_element_target_dependson_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case comment {
    Some(v) -> [#("comment", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case display {
    Some(v) -> [#("display", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case code {
    Some(v) -> [#("code", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn conceptmap_group_element_target_decoder() -> Decoder(
  ConceptmapGroupElementTarget,
) {
  use depends_on <- decode.optional_field(
    "dependsOn",
    [],
    decode.list(conceptmap_group_element_target_dependson_decoder()),
  )
  use comment <- decode.optional_field(
    "comment",
    None,
    decode.optional(decode.string),
  )
  use equivalence <- decode.field(
    "equivalence",
    r4bvaluesets.conceptmapequivalence_decoder(),
  )
  use display <- decode.optional_field(
    "display",
    None,
    decode.optional(decode.string),
  )
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ConceptmapGroupElementTarget(
    depends_on:,
    comment:,
    equivalence:,
    display:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn conceptmap_group_element_to_json(
  conceptmap_group_element: ConceptmapGroupElement,
) -> Json {
  let ConceptmapGroupElement(
    target:,
    display:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ) = conceptmap_group_element
  let fields = []
  let fields = case target {
    [] -> fields
    _ -> [
      #("target", json.array(target, conceptmap_group_element_target_to_json)),
      ..fields
    ]
  }
  let fields = case display {
    Some(v) -> [#("display", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case code {
    Some(v) -> [#("code", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn conceptmap_group_element_decoder() -> Decoder(ConceptmapGroupElement) {
  use target <- decode.optional_field(
    "target",
    [],
    decode.list(conceptmap_group_element_target_decoder()),
  )
  use display <- decode.optional_field(
    "display",
    None,
    decode.optional(decode.string),
  )
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ConceptmapGroupElement(
    target:,
    display:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn conceptmap_group_to_json(conceptmap_group: ConceptmapGroup) -> Json {
  let ConceptmapGroup(
    unmapped:,
    element:,
    target_version:,
    target:,
    source_version:,
    source:,
    modifier_extension:,
    extension:,
    id:,
  ) = conceptmap_group
  let fields = []
  let fields = case unmapped {
    Some(v) -> [#("unmapped", conceptmap_group_unmapped_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case element {
    [] -> fields
    _ -> [
      #("element", json.array(element, conceptmap_group_element_to_json)),
      ..fields
    ]
  }
  let fields = case target_version {
    Some(v) -> [#("targetVersion", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case target {
    Some(v) -> [#("target", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case source_version {
    Some(v) -> [#("sourceVersion", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case source {
    Some(v) -> [#("source", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn conceptmap_group_decoder() -> Decoder(ConceptmapGroup) {
  use unmapped <- decode.optional_field(
    "unmapped",
    None,
    decode.optional(conceptmap_group_unmapped_decoder()),
  )
  use element <- decode.optional_field(
    "element",
    [],
    decode.list(conceptmap_group_element_decoder()),
  )
  use target_version <- decode.optional_field(
    "targetVersion",
    None,
    decode.optional(decode.string),
  )
  use target <- decode.optional_field(
    "target",
    None,
    decode.optional(decode.string),
  )
  use source_version <- decode.optional_field(
    "sourceVersion",
    None,
    decode.optional(decode.string),
  )
  use source <- decode.optional_field(
    "source",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ConceptmapGroup(
    unmapped:,
    element:,
    target_version:,
    target:,
    source_version:,
    source:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn conceptmap_to_json(conceptmap: Conceptmap) -> Json {
  let Conceptmap(
    group:,
    target:,
    source:,
    copyright:,
    purpose:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    experimental:,
    status:,
    title:,
    name:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = conceptmap
  let fields = [
    #("status", r4bvaluesets.publicationstatus_to_json(status)),
  ]
  let fields = case group {
    [] -> fields
    _ -> [#("group", json.array(group, conceptmap_group_to_json)), ..fields]
  }
  let fields = case target {
    Some(v) -> [
      #(
        "target"
          <> case v {
          ConceptmapTargetUri(_) -> "Uri"
          ConceptmapTargetCanonical(_) -> "Canonical"
        },
        conceptmap_target_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case source {
    Some(v) -> [
      #(
        "source"
          <> case v {
          ConceptmapSourceUri(_) -> "Uri"
          ConceptmapSourceCanonical(_) -> "Canonical"
        },
        conceptmap_source_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case copyright {
    Some(v) -> [#("copyright", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case purpose {
    Some(v) -> [#("purpose", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case jurisdiction {
    [] -> fields
    _ -> [
      #("jurisdiction", json.array(jurisdiction, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case use_context {
    [] -> fields
    _ -> [
      #("useContext", json.array(use_context, usagecontext_to_json)),
      ..fields
    ]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case contact {
    [] -> fields
    _ -> [#("contact", json.array(contact, contactdetail_to_json)), ..fields]
  }
  let fields = case publisher {
    Some(v) -> [#("publisher", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case date {
    Some(v) -> [#("date", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case experimental {
    Some(v) -> [#("experimental", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case title {
    Some(v) -> [#("title", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case version {
    Some(v) -> [#("version", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    Some(v) -> [#("identifier", identifier_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case url {
    Some(v) -> [#("url", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Conceptmap")), ..fields]
  json.object(fields)
}

pub fn conceptmap_decoder() -> Decoder(Conceptmap) {
  use group <- decode.optional_field(
    "group",
    [],
    decode.list(conceptmap_group_decoder()),
  )
  use target <- decode.then(none_if_omitted(conceptmap_target_decoder()))
  use source <- decode.then(none_if_omitted(conceptmap_source_decoder()))
  use copyright <- decode.optional_field(
    "copyright",
    None,
    decode.optional(decode.string),
  )
  use purpose <- decode.optional_field(
    "purpose",
    None,
    decode.optional(decode.string),
  )
  use jurisdiction <- decode.optional_field(
    "jurisdiction",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use use_context <- decode.optional_field(
    "useContext",
    [],
    decode.list(usagecontext_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use contact <- decode.optional_field(
    "contact",
    [],
    decode.list(contactdetail_decoder()),
  )
  use publisher <- decode.optional_field(
    "publisher",
    None,
    decode.optional(decode.string),
  )
  use date <- decode.optional_field(
    "date",
    None,
    decode.optional(decode.string),
  )
  use experimental <- decode.optional_field(
    "experimental",
    None,
    decode.optional(decode.bool),
  )
  use status <- decode.field("status", r4bvaluesets.publicationstatus_decoder())
  use title <- decode.optional_field(
    "title",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use version <- decode.optional_field(
    "version",
    None,
    decode.optional(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    None,
    decode.optional(identifier_decoder()),
  )
  use url <- decode.optional_field("url", None, decode.optional(decode.string))
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Conceptmap",
    decode.failure(conceptmap_new(status:), "resourceType"),
  )
  decode.success(Conceptmap(
    group:,
    target:,
    source:,
    copyright:,
    purpose:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    experimental:,
    status:,
    title:,
    name:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/Condition#resource
pub type Condition {
  Condition(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    clinical_status: Option(Codeableconcept),
    verification_status: Option(Codeableconcept),
    category: List(Codeableconcept),
    severity: Option(Codeableconcept),
    code: Option(Codeableconcept),
    body_site: List(Codeableconcept),
    subject: Reference,
    encounter: Option(Reference),
    onset: Option(ConditionOnset),
    abatement: Option(ConditionAbatement),
    recorded_date: Option(String),
    recorder: Option(Reference),
    asserter: Option(Reference),
    stage: List(ConditionStage),
    evidence: List(ConditionEvidence),
    note: List(Annotation),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Condition#resource
pub type ConditionOnset {
  ConditionOnsetDatetime(onset: String)
  ConditionOnsetAge(onset: Age)
  ConditionOnsetPeriod(onset: Period)
  ConditionOnsetRange(onset: Range)
  ConditionOnsetString(onset: String)
}

pub fn condition_onset_to_json(elt: ConditionOnset) -> Json {
  case elt {
    ConditionOnsetDatetime(v) -> json.string(v)
    ConditionOnsetAge(v) -> age_to_json(v)
    ConditionOnsetPeriod(v) -> period_to_json(v)
    ConditionOnsetRange(v) -> range_to_json(v)
    ConditionOnsetString(v) -> json.string(v)
  }
}

pub fn condition_onset_decoder() -> Decoder(ConditionOnset) {
  decode.one_of(
    decode.field("onsetDateTime", decode.string, decode.success)
      |> decode.map(ConditionOnsetDatetime),
    [
      decode.field("onsetAge", age_decoder(), decode.success)
        |> decode.map(ConditionOnsetAge),
      decode.field("onsetPeriod", period_decoder(), decode.success)
        |> decode.map(ConditionOnsetPeriod),
      decode.field("onsetRange", range_decoder(), decode.success)
        |> decode.map(ConditionOnsetRange),
      decode.field("onsetString", decode.string, decode.success)
        |> decode.map(ConditionOnsetString),
    ],
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Condition#resource
pub type ConditionAbatement {
  ConditionAbatementDatetime(abatement: String)
  ConditionAbatementAge(abatement: Age)
  ConditionAbatementPeriod(abatement: Period)
  ConditionAbatementRange(abatement: Range)
  ConditionAbatementString(abatement: String)
}

pub fn condition_abatement_to_json(elt: ConditionAbatement) -> Json {
  case elt {
    ConditionAbatementDatetime(v) -> json.string(v)
    ConditionAbatementAge(v) -> age_to_json(v)
    ConditionAbatementPeriod(v) -> period_to_json(v)
    ConditionAbatementRange(v) -> range_to_json(v)
    ConditionAbatementString(v) -> json.string(v)
  }
}

pub fn condition_abatement_decoder() -> Decoder(ConditionAbatement) {
  decode.one_of(
    decode.field("abatementDateTime", decode.string, decode.success)
      |> decode.map(ConditionAbatementDatetime),
    [
      decode.field("abatementAge", age_decoder(), decode.success)
        |> decode.map(ConditionAbatementAge),
      decode.field("abatementPeriod", period_decoder(), decode.success)
        |> decode.map(ConditionAbatementPeriod),
      decode.field("abatementRange", range_decoder(), decode.success)
        |> decode.map(ConditionAbatementRange),
      decode.field("abatementString", decode.string, decode.success)
        |> decode.map(ConditionAbatementString),
    ],
  )
}

pub fn condition_new(subject subject: Reference) -> Condition {
  Condition(
    note: [],
    evidence: [],
    stage: [],
    asserter: None,
    recorder: None,
    recorded_date: None,
    abatement: None,
    onset: None,
    encounter: None,
    subject:,
    body_site: [],
    code: None,
    severity: None,
    category: [],
    verification_status: None,
    clinical_status: None,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Condition#resource
pub type ConditionStage {
  ConditionStage(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    summary: Option(Codeableconcept),
    assessment: List(Reference),
    type_: Option(Codeableconcept),
  )
}

pub fn condition_stage_new() -> ConditionStage {
  ConditionStage(
    type_: None,
    assessment: [],
    summary: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Condition#resource
pub type ConditionEvidence {
  ConditionEvidence(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    code: List(Codeableconcept),
    detail: List(Reference),
  )
}

pub fn condition_evidence_new() -> ConditionEvidence {
  ConditionEvidence(
    detail: [],
    code: [],
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn condition_evidence_to_json(condition_evidence: ConditionEvidence) -> Json {
  let ConditionEvidence(detail:, code:, modifier_extension:, extension:, id:) =
    condition_evidence
  let fields = []
  let fields = case detail {
    [] -> fields
    _ -> [#("detail", json.array(detail, reference_to_json)), ..fields]
  }
  let fields = case code {
    [] -> fields
    _ -> [#("code", json.array(code, codeableconcept_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn condition_evidence_decoder() -> Decoder(ConditionEvidence) {
  use detail <- decode.optional_field(
    "detail",
    [],
    decode.list(reference_decoder()),
  )
  use code <- decode.optional_field(
    "code",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ConditionEvidence(
    detail:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn condition_stage_to_json(condition_stage: ConditionStage) -> Json {
  let ConditionStage(
    type_:,
    assessment:,
    summary:,
    modifier_extension:,
    extension:,
    id:,
  ) = condition_stage
  let fields = []
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case assessment {
    [] -> fields
    _ -> [#("assessment", json.array(assessment, reference_to_json)), ..fields]
  }
  let fields = case summary {
    Some(v) -> [#("summary", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn condition_stage_decoder() -> Decoder(ConditionStage) {
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use assessment <- decode.optional_field(
    "assessment",
    [],
    decode.list(reference_decoder()),
  )
  use summary <- decode.optional_field(
    "summary",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ConditionStage(
    type_:,
    assessment:,
    summary:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn condition_to_json(condition: Condition) -> Json {
  let Condition(
    note:,
    evidence:,
    stage:,
    asserter:,
    recorder:,
    recorded_date:,
    abatement:,
    onset:,
    encounter:,
    subject:,
    body_site:,
    code:,
    severity:,
    category:,
    verification_status:,
    clinical_status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = condition
  let fields = [
    #("subject", reference_to_json(subject)),
  ]
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case evidence {
    [] -> fields
    _ -> [
      #("evidence", json.array(evidence, condition_evidence_to_json)),
      ..fields
    ]
  }
  let fields = case stage {
    [] -> fields
    _ -> [#("stage", json.array(stage, condition_stage_to_json)), ..fields]
  }
  let fields = case asserter {
    Some(v) -> [#("asserter", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case recorder {
    Some(v) -> [#("recorder", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case recorded_date {
    Some(v) -> [#("recordedDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case abatement {
    Some(v) -> [
      #(
        "abatement"
          <> case v {
          ConditionAbatementDatetime(_) -> "Datetime"
          ConditionAbatementAge(_) -> "Age"
          ConditionAbatementPeriod(_) -> "Period"
          ConditionAbatementRange(_) -> "Range"
          ConditionAbatementString(_) -> "String"
        },
        condition_abatement_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case onset {
    Some(v) -> [
      #(
        "onset"
          <> case v {
          ConditionOnsetDatetime(_) -> "Datetime"
          ConditionOnsetAge(_) -> "Age"
          ConditionOnsetPeriod(_) -> "Period"
          ConditionOnsetRange(_) -> "Range"
          ConditionOnsetString(_) -> "String"
        },
        condition_onset_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case encounter {
    Some(v) -> [#("encounter", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case body_site {
    [] -> fields
    _ -> [
      #("bodySite", json.array(body_site, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case code {
    Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case severity {
    Some(v) -> [#("severity", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case category {
    [] -> fields
    _ -> [
      #("category", json.array(category, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case verification_status {
    Some(v) -> [#("verificationStatus", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case clinical_status {
    Some(v) -> [#("clinicalStatus", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Condition")), ..fields]
  json.object(fields)
}

pub fn condition_decoder() -> Decoder(Condition) {
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use evidence <- decode.optional_field(
    "evidence",
    [],
    decode.list(condition_evidence_decoder()),
  )
  use stage <- decode.optional_field(
    "stage",
    [],
    decode.list(condition_stage_decoder()),
  )
  use asserter <- decode.optional_field(
    "asserter",
    None,
    decode.optional(reference_decoder()),
  )
  use recorder <- decode.optional_field(
    "recorder",
    None,
    decode.optional(reference_decoder()),
  )
  use recorded_date <- decode.optional_field(
    "recordedDate",
    None,
    decode.optional(decode.string),
  )
  use abatement <- decode.then(none_if_omitted(condition_abatement_decoder()))
  use onset <- decode.then(none_if_omitted(condition_onset_decoder()))
  use encounter <- decode.optional_field(
    "encounter",
    None,
    decode.optional(reference_decoder()),
  )
  use subject <- decode.field("subject", reference_decoder())
  use body_site <- decode.optional_field(
    "bodySite",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use severity <- decode.optional_field(
    "severity",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use category <- decode.optional_field(
    "category",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use verification_status <- decode.optional_field(
    "verificationStatus",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use clinical_status <- decode.optional_field(
    "clinicalStatus",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Condition",
    decode.failure(condition_new(subject:), "resourceType"),
  )
  decode.success(Condition(
    note:,
    evidence:,
    stage:,
    asserter:,
    recorder:,
    recorded_date:,
    abatement:,
    onset:,
    encounter:,
    subject:,
    body_site:,
    code:,
    severity:,
    category:,
    verification_status:,
    clinical_status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/Consent#resource
pub type Consent {
  Consent(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    status: r4bvaluesets.Consentstatecodes,
    scope: Codeableconcept,
    category: List(Codeableconcept),
    patient: Option(Reference),
    date_time: Option(String),
    performer: List(Reference),
    organization: List(Reference),
    source: Option(ConsentSource),
    policy: List(ConsentPolicy),
    policy_rule: Option(Codeableconcept),
    verification: List(ConsentVerification),
    provision: Option(ConsentProvision),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Consent#resource
pub type ConsentSource {
  ConsentSourceAttachment(source: Attachment)
  ConsentSourceReference(source: Reference)
}

pub fn consent_source_to_json(elt: ConsentSource) -> Json {
  case elt {
    ConsentSourceAttachment(v) -> attachment_to_json(v)
    ConsentSourceReference(v) -> reference_to_json(v)
  }
}

pub fn consent_source_decoder() -> Decoder(ConsentSource) {
  decode.one_of(
    decode.field("sourceAttachment", attachment_decoder(), decode.success)
      |> decode.map(ConsentSourceAttachment),
    [
      decode.field("sourceReference", reference_decoder(), decode.success)
      |> decode.map(ConsentSourceReference),
    ],
  )
}

pub fn consent_new(
  scope scope: Codeableconcept,
  status status: r4bvaluesets.Consentstatecodes,
) -> Consent {
  Consent(
    provision: None,
    verification: [],
    policy_rule: None,
    policy: [],
    source: None,
    organization: [],
    performer: [],
    date_time: None,
    patient: None,
    category: [],
    scope:,
    status:,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Consent#resource
pub type ConsentPolicy {
  ConsentPolicy(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    authority: Option(String),
    uri: Option(String),
  )
}

pub fn consent_policy_new() -> ConsentPolicy {
  ConsentPolicy(
    uri: None,
    authority: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Consent#resource
pub type ConsentVerification {
  ConsentVerification(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    verified: Bool,
    verified_with: Option(Reference),
    verification_date: Option(String),
  )
}

pub fn consent_verification_new(verified verified: Bool) -> ConsentVerification {
  ConsentVerification(
    verification_date: None,
    verified_with: None,
    verified:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Consent#resource
pub type ConsentProvision {
  ConsentProvision(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Option(r4bvaluesets.Consentprovisiontype),
    period: Option(Period),
    actor: List(ConsentProvisionActor),
    action: List(Codeableconcept),
    security_label: List(Coding),
    purpose: List(Coding),
    class: List(Coding),
    code: List(Codeableconcept),
    data_period: Option(Period),
    data: List(ConsentProvisionData),
  )
}

pub fn consent_provision_new() -> ConsentProvision {
  ConsentProvision(
    data: [],
    data_period: None,
    code: [],
    class: [],
    purpose: [],
    security_label: [],
    action: [],
    actor: [],
    period: None,
    type_: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Consent#resource
pub type ConsentProvisionActor {
  ConsentProvisionActor(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    role: Codeableconcept,
    reference: Reference,
  )
}

pub fn consent_provision_actor_new(
  reference reference: Reference,
  role role: Codeableconcept,
) -> ConsentProvisionActor {
  ConsentProvisionActor(
    reference:,
    role:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Consent#resource
pub type ConsentProvisionData {
  ConsentProvisionData(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    meaning: r4bvaluesets.Consentdatameaning,
    reference: Reference,
  )
}

pub fn consent_provision_data_new(
  reference reference: Reference,
  meaning meaning: r4bvaluesets.Consentdatameaning,
) -> ConsentProvisionData {
  ConsentProvisionData(
    reference:,
    meaning:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn consent_provision_data_to_json(
  consent_provision_data: ConsentProvisionData,
) -> Json {
  let ConsentProvisionData(
    reference:,
    meaning:,
    modifier_extension:,
    extension:,
    id:,
  ) = consent_provision_data
  let fields = [
    #("reference", reference_to_json(reference)),
    #("meaning", r4bvaluesets.consentdatameaning_to_json(meaning)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn consent_provision_data_decoder() -> Decoder(ConsentProvisionData) {
  use reference <- decode.field("reference", reference_decoder())
  use meaning <- decode.field(
    "meaning",
    r4bvaluesets.consentdatameaning_decoder(),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ConsentProvisionData(
    reference:,
    meaning:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn consent_provision_actor_to_json(
  consent_provision_actor: ConsentProvisionActor,
) -> Json {
  let ConsentProvisionActor(
    reference:,
    role:,
    modifier_extension:,
    extension:,
    id:,
  ) = consent_provision_actor
  let fields = [
    #("reference", reference_to_json(reference)),
    #("role", codeableconcept_to_json(role)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn consent_provision_actor_decoder() -> Decoder(ConsentProvisionActor) {
  use reference <- decode.field("reference", reference_decoder())
  use role <- decode.field("role", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ConsentProvisionActor(
    reference:,
    role:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn consent_provision_to_json(consent_provision: ConsentProvision) -> Json {
  let ConsentProvision(
    data:,
    data_period:,
    code:,
    class:,
    purpose:,
    security_label:,
    action:,
    actor:,
    period:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = consent_provision
  let fields = []
  let fields = case data {
    [] -> fields
    _ -> [#("data", json.array(data, consent_provision_data_to_json)), ..fields]
  }
  let fields = case data_period {
    Some(v) -> [#("dataPeriod", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case code {
    [] -> fields
    _ -> [#("code", json.array(code, codeableconcept_to_json)), ..fields]
  }
  let fields = case class {
    [] -> fields
    _ -> [#("class", json.array(class, coding_to_json)), ..fields]
  }
  let fields = case purpose {
    [] -> fields
    _ -> [#("purpose", json.array(purpose, coding_to_json)), ..fields]
  }
  let fields = case security_label {
    [] -> fields
    _ -> [
      #("securityLabel", json.array(security_label, coding_to_json)),
      ..fields
    ]
  }
  let fields = case action {
    [] -> fields
    _ -> [#("action", json.array(action, codeableconcept_to_json)), ..fields]
  }
  let fields = case actor {
    [] -> fields
    _ -> [
      #("actor", json.array(actor, consent_provision_actor_to_json)),
      ..fields
    ]
  }
  let fields = case period {
    Some(v) -> [#("period", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [
      #("type", r4bvaluesets.consentprovisiontype_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn consent_provision_decoder() -> Decoder(ConsentProvision) {
  use data <- decode.optional_field(
    "data",
    [],
    decode.list(consent_provision_data_decoder()),
  )
  use data_period <- decode.optional_field(
    "dataPeriod",
    None,
    decode.optional(period_decoder()),
  )
  use code <- decode.optional_field(
    "code",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use class <- decode.optional_field("class", [], decode.list(coding_decoder()))
  use purpose <- decode.optional_field(
    "purpose",
    [],
    decode.list(coding_decoder()),
  )
  use security_label <- decode.optional_field(
    "securityLabel",
    [],
    decode.list(coding_decoder()),
  )
  use action <- decode.optional_field(
    "action",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use actor <- decode.optional_field(
    "actor",
    [],
    decode.list(consent_provision_actor_decoder()),
  )
  use period <- decode.optional_field(
    "period",
    None,
    decode.optional(period_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(r4bvaluesets.consentprovisiontype_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ConsentProvision(
    data:,
    data_period:,
    code:,
    class:,
    purpose:,
    security_label:,
    action:,
    actor:,
    period:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn consent_verification_to_json(
  consent_verification: ConsentVerification,
) -> Json {
  let ConsentVerification(
    verification_date:,
    verified_with:,
    verified:,
    modifier_extension:,
    extension:,
    id:,
  ) = consent_verification
  let fields = [
    #("verified", json.bool(verified)),
  ]
  let fields = case verification_date {
    Some(v) -> [#("verificationDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case verified_with {
    Some(v) -> [#("verifiedWith", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn consent_verification_decoder() -> Decoder(ConsentVerification) {
  use verification_date <- decode.optional_field(
    "verificationDate",
    None,
    decode.optional(decode.string),
  )
  use verified_with <- decode.optional_field(
    "verifiedWith",
    None,
    decode.optional(reference_decoder()),
  )
  use verified <- decode.field("verified", decode.bool)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ConsentVerification(
    verification_date:,
    verified_with:,
    verified:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn consent_policy_to_json(consent_policy: ConsentPolicy) -> Json {
  let ConsentPolicy(uri:, authority:, modifier_extension:, extension:, id:) =
    consent_policy
  let fields = []
  let fields = case uri {
    Some(v) -> [#("uri", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case authority {
    Some(v) -> [#("authority", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn consent_policy_decoder() -> Decoder(ConsentPolicy) {
  use uri <- decode.optional_field("uri", None, decode.optional(decode.string))
  use authority <- decode.optional_field(
    "authority",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ConsentPolicy(
    uri:,
    authority:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn consent_to_json(consent: Consent) -> Json {
  let Consent(
    provision:,
    verification:,
    policy_rule:,
    policy:,
    source:,
    organization:,
    performer:,
    date_time:,
    patient:,
    category:,
    scope:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = consent
  let fields = [
    #("scope", codeableconcept_to_json(scope)),
    #("status", r4bvaluesets.consentstatecodes_to_json(status)),
  ]
  let fields = case provision {
    Some(v) -> [#("provision", consent_provision_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case verification {
    [] -> fields
    _ -> [
      #("verification", json.array(verification, consent_verification_to_json)),
      ..fields
    ]
  }
  let fields = case policy_rule {
    Some(v) -> [#("policyRule", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case policy {
    [] -> fields
    _ -> [#("policy", json.array(policy, consent_policy_to_json)), ..fields]
  }
  let fields = case source {
    Some(v) -> [
      #(
        "source"
          <> case v {
          ConsentSourceAttachment(_) -> "Attachment"
          ConsentSourceReference(_) -> "Reference"
        },
        consent_source_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case organization {
    [] -> fields
    _ -> [
      #("organization", json.array(organization, reference_to_json)),
      ..fields
    ]
  }
  let fields = case performer {
    [] -> fields
    _ -> [#("performer", json.array(performer, reference_to_json)), ..fields]
  }
  let fields = case date_time {
    Some(v) -> [#("dateTime", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case patient {
    Some(v) -> [#("patient", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case category {
    [] -> fields
    _ -> [
      #("category", json.array(category, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Consent")), ..fields]
  json.object(fields)
}

pub fn consent_decoder() -> Decoder(Consent) {
  use provision <- decode.optional_field(
    "provision",
    None,
    decode.optional(consent_provision_decoder()),
  )
  use verification <- decode.optional_field(
    "verification",
    [],
    decode.list(consent_verification_decoder()),
  )
  use policy_rule <- decode.optional_field(
    "policyRule",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use policy <- decode.optional_field(
    "policy",
    [],
    decode.list(consent_policy_decoder()),
  )
  use source <- decode.then(none_if_omitted(consent_source_decoder()))
  use organization <- decode.optional_field(
    "organization",
    [],
    decode.list(reference_decoder()),
  )
  use performer <- decode.optional_field(
    "performer",
    [],
    decode.list(reference_decoder()),
  )
  use date_time <- decode.optional_field(
    "dateTime",
    None,
    decode.optional(decode.string),
  )
  use patient <- decode.optional_field(
    "patient",
    None,
    decode.optional(reference_decoder()),
  )
  use category <- decode.optional_field(
    "category",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use scope <- decode.field("scope", codeableconcept_decoder())
  use status <- decode.field("status", r4bvaluesets.consentstatecodes_decoder())
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Consent",
    decode.failure(consent_new(scope:, status:), "resourceType"),
  )
  decode.success(Consent(
    provision:,
    verification:,
    policy_rule:,
    policy:,
    source:,
    organization:,
    performer:,
    date_time:,
    patient:,
    category:,
    scope:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/Contract#resource
pub type Contract {
  Contract(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    url: Option(String),
    version: Option(String),
    status: Option(r4bvaluesets.Contractstatus),
    legal_state: Option(Codeableconcept),
    instantiates_canonical: Option(Reference),
    instantiates_uri: Option(String),
    content_derivative: Option(Codeableconcept),
    issued: Option(String),
    applies: Option(Period),
    expiration_type: Option(Codeableconcept),
    subject: List(Reference),
    authority: List(Reference),
    domain: List(Reference),
    site: List(Reference),
    name: Option(String),
    title: Option(String),
    subtitle: Option(String),
    alias: List(String),
    author: Option(Reference),
    scope: Option(Codeableconcept),
    topic: Option(ContractTopic),
    type_: Option(Codeableconcept),
    sub_type: List(Codeableconcept),
    content_definition: Option(ContractContentdefinition),
    term: List(ContractTerm),
    supporting_info: List(Reference),
    relevant_history: List(Reference),
    signer: List(ContractSigner),
    friendly: List(ContractFriendly),
    legal: List(ContractLegal),
    rule: List(ContractRule),
    legally_binding: Option(ContractLegallybinding),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Contract#resource
pub type ContractTopic {
  ContractTopicCodeableconcept(topic: Codeableconcept)
  ContractTopicReference(topic: Reference)
}

pub fn contract_topic_to_json(elt: ContractTopic) -> Json {
  case elt {
    ContractTopicCodeableconcept(v) -> codeableconcept_to_json(v)
    ContractTopicReference(v) -> reference_to_json(v)
  }
}

pub fn contract_topic_decoder() -> Decoder(ContractTopic) {
  decode.one_of(
    decode.field(
      "topicCodeableConcept",
      codeableconcept_decoder(),
      decode.success,
    )
      |> decode.map(ContractTopicCodeableconcept),
    [
      decode.field("topicReference", reference_decoder(), decode.success)
      |> decode.map(ContractTopicReference),
    ],
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Contract#resource
pub type ContractLegallybinding {
  ContractLegallybindingAttachment(legally_binding: Attachment)
  ContractLegallybindingReference(legally_binding: Reference)
}

pub fn contract_legallybinding_to_json(elt: ContractLegallybinding) -> Json {
  case elt {
    ContractLegallybindingAttachment(v) -> attachment_to_json(v)
    ContractLegallybindingReference(v) -> reference_to_json(v)
  }
}

pub fn contract_legallybinding_decoder() -> Decoder(ContractLegallybinding) {
  decode.one_of(
    decode.field(
      "legallyBindingAttachment",
      attachment_decoder(),
      decode.success,
    )
      |> decode.map(ContractLegallybindingAttachment),
    [
      decode.field(
        "legallyBindingReference",
        reference_decoder(),
        decode.success,
      )
      |> decode.map(ContractLegallybindingReference),
    ],
  )
}

pub fn contract_new() -> Contract {
  Contract(
    legally_binding: None,
    rule: [],
    legal: [],
    friendly: [],
    signer: [],
    relevant_history: [],
    supporting_info: [],
    term: [],
    content_definition: None,
    sub_type: [],
    type_: None,
    topic: None,
    scope: None,
    author: None,
    alias: [],
    subtitle: None,
    title: None,
    name: None,
    site: [],
    domain: [],
    authority: [],
    subject: [],
    expiration_type: None,
    applies: None,
    issued: None,
    content_derivative: None,
    instantiates_uri: None,
    instantiates_canonical: None,
    legal_state: None,
    status: None,
    version: None,
    url: None,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Contract#resource
pub type ContractContentdefinition {
  ContractContentdefinition(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Codeableconcept,
    sub_type: Option(Codeableconcept),
    publisher: Option(Reference),
    publication_date: Option(String),
    publication_status: r4bvaluesets.Contractpublicationstatus,
    copyright: Option(String),
  )
}

pub fn contract_contentdefinition_new(
  publication_status publication_status: r4bvaluesets.Contractpublicationstatus,
  type_ type_: Codeableconcept,
) -> ContractContentdefinition {
  ContractContentdefinition(
    copyright: None,
    publication_status:,
    publication_date: None,
    publisher: None,
    sub_type: None,
    type_:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Contract#resource
pub type ContractTerm {
  ContractTerm(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: Option(Identifier),
    issued: Option(String),
    applies: Option(Period),
    topic: Option(ContractTermTopic),
    type_: Option(Codeableconcept),
    sub_type: Option(Codeableconcept),
    text: Option(String),
    security_label: List(ContractTermSecuritylabel),
    offer: ContractTermOffer,
    asset: List(ContractTermAsset),
    action: List(ContractTermAction),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Contract#resource
pub type ContractTermTopic {
  ContractTermTopicCodeableconcept(topic: Codeableconcept)
  ContractTermTopicReference(topic: Reference)
}

pub fn contract_term_topic_to_json(elt: ContractTermTopic) -> Json {
  case elt {
    ContractTermTopicCodeableconcept(v) -> codeableconcept_to_json(v)
    ContractTermTopicReference(v) -> reference_to_json(v)
  }
}

pub fn contract_term_topic_decoder() -> Decoder(ContractTermTopic) {
  decode.one_of(
    decode.field(
      "topicCodeableConcept",
      codeableconcept_decoder(),
      decode.success,
    )
      |> decode.map(ContractTermTopicCodeableconcept),
    [
      decode.field("topicReference", reference_decoder(), decode.success)
      |> decode.map(ContractTermTopicReference),
    ],
  )
}

pub fn contract_term_new(offer offer: ContractTermOffer) -> ContractTerm {
  ContractTerm(
    action: [],
    asset: [],
    offer:,
    security_label: [],
    text: None,
    sub_type: None,
    type_: None,
    topic: None,
    applies: None,
    issued: None,
    identifier: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Contract#resource
pub type ContractTermSecuritylabel {
  ContractTermSecuritylabel(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    number: List(Int),
    classification: Coding,
    category: List(Coding),
    control: List(Coding),
  )
}

pub fn contract_term_securitylabel_new(
  classification classification: Coding,
) -> ContractTermSecuritylabel {
  ContractTermSecuritylabel(
    control: [],
    category: [],
    classification:,
    number: [],
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Contract#resource
pub type ContractTermOffer {
  ContractTermOffer(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    party: List(ContractTermOfferParty),
    topic: Option(Reference),
    type_: Option(Codeableconcept),
    decision: Option(Codeableconcept),
    decision_mode: List(Codeableconcept),
    answer: List(ContractTermOfferAnswer),
    text: Option(String),
    link_id: List(String),
    security_label_number: List(Int),
  )
}

pub fn contract_term_offer_new() -> ContractTermOffer {
  ContractTermOffer(
    security_label_number: [],
    link_id: [],
    text: None,
    answer: [],
    decision_mode: [],
    decision: None,
    type_: None,
    topic: None,
    party: [],
    identifier: [],
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Contract#resource
pub type ContractTermOfferParty {
  ContractTermOfferParty(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    reference: List(Reference),
    role: Codeableconcept,
  )
}

pub fn contract_term_offer_party_new(
  role role: Codeableconcept,
) -> ContractTermOfferParty {
  ContractTermOfferParty(
    role:,
    reference: [],
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Contract#resource
pub type ContractTermOfferAnswer {
  ContractTermOfferAnswer(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    value: ContractTermOfferAnswerValue,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Contract#resource
pub type ContractTermOfferAnswerValue {
  ContractTermOfferAnswerValueBoolean(value: Bool)
  ContractTermOfferAnswerValueDecimal(value: Float)
  ContractTermOfferAnswerValueInteger(value: Int)
  ContractTermOfferAnswerValueDate(value: String)
  ContractTermOfferAnswerValueDatetime(value: String)
  ContractTermOfferAnswerValueTime(value: String)
  ContractTermOfferAnswerValueString(value: String)
  ContractTermOfferAnswerValueUri(value: String)
  ContractTermOfferAnswerValueAttachment(value: Attachment)
  ContractTermOfferAnswerValueCoding(value: Coding)
  ContractTermOfferAnswerValueQuantity(value: Quantity)
  ContractTermOfferAnswerValueReference(value: Reference)
}

pub fn contract_term_offer_answer_value_to_json(
  elt: ContractTermOfferAnswerValue,
) -> Json {
  case elt {
    ContractTermOfferAnswerValueBoolean(v) -> json.bool(v)
    ContractTermOfferAnswerValueDecimal(v) -> json.float(v)
    ContractTermOfferAnswerValueInteger(v) -> json.int(v)
    ContractTermOfferAnswerValueDate(v) -> json.string(v)
    ContractTermOfferAnswerValueDatetime(v) -> json.string(v)
    ContractTermOfferAnswerValueTime(v) -> json.string(v)
    ContractTermOfferAnswerValueString(v) -> json.string(v)
    ContractTermOfferAnswerValueUri(v) -> json.string(v)
    ContractTermOfferAnswerValueAttachment(v) -> attachment_to_json(v)
    ContractTermOfferAnswerValueCoding(v) -> coding_to_json(v)
    ContractTermOfferAnswerValueQuantity(v) -> quantity_to_json(v)
    ContractTermOfferAnswerValueReference(v) -> reference_to_json(v)
  }
}

pub fn contract_term_offer_answer_value_decoder() -> Decoder(
  ContractTermOfferAnswerValue,
) {
  decode.one_of(
    decode.field("valueBoolean", decode.bool, decode.success)
      |> decode.map(ContractTermOfferAnswerValueBoolean),
    [
      decode.field("valueDecimal", decode.float, decode.success)
        |> decode.map(ContractTermOfferAnswerValueDecimal),
      decode.field("valueInteger", decode.int, decode.success)
        |> decode.map(ContractTermOfferAnswerValueInteger),
      decode.field("valueDate", decode.string, decode.success)
        |> decode.map(ContractTermOfferAnswerValueDate),
      decode.field("valueDateTime", decode.string, decode.success)
        |> decode.map(ContractTermOfferAnswerValueDatetime),
      decode.field("valueTime", decode.string, decode.success)
        |> decode.map(ContractTermOfferAnswerValueTime),
      decode.field("valueString", decode.string, decode.success)
        |> decode.map(ContractTermOfferAnswerValueString),
      decode.field("valueUri", decode.string, decode.success)
        |> decode.map(ContractTermOfferAnswerValueUri),
      decode.field("valueAttachment", attachment_decoder(), decode.success)
        |> decode.map(ContractTermOfferAnswerValueAttachment),
      decode.field("valueCoding", coding_decoder(), decode.success)
        |> decode.map(ContractTermOfferAnswerValueCoding),
      decode.field("valueQuantity", quantity_decoder(), decode.success)
        |> decode.map(ContractTermOfferAnswerValueQuantity),
      decode.field("valueReference", reference_decoder(), decode.success)
        |> decode.map(ContractTermOfferAnswerValueReference),
    ],
  )
}

pub fn contract_term_offer_answer_new(
  value value: ContractTermOfferAnswerValue,
) -> ContractTermOfferAnswer {
  ContractTermOfferAnswer(
    value:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Contract#resource
pub type ContractTermAsset {
  ContractTermAsset(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    scope: Option(Codeableconcept),
    type_: List(Codeableconcept),
    type_reference: List(Reference),
    subtype: List(Codeableconcept),
    relationship: Option(Coding),
    context: List(ContractTermAssetContext),
    condition: Option(String),
    period_type: List(Codeableconcept),
    period: List(Period),
    use_period: List(Period),
    text: Option(String),
    link_id: List(String),
    security_label_number: List(Int),
    valued_item: List(ContractTermAssetValueditem),
  )
}

pub fn contract_term_asset_new() -> ContractTermAsset {
  ContractTermAsset(
    valued_item: [],
    security_label_number: [],
    link_id: [],
    text: None,
    use_period: [],
    period: [],
    period_type: [],
    condition: None,
    context: [],
    relationship: None,
    subtype: [],
    type_reference: [],
    type_: [],
    scope: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Contract#resource
pub type ContractTermAssetContext {
  ContractTermAssetContext(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    reference: Option(Reference),
    code: List(Codeableconcept),
    text: Option(String),
  )
}

pub fn contract_term_asset_context_new() -> ContractTermAssetContext {
  ContractTermAssetContext(
    text: None,
    code: [],
    reference: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Contract#resource
pub type ContractTermAssetValueditem {
  ContractTermAssetValueditem(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    entity: Option(ContractTermAssetValueditemEntity),
    identifier: Option(Identifier),
    effective_time: Option(String),
    quantity: Option(Quantity),
    unit_price: Option(Money),
    factor: Option(Float),
    points: Option(Float),
    net: Option(Money),
    payment: Option(String),
    payment_date: Option(String),
    responsible: Option(Reference),
    recipient: Option(Reference),
    link_id: List(String),
    security_label_number: List(Int),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Contract#resource
pub type ContractTermAssetValueditemEntity {
  ContractTermAssetValueditemEntityCodeableconcept(entity: Codeableconcept)
  ContractTermAssetValueditemEntityReference(entity: Reference)
}

pub fn contract_term_asset_valueditem_entity_to_json(
  elt: ContractTermAssetValueditemEntity,
) -> Json {
  case elt {
    ContractTermAssetValueditemEntityCodeableconcept(v) ->
      codeableconcept_to_json(v)
    ContractTermAssetValueditemEntityReference(v) -> reference_to_json(v)
  }
}

pub fn contract_term_asset_valueditem_entity_decoder() -> Decoder(
  ContractTermAssetValueditemEntity,
) {
  decode.one_of(
    decode.field(
      "entityCodeableConcept",
      codeableconcept_decoder(),
      decode.success,
    )
      |> decode.map(ContractTermAssetValueditemEntityCodeableconcept),
    [
      decode.field("entityReference", reference_decoder(), decode.success)
      |> decode.map(ContractTermAssetValueditemEntityReference),
    ],
  )
}

pub fn contract_term_asset_valueditem_new() -> ContractTermAssetValueditem {
  ContractTermAssetValueditem(
    security_label_number: [],
    link_id: [],
    recipient: None,
    responsible: None,
    payment_date: None,
    payment: None,
    net: None,
    points: None,
    factor: None,
    unit_price: None,
    quantity: None,
    effective_time: None,
    identifier: None,
    entity: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Contract#resource
pub type ContractTermAction {
  ContractTermAction(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    do_not_perform: Option(Bool),
    type_: Codeableconcept,
    subject: List(ContractTermActionSubject),
    intent: Codeableconcept,
    link_id: List(String),
    status: Codeableconcept,
    context: Option(Reference),
    context_link_id: List(String),
    occurrence: Option(ContractTermActionOccurrence),
    requester: List(Reference),
    requester_link_id: List(String),
    performer_type: List(Codeableconcept),
    performer_role: Option(Codeableconcept),
    performer: Option(Reference),
    performer_link_id: List(String),
    reason_code: List(Codeableconcept),
    reason_reference: List(Reference),
    reason: List(String),
    reason_link_id: List(String),
    note: List(Annotation),
    security_label_number: List(Int),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Contract#resource
pub type ContractTermActionOccurrence {
  ContractTermActionOccurrenceDatetime(occurrence: String)
  ContractTermActionOccurrencePeriod(occurrence: Period)
  ContractTermActionOccurrenceTiming(occurrence: Timing)
}

pub fn contract_term_action_occurrence_to_json(
  elt: ContractTermActionOccurrence,
) -> Json {
  case elt {
    ContractTermActionOccurrenceDatetime(v) -> json.string(v)
    ContractTermActionOccurrencePeriod(v) -> period_to_json(v)
    ContractTermActionOccurrenceTiming(v) -> timing_to_json(v)
  }
}

pub fn contract_term_action_occurrence_decoder() -> Decoder(
  ContractTermActionOccurrence,
) {
  decode.one_of(
    decode.field("occurrenceDateTime", decode.string, decode.success)
      |> decode.map(ContractTermActionOccurrenceDatetime),
    [
      decode.field("occurrencePeriod", period_decoder(), decode.success)
        |> decode.map(ContractTermActionOccurrencePeriod),
      decode.field("occurrenceTiming", timing_decoder(), decode.success)
        |> decode.map(ContractTermActionOccurrenceTiming),
    ],
  )
}

pub fn contract_term_action_new(
  status status: Codeableconcept,
  intent intent: Codeableconcept,
  type_ type_: Codeableconcept,
) -> ContractTermAction {
  ContractTermAction(
    security_label_number: [],
    note: [],
    reason_link_id: [],
    reason: [],
    reason_reference: [],
    reason_code: [],
    performer_link_id: [],
    performer: None,
    performer_role: None,
    performer_type: [],
    requester_link_id: [],
    requester: [],
    occurrence: None,
    context_link_id: [],
    context: None,
    status:,
    link_id: [],
    intent:,
    subject: [],
    type_:,
    do_not_perform: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Contract#resource
pub type ContractTermActionSubject {
  ContractTermActionSubject(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    reference: List(Reference),
    role: Option(Codeableconcept),
  )
}

pub fn contract_term_action_subject_new() -> ContractTermActionSubject {
  ContractTermActionSubject(
    role: None,
    reference: [],
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Contract#resource
pub type ContractSigner {
  ContractSigner(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Coding,
    party: Reference,
    signature: List(Signature),
  )
}

pub fn contract_signer_new(
  party party: Reference,
  type_ type_: Coding,
) -> ContractSigner {
  ContractSigner(
    signature: [],
    party:,
    type_:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Contract#resource
pub type ContractFriendly {
  ContractFriendly(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    content: ContractFriendlyContent,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Contract#resource
pub type ContractFriendlyContent {
  ContractFriendlyContentAttachment(content: Attachment)
  ContractFriendlyContentReference(content: Reference)
}

pub fn contract_friendly_content_to_json(elt: ContractFriendlyContent) -> Json {
  case elt {
    ContractFriendlyContentAttachment(v) -> attachment_to_json(v)
    ContractFriendlyContentReference(v) -> reference_to_json(v)
  }
}

pub fn contract_friendly_content_decoder() -> Decoder(ContractFriendlyContent) {
  decode.one_of(
    decode.field("contentAttachment", attachment_decoder(), decode.success)
      |> decode.map(ContractFriendlyContentAttachment),
    [
      decode.field("contentReference", reference_decoder(), decode.success)
      |> decode.map(ContractFriendlyContentReference),
    ],
  )
}

pub fn contract_friendly_new(
  content content: ContractFriendlyContent,
) -> ContractFriendly {
  ContractFriendly(content:, modifier_extension: [], extension: [], id: None)
}

///http://hl7.org/fhir/r4b/StructureDefinition/Contract#resource
pub type ContractLegal {
  ContractLegal(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    content: ContractLegalContent,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Contract#resource
pub type ContractLegalContent {
  ContractLegalContentAttachment(content: Attachment)
  ContractLegalContentReference(content: Reference)
}

pub fn contract_legal_content_to_json(elt: ContractLegalContent) -> Json {
  case elt {
    ContractLegalContentAttachment(v) -> attachment_to_json(v)
    ContractLegalContentReference(v) -> reference_to_json(v)
  }
}

pub fn contract_legal_content_decoder() -> Decoder(ContractLegalContent) {
  decode.one_of(
    decode.field("contentAttachment", attachment_decoder(), decode.success)
      |> decode.map(ContractLegalContentAttachment),
    [
      decode.field("contentReference", reference_decoder(), decode.success)
      |> decode.map(ContractLegalContentReference),
    ],
  )
}

pub fn contract_legal_new(
  content content: ContractLegalContent,
) -> ContractLegal {
  ContractLegal(content:, modifier_extension: [], extension: [], id: None)
}

///http://hl7.org/fhir/r4b/StructureDefinition/Contract#resource
pub type ContractRule {
  ContractRule(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    content: ContractRuleContent,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Contract#resource
pub type ContractRuleContent {
  ContractRuleContentAttachment(content: Attachment)
  ContractRuleContentReference(content: Reference)
}

pub fn contract_rule_content_to_json(elt: ContractRuleContent) -> Json {
  case elt {
    ContractRuleContentAttachment(v) -> attachment_to_json(v)
    ContractRuleContentReference(v) -> reference_to_json(v)
  }
}

pub fn contract_rule_content_decoder() -> Decoder(ContractRuleContent) {
  decode.one_of(
    decode.field("contentAttachment", attachment_decoder(), decode.success)
      |> decode.map(ContractRuleContentAttachment),
    [
      decode.field("contentReference", reference_decoder(), decode.success)
      |> decode.map(ContractRuleContentReference),
    ],
  )
}

pub fn contract_rule_new(content content: ContractRuleContent) -> ContractRule {
  ContractRule(content:, modifier_extension: [], extension: [], id: None)
}

pub fn contract_rule_to_json(contract_rule: ContractRule) -> Json {
  let ContractRule(content:, modifier_extension:, extension:, id:) =
    contract_rule
  let fields = [
    #("content", contract_rule_content_to_json(content)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn contract_rule_decoder() -> Decoder(ContractRule) {
  use content <- decode.then(contract_rule_content_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ContractRule(content:, modifier_extension:, extension:, id:))
}

pub fn contract_legal_to_json(contract_legal: ContractLegal) -> Json {
  let ContractLegal(content:, modifier_extension:, extension:, id:) =
    contract_legal
  let fields = [
    #("content", contract_legal_content_to_json(content)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn contract_legal_decoder() -> Decoder(ContractLegal) {
  use content <- decode.then(contract_legal_content_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ContractLegal(content:, modifier_extension:, extension:, id:))
}

pub fn contract_friendly_to_json(contract_friendly: ContractFriendly) -> Json {
  let ContractFriendly(content:, modifier_extension:, extension:, id:) =
    contract_friendly
  let fields = [
    #("content", contract_friendly_content_to_json(content)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn contract_friendly_decoder() -> Decoder(ContractFriendly) {
  use content <- decode.then(contract_friendly_content_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ContractFriendly(
    content:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn contract_signer_to_json(contract_signer: ContractSigner) -> Json {
  let ContractSigner(
    signature:,
    party:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = contract_signer
  let fields = [
    #("party", reference_to_json(party)),
    #("type", coding_to_json(type_)),
  ]
  let fields = case signature {
    [] -> fields
    _ -> [#("signature", json.array(signature, signature_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn contract_signer_decoder() -> Decoder(ContractSigner) {
  use signature <- decode.optional_field(
    "signature",
    [],
    decode.list(signature_decoder()),
  )
  use party <- decode.field("party", reference_decoder())
  use type_ <- decode.field("type", coding_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ContractSigner(
    signature:,
    party:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn contract_term_action_subject_to_json(
  contract_term_action_subject: ContractTermActionSubject,
) -> Json {
  let ContractTermActionSubject(
    role:,
    reference:,
    modifier_extension:,
    extension:,
    id:,
  ) = contract_term_action_subject
  let fields = []
  let fields = case role {
    Some(v) -> [#("role", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case reference {
    [] -> fields
    _ -> [#("reference", json.array(reference, reference_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn contract_term_action_subject_decoder() -> Decoder(
  ContractTermActionSubject,
) {
  use role <- decode.optional_field(
    "role",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use reference <- decode.optional_field(
    "reference",
    [],
    decode.list(reference_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ContractTermActionSubject(
    role:,
    reference:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn contract_term_action_to_json(
  contract_term_action: ContractTermAction,
) -> Json {
  let ContractTermAction(
    security_label_number:,
    note:,
    reason_link_id:,
    reason:,
    reason_reference:,
    reason_code:,
    performer_link_id:,
    performer:,
    performer_role:,
    performer_type:,
    requester_link_id:,
    requester:,
    occurrence:,
    context_link_id:,
    context:,
    status:,
    link_id:,
    intent:,
    subject:,
    type_:,
    do_not_perform:,
    modifier_extension:,
    extension:,
    id:,
  ) = contract_term_action
  let fields = [
    #("status", codeableconcept_to_json(status)),
    #("intent", codeableconcept_to_json(intent)),
    #("type", codeableconcept_to_json(type_)),
  ]
  let fields = case security_label_number {
    [] -> fields
    _ -> [
      #("securityLabelNumber", json.array(security_label_number, json.int)),
      ..fields
    ]
  }
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case reason_link_id {
    [] -> fields
    _ -> [#("reasonLinkId", json.array(reason_link_id, json.string)), ..fields]
  }
  let fields = case reason {
    [] -> fields
    _ -> [#("reason", json.array(reason, json.string)), ..fields]
  }
  let fields = case reason_reference {
    [] -> fields
    _ -> [
      #("reasonReference", json.array(reason_reference, reference_to_json)),
      ..fields
    ]
  }
  let fields = case reason_code {
    [] -> fields
    _ -> [
      #("reasonCode", json.array(reason_code, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case performer_link_id {
    [] -> fields
    _ -> [
      #("performerLinkId", json.array(performer_link_id, json.string)),
      ..fields
    ]
  }
  let fields = case performer {
    Some(v) -> [#("performer", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case performer_role {
    Some(v) -> [#("performerRole", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case performer_type {
    [] -> fields
    _ -> [
      #("performerType", json.array(performer_type, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case requester_link_id {
    [] -> fields
    _ -> [
      #("requesterLinkId", json.array(requester_link_id, json.string)),
      ..fields
    ]
  }
  let fields = case requester {
    [] -> fields
    _ -> [#("requester", json.array(requester, reference_to_json)), ..fields]
  }
  let fields = case occurrence {
    Some(v) -> [
      #(
        "occurrence"
          <> case v {
          ContractTermActionOccurrenceDatetime(_) -> "Datetime"
          ContractTermActionOccurrencePeriod(_) -> "Period"
          ContractTermActionOccurrenceTiming(_) -> "Timing"
        },
        contract_term_action_occurrence_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case context_link_id {
    [] -> fields
    _ -> [
      #("contextLinkId", json.array(context_link_id, json.string)),
      ..fields
    ]
  }
  let fields = case context {
    Some(v) -> [#("context", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case link_id {
    [] -> fields
    _ -> [#("linkId", json.array(link_id, json.string)), ..fields]
  }
  let fields = case subject {
    [] -> fields
    _ -> [
      #("subject", json.array(subject, contract_term_action_subject_to_json)),
      ..fields
    ]
  }
  let fields = case do_not_perform {
    Some(v) -> [#("doNotPerform", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn contract_term_action_decoder() -> Decoder(ContractTermAction) {
  use security_label_number <- decode.optional_field(
    "securityLabelNumber",
    [],
    decode.list(decode.int),
  )
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use reason_link_id <- decode.optional_field(
    "reasonLinkId",
    [],
    decode.list(decode.string),
  )
  use reason <- decode.optional_field("reason", [], decode.list(decode.string))
  use reason_reference <- decode.optional_field(
    "reasonReference",
    [],
    decode.list(reference_decoder()),
  )
  use reason_code <- decode.optional_field(
    "reasonCode",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use performer_link_id <- decode.optional_field(
    "performerLinkId",
    [],
    decode.list(decode.string),
  )
  use performer <- decode.optional_field(
    "performer",
    None,
    decode.optional(reference_decoder()),
  )
  use performer_role <- decode.optional_field(
    "performerRole",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use performer_type <- decode.optional_field(
    "performerType",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use requester_link_id <- decode.optional_field(
    "requesterLinkId",
    [],
    decode.list(decode.string),
  )
  use requester <- decode.optional_field(
    "requester",
    [],
    decode.list(reference_decoder()),
  )
  use occurrence <- decode.then(
    none_if_omitted(contract_term_action_occurrence_decoder()),
  )
  use context_link_id <- decode.optional_field(
    "contextLinkId",
    [],
    decode.list(decode.string),
  )
  use context <- decode.optional_field(
    "context",
    None,
    decode.optional(reference_decoder()),
  )
  use status <- decode.field("status", codeableconcept_decoder())
  use link_id <- decode.optional_field("linkId", [], decode.list(decode.string))
  use intent <- decode.field("intent", codeableconcept_decoder())
  use subject <- decode.optional_field(
    "subject",
    [],
    decode.list(contract_term_action_subject_decoder()),
  )
  use type_ <- decode.field("type", codeableconcept_decoder())
  use do_not_perform <- decode.optional_field(
    "doNotPerform",
    None,
    decode.optional(decode.bool),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ContractTermAction(
    security_label_number:,
    note:,
    reason_link_id:,
    reason:,
    reason_reference:,
    reason_code:,
    performer_link_id:,
    performer:,
    performer_role:,
    performer_type:,
    requester_link_id:,
    requester:,
    occurrence:,
    context_link_id:,
    context:,
    status:,
    link_id:,
    intent:,
    subject:,
    type_:,
    do_not_perform:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn contract_term_asset_valueditem_to_json(
  contract_term_asset_valueditem: ContractTermAssetValueditem,
) -> Json {
  let ContractTermAssetValueditem(
    security_label_number:,
    link_id:,
    recipient:,
    responsible:,
    payment_date:,
    payment:,
    net:,
    points:,
    factor:,
    unit_price:,
    quantity:,
    effective_time:,
    identifier:,
    entity:,
    modifier_extension:,
    extension:,
    id:,
  ) = contract_term_asset_valueditem
  let fields = []
  let fields = case security_label_number {
    [] -> fields
    _ -> [
      #("securityLabelNumber", json.array(security_label_number, json.int)),
      ..fields
    ]
  }
  let fields = case link_id {
    [] -> fields
    _ -> [#("linkId", json.array(link_id, json.string)), ..fields]
  }
  let fields = case recipient {
    Some(v) -> [#("recipient", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case responsible {
    Some(v) -> [#("responsible", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case payment_date {
    Some(v) -> [#("paymentDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case payment {
    Some(v) -> [#("payment", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case net {
    Some(v) -> [#("net", money_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case points {
    Some(v) -> [#("points", json.float(v)), ..fields]
    None -> fields
  }
  let fields = case factor {
    Some(v) -> [#("factor", json.float(v)), ..fields]
    None -> fields
  }
  let fields = case unit_price {
    Some(v) -> [#("unitPrice", money_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case quantity {
    Some(v) -> [#("quantity", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case effective_time {
    Some(v) -> [#("effectiveTime", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    Some(v) -> [#("identifier", identifier_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case entity {
    Some(v) -> [
      #(
        "entity"
          <> case v {
          ContractTermAssetValueditemEntityCodeableconcept(_) ->
            "Codeableconcept"
          ContractTermAssetValueditemEntityReference(_) -> "Reference"
        },
        contract_term_asset_valueditem_entity_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn contract_term_asset_valueditem_decoder() -> Decoder(
  ContractTermAssetValueditem,
) {
  use security_label_number <- decode.optional_field(
    "securityLabelNumber",
    [],
    decode.list(decode.int),
  )
  use link_id <- decode.optional_field("linkId", [], decode.list(decode.string))
  use recipient <- decode.optional_field(
    "recipient",
    None,
    decode.optional(reference_decoder()),
  )
  use responsible <- decode.optional_field(
    "responsible",
    None,
    decode.optional(reference_decoder()),
  )
  use payment_date <- decode.optional_field(
    "paymentDate",
    None,
    decode.optional(decode.string),
  )
  use payment <- decode.optional_field(
    "payment",
    None,
    decode.optional(decode.string),
  )
  use net <- decode.optional_field(
    "net",
    None,
    decode.optional(money_decoder()),
  )
  use points <- decode.optional_field(
    "points",
    None,
    decode.optional(decode.float),
  )
  use factor <- decode.optional_field(
    "factor",
    None,
    decode.optional(decode.float),
  )
  use unit_price <- decode.optional_field(
    "unitPrice",
    None,
    decode.optional(money_decoder()),
  )
  use quantity <- decode.optional_field(
    "quantity",
    None,
    decode.optional(quantity_decoder()),
  )
  use effective_time <- decode.optional_field(
    "effectiveTime",
    None,
    decode.optional(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    None,
    decode.optional(identifier_decoder()),
  )
  use entity <- decode.then(
    none_if_omitted(contract_term_asset_valueditem_entity_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ContractTermAssetValueditem(
    security_label_number:,
    link_id:,
    recipient:,
    responsible:,
    payment_date:,
    payment:,
    net:,
    points:,
    factor:,
    unit_price:,
    quantity:,
    effective_time:,
    identifier:,
    entity:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn contract_term_asset_context_to_json(
  contract_term_asset_context: ContractTermAssetContext,
) -> Json {
  let ContractTermAssetContext(
    text:,
    code:,
    reference:,
    modifier_extension:,
    extension:,
    id:,
  ) = contract_term_asset_context
  let fields = []
  let fields = case text {
    Some(v) -> [#("text", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case code {
    [] -> fields
    _ -> [#("code", json.array(code, codeableconcept_to_json)), ..fields]
  }
  let fields = case reference {
    Some(v) -> [#("reference", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn contract_term_asset_context_decoder() -> Decoder(
  ContractTermAssetContext,
) {
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(decode.string),
  )
  use code <- decode.optional_field(
    "code",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use reference <- decode.optional_field(
    "reference",
    None,
    decode.optional(reference_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ContractTermAssetContext(
    text:,
    code:,
    reference:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn contract_term_asset_to_json(
  contract_term_asset: ContractTermAsset,
) -> Json {
  let ContractTermAsset(
    valued_item:,
    security_label_number:,
    link_id:,
    text:,
    use_period:,
    period:,
    period_type:,
    condition:,
    context:,
    relationship:,
    subtype:,
    type_reference:,
    type_:,
    scope:,
    modifier_extension:,
    extension:,
    id:,
  ) = contract_term_asset
  let fields = []
  let fields = case valued_item {
    [] -> fields
    _ -> [
      #(
        "valuedItem",
        json.array(valued_item, contract_term_asset_valueditem_to_json),
      ),
      ..fields
    ]
  }
  let fields = case security_label_number {
    [] -> fields
    _ -> [
      #("securityLabelNumber", json.array(security_label_number, json.int)),
      ..fields
    ]
  }
  let fields = case link_id {
    [] -> fields
    _ -> [#("linkId", json.array(link_id, json.string)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case use_period {
    [] -> fields
    _ -> [#("usePeriod", json.array(use_period, period_to_json)), ..fields]
  }
  let fields = case period {
    [] -> fields
    _ -> [#("period", json.array(period, period_to_json)), ..fields]
  }
  let fields = case period_type {
    [] -> fields
    _ -> [
      #("periodType", json.array(period_type, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case condition {
    Some(v) -> [#("condition", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case context {
    [] -> fields
    _ -> [
      #("context", json.array(context, contract_term_asset_context_to_json)),
      ..fields
    ]
  }
  let fields = case relationship {
    Some(v) -> [#("relationship", coding_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case subtype {
    [] -> fields
    _ -> [#("subtype", json.array(subtype, codeableconcept_to_json)), ..fields]
  }
  let fields = case type_reference {
    [] -> fields
    _ -> [
      #("typeReference", json.array(type_reference, reference_to_json)),
      ..fields
    ]
  }
  let fields = case type_ {
    [] -> fields
    _ -> [#("type", json.array(type_, codeableconcept_to_json)), ..fields]
  }
  let fields = case scope {
    Some(v) -> [#("scope", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn contract_term_asset_decoder() -> Decoder(ContractTermAsset) {
  use valued_item <- decode.optional_field(
    "valuedItem",
    [],
    decode.list(contract_term_asset_valueditem_decoder()),
  )
  use security_label_number <- decode.optional_field(
    "securityLabelNumber",
    [],
    decode.list(decode.int),
  )
  use link_id <- decode.optional_field("linkId", [], decode.list(decode.string))
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(decode.string),
  )
  use use_period <- decode.optional_field(
    "usePeriod",
    [],
    decode.list(period_decoder()),
  )
  use period <- decode.optional_field(
    "period",
    [],
    decode.list(period_decoder()),
  )
  use period_type <- decode.optional_field(
    "periodType",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use condition <- decode.optional_field(
    "condition",
    None,
    decode.optional(decode.string),
  )
  use context <- decode.optional_field(
    "context",
    [],
    decode.list(contract_term_asset_context_decoder()),
  )
  use relationship <- decode.optional_field(
    "relationship",
    None,
    decode.optional(coding_decoder()),
  )
  use subtype <- decode.optional_field(
    "subtype",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use type_reference <- decode.optional_field(
    "typeReference",
    [],
    decode.list(reference_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use scope <- decode.optional_field(
    "scope",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ContractTermAsset(
    valued_item:,
    security_label_number:,
    link_id:,
    text:,
    use_period:,
    period:,
    period_type:,
    condition:,
    context:,
    relationship:,
    subtype:,
    type_reference:,
    type_:,
    scope:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn contract_term_offer_answer_to_json(
  contract_term_offer_answer: ContractTermOfferAnswer,
) -> Json {
  let ContractTermOfferAnswer(value:, modifier_extension:, extension:, id:) =
    contract_term_offer_answer
  let fields = [
    #("value", contract_term_offer_answer_value_to_json(value)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn contract_term_offer_answer_decoder() -> Decoder(ContractTermOfferAnswer) {
  use value <- decode.then(contract_term_offer_answer_value_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ContractTermOfferAnswer(
    value:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn contract_term_offer_party_to_json(
  contract_term_offer_party: ContractTermOfferParty,
) -> Json {
  let ContractTermOfferParty(
    role:,
    reference:,
    modifier_extension:,
    extension:,
    id:,
  ) = contract_term_offer_party
  let fields = [
    #("role", codeableconcept_to_json(role)),
  ]
  let fields = case reference {
    [] -> fields
    _ -> [#("reference", json.array(reference, reference_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn contract_term_offer_party_decoder() -> Decoder(ContractTermOfferParty) {
  use role <- decode.field("role", codeableconcept_decoder())
  use reference <- decode.optional_field(
    "reference",
    [],
    decode.list(reference_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ContractTermOfferParty(
    role:,
    reference:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn contract_term_offer_to_json(
  contract_term_offer: ContractTermOffer,
) -> Json {
  let ContractTermOffer(
    security_label_number:,
    link_id:,
    text:,
    answer:,
    decision_mode:,
    decision:,
    type_:,
    topic:,
    party:,
    identifier:,
    modifier_extension:,
    extension:,
    id:,
  ) = contract_term_offer
  let fields = []
  let fields = case security_label_number {
    [] -> fields
    _ -> [
      #("securityLabelNumber", json.array(security_label_number, json.int)),
      ..fields
    ]
  }
  let fields = case link_id {
    [] -> fields
    _ -> [#("linkId", json.array(link_id, json.string)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case answer {
    [] -> fields
    _ -> [
      #("answer", json.array(answer, contract_term_offer_answer_to_json)),
      ..fields
    ]
  }
  let fields = case decision_mode {
    [] -> fields
    _ -> [
      #("decisionMode", json.array(decision_mode, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case decision {
    Some(v) -> [#("decision", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case topic {
    Some(v) -> [#("topic", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case party {
    [] -> fields
    _ -> [
      #("party", json.array(party, contract_term_offer_party_to_json)),
      ..fields
    ]
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn contract_term_offer_decoder() -> Decoder(ContractTermOffer) {
  use security_label_number <- decode.optional_field(
    "securityLabelNumber",
    [],
    decode.list(decode.int),
  )
  use link_id <- decode.optional_field("linkId", [], decode.list(decode.string))
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(decode.string),
  )
  use answer <- decode.optional_field(
    "answer",
    [],
    decode.list(contract_term_offer_answer_decoder()),
  )
  use decision_mode <- decode.optional_field(
    "decisionMode",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use decision <- decode.optional_field(
    "decision",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use topic <- decode.optional_field(
    "topic",
    None,
    decode.optional(reference_decoder()),
  )
  use party <- decode.optional_field(
    "party",
    [],
    decode.list(contract_term_offer_party_decoder()),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ContractTermOffer(
    security_label_number:,
    link_id:,
    text:,
    answer:,
    decision_mode:,
    decision:,
    type_:,
    topic:,
    party:,
    identifier:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn contract_term_securitylabel_to_json(
  contract_term_securitylabel: ContractTermSecuritylabel,
) -> Json {
  let ContractTermSecuritylabel(
    control:,
    category:,
    classification:,
    number:,
    modifier_extension:,
    extension:,
    id:,
  ) = contract_term_securitylabel
  let fields = [
    #("classification", coding_to_json(classification)),
  ]
  let fields = case control {
    [] -> fields
    _ -> [#("control", json.array(control, coding_to_json)), ..fields]
  }
  let fields = case category {
    [] -> fields
    _ -> [#("category", json.array(category, coding_to_json)), ..fields]
  }
  let fields = case number {
    [] -> fields
    _ -> [#("number", json.array(number, json.int)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn contract_term_securitylabel_decoder() -> Decoder(
  ContractTermSecuritylabel,
) {
  use control <- decode.optional_field(
    "control",
    [],
    decode.list(coding_decoder()),
  )
  use category <- decode.optional_field(
    "category",
    [],
    decode.list(coding_decoder()),
  )
  use classification <- decode.field("classification", coding_decoder())
  use number <- decode.optional_field("number", [], decode.list(decode.int))
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ContractTermSecuritylabel(
    control:,
    category:,
    classification:,
    number:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn contract_term_to_json(contract_term: ContractTerm) -> Json {
  let ContractTerm(
    action:,
    asset:,
    offer:,
    security_label:,
    text:,
    sub_type:,
    type_:,
    topic:,
    applies:,
    issued:,
    identifier:,
    modifier_extension:,
    extension:,
    id:,
  ) = contract_term
  let fields = [
    #("offer", contract_term_offer_to_json(offer)),
  ]
  let fields = case action {
    [] -> fields
    _ -> [
      #("action", json.array(action, contract_term_action_to_json)),
      ..fields
    ]
  }
  let fields = case asset {
    [] -> fields
    _ -> [#("asset", json.array(asset, contract_term_asset_to_json)), ..fields]
  }
  let fields = case security_label {
    [] -> fields
    _ -> [
      #(
        "securityLabel",
        json.array(security_label, contract_term_securitylabel_to_json),
      ),
      ..fields
    ]
  }
  let fields = case text {
    Some(v) -> [#("text", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case sub_type {
    Some(v) -> [#("subType", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case topic {
    Some(v) -> [
      #(
        "topic"
          <> case v {
          ContractTermTopicCodeableconcept(_) -> "Codeableconcept"
          ContractTermTopicReference(_) -> "Reference"
        },
        contract_term_topic_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case applies {
    Some(v) -> [#("applies", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case issued {
    Some(v) -> [#("issued", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    Some(v) -> [#("identifier", identifier_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn contract_term_decoder() -> Decoder(ContractTerm) {
  use action <- decode.optional_field(
    "action",
    [],
    decode.list(contract_term_action_decoder()),
  )
  use asset <- decode.optional_field(
    "asset",
    [],
    decode.list(contract_term_asset_decoder()),
  )
  use offer <- decode.field("offer", contract_term_offer_decoder())
  use security_label <- decode.optional_field(
    "securityLabel",
    [],
    decode.list(contract_term_securitylabel_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(decode.string),
  )
  use sub_type <- decode.optional_field(
    "subType",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use topic <- decode.then(none_if_omitted(contract_term_topic_decoder()))
  use applies <- decode.optional_field(
    "applies",
    None,
    decode.optional(period_decoder()),
  )
  use issued <- decode.optional_field(
    "issued",
    None,
    decode.optional(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    None,
    decode.optional(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ContractTerm(
    action:,
    asset:,
    offer:,
    security_label:,
    text:,
    sub_type:,
    type_:,
    topic:,
    applies:,
    issued:,
    identifier:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn contract_contentdefinition_to_json(
  contract_contentdefinition: ContractContentdefinition,
) -> Json {
  let ContractContentdefinition(
    copyright:,
    publication_status:,
    publication_date:,
    publisher:,
    sub_type:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = contract_contentdefinition
  let fields = [
    #(
      "publicationStatus",
      r4bvaluesets.contractpublicationstatus_to_json(publication_status),
    ),
    #("type", codeableconcept_to_json(type_)),
  ]
  let fields = case copyright {
    Some(v) -> [#("copyright", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case publication_date {
    Some(v) -> [#("publicationDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case publisher {
    Some(v) -> [#("publisher", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case sub_type {
    Some(v) -> [#("subType", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn contract_contentdefinition_decoder() -> Decoder(
  ContractContentdefinition,
) {
  use copyright <- decode.optional_field(
    "copyright",
    None,
    decode.optional(decode.string),
  )
  use publication_status <- decode.field(
    "publicationStatus",
    r4bvaluesets.contractpublicationstatus_decoder(),
  )
  use publication_date <- decode.optional_field(
    "publicationDate",
    None,
    decode.optional(decode.string),
  )
  use publisher <- decode.optional_field(
    "publisher",
    None,
    decode.optional(reference_decoder()),
  )
  use sub_type <- decode.optional_field(
    "subType",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use type_ <- decode.field("type", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ContractContentdefinition(
    copyright:,
    publication_status:,
    publication_date:,
    publisher:,
    sub_type:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn contract_to_json(contract: Contract) -> Json {
  let Contract(
    legally_binding:,
    rule:,
    legal:,
    friendly:,
    signer:,
    relevant_history:,
    supporting_info:,
    term:,
    content_definition:,
    sub_type:,
    type_:,
    topic:,
    scope:,
    author:,
    alias:,
    subtitle:,
    title:,
    name:,
    site:,
    domain:,
    authority:,
    subject:,
    expiration_type:,
    applies:,
    issued:,
    content_derivative:,
    instantiates_uri:,
    instantiates_canonical:,
    legal_state:,
    status:,
    version:,
    url:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = contract
  let fields = []
  let fields = case legally_binding {
    Some(v) -> [
      #(
        "legallyBinding"
          <> case v {
          ContractLegallybindingAttachment(_) -> "Attachment"
          ContractLegallybindingReference(_) -> "Reference"
        },
        contract_legallybinding_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case rule {
    [] -> fields
    _ -> [#("rule", json.array(rule, contract_rule_to_json)), ..fields]
  }
  let fields = case legal {
    [] -> fields
    _ -> [#("legal", json.array(legal, contract_legal_to_json)), ..fields]
  }
  let fields = case friendly {
    [] -> fields
    _ -> [
      #("friendly", json.array(friendly, contract_friendly_to_json)),
      ..fields
    ]
  }
  let fields = case signer {
    [] -> fields
    _ -> [#("signer", json.array(signer, contract_signer_to_json)), ..fields]
  }
  let fields = case relevant_history {
    [] -> fields
    _ -> [
      #("relevantHistory", json.array(relevant_history, reference_to_json)),
      ..fields
    ]
  }
  let fields = case supporting_info {
    [] -> fields
    _ -> [
      #("supportingInfo", json.array(supporting_info, reference_to_json)),
      ..fields
    ]
  }
  let fields = case term {
    [] -> fields
    _ -> [#("term", json.array(term, contract_term_to_json)), ..fields]
  }
  let fields = case content_definition {
    Some(v) -> [
      #("contentDefinition", contract_contentdefinition_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case sub_type {
    [] -> fields
    _ -> [#("subType", json.array(sub_type, codeableconcept_to_json)), ..fields]
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case topic {
    Some(v) -> [
      #(
        "topic"
          <> case v {
          ContractTopicCodeableconcept(_) -> "Codeableconcept"
          ContractTopicReference(_) -> "Reference"
        },
        contract_topic_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case scope {
    Some(v) -> [#("scope", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case author {
    Some(v) -> [#("author", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case alias {
    [] -> fields
    _ -> [#("alias", json.array(alias, json.string)), ..fields]
  }
  let fields = case subtitle {
    Some(v) -> [#("subtitle", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case title {
    Some(v) -> [#("title", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case site {
    [] -> fields
    _ -> [#("site", json.array(site, reference_to_json)), ..fields]
  }
  let fields = case domain {
    [] -> fields
    _ -> [#("domain", json.array(domain, reference_to_json)), ..fields]
  }
  let fields = case authority {
    [] -> fields
    _ -> [#("authority", json.array(authority, reference_to_json)), ..fields]
  }
  let fields = case subject {
    [] -> fields
    _ -> [#("subject", json.array(subject, reference_to_json)), ..fields]
  }
  let fields = case expiration_type {
    Some(v) -> [#("expirationType", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case applies {
    Some(v) -> [#("applies", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case issued {
    Some(v) -> [#("issued", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case content_derivative {
    Some(v) -> [#("contentDerivative", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case instantiates_uri {
    Some(v) -> [#("instantiatesUri", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case instantiates_canonical {
    Some(v) -> [#("instantiatesCanonical", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case legal_state {
    Some(v) -> [#("legalState", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case status {
    Some(v) -> [#("status", r4bvaluesets.contractstatus_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case version {
    Some(v) -> [#("version", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case url {
    Some(v) -> [#("url", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Contract")), ..fields]
  json.object(fields)
}

pub fn contract_decoder() -> Decoder(Contract) {
  use legally_binding <- decode.then(
    none_if_omitted(contract_legallybinding_decoder()),
  )
  use rule <- decode.optional_field(
    "rule",
    [],
    decode.list(contract_rule_decoder()),
  )
  use legal <- decode.optional_field(
    "legal",
    [],
    decode.list(contract_legal_decoder()),
  )
  use friendly <- decode.optional_field(
    "friendly",
    [],
    decode.list(contract_friendly_decoder()),
  )
  use signer <- decode.optional_field(
    "signer",
    [],
    decode.list(contract_signer_decoder()),
  )
  use relevant_history <- decode.optional_field(
    "relevantHistory",
    [],
    decode.list(reference_decoder()),
  )
  use supporting_info <- decode.optional_field(
    "supportingInfo",
    [],
    decode.list(reference_decoder()),
  )
  use term <- decode.optional_field(
    "term",
    [],
    decode.list(contract_term_decoder()),
  )
  use content_definition <- decode.optional_field(
    "contentDefinition",
    None,
    decode.optional(contract_contentdefinition_decoder()),
  )
  use sub_type <- decode.optional_field(
    "subType",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use topic <- decode.then(none_if_omitted(contract_topic_decoder()))
  use scope <- decode.optional_field(
    "scope",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use author <- decode.optional_field(
    "author",
    None,
    decode.optional(reference_decoder()),
  )
  use alias <- decode.optional_field("alias", [], decode.list(decode.string))
  use subtitle <- decode.optional_field(
    "subtitle",
    None,
    decode.optional(decode.string),
  )
  use title <- decode.optional_field(
    "title",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use site <- decode.optional_field(
    "site",
    [],
    decode.list(reference_decoder()),
  )
  use domain <- decode.optional_field(
    "domain",
    [],
    decode.list(reference_decoder()),
  )
  use authority <- decode.optional_field(
    "authority",
    [],
    decode.list(reference_decoder()),
  )
  use subject <- decode.optional_field(
    "subject",
    [],
    decode.list(reference_decoder()),
  )
  use expiration_type <- decode.optional_field(
    "expirationType",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use applies <- decode.optional_field(
    "applies",
    None,
    decode.optional(period_decoder()),
  )
  use issued <- decode.optional_field(
    "issued",
    None,
    decode.optional(decode.string),
  )
  use content_derivative <- decode.optional_field(
    "contentDerivative",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use instantiates_uri <- decode.optional_field(
    "instantiatesUri",
    None,
    decode.optional(decode.string),
  )
  use instantiates_canonical <- decode.optional_field(
    "instantiatesCanonical",
    None,
    decode.optional(reference_decoder()),
  )
  use legal_state <- decode.optional_field(
    "legalState",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use status <- decode.optional_field(
    "status",
    None,
    decode.optional(r4bvaluesets.contractstatus_decoder()),
  )
  use version <- decode.optional_field(
    "version",
    None,
    decode.optional(decode.string),
  )
  use url <- decode.optional_field("url", None, decode.optional(decode.string))
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Contract",
    decode.failure(contract_new(), "resourceType"),
  )
  decode.success(Contract(
    legally_binding:,
    rule:,
    legal:,
    friendly:,
    signer:,
    relevant_history:,
    supporting_info:,
    term:,
    content_definition:,
    sub_type:,
    type_:,
    topic:,
    scope:,
    author:,
    alias:,
    subtitle:,
    title:,
    name:,
    site:,
    domain:,
    authority:,
    subject:,
    expiration_type:,
    applies:,
    issued:,
    content_derivative:,
    instantiates_uri:,
    instantiates_canonical:,
    legal_state:,
    status:,
    version:,
    url:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/Coverage#resource
pub type Coverage {
  Coverage(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    status: r4bvaluesets.Fmstatus,
    type_: Option(Codeableconcept),
    policy_holder: Option(Reference),
    subscriber: Option(Reference),
    subscriber_id: Option(String),
    beneficiary: Reference,
    dependent: Option(String),
    relationship: Option(Codeableconcept),
    period: Option(Period),
    payor: List(Reference),
    class: List(CoverageClass),
    order: Option(Int),
    network: Option(String),
    cost_to_beneficiary: List(CoverageCosttobeneficiary),
    subrogation: Option(Bool),
    contract: List(Reference),
  )
}

pub fn coverage_new(
  beneficiary beneficiary: Reference,
  status status: r4bvaluesets.Fmstatus,
) -> Coverage {
  Coverage(
    contract: [],
    subrogation: None,
    cost_to_beneficiary: [],
    network: None,
    order: None,
    class: [],
    payor: [],
    period: None,
    relationship: None,
    dependent: None,
    beneficiary:,
    subscriber_id: None,
    subscriber: None,
    policy_holder: None,
    type_: None,
    status:,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Coverage#resource
pub type CoverageClass {
  CoverageClass(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Codeableconcept,
    value: String,
    name: Option(String),
  )
}

pub fn coverage_class_new(
  value value: String,
  type_ type_: Codeableconcept,
) -> CoverageClass {
  CoverageClass(
    name: None,
    value:,
    type_:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Coverage#resource
pub type CoverageCosttobeneficiary {
  CoverageCosttobeneficiary(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Option(Codeableconcept),
    value: CoverageCosttobeneficiaryValue,
    exception: List(CoverageCosttobeneficiaryException),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Coverage#resource
pub type CoverageCosttobeneficiaryValue {
  CoverageCosttobeneficiaryValueQuantity(value: Quantity)
  CoverageCosttobeneficiaryValueMoney(value: Money)
}

pub fn coverage_costtobeneficiary_value_to_json(
  elt: CoverageCosttobeneficiaryValue,
) -> Json {
  case elt {
    CoverageCosttobeneficiaryValueQuantity(v) -> quantity_to_json(v)
    CoverageCosttobeneficiaryValueMoney(v) -> money_to_json(v)
  }
}

pub fn coverage_costtobeneficiary_value_decoder() -> Decoder(
  CoverageCosttobeneficiaryValue,
) {
  decode.one_of(
    decode.field("valueQuantity", quantity_decoder(), decode.success)
      |> decode.map(CoverageCosttobeneficiaryValueQuantity),
    [
      decode.field("valueMoney", money_decoder(), decode.success)
      |> decode.map(CoverageCosttobeneficiaryValueMoney),
    ],
  )
}

pub fn coverage_costtobeneficiary_new(
  value value: CoverageCosttobeneficiaryValue,
) -> CoverageCosttobeneficiary {
  CoverageCosttobeneficiary(
    exception: [],
    value:,
    type_: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Coverage#resource
pub type CoverageCosttobeneficiaryException {
  CoverageCosttobeneficiaryException(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Codeableconcept,
    period: Option(Period),
  )
}

pub fn coverage_costtobeneficiary_exception_new(
  type_ type_: Codeableconcept,
) -> CoverageCosttobeneficiaryException {
  CoverageCosttobeneficiaryException(
    period: None,
    type_:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn coverage_costtobeneficiary_exception_to_json(
  coverage_costtobeneficiary_exception: CoverageCosttobeneficiaryException,
) -> Json {
  let CoverageCosttobeneficiaryException(
    period:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = coverage_costtobeneficiary_exception
  let fields = [
    #("type", codeableconcept_to_json(type_)),
  ]
  let fields = case period {
    Some(v) -> [#("period", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn coverage_costtobeneficiary_exception_decoder() -> Decoder(
  CoverageCosttobeneficiaryException,
) {
  use period <- decode.optional_field(
    "period",
    None,
    decode.optional(period_decoder()),
  )
  use type_ <- decode.field("type", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CoverageCosttobeneficiaryException(
    period:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn coverage_costtobeneficiary_to_json(
  coverage_costtobeneficiary: CoverageCosttobeneficiary,
) -> Json {
  let CoverageCosttobeneficiary(
    exception:,
    value:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = coverage_costtobeneficiary
  let fields = [
    #("value", coverage_costtobeneficiary_value_to_json(value)),
  ]
  let fields = case exception {
    [] -> fields
    _ -> [
      #(
        "exception",
        json.array(exception, coverage_costtobeneficiary_exception_to_json),
      ),
      ..fields
    ]
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn coverage_costtobeneficiary_decoder() -> Decoder(
  CoverageCosttobeneficiary,
) {
  use exception <- decode.optional_field(
    "exception",
    [],
    decode.list(coverage_costtobeneficiary_exception_decoder()),
  )
  use value <- decode.then(coverage_costtobeneficiary_value_decoder())
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CoverageCosttobeneficiary(
    exception:,
    value:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn coverage_class_to_json(coverage_class: CoverageClass) -> Json {
  let CoverageClass(name:, value:, type_:, modifier_extension:, extension:, id:) =
    coverage_class
  let fields = [
    #("value", json.string(value)),
    #("type", codeableconcept_to_json(type_)),
  ]
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn coverage_class_decoder() -> Decoder(CoverageClass) {
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use value <- decode.field("value", decode.string)
  use type_ <- decode.field("type", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CoverageClass(
    name:,
    value:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn coverage_to_json(coverage: Coverage) -> Json {
  let Coverage(
    contract:,
    subrogation:,
    cost_to_beneficiary:,
    network:,
    order:,
    class:,
    payor:,
    period:,
    relationship:,
    dependent:,
    beneficiary:,
    subscriber_id:,
    subscriber:,
    policy_holder:,
    type_:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = coverage
  let fields = [
    #("beneficiary", reference_to_json(beneficiary)),
    #("status", r4bvaluesets.fmstatus_to_json(status)),
  ]
  let fields = case contract {
    [] -> fields
    _ -> [#("contract", json.array(contract, reference_to_json)), ..fields]
  }
  let fields = case subrogation {
    Some(v) -> [#("subrogation", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case cost_to_beneficiary {
    [] -> fields
    _ -> [
      #(
        "costToBeneficiary",
        json.array(cost_to_beneficiary, coverage_costtobeneficiary_to_json),
      ),
      ..fields
    ]
  }
  let fields = case network {
    Some(v) -> [#("network", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case order {
    Some(v) -> [#("order", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case class {
    [] -> fields
    _ -> [#("class", json.array(class, coverage_class_to_json)), ..fields]
  }
  let fields = case payor {
    [] -> fields
    _ -> [#("payor", json.array(payor, reference_to_json)), ..fields]
  }
  let fields = case period {
    Some(v) -> [#("period", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case relationship {
    Some(v) -> [#("relationship", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case dependent {
    Some(v) -> [#("dependent", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case subscriber_id {
    Some(v) -> [#("subscriberId", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case subscriber {
    Some(v) -> [#("subscriber", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case policy_holder {
    Some(v) -> [#("policyHolder", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Coverage")), ..fields]
  json.object(fields)
}

pub fn coverage_decoder() -> Decoder(Coverage) {
  use contract <- decode.optional_field(
    "contract",
    [],
    decode.list(reference_decoder()),
  )
  use subrogation <- decode.optional_field(
    "subrogation",
    None,
    decode.optional(decode.bool),
  )
  use cost_to_beneficiary <- decode.optional_field(
    "costToBeneficiary",
    [],
    decode.list(coverage_costtobeneficiary_decoder()),
  )
  use network <- decode.optional_field(
    "network",
    None,
    decode.optional(decode.string),
  )
  use order <- decode.optional_field("order", None, decode.optional(decode.int))
  use class <- decode.optional_field(
    "class",
    [],
    decode.list(coverage_class_decoder()),
  )
  use payor <- decode.optional_field(
    "payor",
    [],
    decode.list(reference_decoder()),
  )
  use period <- decode.optional_field(
    "period",
    None,
    decode.optional(period_decoder()),
  )
  use relationship <- decode.optional_field(
    "relationship",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use dependent <- decode.optional_field(
    "dependent",
    None,
    decode.optional(decode.string),
  )
  use beneficiary <- decode.field("beneficiary", reference_decoder())
  use subscriber_id <- decode.optional_field(
    "subscriberId",
    None,
    decode.optional(decode.string),
  )
  use subscriber <- decode.optional_field(
    "subscriber",
    None,
    decode.optional(reference_decoder()),
  )
  use policy_holder <- decode.optional_field(
    "policyHolder",
    None,
    decode.optional(reference_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use status <- decode.field("status", r4bvaluesets.fmstatus_decoder())
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Coverage",
    decode.failure(coverage_new(beneficiary:, status:), "resourceType"),
  )
  decode.success(Coverage(
    contract:,
    subrogation:,
    cost_to_beneficiary:,
    network:,
    order:,
    class:,
    payor:,
    period:,
    relationship:,
    dependent:,
    beneficiary:,
    subscriber_id:,
    subscriber:,
    policy_holder:,
    type_:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/CoverageEligibilityRequest#resource
pub type Coverageeligibilityrequest {
  Coverageeligibilityrequest(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    status: r4bvaluesets.Fmstatus,
    priority: Option(Codeableconcept),
    purpose: List(r4bvaluesets.Eligibilityrequestpurpose),
    patient: Reference,
    serviced: Option(CoverageeligibilityrequestServiced),
    created: String,
    enterer: Option(Reference),
    provider: Option(Reference),
    insurer: Reference,
    facility: Option(Reference),
    supporting_info: List(CoverageeligibilityrequestSupportinginfo),
    insurance: List(CoverageeligibilityrequestInsurance),
    item: List(CoverageeligibilityrequestItem),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/CoverageEligibilityRequest#resource
pub type CoverageeligibilityrequestServiced {
  CoverageeligibilityrequestServicedDate(serviced: String)
  CoverageeligibilityrequestServicedPeriod(serviced: Period)
}

pub fn coverageeligibilityrequest_serviced_to_json(
  elt: CoverageeligibilityrequestServiced,
) -> Json {
  case elt {
    CoverageeligibilityrequestServicedDate(v) -> json.string(v)
    CoverageeligibilityrequestServicedPeriod(v) -> period_to_json(v)
  }
}

pub fn coverageeligibilityrequest_serviced_decoder() -> Decoder(
  CoverageeligibilityrequestServiced,
) {
  decode.one_of(
    decode.field("servicedDate", decode.string, decode.success)
      |> decode.map(CoverageeligibilityrequestServicedDate),
    [
      decode.field("servicedPeriod", period_decoder(), decode.success)
      |> decode.map(CoverageeligibilityrequestServicedPeriod),
    ],
  )
}

pub fn coverageeligibilityrequest_new(
  insurer insurer: Reference,
  created created: String,
  patient patient: Reference,
  status status: r4bvaluesets.Fmstatus,
) -> Coverageeligibilityrequest {
  Coverageeligibilityrequest(
    item: [],
    insurance: [],
    supporting_info: [],
    facility: None,
    insurer:,
    provider: None,
    enterer: None,
    created:,
    serviced: None,
    patient:,
    purpose: [],
    priority: None,
    status:,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/CoverageEligibilityRequest#resource
pub type CoverageeligibilityrequestSupportinginfo {
  CoverageeligibilityrequestSupportinginfo(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    sequence: Int,
    information: Reference,
    applies_to_all: Option(Bool),
  )
}

pub fn coverageeligibilityrequest_supportinginfo_new(
  information information: Reference,
  sequence sequence: Int,
) -> CoverageeligibilityrequestSupportinginfo {
  CoverageeligibilityrequestSupportinginfo(
    applies_to_all: None,
    information:,
    sequence:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/CoverageEligibilityRequest#resource
pub type CoverageeligibilityrequestInsurance {
  CoverageeligibilityrequestInsurance(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    focal: Option(Bool),
    coverage: Reference,
    business_arrangement: Option(String),
  )
}

pub fn coverageeligibilityrequest_insurance_new(
  coverage coverage: Reference,
) -> CoverageeligibilityrequestInsurance {
  CoverageeligibilityrequestInsurance(
    business_arrangement: None,
    coverage:,
    focal: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/CoverageEligibilityRequest#resource
pub type CoverageeligibilityrequestItem {
  CoverageeligibilityrequestItem(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    supporting_info_sequence: List(Int),
    category: Option(Codeableconcept),
    product_or_service: Option(Codeableconcept),
    modifier: List(Codeableconcept),
    provider: Option(Reference),
    quantity: Option(Quantity),
    unit_price: Option(Money),
    facility: Option(Reference),
    diagnosis: List(CoverageeligibilityrequestItemDiagnosis),
    detail: List(Reference),
  )
}

pub fn coverageeligibilityrequest_item_new() -> CoverageeligibilityrequestItem {
  CoverageeligibilityrequestItem(
    detail: [],
    diagnosis: [],
    facility: None,
    unit_price: None,
    quantity: None,
    provider: None,
    modifier: [],
    product_or_service: None,
    category: None,
    supporting_info_sequence: [],
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/CoverageEligibilityRequest#resource
pub type CoverageeligibilityrequestItemDiagnosis {
  CoverageeligibilityrequestItemDiagnosis(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    diagnosis: Option(CoverageeligibilityrequestItemDiagnosisDiagnosis),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/CoverageEligibilityRequest#resource
pub type CoverageeligibilityrequestItemDiagnosisDiagnosis {
  CoverageeligibilityrequestItemDiagnosisDiagnosisCodeableconcept(
    diagnosis: Codeableconcept,
  )
  CoverageeligibilityrequestItemDiagnosisDiagnosisReference(
    diagnosis: Reference,
  )
}

pub fn coverageeligibilityrequest_item_diagnosis_diagnosis_to_json(
  elt: CoverageeligibilityrequestItemDiagnosisDiagnosis,
) -> Json {
  case elt {
    CoverageeligibilityrequestItemDiagnosisDiagnosisCodeableconcept(v) ->
      codeableconcept_to_json(v)
    CoverageeligibilityrequestItemDiagnosisDiagnosisReference(v) ->
      reference_to_json(v)
  }
}

pub fn coverageeligibilityrequest_item_diagnosis_diagnosis_decoder() -> Decoder(
  CoverageeligibilityrequestItemDiagnosisDiagnosis,
) {
  decode.one_of(
    decode.field(
      "diagnosisCodeableConcept",
      codeableconcept_decoder(),
      decode.success,
    )
      |> decode.map(
        CoverageeligibilityrequestItemDiagnosisDiagnosisCodeableconcept,
      ),
    [
      decode.field("diagnosisReference", reference_decoder(), decode.success)
      |> decode.map(CoverageeligibilityrequestItemDiagnosisDiagnosisReference),
    ],
  )
}

pub fn coverageeligibilityrequest_item_diagnosis_new() -> CoverageeligibilityrequestItemDiagnosis {
  CoverageeligibilityrequestItemDiagnosis(
    diagnosis: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn coverageeligibilityrequest_item_diagnosis_to_json(
  coverageeligibilityrequest_item_diagnosis: CoverageeligibilityrequestItemDiagnosis,
) -> Json {
  let CoverageeligibilityrequestItemDiagnosis(
    diagnosis:,
    modifier_extension:,
    extension:,
    id:,
  ) = coverageeligibilityrequest_item_diagnosis
  let fields = []
  let fields = case diagnosis {
    Some(v) -> [
      #(
        "diagnosis"
          <> case v {
          CoverageeligibilityrequestItemDiagnosisDiagnosisCodeableconcept(_) ->
            "Codeableconcept"
          CoverageeligibilityrequestItemDiagnosisDiagnosisReference(_) ->
            "Reference"
        },
        coverageeligibilityrequest_item_diagnosis_diagnosis_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn coverageeligibilityrequest_item_diagnosis_decoder() -> Decoder(
  CoverageeligibilityrequestItemDiagnosis,
) {
  use diagnosis <- decode.then(
    none_if_omitted(
      coverageeligibilityrequest_item_diagnosis_diagnosis_decoder(),
    ),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CoverageeligibilityrequestItemDiagnosis(
    diagnosis:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn coverageeligibilityrequest_item_to_json(
  coverageeligibilityrequest_item: CoverageeligibilityrequestItem,
) -> Json {
  let CoverageeligibilityrequestItem(
    detail:,
    diagnosis:,
    facility:,
    unit_price:,
    quantity:,
    provider:,
    modifier:,
    product_or_service:,
    category:,
    supporting_info_sequence:,
    modifier_extension:,
    extension:,
    id:,
  ) = coverageeligibilityrequest_item
  let fields = []
  let fields = case detail {
    [] -> fields
    _ -> [#("detail", json.array(detail, reference_to_json)), ..fields]
  }
  let fields = case diagnosis {
    [] -> fields
    _ -> [
      #(
        "diagnosis",
        json.array(diagnosis, coverageeligibilityrequest_item_diagnosis_to_json),
      ),
      ..fields
    ]
  }
  let fields = case facility {
    Some(v) -> [#("facility", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case unit_price {
    Some(v) -> [#("unitPrice", money_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case quantity {
    Some(v) -> [#("quantity", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case provider {
    Some(v) -> [#("provider", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier {
    [] -> fields
    _ -> [
      #("modifier", json.array(modifier, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case product_or_service {
    Some(v) -> [#("productOrService", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case category {
    Some(v) -> [#("category", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case supporting_info_sequence {
    [] -> fields
    _ -> [
      #(
        "supportingInfoSequence",
        json.array(supporting_info_sequence, json.int),
      ),
      ..fields
    ]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn coverageeligibilityrequest_item_decoder() -> Decoder(
  CoverageeligibilityrequestItem,
) {
  use detail <- decode.optional_field(
    "detail",
    [],
    decode.list(reference_decoder()),
  )
  use diagnosis <- decode.optional_field(
    "diagnosis",
    [],
    decode.list(coverageeligibilityrequest_item_diagnosis_decoder()),
  )
  use facility <- decode.optional_field(
    "facility",
    None,
    decode.optional(reference_decoder()),
  )
  use unit_price <- decode.optional_field(
    "unitPrice",
    None,
    decode.optional(money_decoder()),
  )
  use quantity <- decode.optional_field(
    "quantity",
    None,
    decode.optional(quantity_decoder()),
  )
  use provider <- decode.optional_field(
    "provider",
    None,
    decode.optional(reference_decoder()),
  )
  use modifier <- decode.optional_field(
    "modifier",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use product_or_service <- decode.optional_field(
    "productOrService",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use category <- decode.optional_field(
    "category",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use supporting_info_sequence <- decode.optional_field(
    "supportingInfoSequence",
    [],
    decode.list(decode.int),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CoverageeligibilityrequestItem(
    detail:,
    diagnosis:,
    facility:,
    unit_price:,
    quantity:,
    provider:,
    modifier:,
    product_or_service:,
    category:,
    supporting_info_sequence:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn coverageeligibilityrequest_insurance_to_json(
  coverageeligibilityrequest_insurance: CoverageeligibilityrequestInsurance,
) -> Json {
  let CoverageeligibilityrequestInsurance(
    business_arrangement:,
    coverage:,
    focal:,
    modifier_extension:,
    extension:,
    id:,
  ) = coverageeligibilityrequest_insurance
  let fields = [
    #("coverage", reference_to_json(coverage)),
  ]
  let fields = case business_arrangement {
    Some(v) -> [#("businessArrangement", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case focal {
    Some(v) -> [#("focal", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn coverageeligibilityrequest_insurance_decoder() -> Decoder(
  CoverageeligibilityrequestInsurance,
) {
  use business_arrangement <- decode.optional_field(
    "businessArrangement",
    None,
    decode.optional(decode.string),
  )
  use coverage <- decode.field("coverage", reference_decoder())
  use focal <- decode.optional_field(
    "focal",
    None,
    decode.optional(decode.bool),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CoverageeligibilityrequestInsurance(
    business_arrangement:,
    coverage:,
    focal:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn coverageeligibilityrequest_supportinginfo_to_json(
  coverageeligibilityrequest_supportinginfo: CoverageeligibilityrequestSupportinginfo,
) -> Json {
  let CoverageeligibilityrequestSupportinginfo(
    applies_to_all:,
    information:,
    sequence:,
    modifier_extension:,
    extension:,
    id:,
  ) = coverageeligibilityrequest_supportinginfo
  let fields = [
    #("information", reference_to_json(information)),
    #("sequence", json.int(sequence)),
  ]
  let fields = case applies_to_all {
    Some(v) -> [#("appliesToAll", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn coverageeligibilityrequest_supportinginfo_decoder() -> Decoder(
  CoverageeligibilityrequestSupportinginfo,
) {
  use applies_to_all <- decode.optional_field(
    "appliesToAll",
    None,
    decode.optional(decode.bool),
  )
  use information <- decode.field("information", reference_decoder())
  use sequence <- decode.field("sequence", decode.int)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CoverageeligibilityrequestSupportinginfo(
    applies_to_all:,
    information:,
    sequence:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn coverageeligibilityrequest_to_json(
  coverageeligibilityrequest: Coverageeligibilityrequest,
) -> Json {
  let Coverageeligibilityrequest(
    item:,
    insurance:,
    supporting_info:,
    facility:,
    insurer:,
    provider:,
    enterer:,
    created:,
    serviced:,
    patient:,
    purpose:,
    priority:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = coverageeligibilityrequest
  let fields = [
    #("insurer", reference_to_json(insurer)),
    #("created", json.string(created)),
    #("patient", reference_to_json(patient)),
    #("status", r4bvaluesets.fmstatus_to_json(status)),
  ]
  let fields = case item {
    [] -> fields
    _ -> [
      #("item", json.array(item, coverageeligibilityrequest_item_to_json)),
      ..fields
    ]
  }
  let fields = case insurance {
    [] -> fields
    _ -> [
      #(
        "insurance",
        json.array(insurance, coverageeligibilityrequest_insurance_to_json),
      ),
      ..fields
    ]
  }
  let fields = case supporting_info {
    [] -> fields
    _ -> [
      #(
        "supportingInfo",
        json.array(
          supporting_info,
          coverageeligibilityrequest_supportinginfo_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case facility {
    Some(v) -> [#("facility", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case provider {
    Some(v) -> [#("provider", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case enterer {
    Some(v) -> [#("enterer", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case serviced {
    Some(v) -> [
      #(
        "serviced"
          <> case v {
          CoverageeligibilityrequestServicedDate(_) -> "Date"
          CoverageeligibilityrequestServicedPeriod(_) -> "Period"
        },
        coverageeligibilityrequest_serviced_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case purpose {
    [] -> fields
    _ -> [
      #(
        "purpose",
        json.array(purpose, r4bvaluesets.eligibilityrequestpurpose_to_json),
      ),
      ..fields
    ]
  }
  let fields = case priority {
    Some(v) -> [#("priority", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [
    #("resourceType", json.string("Coverageeligibilityrequest")),
    ..fields
  ]
  json.object(fields)
}

pub fn coverageeligibilityrequest_decoder() -> Decoder(
  Coverageeligibilityrequest,
) {
  use item <- decode.optional_field(
    "item",
    [],
    decode.list(coverageeligibilityrequest_item_decoder()),
  )
  use insurance <- decode.optional_field(
    "insurance",
    [],
    decode.list(coverageeligibilityrequest_insurance_decoder()),
  )
  use supporting_info <- decode.optional_field(
    "supportingInfo",
    [],
    decode.list(coverageeligibilityrequest_supportinginfo_decoder()),
  )
  use facility <- decode.optional_field(
    "facility",
    None,
    decode.optional(reference_decoder()),
  )
  use insurer <- decode.field("insurer", reference_decoder())
  use provider <- decode.optional_field(
    "provider",
    None,
    decode.optional(reference_decoder()),
  )
  use enterer <- decode.optional_field(
    "enterer",
    None,
    decode.optional(reference_decoder()),
  )
  use created <- decode.field("created", decode.string)
  use serviced <- decode.then(
    none_if_omitted(coverageeligibilityrequest_serviced_decoder()),
  )
  use patient <- decode.field("patient", reference_decoder())
  use purpose <- decode.optional_field(
    "purpose",
    [],
    decode.list(r4bvaluesets.eligibilityrequestpurpose_decoder()),
  )
  use priority <- decode.optional_field(
    "priority",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use status <- decode.field("status", r4bvaluesets.fmstatus_decoder())
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Coverageeligibilityrequest",
    decode.failure(
      coverageeligibilityrequest_new(insurer:, created:, patient:, status:),
      "resourceType",
    ),
  )
  decode.success(Coverageeligibilityrequest(
    item:,
    insurance:,
    supporting_info:,
    facility:,
    insurer:,
    provider:,
    enterer:,
    created:,
    serviced:,
    patient:,
    purpose:,
    priority:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/CoverageEligibilityResponse#resource
pub type Coverageeligibilityresponse {
  Coverageeligibilityresponse(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    status: r4bvaluesets.Fmstatus,
    purpose: List(r4bvaluesets.Eligibilityresponsepurpose),
    patient: Reference,
    serviced: Option(CoverageeligibilityresponseServiced),
    created: String,
    requestor: Option(Reference),
    request: Reference,
    outcome: r4bvaluesets.Remittanceoutcome,
    disposition: Option(String),
    insurer: Reference,
    insurance: List(CoverageeligibilityresponseInsurance),
    pre_auth_ref: Option(String),
    form: Option(Codeableconcept),
    error: List(CoverageeligibilityresponseError),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/CoverageEligibilityResponse#resource
pub type CoverageeligibilityresponseServiced {
  CoverageeligibilityresponseServicedDate(serviced: String)
  CoverageeligibilityresponseServicedPeriod(serviced: Period)
}

pub fn coverageeligibilityresponse_serviced_to_json(
  elt: CoverageeligibilityresponseServiced,
) -> Json {
  case elt {
    CoverageeligibilityresponseServicedDate(v) -> json.string(v)
    CoverageeligibilityresponseServicedPeriod(v) -> period_to_json(v)
  }
}

pub fn coverageeligibilityresponse_serviced_decoder() -> Decoder(
  CoverageeligibilityresponseServiced,
) {
  decode.one_of(
    decode.field("servicedDate", decode.string, decode.success)
      |> decode.map(CoverageeligibilityresponseServicedDate),
    [
      decode.field("servicedPeriod", period_decoder(), decode.success)
      |> decode.map(CoverageeligibilityresponseServicedPeriod),
    ],
  )
}

pub fn coverageeligibilityresponse_new(
  insurer insurer: Reference,
  outcome outcome: r4bvaluesets.Remittanceoutcome,
  request request: Reference,
  created created: String,
  patient patient: Reference,
  status status: r4bvaluesets.Fmstatus,
) -> Coverageeligibilityresponse {
  Coverageeligibilityresponse(
    error: [],
    form: None,
    pre_auth_ref: None,
    insurance: [],
    insurer:,
    disposition: None,
    outcome:,
    request:,
    requestor: None,
    created:,
    serviced: None,
    patient:,
    purpose: [],
    status:,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/CoverageEligibilityResponse#resource
pub type CoverageeligibilityresponseInsurance {
  CoverageeligibilityresponseInsurance(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    coverage: Reference,
    inforce: Option(Bool),
    benefit_period: Option(Period),
    item: List(CoverageeligibilityresponseInsuranceItem),
  )
}

pub fn coverageeligibilityresponse_insurance_new(
  coverage coverage: Reference,
) -> CoverageeligibilityresponseInsurance {
  CoverageeligibilityresponseInsurance(
    item: [],
    benefit_period: None,
    inforce: None,
    coverage:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/CoverageEligibilityResponse#resource
pub type CoverageeligibilityresponseInsuranceItem {
  CoverageeligibilityresponseInsuranceItem(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    category: Option(Codeableconcept),
    product_or_service: Option(Codeableconcept),
    modifier: List(Codeableconcept),
    provider: Option(Reference),
    excluded: Option(Bool),
    name: Option(String),
    description: Option(String),
    network: Option(Codeableconcept),
    unit: Option(Codeableconcept),
    term: Option(Codeableconcept),
    benefit: List(CoverageeligibilityresponseInsuranceItemBenefit),
    authorization_required: Option(Bool),
    authorization_supporting: List(Codeableconcept),
    authorization_url: Option(String),
  )
}

pub fn coverageeligibilityresponse_insurance_item_new() -> CoverageeligibilityresponseInsuranceItem {
  CoverageeligibilityresponseInsuranceItem(
    authorization_url: None,
    authorization_supporting: [],
    authorization_required: None,
    benefit: [],
    term: None,
    unit: None,
    network: None,
    description: None,
    name: None,
    excluded: None,
    provider: None,
    modifier: [],
    product_or_service: None,
    category: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/CoverageEligibilityResponse#resource
pub type CoverageeligibilityresponseInsuranceItemBenefit {
  CoverageeligibilityresponseInsuranceItemBenefit(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Codeableconcept,
    allowed: Option(CoverageeligibilityresponseInsuranceItemBenefitAllowed),
    used: Option(CoverageeligibilityresponseInsuranceItemBenefitUsed),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/CoverageEligibilityResponse#resource
pub type CoverageeligibilityresponseInsuranceItemBenefitAllowed {
  CoverageeligibilityresponseInsuranceItemBenefitAllowedUnsignedint(
    allowed: Int,
  )
  CoverageeligibilityresponseInsuranceItemBenefitAllowedString(allowed: String)
  CoverageeligibilityresponseInsuranceItemBenefitAllowedMoney(allowed: Money)
}

pub fn coverageeligibilityresponse_insurance_item_benefit_allowed_to_json(
  elt: CoverageeligibilityresponseInsuranceItemBenefitAllowed,
) -> Json {
  case elt {
    CoverageeligibilityresponseInsuranceItemBenefitAllowedUnsignedint(v) ->
      json.int(v)
    CoverageeligibilityresponseInsuranceItemBenefitAllowedString(v) ->
      json.string(v)
    CoverageeligibilityresponseInsuranceItemBenefitAllowedMoney(v) ->
      money_to_json(v)
  }
}

pub fn coverageeligibilityresponse_insurance_item_benefit_allowed_decoder() -> Decoder(
  CoverageeligibilityresponseInsuranceItemBenefitAllowed,
) {
  decode.one_of(
    decode.field("allowedUnsignedInt", decode.int, decode.success)
      |> decode.map(
        CoverageeligibilityresponseInsuranceItemBenefitAllowedUnsignedint,
      ),
    [
      decode.field("allowedString", decode.string, decode.success)
        |> decode.map(
          CoverageeligibilityresponseInsuranceItemBenefitAllowedString,
        ),
      decode.field("allowedMoney", money_decoder(), decode.success)
        |> decode.map(
          CoverageeligibilityresponseInsuranceItemBenefitAllowedMoney,
        ),
    ],
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/CoverageEligibilityResponse#resource
pub type CoverageeligibilityresponseInsuranceItemBenefitUsed {
  CoverageeligibilityresponseInsuranceItemBenefitUsedUnsignedint(used: Int)
  CoverageeligibilityresponseInsuranceItemBenefitUsedString(used: String)
  CoverageeligibilityresponseInsuranceItemBenefitUsedMoney(used: Money)
}

pub fn coverageeligibilityresponse_insurance_item_benefit_used_to_json(
  elt: CoverageeligibilityresponseInsuranceItemBenefitUsed,
) -> Json {
  case elt {
    CoverageeligibilityresponseInsuranceItemBenefitUsedUnsignedint(v) ->
      json.int(v)
    CoverageeligibilityresponseInsuranceItemBenefitUsedString(v) ->
      json.string(v)
    CoverageeligibilityresponseInsuranceItemBenefitUsedMoney(v) ->
      money_to_json(v)
  }
}

pub fn coverageeligibilityresponse_insurance_item_benefit_used_decoder() -> Decoder(
  CoverageeligibilityresponseInsuranceItemBenefitUsed,
) {
  decode.one_of(
    decode.field("usedUnsignedInt", decode.int, decode.success)
      |> decode.map(
        CoverageeligibilityresponseInsuranceItemBenefitUsedUnsignedint,
      ),
    [
      decode.field("usedString", decode.string, decode.success)
        |> decode.map(CoverageeligibilityresponseInsuranceItemBenefitUsedString),
      decode.field("usedMoney", money_decoder(), decode.success)
        |> decode.map(CoverageeligibilityresponseInsuranceItemBenefitUsedMoney),
    ],
  )
}

pub fn coverageeligibilityresponse_insurance_item_benefit_new(
  type_ type_: Codeableconcept,
) -> CoverageeligibilityresponseInsuranceItemBenefit {
  CoverageeligibilityresponseInsuranceItemBenefit(
    used: None,
    allowed: None,
    type_:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/CoverageEligibilityResponse#resource
pub type CoverageeligibilityresponseError {
  CoverageeligibilityresponseError(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    code: Codeableconcept,
  )
}

pub fn coverageeligibilityresponse_error_new(
  code code: Codeableconcept,
) -> CoverageeligibilityresponseError {
  CoverageeligibilityresponseError(
    code:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn coverageeligibilityresponse_error_to_json(
  coverageeligibilityresponse_error: CoverageeligibilityresponseError,
) -> Json {
  let CoverageeligibilityresponseError(
    code:,
    modifier_extension:,
    extension:,
    id:,
  ) = coverageeligibilityresponse_error
  let fields = [
    #("code", codeableconcept_to_json(code)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn coverageeligibilityresponse_error_decoder() -> Decoder(
  CoverageeligibilityresponseError,
) {
  use code <- decode.field("code", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CoverageeligibilityresponseError(
    code:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn coverageeligibilityresponse_insurance_item_benefit_to_json(
  coverageeligibilityresponse_insurance_item_benefit: CoverageeligibilityresponseInsuranceItemBenefit,
) -> Json {
  let CoverageeligibilityresponseInsuranceItemBenefit(
    used:,
    allowed:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = coverageeligibilityresponse_insurance_item_benefit
  let fields = [
    #("type", codeableconcept_to_json(type_)),
  ]
  let fields = case used {
    Some(v) -> [
      #(
        "used"
          <> case v {
          CoverageeligibilityresponseInsuranceItemBenefitUsedUnsignedint(_) ->
            "Unsignedint"
          CoverageeligibilityresponseInsuranceItemBenefitUsedString(_) ->
            "String"
          CoverageeligibilityresponseInsuranceItemBenefitUsedMoney(_) -> "Money"
        },
        coverageeligibilityresponse_insurance_item_benefit_used_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case allowed {
    Some(v) -> [
      #(
        "allowed"
          <> case v {
          CoverageeligibilityresponseInsuranceItemBenefitAllowedUnsignedint(_) ->
            "Unsignedint"
          CoverageeligibilityresponseInsuranceItemBenefitAllowedString(_) ->
            "String"
          CoverageeligibilityresponseInsuranceItemBenefitAllowedMoney(_) ->
            "Money"
        },
        coverageeligibilityresponse_insurance_item_benefit_allowed_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn coverageeligibilityresponse_insurance_item_benefit_decoder() -> Decoder(
  CoverageeligibilityresponseInsuranceItemBenefit,
) {
  use used <- decode.then(
    none_if_omitted(
      coverageeligibilityresponse_insurance_item_benefit_used_decoder(),
    ),
  )
  use allowed <- decode.then(
    none_if_omitted(
      coverageeligibilityresponse_insurance_item_benefit_allowed_decoder(),
    ),
  )
  use type_ <- decode.field("type", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CoverageeligibilityresponseInsuranceItemBenefit(
    used:,
    allowed:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn coverageeligibilityresponse_insurance_item_to_json(
  coverageeligibilityresponse_insurance_item: CoverageeligibilityresponseInsuranceItem,
) -> Json {
  let CoverageeligibilityresponseInsuranceItem(
    authorization_url:,
    authorization_supporting:,
    authorization_required:,
    benefit:,
    term:,
    unit:,
    network:,
    description:,
    name:,
    excluded:,
    provider:,
    modifier:,
    product_or_service:,
    category:,
    modifier_extension:,
    extension:,
    id:,
  ) = coverageeligibilityresponse_insurance_item
  let fields = []
  let fields = case authorization_url {
    Some(v) -> [#("authorizationUrl", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case authorization_supporting {
    [] -> fields
    _ -> [
      #(
        "authorizationSupporting",
        json.array(authorization_supporting, codeableconcept_to_json),
      ),
      ..fields
    ]
  }
  let fields = case authorization_required {
    Some(v) -> [#("authorizationRequired", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case benefit {
    [] -> fields
    _ -> [
      #(
        "benefit",
        json.array(
          benefit,
          coverageeligibilityresponse_insurance_item_benefit_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case term {
    Some(v) -> [#("term", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case unit {
    Some(v) -> [#("unit", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case network {
    Some(v) -> [#("network", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case excluded {
    Some(v) -> [#("excluded", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case provider {
    Some(v) -> [#("provider", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier {
    [] -> fields
    _ -> [
      #("modifier", json.array(modifier, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case product_or_service {
    Some(v) -> [#("productOrService", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case category {
    Some(v) -> [#("category", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn coverageeligibilityresponse_insurance_item_decoder() -> Decoder(
  CoverageeligibilityresponseInsuranceItem,
) {
  use authorization_url <- decode.optional_field(
    "authorizationUrl",
    None,
    decode.optional(decode.string),
  )
  use authorization_supporting <- decode.optional_field(
    "authorizationSupporting",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use authorization_required <- decode.optional_field(
    "authorizationRequired",
    None,
    decode.optional(decode.bool),
  )
  use benefit <- decode.optional_field(
    "benefit",
    [],
    decode.list(coverageeligibilityresponse_insurance_item_benefit_decoder()),
  )
  use term <- decode.optional_field(
    "term",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use unit <- decode.optional_field(
    "unit",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use network <- decode.optional_field(
    "network",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use excluded <- decode.optional_field(
    "excluded",
    None,
    decode.optional(decode.bool),
  )
  use provider <- decode.optional_field(
    "provider",
    None,
    decode.optional(reference_decoder()),
  )
  use modifier <- decode.optional_field(
    "modifier",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use product_or_service <- decode.optional_field(
    "productOrService",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use category <- decode.optional_field(
    "category",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CoverageeligibilityresponseInsuranceItem(
    authorization_url:,
    authorization_supporting:,
    authorization_required:,
    benefit:,
    term:,
    unit:,
    network:,
    description:,
    name:,
    excluded:,
    provider:,
    modifier:,
    product_or_service:,
    category:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn coverageeligibilityresponse_insurance_to_json(
  coverageeligibilityresponse_insurance: CoverageeligibilityresponseInsurance,
) -> Json {
  let CoverageeligibilityresponseInsurance(
    item:,
    benefit_period:,
    inforce:,
    coverage:,
    modifier_extension:,
    extension:,
    id:,
  ) = coverageeligibilityresponse_insurance
  let fields = [
    #("coverage", reference_to_json(coverage)),
  ]
  let fields = case item {
    [] -> fields
    _ -> [
      #(
        "item",
        json.array(item, coverageeligibilityresponse_insurance_item_to_json),
      ),
      ..fields
    ]
  }
  let fields = case benefit_period {
    Some(v) -> [#("benefitPeriod", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case inforce {
    Some(v) -> [#("inforce", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn coverageeligibilityresponse_insurance_decoder() -> Decoder(
  CoverageeligibilityresponseInsurance,
) {
  use item <- decode.optional_field(
    "item",
    [],
    decode.list(coverageeligibilityresponse_insurance_item_decoder()),
  )
  use benefit_period <- decode.optional_field(
    "benefitPeriod",
    None,
    decode.optional(period_decoder()),
  )
  use inforce <- decode.optional_field(
    "inforce",
    None,
    decode.optional(decode.bool),
  )
  use coverage <- decode.field("coverage", reference_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CoverageeligibilityresponseInsurance(
    item:,
    benefit_period:,
    inforce:,
    coverage:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn coverageeligibilityresponse_to_json(
  coverageeligibilityresponse: Coverageeligibilityresponse,
) -> Json {
  let Coverageeligibilityresponse(
    error:,
    form:,
    pre_auth_ref:,
    insurance:,
    insurer:,
    disposition:,
    outcome:,
    request:,
    requestor:,
    created:,
    serviced:,
    patient:,
    purpose:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = coverageeligibilityresponse
  let fields = [
    #("insurer", reference_to_json(insurer)),
    #("outcome", r4bvaluesets.remittanceoutcome_to_json(outcome)),
    #("request", reference_to_json(request)),
    #("created", json.string(created)),
    #("patient", reference_to_json(patient)),
    #("status", r4bvaluesets.fmstatus_to_json(status)),
  ]
  let fields = case error {
    [] -> fields
    _ -> [
      #("error", json.array(error, coverageeligibilityresponse_error_to_json)),
      ..fields
    ]
  }
  let fields = case form {
    Some(v) -> [#("form", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case pre_auth_ref {
    Some(v) -> [#("preAuthRef", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case insurance {
    [] -> fields
    _ -> [
      #(
        "insurance",
        json.array(insurance, coverageeligibilityresponse_insurance_to_json),
      ),
      ..fields
    ]
  }
  let fields = case disposition {
    Some(v) -> [#("disposition", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case requestor {
    Some(v) -> [#("requestor", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case serviced {
    Some(v) -> [
      #(
        "serviced"
          <> case v {
          CoverageeligibilityresponseServicedDate(_) -> "Date"
          CoverageeligibilityresponseServicedPeriod(_) -> "Period"
        },
        coverageeligibilityresponse_serviced_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case purpose {
    [] -> fields
    _ -> [
      #(
        "purpose",
        json.array(purpose, r4bvaluesets.eligibilityresponsepurpose_to_json),
      ),
      ..fields
    ]
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [
    #("resourceType", json.string("Coverageeligibilityresponse")),
    ..fields
  ]
  json.object(fields)
}

pub fn coverageeligibilityresponse_decoder() -> Decoder(
  Coverageeligibilityresponse,
) {
  use error <- decode.optional_field(
    "error",
    [],
    decode.list(coverageeligibilityresponse_error_decoder()),
  )
  use form <- decode.optional_field(
    "form",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use pre_auth_ref <- decode.optional_field(
    "preAuthRef",
    None,
    decode.optional(decode.string),
  )
  use insurance <- decode.optional_field(
    "insurance",
    [],
    decode.list(coverageeligibilityresponse_insurance_decoder()),
  )
  use insurer <- decode.field("insurer", reference_decoder())
  use disposition <- decode.optional_field(
    "disposition",
    None,
    decode.optional(decode.string),
  )
  use outcome <- decode.field(
    "outcome",
    r4bvaluesets.remittanceoutcome_decoder(),
  )
  use request <- decode.field("request", reference_decoder())
  use requestor <- decode.optional_field(
    "requestor",
    None,
    decode.optional(reference_decoder()),
  )
  use created <- decode.field("created", decode.string)
  use serviced <- decode.then(
    none_if_omitted(coverageeligibilityresponse_serviced_decoder()),
  )
  use patient <- decode.field("patient", reference_decoder())
  use purpose <- decode.optional_field(
    "purpose",
    [],
    decode.list(r4bvaluesets.eligibilityresponsepurpose_decoder()),
  )
  use status <- decode.field("status", r4bvaluesets.fmstatus_decoder())
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Coverageeligibilityresponse",
    decode.failure(
      coverageeligibilityresponse_new(
        insurer:,
        outcome:,
        request:,
        created:,
        patient:,
        status:,
      ),
      "resourceType",
    ),
  )
  decode.success(Coverageeligibilityresponse(
    error:,
    form:,
    pre_auth_ref:,
    insurance:,
    insurer:,
    disposition:,
    outcome:,
    request:,
    requestor:,
    created:,
    serviced:,
    patient:,
    purpose:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/DetectedIssue#resource
pub type Detectedissue {
  Detectedissue(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    status: r4bvaluesets.Observationstatus,
    code: Option(Codeableconcept),
    severity: Option(r4bvaluesets.Detectedissueseverity),
    patient: Option(Reference),
    identified: Option(DetectedissueIdentified),
    author: Option(Reference),
    implicated: List(Reference),
    evidence: List(DetectedissueEvidence),
    detail: Option(String),
    reference: Option(String),
    mitigation: List(DetectedissueMitigation),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/DetectedIssue#resource
pub type DetectedissueIdentified {
  DetectedissueIdentifiedDatetime(identified: String)
  DetectedissueIdentifiedPeriod(identified: Period)
}

pub fn detectedissue_identified_to_json(elt: DetectedissueIdentified) -> Json {
  case elt {
    DetectedissueIdentifiedDatetime(v) -> json.string(v)
    DetectedissueIdentifiedPeriod(v) -> period_to_json(v)
  }
}

pub fn detectedissue_identified_decoder() -> Decoder(DetectedissueIdentified) {
  decode.one_of(
    decode.field("identifiedDateTime", decode.string, decode.success)
      |> decode.map(DetectedissueIdentifiedDatetime),
    [
      decode.field("identifiedPeriod", period_decoder(), decode.success)
      |> decode.map(DetectedissueIdentifiedPeriod),
    ],
  )
}

pub fn detectedissue_new(
  status status: r4bvaluesets.Observationstatus,
) -> Detectedissue {
  Detectedissue(
    mitigation: [],
    reference: None,
    detail: None,
    evidence: [],
    implicated: [],
    author: None,
    identified: None,
    patient: None,
    severity: None,
    code: None,
    status:,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/DetectedIssue#resource
pub type DetectedissueEvidence {
  DetectedissueEvidence(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    code: List(Codeableconcept),
    detail: List(Reference),
  )
}

pub fn detectedissue_evidence_new() -> DetectedissueEvidence {
  DetectedissueEvidence(
    detail: [],
    code: [],
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/DetectedIssue#resource
pub type DetectedissueMitigation {
  DetectedissueMitigation(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    action: Codeableconcept,
    date: Option(String),
    author: Option(Reference),
  )
}

pub fn detectedissue_mitigation_new(
  action action: Codeableconcept,
) -> DetectedissueMitigation {
  DetectedissueMitigation(
    author: None,
    date: None,
    action:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn detectedissue_mitigation_to_json(
  detectedissue_mitigation: DetectedissueMitigation,
) -> Json {
  let DetectedissueMitigation(
    author:,
    date:,
    action:,
    modifier_extension:,
    extension:,
    id:,
  ) = detectedissue_mitigation
  let fields = [
    #("action", codeableconcept_to_json(action)),
  ]
  let fields = case author {
    Some(v) -> [#("author", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case date {
    Some(v) -> [#("date", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn detectedissue_mitigation_decoder() -> Decoder(DetectedissueMitigation) {
  use author <- decode.optional_field(
    "author",
    None,
    decode.optional(reference_decoder()),
  )
  use date <- decode.optional_field(
    "date",
    None,
    decode.optional(decode.string),
  )
  use action <- decode.field("action", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(DetectedissueMitigation(
    author:,
    date:,
    action:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn detectedissue_evidence_to_json(
  detectedissue_evidence: DetectedissueEvidence,
) -> Json {
  let DetectedissueEvidence(
    detail:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ) = detectedissue_evidence
  let fields = []
  let fields = case detail {
    [] -> fields
    _ -> [#("detail", json.array(detail, reference_to_json)), ..fields]
  }
  let fields = case code {
    [] -> fields
    _ -> [#("code", json.array(code, codeableconcept_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn detectedissue_evidence_decoder() -> Decoder(DetectedissueEvidence) {
  use detail <- decode.optional_field(
    "detail",
    [],
    decode.list(reference_decoder()),
  )
  use code <- decode.optional_field(
    "code",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(DetectedissueEvidence(
    detail:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn detectedissue_to_json(detectedissue: Detectedissue) -> Json {
  let Detectedissue(
    mitigation:,
    reference:,
    detail:,
    evidence:,
    implicated:,
    author:,
    identified:,
    patient:,
    severity:,
    code:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = detectedissue
  let fields = [
    #("status", r4bvaluesets.observationstatus_to_json(status)),
  ]
  let fields = case mitigation {
    [] -> fields
    _ -> [
      #("mitigation", json.array(mitigation, detectedissue_mitigation_to_json)),
      ..fields
    ]
  }
  let fields = case reference {
    Some(v) -> [#("reference", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case detail {
    Some(v) -> [#("detail", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case evidence {
    [] -> fields
    _ -> [
      #("evidence", json.array(evidence, detectedissue_evidence_to_json)),
      ..fields
    ]
  }
  let fields = case implicated {
    [] -> fields
    _ -> [#("implicated", json.array(implicated, reference_to_json)), ..fields]
  }
  let fields = case author {
    Some(v) -> [#("author", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case identified {
    Some(v) -> [
      #(
        "identified"
          <> case v {
          DetectedissueIdentifiedDatetime(_) -> "Datetime"
          DetectedissueIdentifiedPeriod(_) -> "Period"
        },
        detectedissue_identified_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case patient {
    Some(v) -> [#("patient", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case severity {
    Some(v) -> [
      #("severity", r4bvaluesets.detectedissueseverity_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case code {
    Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Detectedissue")), ..fields]
  json.object(fields)
}

pub fn detectedissue_decoder() -> Decoder(Detectedissue) {
  use mitigation <- decode.optional_field(
    "mitigation",
    [],
    decode.list(detectedissue_mitigation_decoder()),
  )
  use reference <- decode.optional_field(
    "reference",
    None,
    decode.optional(decode.string),
  )
  use detail <- decode.optional_field(
    "detail",
    None,
    decode.optional(decode.string),
  )
  use evidence <- decode.optional_field(
    "evidence",
    [],
    decode.list(detectedissue_evidence_decoder()),
  )
  use implicated <- decode.optional_field(
    "implicated",
    [],
    decode.list(reference_decoder()),
  )
  use author <- decode.optional_field(
    "author",
    None,
    decode.optional(reference_decoder()),
  )
  use identified <- decode.then(
    none_if_omitted(detectedissue_identified_decoder()),
  )
  use patient <- decode.optional_field(
    "patient",
    None,
    decode.optional(reference_decoder()),
  )
  use severity <- decode.optional_field(
    "severity",
    None,
    decode.optional(r4bvaluesets.detectedissueseverity_decoder()),
  )
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use status <- decode.field("status", r4bvaluesets.observationstatus_decoder())
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Detectedissue",
    decode.failure(detectedissue_new(status:), "resourceType"),
  )
  decode.success(Detectedissue(
    mitigation:,
    reference:,
    detail:,
    evidence:,
    implicated:,
    author:,
    identified:,
    patient:,
    severity:,
    code:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/Device#resource
pub type Device {
  Device(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    definition: Option(Reference),
    udi_carrier: List(DeviceUdicarrier),
    status: Option(r4bvaluesets.Devicestatus),
    status_reason: List(Codeableconcept),
    distinct_identifier: Option(String),
    manufacturer: Option(String),
    manufacture_date: Option(String),
    expiration_date: Option(String),
    lot_number: Option(String),
    serial_number: Option(String),
    device_name: List(DeviceDevicename),
    model_number: Option(String),
    part_number: Option(String),
    type_: Option(Codeableconcept),
    specialization: List(DeviceSpecialization),
    version: List(DeviceVersion),
    property: List(DeviceProperty),
    patient: Option(Reference),
    owner: Option(Reference),
    contact: List(Contactpoint),
    location: Option(Reference),
    url: Option(String),
    note: List(Annotation),
    safety: List(Codeableconcept),
    parent: Option(Reference),
  )
}

pub fn device_new() -> Device {
  Device(
    parent: None,
    safety: [],
    note: [],
    url: None,
    location: None,
    contact: [],
    owner: None,
    patient: None,
    property: [],
    version: [],
    specialization: [],
    type_: None,
    part_number: None,
    model_number: None,
    device_name: [],
    serial_number: None,
    lot_number: None,
    expiration_date: None,
    manufacture_date: None,
    manufacturer: None,
    distinct_identifier: None,
    status_reason: [],
    status: None,
    udi_carrier: [],
    definition: None,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Device#resource
pub type DeviceUdicarrier {
  DeviceUdicarrier(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    device_identifier: Option(String),
    issuer: Option(String),
    jurisdiction: Option(String),
    carrier_aidc: Option(String),
    carrier_hrf: Option(String),
    entry_type: Option(r4bvaluesets.Udientrytype),
  )
}

pub fn device_udicarrier_new() -> DeviceUdicarrier {
  DeviceUdicarrier(
    entry_type: None,
    carrier_hrf: None,
    carrier_aidc: None,
    jurisdiction: None,
    issuer: None,
    device_identifier: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Device#resource
pub type DeviceDevicename {
  DeviceDevicename(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    name: String,
    type_: r4bvaluesets.Devicenametype,
  )
}

pub fn device_devicename_new(
  type_ type_: r4bvaluesets.Devicenametype,
  name name: String,
) -> DeviceDevicename {
  DeviceDevicename(
    type_:,
    name:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Device#resource
pub type DeviceSpecialization {
  DeviceSpecialization(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    system_type: Codeableconcept,
    version: Option(String),
  )
}

pub fn device_specialization_new(
  system_type system_type: Codeableconcept,
) -> DeviceSpecialization {
  DeviceSpecialization(
    version: None,
    system_type:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Device#resource
pub type DeviceVersion {
  DeviceVersion(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Option(Codeableconcept),
    component: Option(Identifier),
    value: String,
  )
}

pub fn device_version_new(value value: String) -> DeviceVersion {
  DeviceVersion(
    value:,
    component: None,
    type_: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Device#resource
pub type DeviceProperty {
  DeviceProperty(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Codeableconcept,
    value_quantity: List(Quantity),
    value_code: List(Codeableconcept),
  )
}

pub fn device_property_new(type_ type_: Codeableconcept) -> DeviceProperty {
  DeviceProperty(
    value_code: [],
    value_quantity: [],
    type_:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn device_property_to_json(device_property: DeviceProperty) -> Json {
  let DeviceProperty(
    value_code:,
    value_quantity:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = device_property
  let fields = [
    #("type", codeableconcept_to_json(type_)),
  ]
  let fields = case value_code {
    [] -> fields
    _ -> [
      #("valueCode", json.array(value_code, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case value_quantity {
    [] -> fields
    _ -> [
      #("valueQuantity", json.array(value_quantity, quantity_to_json)),
      ..fields
    ]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn device_property_decoder() -> Decoder(DeviceProperty) {
  use value_code <- decode.optional_field(
    "valueCode",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use value_quantity <- decode.optional_field(
    "valueQuantity",
    [],
    decode.list(quantity_decoder()),
  )
  use type_ <- decode.field("type", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(DeviceProperty(
    value_code:,
    value_quantity:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn device_version_to_json(device_version: DeviceVersion) -> Json {
  let DeviceVersion(
    value:,
    component:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = device_version
  let fields = [
    #("value", json.string(value)),
  ]
  let fields = case component {
    Some(v) -> [#("component", identifier_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn device_version_decoder() -> Decoder(DeviceVersion) {
  use value <- decode.field("value", decode.string)
  use component <- decode.optional_field(
    "component",
    None,
    decode.optional(identifier_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(DeviceVersion(
    value:,
    component:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn device_specialization_to_json(
  device_specialization: DeviceSpecialization,
) -> Json {
  let DeviceSpecialization(
    version:,
    system_type:,
    modifier_extension:,
    extension:,
    id:,
  ) = device_specialization
  let fields = [
    #("systemType", codeableconcept_to_json(system_type)),
  ]
  let fields = case version {
    Some(v) -> [#("version", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn device_specialization_decoder() -> Decoder(DeviceSpecialization) {
  use version <- decode.optional_field(
    "version",
    None,
    decode.optional(decode.string),
  )
  use system_type <- decode.field("systemType", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(DeviceSpecialization(
    version:,
    system_type:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn device_devicename_to_json(device_devicename: DeviceDevicename) -> Json {
  let DeviceDevicename(type_:, name:, modifier_extension:, extension:, id:) =
    device_devicename
  let fields = [
    #("type", r4bvaluesets.devicenametype_to_json(type_)),
    #("name", json.string(name)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn device_devicename_decoder() -> Decoder(DeviceDevicename) {
  use type_ <- decode.field("type", r4bvaluesets.devicenametype_decoder())
  use name <- decode.field("name", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(DeviceDevicename(
    type_:,
    name:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn device_udicarrier_to_json(device_udicarrier: DeviceUdicarrier) -> Json {
  let DeviceUdicarrier(
    entry_type:,
    carrier_hrf:,
    carrier_aidc:,
    jurisdiction:,
    issuer:,
    device_identifier:,
    modifier_extension:,
    extension:,
    id:,
  ) = device_udicarrier
  let fields = []
  let fields = case entry_type {
    Some(v) -> [#("entryType", r4bvaluesets.udientrytype_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case carrier_hrf {
    Some(v) -> [#("carrierHRF", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case carrier_aidc {
    Some(v) -> [#("carrierAIDC", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case jurisdiction {
    Some(v) -> [#("jurisdiction", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case issuer {
    Some(v) -> [#("issuer", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case device_identifier {
    Some(v) -> [#("deviceIdentifier", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn device_udicarrier_decoder() -> Decoder(DeviceUdicarrier) {
  use entry_type <- decode.optional_field(
    "entryType",
    None,
    decode.optional(r4bvaluesets.udientrytype_decoder()),
  )
  use carrier_hrf <- decode.optional_field(
    "carrierHRF",
    None,
    decode.optional(decode.string),
  )
  use carrier_aidc <- decode.optional_field(
    "carrierAIDC",
    None,
    decode.optional(decode.string),
  )
  use jurisdiction <- decode.optional_field(
    "jurisdiction",
    None,
    decode.optional(decode.string),
  )
  use issuer <- decode.optional_field(
    "issuer",
    None,
    decode.optional(decode.string),
  )
  use device_identifier <- decode.optional_field(
    "deviceIdentifier",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(DeviceUdicarrier(
    entry_type:,
    carrier_hrf:,
    carrier_aidc:,
    jurisdiction:,
    issuer:,
    device_identifier:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn device_to_json(device: Device) -> Json {
  let Device(
    parent:,
    safety:,
    note:,
    url:,
    location:,
    contact:,
    owner:,
    patient:,
    property:,
    version:,
    specialization:,
    type_:,
    part_number:,
    model_number:,
    device_name:,
    serial_number:,
    lot_number:,
    expiration_date:,
    manufacture_date:,
    manufacturer:,
    distinct_identifier:,
    status_reason:,
    status:,
    udi_carrier:,
    definition:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = device
  let fields = []
  let fields = case parent {
    Some(v) -> [#("parent", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case safety {
    [] -> fields
    _ -> [#("safety", json.array(safety, codeableconcept_to_json)), ..fields]
  }
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case url {
    Some(v) -> [#("url", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case location {
    Some(v) -> [#("location", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case contact {
    [] -> fields
    _ -> [#("contact", json.array(contact, contactpoint_to_json)), ..fields]
  }
  let fields = case owner {
    Some(v) -> [#("owner", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case patient {
    Some(v) -> [#("patient", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case property {
    [] -> fields
    _ -> [
      #("property", json.array(property, device_property_to_json)),
      ..fields
    ]
  }
  let fields = case version {
    [] -> fields
    _ -> [#("version", json.array(version, device_version_to_json)), ..fields]
  }
  let fields = case specialization {
    [] -> fields
    _ -> [
      #(
        "specialization",
        json.array(specialization, device_specialization_to_json),
      ),
      ..fields
    ]
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case part_number {
    Some(v) -> [#("partNumber", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case model_number {
    Some(v) -> [#("modelNumber", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case device_name {
    [] -> fields
    _ -> [
      #("deviceName", json.array(device_name, device_devicename_to_json)),
      ..fields
    ]
  }
  let fields = case serial_number {
    Some(v) -> [#("serialNumber", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case lot_number {
    Some(v) -> [#("lotNumber", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case expiration_date {
    Some(v) -> [#("expirationDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case manufacture_date {
    Some(v) -> [#("manufactureDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case manufacturer {
    Some(v) -> [#("manufacturer", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case distinct_identifier {
    Some(v) -> [#("distinctIdentifier", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case status_reason {
    [] -> fields
    _ -> [
      #("statusReason", json.array(status_reason, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case status {
    Some(v) -> [#("status", r4bvaluesets.devicestatus_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case udi_carrier {
    [] -> fields
    _ -> [
      #("udiCarrier", json.array(udi_carrier, device_udicarrier_to_json)),
      ..fields
    ]
  }
  let fields = case definition {
    Some(v) -> [#("definition", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Device")), ..fields]
  json.object(fields)
}

pub fn device_decoder() -> Decoder(Device) {
  use parent <- decode.optional_field(
    "parent",
    None,
    decode.optional(reference_decoder()),
  )
  use safety <- decode.optional_field(
    "safety",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use url <- decode.optional_field("url", None, decode.optional(decode.string))
  use location <- decode.optional_field(
    "location",
    None,
    decode.optional(reference_decoder()),
  )
  use contact <- decode.optional_field(
    "contact",
    [],
    decode.list(contactpoint_decoder()),
  )
  use owner <- decode.optional_field(
    "owner",
    None,
    decode.optional(reference_decoder()),
  )
  use patient <- decode.optional_field(
    "patient",
    None,
    decode.optional(reference_decoder()),
  )
  use property <- decode.optional_field(
    "property",
    [],
    decode.list(device_property_decoder()),
  )
  use version <- decode.optional_field(
    "version",
    [],
    decode.list(device_version_decoder()),
  )
  use specialization <- decode.optional_field(
    "specialization",
    [],
    decode.list(device_specialization_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use part_number <- decode.optional_field(
    "partNumber",
    None,
    decode.optional(decode.string),
  )
  use model_number <- decode.optional_field(
    "modelNumber",
    None,
    decode.optional(decode.string),
  )
  use device_name <- decode.optional_field(
    "deviceName",
    [],
    decode.list(device_devicename_decoder()),
  )
  use serial_number <- decode.optional_field(
    "serialNumber",
    None,
    decode.optional(decode.string),
  )
  use lot_number <- decode.optional_field(
    "lotNumber",
    None,
    decode.optional(decode.string),
  )
  use expiration_date <- decode.optional_field(
    "expirationDate",
    None,
    decode.optional(decode.string),
  )
  use manufacture_date <- decode.optional_field(
    "manufactureDate",
    None,
    decode.optional(decode.string),
  )
  use manufacturer <- decode.optional_field(
    "manufacturer",
    None,
    decode.optional(decode.string),
  )
  use distinct_identifier <- decode.optional_field(
    "distinctIdentifier",
    None,
    decode.optional(decode.string),
  )
  use status_reason <- decode.optional_field(
    "statusReason",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use status <- decode.optional_field(
    "status",
    None,
    decode.optional(r4bvaluesets.devicestatus_decoder()),
  )
  use udi_carrier <- decode.optional_field(
    "udiCarrier",
    [],
    decode.list(device_udicarrier_decoder()),
  )
  use definition <- decode.optional_field(
    "definition",
    None,
    decode.optional(reference_decoder()),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Device",
    decode.failure(device_new(), "resourceType"),
  )
  decode.success(Device(
    parent:,
    safety:,
    note:,
    url:,
    location:,
    contact:,
    owner:,
    patient:,
    property:,
    version:,
    specialization:,
    type_:,
    part_number:,
    model_number:,
    device_name:,
    serial_number:,
    lot_number:,
    expiration_date:,
    manufacture_date:,
    manufacturer:,
    distinct_identifier:,
    status_reason:,
    status:,
    udi_carrier:,
    definition:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/DeviceDefinition#resource
pub type Devicedefinition {
  Devicedefinition(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    udi_device_identifier: List(DevicedefinitionUdideviceidentifier),
    manufacturer: Option(DevicedefinitionManufacturer),
    device_name: List(DevicedefinitionDevicename),
    model_number: Option(String),
    type_: Option(Codeableconcept),
    specialization: List(DevicedefinitionSpecialization),
    version: List(String),
    safety: List(Codeableconcept),
    shelf_life_storage: List(Productshelflife),
    physical_characteristics: Option(Prodcharacteristic),
    language_code: List(Codeableconcept),
    capability: List(DevicedefinitionCapability),
    property: List(DevicedefinitionProperty),
    owner: Option(Reference),
    contact: List(Contactpoint),
    url: Option(String),
    online_information: Option(String),
    note: List(Annotation),
    quantity: Option(Quantity),
    parent_device: Option(Reference),
    material: List(DevicedefinitionMaterial),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/DeviceDefinition#resource
pub type DevicedefinitionManufacturer {
  DevicedefinitionManufacturerString(manufacturer: String)
  DevicedefinitionManufacturerReference(manufacturer: Reference)
}

pub fn devicedefinition_manufacturer_to_json(
  elt: DevicedefinitionManufacturer,
) -> Json {
  case elt {
    DevicedefinitionManufacturerString(v) -> json.string(v)
    DevicedefinitionManufacturerReference(v) -> reference_to_json(v)
  }
}

pub fn devicedefinition_manufacturer_decoder() -> Decoder(
  DevicedefinitionManufacturer,
) {
  decode.one_of(
    decode.field("manufacturerString", decode.string, decode.success)
      |> decode.map(DevicedefinitionManufacturerString),
    [
      decode.field("manufacturerReference", reference_decoder(), decode.success)
      |> decode.map(DevicedefinitionManufacturerReference),
    ],
  )
}

pub fn devicedefinition_new() -> Devicedefinition {
  Devicedefinition(
    material: [],
    parent_device: None,
    quantity: None,
    note: [],
    online_information: None,
    url: None,
    contact: [],
    owner: None,
    property: [],
    capability: [],
    language_code: [],
    physical_characteristics: None,
    shelf_life_storage: [],
    safety: [],
    version: [],
    specialization: [],
    type_: None,
    model_number: None,
    device_name: [],
    manufacturer: None,
    udi_device_identifier: [],
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/DeviceDefinition#resource
pub type DevicedefinitionUdideviceidentifier {
  DevicedefinitionUdideviceidentifier(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    device_identifier: String,
    issuer: String,
    jurisdiction: String,
  )
}

pub fn devicedefinition_udideviceidentifier_new(
  jurisdiction jurisdiction: String,
  issuer issuer: String,
  device_identifier device_identifier: String,
) -> DevicedefinitionUdideviceidentifier {
  DevicedefinitionUdideviceidentifier(
    jurisdiction:,
    issuer:,
    device_identifier:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/DeviceDefinition#resource
pub type DevicedefinitionDevicename {
  DevicedefinitionDevicename(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    name: String,
    type_: r4bvaluesets.Devicenametype,
  )
}

pub fn devicedefinition_devicename_new(
  type_ type_: r4bvaluesets.Devicenametype,
  name name: String,
) -> DevicedefinitionDevicename {
  DevicedefinitionDevicename(
    type_:,
    name:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/DeviceDefinition#resource
pub type DevicedefinitionSpecialization {
  DevicedefinitionSpecialization(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    system_type: String,
    version: Option(String),
  )
}

pub fn devicedefinition_specialization_new(
  system_type system_type: String,
) -> DevicedefinitionSpecialization {
  DevicedefinitionSpecialization(
    version: None,
    system_type:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/DeviceDefinition#resource
pub type DevicedefinitionCapability {
  DevicedefinitionCapability(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Codeableconcept,
    description: List(Codeableconcept),
  )
}

pub fn devicedefinition_capability_new(
  type_ type_: Codeableconcept,
) -> DevicedefinitionCapability {
  DevicedefinitionCapability(
    description: [],
    type_:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/DeviceDefinition#resource
pub type DevicedefinitionProperty {
  DevicedefinitionProperty(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Codeableconcept,
    value_quantity: List(Quantity),
    value_code: List(Codeableconcept),
  )
}

pub fn devicedefinition_property_new(
  type_ type_: Codeableconcept,
) -> DevicedefinitionProperty {
  DevicedefinitionProperty(
    value_code: [],
    value_quantity: [],
    type_:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/DeviceDefinition#resource
pub type DevicedefinitionMaterial {
  DevicedefinitionMaterial(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    substance: Codeableconcept,
    alternate: Option(Bool),
    allergenic_indicator: Option(Bool),
  )
}

pub fn devicedefinition_material_new(
  substance substance: Codeableconcept,
) -> DevicedefinitionMaterial {
  DevicedefinitionMaterial(
    allergenic_indicator: None,
    alternate: None,
    substance:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn devicedefinition_material_to_json(
  devicedefinition_material: DevicedefinitionMaterial,
) -> Json {
  let DevicedefinitionMaterial(
    allergenic_indicator:,
    alternate:,
    substance:,
    modifier_extension:,
    extension:,
    id:,
  ) = devicedefinition_material
  let fields = [
    #("substance", codeableconcept_to_json(substance)),
  ]
  let fields = case allergenic_indicator {
    Some(v) -> [#("allergenicIndicator", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case alternate {
    Some(v) -> [#("alternate", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn devicedefinition_material_decoder() -> Decoder(DevicedefinitionMaterial) {
  use allergenic_indicator <- decode.optional_field(
    "allergenicIndicator",
    None,
    decode.optional(decode.bool),
  )
  use alternate <- decode.optional_field(
    "alternate",
    None,
    decode.optional(decode.bool),
  )
  use substance <- decode.field("substance", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(DevicedefinitionMaterial(
    allergenic_indicator:,
    alternate:,
    substance:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn devicedefinition_property_to_json(
  devicedefinition_property: DevicedefinitionProperty,
) -> Json {
  let DevicedefinitionProperty(
    value_code:,
    value_quantity:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = devicedefinition_property
  let fields = [
    #("type", codeableconcept_to_json(type_)),
  ]
  let fields = case value_code {
    [] -> fields
    _ -> [
      #("valueCode", json.array(value_code, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case value_quantity {
    [] -> fields
    _ -> [
      #("valueQuantity", json.array(value_quantity, quantity_to_json)),
      ..fields
    ]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn devicedefinition_property_decoder() -> Decoder(DevicedefinitionProperty) {
  use value_code <- decode.optional_field(
    "valueCode",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use value_quantity <- decode.optional_field(
    "valueQuantity",
    [],
    decode.list(quantity_decoder()),
  )
  use type_ <- decode.field("type", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(DevicedefinitionProperty(
    value_code:,
    value_quantity:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn devicedefinition_capability_to_json(
  devicedefinition_capability: DevicedefinitionCapability,
) -> Json {
  let DevicedefinitionCapability(
    description:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = devicedefinition_capability
  let fields = [
    #("type", codeableconcept_to_json(type_)),
  ]
  let fields = case description {
    [] -> fields
    _ -> [
      #("description", json.array(description, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn devicedefinition_capability_decoder() -> Decoder(
  DevicedefinitionCapability,
) {
  use description <- decode.optional_field(
    "description",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use type_ <- decode.field("type", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(DevicedefinitionCapability(
    description:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn devicedefinition_specialization_to_json(
  devicedefinition_specialization: DevicedefinitionSpecialization,
) -> Json {
  let DevicedefinitionSpecialization(
    version:,
    system_type:,
    modifier_extension:,
    extension:,
    id:,
  ) = devicedefinition_specialization
  let fields = [
    #("systemType", json.string(system_type)),
  ]
  let fields = case version {
    Some(v) -> [#("version", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn devicedefinition_specialization_decoder() -> Decoder(
  DevicedefinitionSpecialization,
) {
  use version <- decode.optional_field(
    "version",
    None,
    decode.optional(decode.string),
  )
  use system_type <- decode.field("systemType", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(DevicedefinitionSpecialization(
    version:,
    system_type:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn devicedefinition_devicename_to_json(
  devicedefinition_devicename: DevicedefinitionDevicename,
) -> Json {
  let DevicedefinitionDevicename(
    type_:,
    name:,
    modifier_extension:,
    extension:,
    id:,
  ) = devicedefinition_devicename
  let fields = [
    #("type", r4bvaluesets.devicenametype_to_json(type_)),
    #("name", json.string(name)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn devicedefinition_devicename_decoder() -> Decoder(
  DevicedefinitionDevicename,
) {
  use type_ <- decode.field("type", r4bvaluesets.devicenametype_decoder())
  use name <- decode.field("name", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(DevicedefinitionDevicename(
    type_:,
    name:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn devicedefinition_udideviceidentifier_to_json(
  devicedefinition_udideviceidentifier: DevicedefinitionUdideviceidentifier,
) -> Json {
  let DevicedefinitionUdideviceidentifier(
    jurisdiction:,
    issuer:,
    device_identifier:,
    modifier_extension:,
    extension:,
    id:,
  ) = devicedefinition_udideviceidentifier
  let fields = [
    #("jurisdiction", json.string(jurisdiction)),
    #("issuer", json.string(issuer)),
    #("deviceIdentifier", json.string(device_identifier)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn devicedefinition_udideviceidentifier_decoder() -> Decoder(
  DevicedefinitionUdideviceidentifier,
) {
  use jurisdiction <- decode.field("jurisdiction", decode.string)
  use issuer <- decode.field("issuer", decode.string)
  use device_identifier <- decode.field("deviceIdentifier", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(DevicedefinitionUdideviceidentifier(
    jurisdiction:,
    issuer:,
    device_identifier:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn devicedefinition_to_json(devicedefinition: Devicedefinition) -> Json {
  let Devicedefinition(
    material:,
    parent_device:,
    quantity:,
    note:,
    online_information:,
    url:,
    contact:,
    owner:,
    property:,
    capability:,
    language_code:,
    physical_characteristics:,
    shelf_life_storage:,
    safety:,
    version:,
    specialization:,
    type_:,
    model_number:,
    device_name:,
    manufacturer:,
    udi_device_identifier:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = devicedefinition
  let fields = []
  let fields = case material {
    [] -> fields
    _ -> [
      #("material", json.array(material, devicedefinition_material_to_json)),
      ..fields
    ]
  }
  let fields = case parent_device {
    Some(v) -> [#("parentDevice", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case quantity {
    Some(v) -> [#("quantity", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case online_information {
    Some(v) -> [#("onlineInformation", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case url {
    Some(v) -> [#("url", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case contact {
    [] -> fields
    _ -> [#("contact", json.array(contact, contactpoint_to_json)), ..fields]
  }
  let fields = case owner {
    Some(v) -> [#("owner", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case property {
    [] -> fields
    _ -> [
      #("property", json.array(property, devicedefinition_property_to_json)),
      ..fields
    ]
  }
  let fields = case capability {
    [] -> fields
    _ -> [
      #(
        "capability",
        json.array(capability, devicedefinition_capability_to_json),
      ),
      ..fields
    ]
  }
  let fields = case language_code {
    [] -> fields
    _ -> [
      #("languageCode", json.array(language_code, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case physical_characteristics {
    Some(v) -> [
      #("physicalCharacteristics", prodcharacteristic_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case shelf_life_storage {
    [] -> fields
    _ -> [
      #(
        "shelfLifeStorage",
        json.array(shelf_life_storage, productshelflife_to_json),
      ),
      ..fields
    ]
  }
  let fields = case safety {
    [] -> fields
    _ -> [#("safety", json.array(safety, codeableconcept_to_json)), ..fields]
  }
  let fields = case version {
    [] -> fields
    _ -> [#("version", json.array(version, json.string)), ..fields]
  }
  let fields = case specialization {
    [] -> fields
    _ -> [
      #(
        "specialization",
        json.array(specialization, devicedefinition_specialization_to_json),
      ),
      ..fields
    ]
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case model_number {
    Some(v) -> [#("modelNumber", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case device_name {
    [] -> fields
    _ -> [
      #(
        "deviceName",
        json.array(device_name, devicedefinition_devicename_to_json),
      ),
      ..fields
    ]
  }
  let fields = case manufacturer {
    Some(v) -> [
      #(
        "manufacturer"
          <> case v {
          DevicedefinitionManufacturerString(_) -> "String"
          DevicedefinitionManufacturerReference(_) -> "Reference"
        },
        devicedefinition_manufacturer_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case udi_device_identifier {
    [] -> fields
    _ -> [
      #(
        "udiDeviceIdentifier",
        json.array(
          udi_device_identifier,
          devicedefinition_udideviceidentifier_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Devicedefinition")), ..fields]
  json.object(fields)
}

pub fn devicedefinition_decoder() -> Decoder(Devicedefinition) {
  use material <- decode.optional_field(
    "material",
    [],
    decode.list(devicedefinition_material_decoder()),
  )
  use parent_device <- decode.optional_field(
    "parentDevice",
    None,
    decode.optional(reference_decoder()),
  )
  use quantity <- decode.optional_field(
    "quantity",
    None,
    decode.optional(quantity_decoder()),
  )
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use online_information <- decode.optional_field(
    "onlineInformation",
    None,
    decode.optional(decode.string),
  )
  use url <- decode.optional_field("url", None, decode.optional(decode.string))
  use contact <- decode.optional_field(
    "contact",
    [],
    decode.list(contactpoint_decoder()),
  )
  use owner <- decode.optional_field(
    "owner",
    None,
    decode.optional(reference_decoder()),
  )
  use property <- decode.optional_field(
    "property",
    [],
    decode.list(devicedefinition_property_decoder()),
  )
  use capability <- decode.optional_field(
    "capability",
    [],
    decode.list(devicedefinition_capability_decoder()),
  )
  use language_code <- decode.optional_field(
    "languageCode",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use physical_characteristics <- decode.optional_field(
    "physicalCharacteristics",
    None,
    decode.optional(prodcharacteristic_decoder()),
  )
  use shelf_life_storage <- decode.optional_field(
    "shelfLifeStorage",
    [],
    decode.list(productshelflife_decoder()),
  )
  use safety <- decode.optional_field(
    "safety",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use version <- decode.optional_field(
    "version",
    [],
    decode.list(decode.string),
  )
  use specialization <- decode.optional_field(
    "specialization",
    [],
    decode.list(devicedefinition_specialization_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use model_number <- decode.optional_field(
    "modelNumber",
    None,
    decode.optional(decode.string),
  )
  use device_name <- decode.optional_field(
    "deviceName",
    [],
    decode.list(devicedefinition_devicename_decoder()),
  )
  use manufacturer <- decode.then(
    none_if_omitted(devicedefinition_manufacturer_decoder()),
  )
  use udi_device_identifier <- decode.optional_field(
    "udiDeviceIdentifier",
    [],
    decode.list(devicedefinition_udideviceidentifier_decoder()),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Devicedefinition",
    decode.failure(devicedefinition_new(), "resourceType"),
  )
  decode.success(Devicedefinition(
    material:,
    parent_device:,
    quantity:,
    note:,
    online_information:,
    url:,
    contact:,
    owner:,
    property:,
    capability:,
    language_code:,
    physical_characteristics:,
    shelf_life_storage:,
    safety:,
    version:,
    specialization:,
    type_:,
    model_number:,
    device_name:,
    manufacturer:,
    udi_device_identifier:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/DeviceMetric#resource
pub type Devicemetric {
  Devicemetric(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    type_: Codeableconcept,
    unit: Option(Codeableconcept),
    source: Option(Reference),
    parent: Option(Reference),
    operational_status: Option(r4bvaluesets.Metricoperationalstatus),
    color: Option(r4bvaluesets.Metriccolor),
    category: r4bvaluesets.Metriccategory,
    measurement_period: Option(Timing),
    calibration: List(DevicemetricCalibration),
  )
}

pub fn devicemetric_new(
  category category: r4bvaluesets.Metriccategory,
  type_ type_: Codeableconcept,
) -> Devicemetric {
  Devicemetric(
    calibration: [],
    measurement_period: None,
    category:,
    color: None,
    operational_status: None,
    parent: None,
    source: None,
    unit: None,
    type_:,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/DeviceMetric#resource
pub type DevicemetricCalibration {
  DevicemetricCalibration(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Option(r4bvaluesets.Metriccalibrationtype),
    state: Option(r4bvaluesets.Metriccalibrationstate),
    time: Option(String),
  )
}

pub fn devicemetric_calibration_new() -> DevicemetricCalibration {
  DevicemetricCalibration(
    time: None,
    state: None,
    type_: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn devicemetric_calibration_to_json(
  devicemetric_calibration: DevicemetricCalibration,
) -> Json {
  let DevicemetricCalibration(
    time:,
    state:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = devicemetric_calibration
  let fields = []
  let fields = case time {
    Some(v) -> [#("time", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case state {
    Some(v) -> [
      #("state", r4bvaluesets.metriccalibrationstate_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [
      #("type", r4bvaluesets.metriccalibrationtype_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn devicemetric_calibration_decoder() -> Decoder(DevicemetricCalibration) {
  use time <- decode.optional_field(
    "time",
    None,
    decode.optional(decode.string),
  )
  use state <- decode.optional_field(
    "state",
    None,
    decode.optional(r4bvaluesets.metriccalibrationstate_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(r4bvaluesets.metriccalibrationtype_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(DevicemetricCalibration(
    time:,
    state:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn devicemetric_to_json(devicemetric: Devicemetric) -> Json {
  let Devicemetric(
    calibration:,
    measurement_period:,
    category:,
    color:,
    operational_status:,
    parent:,
    source:,
    unit:,
    type_:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = devicemetric
  let fields = [
    #("category", r4bvaluesets.metriccategory_to_json(category)),
    #("type", codeableconcept_to_json(type_)),
  ]
  let fields = case calibration {
    [] -> fields
    _ -> [
      #(
        "calibration",
        json.array(calibration, devicemetric_calibration_to_json),
      ),
      ..fields
    ]
  }
  let fields = case measurement_period {
    Some(v) -> [#("measurementPeriod", timing_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case color {
    Some(v) -> [#("color", r4bvaluesets.metriccolor_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case operational_status {
    Some(v) -> [
      #("operationalStatus", r4bvaluesets.metricoperationalstatus_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case parent {
    Some(v) -> [#("parent", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case source {
    Some(v) -> [#("source", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case unit {
    Some(v) -> [#("unit", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Devicemetric")), ..fields]
  json.object(fields)
}

pub fn devicemetric_decoder() -> Decoder(Devicemetric) {
  use calibration <- decode.optional_field(
    "calibration",
    [],
    decode.list(devicemetric_calibration_decoder()),
  )
  use measurement_period <- decode.optional_field(
    "measurementPeriod",
    None,
    decode.optional(timing_decoder()),
  )
  use category <- decode.field(
    "category",
    r4bvaluesets.metriccategory_decoder(),
  )
  use color <- decode.optional_field(
    "color",
    None,
    decode.optional(r4bvaluesets.metriccolor_decoder()),
  )
  use operational_status <- decode.optional_field(
    "operationalStatus",
    None,
    decode.optional(r4bvaluesets.metricoperationalstatus_decoder()),
  )
  use parent <- decode.optional_field(
    "parent",
    None,
    decode.optional(reference_decoder()),
  )
  use source <- decode.optional_field(
    "source",
    None,
    decode.optional(reference_decoder()),
  )
  use unit <- decode.optional_field(
    "unit",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use type_ <- decode.field("type", codeableconcept_decoder())
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Devicemetric",
    decode.failure(devicemetric_new(category:, type_:), "resourceType"),
  )
  decode.success(Devicemetric(
    calibration:,
    measurement_period:,
    category:,
    color:,
    operational_status:,
    parent:,
    source:,
    unit:,
    type_:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/DeviceRequest#resource
pub type Devicerequest {
  Devicerequest(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    instantiates_canonical: List(String),
    instantiates_uri: List(String),
    based_on: List(Reference),
    prior_request: List(Reference),
    group_identifier: Option(Identifier),
    status: Option(r4bvaluesets.Requeststatus),
    intent: r4bvaluesets.Requestintent,
    priority: Option(r4bvaluesets.Requestpriority),
    code: DevicerequestCode,
    parameter: List(DevicerequestParameter),
    subject: Reference,
    encounter: Option(Reference),
    occurrence: Option(DevicerequestOccurrence),
    authored_on: Option(String),
    requester: Option(Reference),
    performer_type: Option(Codeableconcept),
    performer: Option(Reference),
    reason_code: List(Codeableconcept),
    reason_reference: List(Reference),
    insurance: List(Reference),
    supporting_info: List(Reference),
    note: List(Annotation),
    relevant_history: List(Reference),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/DeviceRequest#resource
pub type DevicerequestCode {
  DevicerequestCodeReference(code: Reference)
  DevicerequestCodeCodeableconcept(code: Codeableconcept)
}

pub fn devicerequest_code_to_json(elt: DevicerequestCode) -> Json {
  case elt {
    DevicerequestCodeReference(v) -> reference_to_json(v)
    DevicerequestCodeCodeableconcept(v) -> codeableconcept_to_json(v)
  }
}

pub fn devicerequest_code_decoder() -> Decoder(DevicerequestCode) {
  decode.one_of(
    decode.field("codeReference", reference_decoder(), decode.success)
      |> decode.map(DevicerequestCodeReference),
    [
      decode.field(
        "codeCodeableConcept",
        codeableconcept_decoder(),
        decode.success,
      )
      |> decode.map(DevicerequestCodeCodeableconcept),
    ],
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/DeviceRequest#resource
pub type DevicerequestOccurrence {
  DevicerequestOccurrenceDatetime(occurrence: String)
  DevicerequestOccurrencePeriod(occurrence: Period)
  DevicerequestOccurrenceTiming(occurrence: Timing)
}

pub fn devicerequest_occurrence_to_json(elt: DevicerequestOccurrence) -> Json {
  case elt {
    DevicerequestOccurrenceDatetime(v) -> json.string(v)
    DevicerequestOccurrencePeriod(v) -> period_to_json(v)
    DevicerequestOccurrenceTiming(v) -> timing_to_json(v)
  }
}

pub fn devicerequest_occurrence_decoder() -> Decoder(DevicerequestOccurrence) {
  decode.one_of(
    decode.field("occurrenceDateTime", decode.string, decode.success)
      |> decode.map(DevicerequestOccurrenceDatetime),
    [
      decode.field("occurrencePeriod", period_decoder(), decode.success)
        |> decode.map(DevicerequestOccurrencePeriod),
      decode.field("occurrenceTiming", timing_decoder(), decode.success)
        |> decode.map(DevicerequestOccurrenceTiming),
    ],
  )
}

pub fn devicerequest_new(
  subject subject: Reference,
  code code: DevicerequestCode,
  intent intent: r4bvaluesets.Requestintent,
) -> Devicerequest {
  Devicerequest(
    relevant_history: [],
    note: [],
    supporting_info: [],
    insurance: [],
    reason_reference: [],
    reason_code: [],
    performer: None,
    performer_type: None,
    requester: None,
    authored_on: None,
    occurrence: None,
    encounter: None,
    subject:,
    parameter: [],
    code:,
    priority: None,
    intent:,
    status: None,
    group_identifier: None,
    prior_request: [],
    based_on: [],
    instantiates_uri: [],
    instantiates_canonical: [],
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/DeviceRequest#resource
pub type DevicerequestParameter {
  DevicerequestParameter(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    code: Option(Codeableconcept),
    value: Option(DevicerequestParameterValue),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/DeviceRequest#resource
pub type DevicerequestParameterValue {
  DevicerequestParameterValueCodeableconcept(value: Codeableconcept)
  DevicerequestParameterValueQuantity(value: Quantity)
  DevicerequestParameterValueRange(value: Range)
  DevicerequestParameterValueBoolean(value: Bool)
}

pub fn devicerequest_parameter_value_to_json(
  elt: DevicerequestParameterValue,
) -> Json {
  case elt {
    DevicerequestParameterValueCodeableconcept(v) -> codeableconcept_to_json(v)
    DevicerequestParameterValueQuantity(v) -> quantity_to_json(v)
    DevicerequestParameterValueRange(v) -> range_to_json(v)
    DevicerequestParameterValueBoolean(v) -> json.bool(v)
  }
}

pub fn devicerequest_parameter_value_decoder() -> Decoder(
  DevicerequestParameterValue,
) {
  decode.one_of(
    decode.field(
      "valueCodeableConcept",
      codeableconcept_decoder(),
      decode.success,
    )
      |> decode.map(DevicerequestParameterValueCodeableconcept),
    [
      decode.field("valueQuantity", quantity_decoder(), decode.success)
        |> decode.map(DevicerequestParameterValueQuantity),
      decode.field("valueRange", range_decoder(), decode.success)
        |> decode.map(DevicerequestParameterValueRange),
      decode.field("valueBoolean", decode.bool, decode.success)
        |> decode.map(DevicerequestParameterValueBoolean),
    ],
  )
}

pub fn devicerequest_parameter_new() -> DevicerequestParameter {
  DevicerequestParameter(
    value: None,
    code: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn devicerequest_parameter_to_json(
  devicerequest_parameter: DevicerequestParameter,
) -> Json {
  let DevicerequestParameter(
    value:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ) = devicerequest_parameter
  let fields = []
  let fields = case value {
    Some(v) -> [
      #(
        "value"
          <> case v {
          DevicerequestParameterValueCodeableconcept(_) -> "Codeableconcept"
          DevicerequestParameterValueQuantity(_) -> "Quantity"
          DevicerequestParameterValueRange(_) -> "Range"
          DevicerequestParameterValueBoolean(_) -> "Boolean"
        },
        devicerequest_parameter_value_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case code {
    Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn devicerequest_parameter_decoder() -> Decoder(DevicerequestParameter) {
  use value <- decode.then(
    none_if_omitted(devicerequest_parameter_value_decoder()),
  )
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(DevicerequestParameter(
    value:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn devicerequest_to_json(devicerequest: Devicerequest) -> Json {
  let Devicerequest(
    relevant_history:,
    note:,
    supporting_info:,
    insurance:,
    reason_reference:,
    reason_code:,
    performer:,
    performer_type:,
    requester:,
    authored_on:,
    occurrence:,
    encounter:,
    subject:,
    parameter:,
    code:,
    priority:,
    intent:,
    status:,
    group_identifier:,
    prior_request:,
    based_on:,
    instantiates_uri:,
    instantiates_canonical:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = devicerequest
  let fields = [
    #("subject", reference_to_json(subject)),
    #("code", devicerequest_code_to_json(code)),
    #("intent", r4bvaluesets.requestintent_to_json(intent)),
  ]
  let fields = case relevant_history {
    [] -> fields
    _ -> [
      #("relevantHistory", json.array(relevant_history, reference_to_json)),
      ..fields
    ]
  }
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case supporting_info {
    [] -> fields
    _ -> [
      #("supportingInfo", json.array(supporting_info, reference_to_json)),
      ..fields
    ]
  }
  let fields = case insurance {
    [] -> fields
    _ -> [#("insurance", json.array(insurance, reference_to_json)), ..fields]
  }
  let fields = case reason_reference {
    [] -> fields
    _ -> [
      #("reasonReference", json.array(reason_reference, reference_to_json)),
      ..fields
    ]
  }
  let fields = case reason_code {
    [] -> fields
    _ -> [
      #("reasonCode", json.array(reason_code, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case performer {
    Some(v) -> [#("performer", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case performer_type {
    Some(v) -> [#("performerType", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case requester {
    Some(v) -> [#("requester", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case authored_on {
    Some(v) -> [#("authoredOn", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case occurrence {
    Some(v) -> [
      #(
        "occurrence"
          <> case v {
          DevicerequestOccurrenceDatetime(_) -> "Datetime"
          DevicerequestOccurrencePeriod(_) -> "Period"
          DevicerequestOccurrenceTiming(_) -> "Timing"
        },
        devicerequest_occurrence_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case encounter {
    Some(v) -> [#("encounter", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case parameter {
    [] -> fields
    _ -> [
      #("parameter", json.array(parameter, devicerequest_parameter_to_json)),
      ..fields
    ]
  }
  let fields = case priority {
    Some(v) -> [
      #("priority", r4bvaluesets.requestpriority_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case status {
    Some(v) -> [#("status", r4bvaluesets.requeststatus_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case group_identifier {
    Some(v) -> [#("groupIdentifier", identifier_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case prior_request {
    [] -> fields
    _ -> [
      #("priorRequest", json.array(prior_request, reference_to_json)),
      ..fields
    ]
  }
  let fields = case based_on {
    [] -> fields
    _ -> [#("basedOn", json.array(based_on, reference_to_json)), ..fields]
  }
  let fields = case instantiates_uri {
    [] -> fields
    _ -> [
      #("instantiatesUri", json.array(instantiates_uri, json.string)),
      ..fields
    ]
  }
  let fields = case instantiates_canonical {
    [] -> fields
    _ -> [
      #(
        "instantiatesCanonical",
        json.array(instantiates_canonical, json.string),
      ),
      ..fields
    ]
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Devicerequest")), ..fields]
  json.object(fields)
}

pub fn devicerequest_decoder() -> Decoder(Devicerequest) {
  use relevant_history <- decode.optional_field(
    "relevantHistory",
    [],
    decode.list(reference_decoder()),
  )
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use supporting_info <- decode.optional_field(
    "supportingInfo",
    [],
    decode.list(reference_decoder()),
  )
  use insurance <- decode.optional_field(
    "insurance",
    [],
    decode.list(reference_decoder()),
  )
  use reason_reference <- decode.optional_field(
    "reasonReference",
    [],
    decode.list(reference_decoder()),
  )
  use reason_code <- decode.optional_field(
    "reasonCode",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use performer <- decode.optional_field(
    "performer",
    None,
    decode.optional(reference_decoder()),
  )
  use performer_type <- decode.optional_field(
    "performerType",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use requester <- decode.optional_field(
    "requester",
    None,
    decode.optional(reference_decoder()),
  )
  use authored_on <- decode.optional_field(
    "authoredOn",
    None,
    decode.optional(decode.string),
  )
  use occurrence <- decode.then(
    none_if_omitted(devicerequest_occurrence_decoder()),
  )
  use encounter <- decode.optional_field(
    "encounter",
    None,
    decode.optional(reference_decoder()),
  )
  use subject <- decode.field("subject", reference_decoder())
  use parameter <- decode.optional_field(
    "parameter",
    [],
    decode.list(devicerequest_parameter_decoder()),
  )
  use code <- decode.then(devicerequest_code_decoder())
  use priority <- decode.optional_field(
    "priority",
    None,
    decode.optional(r4bvaluesets.requestpriority_decoder()),
  )
  use intent <- decode.field("intent", r4bvaluesets.requestintent_decoder())
  use status <- decode.optional_field(
    "status",
    None,
    decode.optional(r4bvaluesets.requeststatus_decoder()),
  )
  use group_identifier <- decode.optional_field(
    "groupIdentifier",
    None,
    decode.optional(identifier_decoder()),
  )
  use prior_request <- decode.optional_field(
    "priorRequest",
    [],
    decode.list(reference_decoder()),
  )
  use based_on <- decode.optional_field(
    "basedOn",
    [],
    decode.list(reference_decoder()),
  )
  use instantiates_uri <- decode.optional_field(
    "instantiatesUri",
    [],
    decode.list(decode.string),
  )
  use instantiates_canonical <- decode.optional_field(
    "instantiatesCanonical",
    [],
    decode.list(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Devicerequest",
    decode.failure(devicerequest_new(subject:, code:, intent:), "resourceType"),
  )
  decode.success(Devicerequest(
    relevant_history:,
    note:,
    supporting_info:,
    insurance:,
    reason_reference:,
    reason_code:,
    performer:,
    performer_type:,
    requester:,
    authored_on:,
    occurrence:,
    encounter:,
    subject:,
    parameter:,
    code:,
    priority:,
    intent:,
    status:,
    group_identifier:,
    prior_request:,
    based_on:,
    instantiates_uri:,
    instantiates_canonical:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/DeviceUseStatement#resource
pub type Deviceusestatement {
  Deviceusestatement(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    based_on: List(Reference),
    status: r4bvaluesets.Devicestatementstatus,
    subject: Reference,
    derived_from: List(Reference),
    timing: Option(DeviceusestatementTiming),
    recorded_on: Option(String),
    source: Option(Reference),
    device: Reference,
    reason_code: List(Codeableconcept),
    reason_reference: List(Reference),
    body_site: Option(Codeableconcept),
    note: List(Annotation),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/DeviceUseStatement#resource
pub type DeviceusestatementTiming {
  DeviceusestatementTimingTiming(timing: Timing)
  DeviceusestatementTimingPeriod(timing: Period)
  DeviceusestatementTimingDatetime(timing: String)
}

pub fn deviceusestatement_timing_to_json(elt: DeviceusestatementTiming) -> Json {
  case elt {
    DeviceusestatementTimingTiming(v) -> timing_to_json(v)
    DeviceusestatementTimingPeriod(v) -> period_to_json(v)
    DeviceusestatementTimingDatetime(v) -> json.string(v)
  }
}

pub fn deviceusestatement_timing_decoder() -> Decoder(DeviceusestatementTiming) {
  decode.one_of(
    decode.field("timingTiming", timing_decoder(), decode.success)
      |> decode.map(DeviceusestatementTimingTiming),
    [
      decode.field("timingPeriod", period_decoder(), decode.success)
        |> decode.map(DeviceusestatementTimingPeriod),
      decode.field("timingDateTime", decode.string, decode.success)
        |> decode.map(DeviceusestatementTimingDatetime),
    ],
  )
}

pub fn deviceusestatement_new(
  device device: Reference,
  subject subject: Reference,
  status status: r4bvaluesets.Devicestatementstatus,
) -> Deviceusestatement {
  Deviceusestatement(
    note: [],
    body_site: None,
    reason_reference: [],
    reason_code: [],
    device:,
    source: None,
    recorded_on: None,
    timing: None,
    derived_from: [],
    subject:,
    status:,
    based_on: [],
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

pub fn deviceusestatement_to_json(
  deviceusestatement: Deviceusestatement,
) -> Json {
  let Deviceusestatement(
    note:,
    body_site:,
    reason_reference:,
    reason_code:,
    device:,
    source:,
    recorded_on:,
    timing:,
    derived_from:,
    subject:,
    status:,
    based_on:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = deviceusestatement
  let fields = [
    #("device", reference_to_json(device)),
    #("subject", reference_to_json(subject)),
    #("status", r4bvaluesets.devicestatementstatus_to_json(status)),
  ]
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case body_site {
    Some(v) -> [#("bodySite", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case reason_reference {
    [] -> fields
    _ -> [
      #("reasonReference", json.array(reason_reference, reference_to_json)),
      ..fields
    ]
  }
  let fields = case reason_code {
    [] -> fields
    _ -> [
      #("reasonCode", json.array(reason_code, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case source {
    Some(v) -> [#("source", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case recorded_on {
    Some(v) -> [#("recordedOn", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case timing {
    Some(v) -> [
      #(
        "timing"
          <> case v {
          DeviceusestatementTimingTiming(_) -> "Timing"
          DeviceusestatementTimingPeriod(_) -> "Period"
          DeviceusestatementTimingDatetime(_) -> "Datetime"
        },
        deviceusestatement_timing_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case derived_from {
    [] -> fields
    _ -> [
      #("derivedFrom", json.array(derived_from, reference_to_json)),
      ..fields
    ]
  }
  let fields = case based_on {
    [] -> fields
    _ -> [#("basedOn", json.array(based_on, reference_to_json)), ..fields]
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Deviceusestatement")), ..fields]
  json.object(fields)
}

pub fn deviceusestatement_decoder() -> Decoder(Deviceusestatement) {
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use body_site <- decode.optional_field(
    "bodySite",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use reason_reference <- decode.optional_field(
    "reasonReference",
    [],
    decode.list(reference_decoder()),
  )
  use reason_code <- decode.optional_field(
    "reasonCode",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use device <- decode.field("device", reference_decoder())
  use source <- decode.optional_field(
    "source",
    None,
    decode.optional(reference_decoder()),
  )
  use recorded_on <- decode.optional_field(
    "recordedOn",
    None,
    decode.optional(decode.string),
  )
  use timing <- decode.then(
    none_if_omitted(deviceusestatement_timing_decoder()),
  )
  use derived_from <- decode.optional_field(
    "derivedFrom",
    [],
    decode.list(reference_decoder()),
  )
  use subject <- decode.field("subject", reference_decoder())
  use status <- decode.field(
    "status",
    r4bvaluesets.devicestatementstatus_decoder(),
  )
  use based_on <- decode.optional_field(
    "basedOn",
    [],
    decode.list(reference_decoder()),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Deviceusestatement",
    decode.failure(
      deviceusestatement_new(device:, subject:, status:),
      "resourceType",
    ),
  )
  decode.success(Deviceusestatement(
    note:,
    body_site:,
    reason_reference:,
    reason_code:,
    device:,
    source:,
    recorded_on:,
    timing:,
    derived_from:,
    subject:,
    status:,
    based_on:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/DiagnosticReport#resource
pub type Diagnosticreport {
  Diagnosticreport(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    based_on: List(Reference),
    status: r4bvaluesets.Diagnosticreportstatus,
    category: List(Codeableconcept),
    code: Codeableconcept,
    subject: Option(Reference),
    encounter: Option(Reference),
    effective: Option(DiagnosticreportEffective),
    issued: Option(String),
    performer: List(Reference),
    results_interpreter: List(Reference),
    specimen: List(Reference),
    result: List(Reference),
    imaging_study: List(Reference),
    media: List(DiagnosticreportMedia),
    conclusion: Option(String),
    conclusion_code: List(Codeableconcept),
    presented_form: List(Attachment),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/DiagnosticReport#resource
pub type DiagnosticreportEffective {
  DiagnosticreportEffectiveDatetime(effective: String)
  DiagnosticreportEffectivePeriod(effective: Period)
}

pub fn diagnosticreport_effective_to_json(
  elt: DiagnosticreportEffective,
) -> Json {
  case elt {
    DiagnosticreportEffectiveDatetime(v) -> json.string(v)
    DiagnosticreportEffectivePeriod(v) -> period_to_json(v)
  }
}

pub fn diagnosticreport_effective_decoder() -> Decoder(
  DiagnosticreportEffective,
) {
  decode.one_of(
    decode.field("effectiveDateTime", decode.string, decode.success)
      |> decode.map(DiagnosticreportEffectiveDatetime),
    [
      decode.field("effectivePeriod", period_decoder(), decode.success)
      |> decode.map(DiagnosticreportEffectivePeriod),
    ],
  )
}

pub fn diagnosticreport_new(
  code code: Codeableconcept,
  status status: r4bvaluesets.Diagnosticreportstatus,
) -> Diagnosticreport {
  Diagnosticreport(
    presented_form: [],
    conclusion_code: [],
    conclusion: None,
    media: [],
    imaging_study: [],
    result: [],
    specimen: [],
    results_interpreter: [],
    performer: [],
    issued: None,
    effective: None,
    encounter: None,
    subject: None,
    code:,
    category: [],
    status:,
    based_on: [],
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/DiagnosticReport#resource
pub type DiagnosticreportMedia {
  DiagnosticreportMedia(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    comment: Option(String),
    link: Reference,
  )
}

pub fn diagnosticreport_media_new(link link: Reference) -> DiagnosticreportMedia {
  DiagnosticreportMedia(
    link:,
    comment: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn diagnosticreport_media_to_json(
  diagnosticreport_media: DiagnosticreportMedia,
) -> Json {
  let DiagnosticreportMedia(
    link:,
    comment:,
    modifier_extension:,
    extension:,
    id:,
  ) = diagnosticreport_media
  let fields = [
    #("link", reference_to_json(link)),
  ]
  let fields = case comment {
    Some(v) -> [#("comment", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn diagnosticreport_media_decoder() -> Decoder(DiagnosticreportMedia) {
  use link <- decode.field("link", reference_decoder())
  use comment <- decode.optional_field(
    "comment",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(DiagnosticreportMedia(
    link:,
    comment:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn diagnosticreport_to_json(diagnosticreport: Diagnosticreport) -> Json {
  let Diagnosticreport(
    presented_form:,
    conclusion_code:,
    conclusion:,
    media:,
    imaging_study:,
    result:,
    specimen:,
    results_interpreter:,
    performer:,
    issued:,
    effective:,
    encounter:,
    subject:,
    code:,
    category:,
    status:,
    based_on:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = diagnosticreport
  let fields = [
    #("code", codeableconcept_to_json(code)),
    #("status", r4bvaluesets.diagnosticreportstatus_to_json(status)),
  ]
  let fields = case presented_form {
    [] -> fields
    _ -> [
      #("presentedForm", json.array(presented_form, attachment_to_json)),
      ..fields
    ]
  }
  let fields = case conclusion_code {
    [] -> fields
    _ -> [
      #("conclusionCode", json.array(conclusion_code, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case conclusion {
    Some(v) -> [#("conclusion", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case media {
    [] -> fields
    _ -> [
      #("media", json.array(media, diagnosticreport_media_to_json)),
      ..fields
    ]
  }
  let fields = case imaging_study {
    [] -> fields
    _ -> [
      #("imagingStudy", json.array(imaging_study, reference_to_json)),
      ..fields
    ]
  }
  let fields = case result {
    [] -> fields
    _ -> [#("result", json.array(result, reference_to_json)), ..fields]
  }
  let fields = case specimen {
    [] -> fields
    _ -> [#("specimen", json.array(specimen, reference_to_json)), ..fields]
  }
  let fields = case results_interpreter {
    [] -> fields
    _ -> [
      #(
        "resultsInterpreter",
        json.array(results_interpreter, reference_to_json),
      ),
      ..fields
    ]
  }
  let fields = case performer {
    [] -> fields
    _ -> [#("performer", json.array(performer, reference_to_json)), ..fields]
  }
  let fields = case issued {
    Some(v) -> [#("issued", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case effective {
    Some(v) -> [
      #(
        "effective"
          <> case v {
          DiagnosticreportEffectiveDatetime(_) -> "Datetime"
          DiagnosticreportEffectivePeriod(_) -> "Period"
        },
        diagnosticreport_effective_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case encounter {
    Some(v) -> [#("encounter", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case subject {
    Some(v) -> [#("subject", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case category {
    [] -> fields
    _ -> [
      #("category", json.array(category, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case based_on {
    [] -> fields
    _ -> [#("basedOn", json.array(based_on, reference_to_json)), ..fields]
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Diagnosticreport")), ..fields]
  json.object(fields)
}

pub fn diagnosticreport_decoder() -> Decoder(Diagnosticreport) {
  use presented_form <- decode.optional_field(
    "presentedForm",
    [],
    decode.list(attachment_decoder()),
  )
  use conclusion_code <- decode.optional_field(
    "conclusionCode",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use conclusion <- decode.optional_field(
    "conclusion",
    None,
    decode.optional(decode.string),
  )
  use media <- decode.optional_field(
    "media",
    [],
    decode.list(diagnosticreport_media_decoder()),
  )
  use imaging_study <- decode.optional_field(
    "imagingStudy",
    [],
    decode.list(reference_decoder()),
  )
  use result <- decode.optional_field(
    "result",
    [],
    decode.list(reference_decoder()),
  )
  use specimen <- decode.optional_field(
    "specimen",
    [],
    decode.list(reference_decoder()),
  )
  use results_interpreter <- decode.optional_field(
    "resultsInterpreter",
    [],
    decode.list(reference_decoder()),
  )
  use performer <- decode.optional_field(
    "performer",
    [],
    decode.list(reference_decoder()),
  )
  use issued <- decode.optional_field(
    "issued",
    None,
    decode.optional(decode.string),
  )
  use effective <- decode.then(
    none_if_omitted(diagnosticreport_effective_decoder()),
  )
  use encounter <- decode.optional_field(
    "encounter",
    None,
    decode.optional(reference_decoder()),
  )
  use subject <- decode.optional_field(
    "subject",
    None,
    decode.optional(reference_decoder()),
  )
  use code <- decode.field("code", codeableconcept_decoder())
  use category <- decode.optional_field(
    "category",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use status <- decode.field(
    "status",
    r4bvaluesets.diagnosticreportstatus_decoder(),
  )
  use based_on <- decode.optional_field(
    "basedOn",
    [],
    decode.list(reference_decoder()),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Diagnosticreport",
    decode.failure(diagnosticreport_new(code:, status:), "resourceType"),
  )
  decode.success(Diagnosticreport(
    presented_form:,
    conclusion_code:,
    conclusion:,
    media:,
    imaging_study:,
    result:,
    specimen:,
    results_interpreter:,
    performer:,
    issued:,
    effective:,
    encounter:,
    subject:,
    code:,
    category:,
    status:,
    based_on:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/DocumentManifest#resource
pub type Documentmanifest {
  Documentmanifest(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    master_identifier: Option(Identifier),
    identifier: List(Identifier),
    status: r4bvaluesets.Documentreferencestatus,
    type_: Option(Codeableconcept),
    subject: Option(Reference),
    created: Option(String),
    author: List(Reference),
    recipient: List(Reference),
    source: Option(String),
    description: Option(String),
    content: List(Reference),
    related: List(DocumentmanifestRelated),
  )
}

pub fn documentmanifest_new(
  status status: r4bvaluesets.Documentreferencestatus,
) -> Documentmanifest {
  Documentmanifest(
    related: [],
    content: [],
    description: None,
    source: None,
    recipient: [],
    author: [],
    created: None,
    subject: None,
    type_: None,
    status:,
    identifier: [],
    master_identifier: None,
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/DocumentManifest#resource
pub type DocumentmanifestRelated {
  DocumentmanifestRelated(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: Option(Identifier),
    ref: Option(Reference),
  )
}

pub fn documentmanifest_related_new() -> DocumentmanifestRelated {
  DocumentmanifestRelated(
    ref: None,
    identifier: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn documentmanifest_related_to_json(
  documentmanifest_related: DocumentmanifestRelated,
) -> Json {
  let DocumentmanifestRelated(
    ref:,
    identifier:,
    modifier_extension:,
    extension:,
    id:,
  ) = documentmanifest_related
  let fields = []
  let fields = case ref {
    Some(v) -> [#("ref", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    Some(v) -> [#("identifier", identifier_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn documentmanifest_related_decoder() -> Decoder(DocumentmanifestRelated) {
  use ref <- decode.optional_field(
    "ref",
    None,
    decode.optional(reference_decoder()),
  )
  use identifier <- decode.optional_field(
    "identifier",
    None,
    decode.optional(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(DocumentmanifestRelated(
    ref:,
    identifier:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn documentmanifest_to_json(documentmanifest: Documentmanifest) -> Json {
  let Documentmanifest(
    related:,
    content:,
    description:,
    source:,
    recipient:,
    author:,
    created:,
    subject:,
    type_:,
    status:,
    identifier:,
    master_identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = documentmanifest
  let fields = [
    #("status", r4bvaluesets.documentreferencestatus_to_json(status)),
  ]
  let fields = case related {
    [] -> fields
    _ -> [
      #("related", json.array(related, documentmanifest_related_to_json)),
      ..fields
    ]
  }
  let fields = case content {
    [] -> fields
    _ -> [#("content", json.array(content, reference_to_json)), ..fields]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case source {
    Some(v) -> [#("source", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case recipient {
    [] -> fields
    _ -> [#("recipient", json.array(recipient, reference_to_json)), ..fields]
  }
  let fields = case author {
    [] -> fields
    _ -> [#("author", json.array(author, reference_to_json)), ..fields]
  }
  let fields = case created {
    Some(v) -> [#("created", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case subject {
    Some(v) -> [#("subject", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case master_identifier {
    Some(v) -> [#("masterIdentifier", identifier_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Documentmanifest")), ..fields]
  json.object(fields)
}

pub fn documentmanifest_decoder() -> Decoder(Documentmanifest) {
  use related <- decode.optional_field(
    "related",
    [],
    decode.list(documentmanifest_related_decoder()),
  )
  use content <- decode.optional_field(
    "content",
    [],
    decode.list(reference_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use source <- decode.optional_field(
    "source",
    None,
    decode.optional(decode.string),
  )
  use recipient <- decode.optional_field(
    "recipient",
    [],
    decode.list(reference_decoder()),
  )
  use author <- decode.optional_field(
    "author",
    [],
    decode.list(reference_decoder()),
  )
  use created <- decode.optional_field(
    "created",
    None,
    decode.optional(decode.string),
  )
  use subject <- decode.optional_field(
    "subject",
    None,
    decode.optional(reference_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use status <- decode.field(
    "status",
    r4bvaluesets.documentreferencestatus_decoder(),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use master_identifier <- decode.optional_field(
    "masterIdentifier",
    None,
    decode.optional(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Documentmanifest",
    decode.failure(documentmanifest_new(status:), "resourceType"),
  )
  decode.success(Documentmanifest(
    related:,
    content:,
    description:,
    source:,
    recipient:,
    author:,
    created:,
    subject:,
    type_:,
    status:,
    identifier:,
    master_identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/DocumentReference#resource
pub type Documentreference {
  Documentreference(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    master_identifier: Option(Identifier),
    identifier: List(Identifier),
    status: r4bvaluesets.Documentreferencestatus,
    doc_status: Option(r4bvaluesets.Compositionstatus),
    type_: Option(Codeableconcept),
    category: List(Codeableconcept),
    subject: Option(Reference),
    date: Option(String),
    author: List(Reference),
    authenticator: Option(Reference),
    custodian: Option(Reference),
    relates_to: List(DocumentreferenceRelatesto),
    description: Option(String),
    security_label: List(Codeableconcept),
    content: List(DocumentreferenceContent),
    context: Option(DocumentreferenceContext),
  )
}

pub fn documentreference_new(
  status status: r4bvaluesets.Documentreferencestatus,
) -> Documentreference {
  Documentreference(
    context: None,
    content: [],
    security_label: [],
    description: None,
    relates_to: [],
    custodian: None,
    authenticator: None,
    author: [],
    date: None,
    subject: None,
    category: [],
    type_: None,
    doc_status: None,
    status:,
    identifier: [],
    master_identifier: None,
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/DocumentReference#resource
pub type DocumentreferenceRelatesto {
  DocumentreferenceRelatesto(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    code: r4bvaluesets.Documentrelationshiptype,
    target: Reference,
  )
}

pub fn documentreference_relatesto_new(
  target target: Reference,
  code code: r4bvaluesets.Documentrelationshiptype,
) -> DocumentreferenceRelatesto {
  DocumentreferenceRelatesto(
    target:,
    code:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/DocumentReference#resource
pub type DocumentreferenceContent {
  DocumentreferenceContent(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    attachment: Attachment,
    format: Option(Coding),
  )
}

pub fn documentreference_content_new(
  attachment attachment: Attachment,
) -> DocumentreferenceContent {
  DocumentreferenceContent(
    format: None,
    attachment:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/DocumentReference#resource
pub type DocumentreferenceContext {
  DocumentreferenceContext(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    encounter: List(Reference),
    event: List(Codeableconcept),
    period: Option(Period),
    facility_type: Option(Codeableconcept),
    practice_setting: Option(Codeableconcept),
    source_patient_info: Option(Reference),
    related: List(Reference),
  )
}

pub fn documentreference_context_new() -> DocumentreferenceContext {
  DocumentreferenceContext(
    related: [],
    source_patient_info: None,
    practice_setting: None,
    facility_type: None,
    period: None,
    event: [],
    encounter: [],
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn documentreference_context_to_json(
  documentreference_context: DocumentreferenceContext,
) -> Json {
  let DocumentreferenceContext(
    related:,
    source_patient_info:,
    practice_setting:,
    facility_type:,
    period:,
    event:,
    encounter:,
    modifier_extension:,
    extension:,
    id:,
  ) = documentreference_context
  let fields = []
  let fields = case related {
    [] -> fields
    _ -> [#("related", json.array(related, reference_to_json)), ..fields]
  }
  let fields = case source_patient_info {
    Some(v) -> [#("sourcePatientInfo", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case practice_setting {
    Some(v) -> [#("practiceSetting", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case facility_type {
    Some(v) -> [#("facilityType", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case period {
    Some(v) -> [#("period", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case event {
    [] -> fields
    _ -> [#("event", json.array(event, codeableconcept_to_json)), ..fields]
  }
  let fields = case encounter {
    [] -> fields
    _ -> [#("encounter", json.array(encounter, reference_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn documentreference_context_decoder() -> Decoder(DocumentreferenceContext) {
  use related <- decode.optional_field(
    "related",
    [],
    decode.list(reference_decoder()),
  )
  use source_patient_info <- decode.optional_field(
    "sourcePatientInfo",
    None,
    decode.optional(reference_decoder()),
  )
  use practice_setting <- decode.optional_field(
    "practiceSetting",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use facility_type <- decode.optional_field(
    "facilityType",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use period <- decode.optional_field(
    "period",
    None,
    decode.optional(period_decoder()),
  )
  use event <- decode.optional_field(
    "event",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use encounter <- decode.optional_field(
    "encounter",
    [],
    decode.list(reference_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(DocumentreferenceContext(
    related:,
    source_patient_info:,
    practice_setting:,
    facility_type:,
    period:,
    event:,
    encounter:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn documentreference_content_to_json(
  documentreference_content: DocumentreferenceContent,
) -> Json {
  let DocumentreferenceContent(
    format:,
    attachment:,
    modifier_extension:,
    extension:,
    id:,
  ) = documentreference_content
  let fields = [
    #("attachment", attachment_to_json(attachment)),
  ]
  let fields = case format {
    Some(v) -> [#("format", coding_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn documentreference_content_decoder() -> Decoder(DocumentreferenceContent) {
  use format <- decode.optional_field(
    "format",
    None,
    decode.optional(coding_decoder()),
  )
  use attachment <- decode.field("attachment", attachment_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(DocumentreferenceContent(
    format:,
    attachment:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn documentreference_relatesto_to_json(
  documentreference_relatesto: DocumentreferenceRelatesto,
) -> Json {
  let DocumentreferenceRelatesto(
    target:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ) = documentreference_relatesto
  let fields = [
    #("target", reference_to_json(target)),
    #("code", r4bvaluesets.documentrelationshiptype_to_json(code)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn documentreference_relatesto_decoder() -> Decoder(
  DocumentreferenceRelatesto,
) {
  use target <- decode.field("target", reference_decoder())
  use code <- decode.field(
    "code",
    r4bvaluesets.documentrelationshiptype_decoder(),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(DocumentreferenceRelatesto(
    target:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn documentreference_to_json(documentreference: Documentreference) -> Json {
  let Documentreference(
    context:,
    content:,
    security_label:,
    description:,
    relates_to:,
    custodian:,
    authenticator:,
    author:,
    date:,
    subject:,
    category:,
    type_:,
    doc_status:,
    status:,
    identifier:,
    master_identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = documentreference
  let fields = [
    #("status", r4bvaluesets.documentreferencestatus_to_json(status)),
  ]
  let fields = case context {
    Some(v) -> [#("context", documentreference_context_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case content {
    [] -> fields
    _ -> [
      #("content", json.array(content, documentreference_content_to_json)),
      ..fields
    ]
  }
  let fields = case security_label {
    [] -> fields
    _ -> [
      #("securityLabel", json.array(security_label, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case relates_to {
    [] -> fields
    _ -> [
      #(
        "relatesTo",
        json.array(relates_to, documentreference_relatesto_to_json),
      ),
      ..fields
    ]
  }
  let fields = case custodian {
    Some(v) -> [#("custodian", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case authenticator {
    Some(v) -> [#("authenticator", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case author {
    [] -> fields
    _ -> [#("author", json.array(author, reference_to_json)), ..fields]
  }
  let fields = case date {
    Some(v) -> [#("date", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case subject {
    Some(v) -> [#("subject", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case category {
    [] -> fields
    _ -> [
      #("category", json.array(category, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case doc_status {
    Some(v) -> [
      #("docStatus", r4bvaluesets.compositionstatus_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case master_identifier {
    Some(v) -> [#("masterIdentifier", identifier_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Documentreference")), ..fields]
  json.object(fields)
}

pub fn documentreference_decoder() -> Decoder(Documentreference) {
  use context <- decode.optional_field(
    "context",
    None,
    decode.optional(documentreference_context_decoder()),
  )
  use content <- decode.optional_field(
    "content",
    [],
    decode.list(documentreference_content_decoder()),
  )
  use security_label <- decode.optional_field(
    "securityLabel",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use relates_to <- decode.optional_field(
    "relatesTo",
    [],
    decode.list(documentreference_relatesto_decoder()),
  )
  use custodian <- decode.optional_field(
    "custodian",
    None,
    decode.optional(reference_decoder()),
  )
  use authenticator <- decode.optional_field(
    "authenticator",
    None,
    decode.optional(reference_decoder()),
  )
  use author <- decode.optional_field(
    "author",
    [],
    decode.list(reference_decoder()),
  )
  use date <- decode.optional_field(
    "date",
    None,
    decode.optional(decode.string),
  )
  use subject <- decode.optional_field(
    "subject",
    None,
    decode.optional(reference_decoder()),
  )
  use category <- decode.optional_field(
    "category",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use doc_status <- decode.optional_field(
    "docStatus",
    None,
    decode.optional(r4bvaluesets.compositionstatus_decoder()),
  )
  use status <- decode.field(
    "status",
    r4bvaluesets.documentreferencestatus_decoder(),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use master_identifier <- decode.optional_field(
    "masterIdentifier",
    None,
    decode.optional(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Documentreference",
    decode.failure(documentreference_new(status:), "resourceType"),
  )
  decode.success(Documentreference(
    context:,
    content:,
    security_label:,
    description:,
    relates_to:,
    custodian:,
    authenticator:,
    author:,
    date:,
    subject:,
    category:,
    type_:,
    doc_status:,
    status:,
    identifier:,
    master_identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/DomainResource#resource
pub type Domainresource {
  Domainresource(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
  )
}

pub fn domainresource_new() -> Domainresource {
  Domainresource(
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

pub fn domainresource_to_json(domainresource: Domainresource) -> Json {
  let Domainresource(
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = domainresource
  let fields = []
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Domainresource")), ..fields]
  json.object(fields)
}

pub fn domainresource_decoder() -> Decoder(Domainresource) {
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Domainresource",
    decode.failure(domainresource_new(), "resourceType"),
  )
  decode.success(Domainresource(
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/Encounter#resource
pub type Encounter {
  Encounter(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    status: r4bvaluesets.Encounterstatus,
    status_history: List(EncounterStatushistory),
    class: Coding,
    class_history: List(EncounterClasshistory),
    type_: List(Codeableconcept),
    service_type: Option(Codeableconcept),
    priority: Option(Codeableconcept),
    subject: Option(Reference),
    episode_of_care: List(Reference),
    based_on: List(Reference),
    participant: List(EncounterParticipant),
    appointment: List(Reference),
    period: Option(Period),
    length: Option(Duration),
    reason_code: List(Codeableconcept),
    reason_reference: List(Reference),
    diagnosis: List(EncounterDiagnosis),
    account: List(Reference),
    hospitalization: Option(EncounterHospitalization),
    location: List(EncounterLocation),
    service_provider: Option(Reference),
    part_of: Option(Reference),
  )
}

pub fn encounter_new(
  class class: Coding,
  status status: r4bvaluesets.Encounterstatus,
) -> Encounter {
  Encounter(
    part_of: None,
    service_provider: None,
    location: [],
    hospitalization: None,
    account: [],
    diagnosis: [],
    reason_reference: [],
    reason_code: [],
    length: None,
    period: None,
    appointment: [],
    participant: [],
    based_on: [],
    episode_of_care: [],
    subject: None,
    priority: None,
    service_type: None,
    type_: [],
    class_history: [],
    class:,
    status_history: [],
    status:,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Encounter#resource
pub type EncounterStatushistory {
  EncounterStatushistory(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    status: r4bvaluesets.Encounterstatus,
    period: Period,
  )
}

pub fn encounter_statushistory_new(
  period period: Period,
  status status: r4bvaluesets.Encounterstatus,
) -> EncounterStatushistory {
  EncounterStatushistory(
    period:,
    status:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Encounter#resource
pub type EncounterClasshistory {
  EncounterClasshistory(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    class: Coding,
    period: Period,
  )
}

pub fn encounter_classhistory_new(
  period period: Period,
  class class: Coding,
) -> EncounterClasshistory {
  EncounterClasshistory(
    period:,
    class:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Encounter#resource
pub type EncounterParticipant {
  EncounterParticipant(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: List(Codeableconcept),
    period: Option(Period),
    individual: Option(Reference),
  )
}

pub fn encounter_participant_new() -> EncounterParticipant {
  EncounterParticipant(
    individual: None,
    period: None,
    type_: [],
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Encounter#resource
pub type EncounterDiagnosis {
  EncounterDiagnosis(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    condition: Reference,
    use_: Option(Codeableconcept),
    rank: Option(Int),
  )
}

pub fn encounter_diagnosis_new(
  condition condition: Reference,
) -> EncounterDiagnosis {
  EncounterDiagnosis(
    rank: None,
    use_: None,
    condition:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Encounter#resource
pub type EncounterHospitalization {
  EncounterHospitalization(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    pre_admission_identifier: Option(Identifier),
    origin: Option(Reference),
    admit_source: Option(Codeableconcept),
    re_admission: Option(Codeableconcept),
    diet_preference: List(Codeableconcept),
    special_courtesy: List(Codeableconcept),
    special_arrangement: List(Codeableconcept),
    destination: Option(Reference),
    discharge_disposition: Option(Codeableconcept),
  )
}

pub fn encounter_hospitalization_new() -> EncounterHospitalization {
  EncounterHospitalization(
    discharge_disposition: None,
    destination: None,
    special_arrangement: [],
    special_courtesy: [],
    diet_preference: [],
    re_admission: None,
    admit_source: None,
    origin: None,
    pre_admission_identifier: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Encounter#resource
pub type EncounterLocation {
  EncounterLocation(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    location: Reference,
    status: Option(r4bvaluesets.Encounterlocationstatus),
    physical_type: Option(Codeableconcept),
    period: Option(Period),
  )
}

pub fn encounter_location_new(location location: Reference) -> EncounterLocation {
  EncounterLocation(
    period: None,
    physical_type: None,
    status: None,
    location:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn encounter_location_to_json(encounter_location: EncounterLocation) -> Json {
  let EncounterLocation(
    period:,
    physical_type:,
    status:,
    location:,
    modifier_extension:,
    extension:,
    id:,
  ) = encounter_location
  let fields = [
    #("location", reference_to_json(location)),
  ]
  let fields = case period {
    Some(v) -> [#("period", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case physical_type {
    Some(v) -> [#("physicalType", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case status {
    Some(v) -> [
      #("status", r4bvaluesets.encounterlocationstatus_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn encounter_location_decoder() -> Decoder(EncounterLocation) {
  use period <- decode.optional_field(
    "period",
    None,
    decode.optional(period_decoder()),
  )
  use physical_type <- decode.optional_field(
    "physicalType",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use status <- decode.optional_field(
    "status",
    None,
    decode.optional(r4bvaluesets.encounterlocationstatus_decoder()),
  )
  use location <- decode.field("location", reference_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(EncounterLocation(
    period:,
    physical_type:,
    status:,
    location:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn encounter_hospitalization_to_json(
  encounter_hospitalization: EncounterHospitalization,
) -> Json {
  let EncounterHospitalization(
    discharge_disposition:,
    destination:,
    special_arrangement:,
    special_courtesy:,
    diet_preference:,
    re_admission:,
    admit_source:,
    origin:,
    pre_admission_identifier:,
    modifier_extension:,
    extension:,
    id:,
  ) = encounter_hospitalization
  let fields = []
  let fields = case discharge_disposition {
    Some(v) -> [#("dischargeDisposition", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case destination {
    Some(v) -> [#("destination", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case special_arrangement {
    [] -> fields
    _ -> [
      #(
        "specialArrangement",
        json.array(special_arrangement, codeableconcept_to_json),
      ),
      ..fields
    ]
  }
  let fields = case special_courtesy {
    [] -> fields
    _ -> [
      #(
        "specialCourtesy",
        json.array(special_courtesy, codeableconcept_to_json),
      ),
      ..fields
    ]
  }
  let fields = case diet_preference {
    [] -> fields
    _ -> [
      #("dietPreference", json.array(diet_preference, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case re_admission {
    Some(v) -> [#("reAdmission", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case admit_source {
    Some(v) -> [#("admitSource", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case origin {
    Some(v) -> [#("origin", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case pre_admission_identifier {
    Some(v) -> [#("preAdmissionIdentifier", identifier_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn encounter_hospitalization_decoder() -> Decoder(EncounterHospitalization) {
  use discharge_disposition <- decode.optional_field(
    "dischargeDisposition",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use destination <- decode.optional_field(
    "destination",
    None,
    decode.optional(reference_decoder()),
  )
  use special_arrangement <- decode.optional_field(
    "specialArrangement",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use special_courtesy <- decode.optional_field(
    "specialCourtesy",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use diet_preference <- decode.optional_field(
    "dietPreference",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use re_admission <- decode.optional_field(
    "reAdmission",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use admit_source <- decode.optional_field(
    "admitSource",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use origin <- decode.optional_field(
    "origin",
    None,
    decode.optional(reference_decoder()),
  )
  use pre_admission_identifier <- decode.optional_field(
    "preAdmissionIdentifier",
    None,
    decode.optional(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(EncounterHospitalization(
    discharge_disposition:,
    destination:,
    special_arrangement:,
    special_courtesy:,
    diet_preference:,
    re_admission:,
    admit_source:,
    origin:,
    pre_admission_identifier:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn encounter_diagnosis_to_json(
  encounter_diagnosis: EncounterDiagnosis,
) -> Json {
  let EncounterDiagnosis(
    rank:,
    use_:,
    condition:,
    modifier_extension:,
    extension:,
    id:,
  ) = encounter_diagnosis
  let fields = [
    #("condition", reference_to_json(condition)),
  ]
  let fields = case rank {
    Some(v) -> [#("rank", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case use_ {
    Some(v) -> [#("use", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn encounter_diagnosis_decoder() -> Decoder(EncounterDiagnosis) {
  use rank <- decode.optional_field("rank", None, decode.optional(decode.int))
  use use_ <- decode.optional_field(
    "use",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use condition <- decode.field("condition", reference_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(EncounterDiagnosis(
    rank:,
    use_:,
    condition:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn encounter_participant_to_json(
  encounter_participant: EncounterParticipant,
) -> Json {
  let EncounterParticipant(
    individual:,
    period:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = encounter_participant
  let fields = []
  let fields = case individual {
    Some(v) -> [#("individual", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case period {
    Some(v) -> [#("period", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    [] -> fields
    _ -> [#("type", json.array(type_, codeableconcept_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn encounter_participant_decoder() -> Decoder(EncounterParticipant) {
  use individual <- decode.optional_field(
    "individual",
    None,
    decode.optional(reference_decoder()),
  )
  use period <- decode.optional_field(
    "period",
    None,
    decode.optional(period_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(EncounterParticipant(
    individual:,
    period:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn encounter_classhistory_to_json(
  encounter_classhistory: EncounterClasshistory,
) -> Json {
  let EncounterClasshistory(
    period:,
    class:,
    modifier_extension:,
    extension:,
    id:,
  ) = encounter_classhistory
  let fields = [
    #("period", period_to_json(period)),
    #("class", coding_to_json(class)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn encounter_classhistory_decoder() -> Decoder(EncounterClasshistory) {
  use period <- decode.field("period", period_decoder())
  use class <- decode.field("class", coding_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(EncounterClasshistory(
    period:,
    class:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn encounter_statushistory_to_json(
  encounter_statushistory: EncounterStatushistory,
) -> Json {
  let EncounterStatushistory(
    period:,
    status:,
    modifier_extension:,
    extension:,
    id:,
  ) = encounter_statushistory
  let fields = [
    #("period", period_to_json(period)),
    #("status", r4bvaluesets.encounterstatus_to_json(status)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn encounter_statushistory_decoder() -> Decoder(EncounterStatushistory) {
  use period <- decode.field("period", period_decoder())
  use status <- decode.field("status", r4bvaluesets.encounterstatus_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(EncounterStatushistory(
    period:,
    status:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn encounter_to_json(encounter: Encounter) -> Json {
  let Encounter(
    part_of:,
    service_provider:,
    location:,
    hospitalization:,
    account:,
    diagnosis:,
    reason_reference:,
    reason_code:,
    length:,
    period:,
    appointment:,
    participant:,
    based_on:,
    episode_of_care:,
    subject:,
    priority:,
    service_type:,
    type_:,
    class_history:,
    class:,
    status_history:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = encounter
  let fields = [
    #("class", coding_to_json(class)),
    #("status", r4bvaluesets.encounterstatus_to_json(status)),
  ]
  let fields = case part_of {
    Some(v) -> [#("partOf", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case service_provider {
    Some(v) -> [#("serviceProvider", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case location {
    [] -> fields
    _ -> [
      #("location", json.array(location, encounter_location_to_json)),
      ..fields
    ]
  }
  let fields = case hospitalization {
    Some(v) -> [
      #("hospitalization", encounter_hospitalization_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case account {
    [] -> fields
    _ -> [#("account", json.array(account, reference_to_json)), ..fields]
  }
  let fields = case diagnosis {
    [] -> fields
    _ -> [
      #("diagnosis", json.array(diagnosis, encounter_diagnosis_to_json)),
      ..fields
    ]
  }
  let fields = case reason_reference {
    [] -> fields
    _ -> [
      #("reasonReference", json.array(reason_reference, reference_to_json)),
      ..fields
    ]
  }
  let fields = case reason_code {
    [] -> fields
    _ -> [
      #("reasonCode", json.array(reason_code, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case length {
    Some(v) -> [#("length", duration_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case period {
    Some(v) -> [#("period", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case appointment {
    [] -> fields
    _ -> [
      #("appointment", json.array(appointment, reference_to_json)),
      ..fields
    ]
  }
  let fields = case participant {
    [] -> fields
    _ -> [
      #("participant", json.array(participant, encounter_participant_to_json)),
      ..fields
    ]
  }
  let fields = case based_on {
    [] -> fields
    _ -> [#("basedOn", json.array(based_on, reference_to_json)), ..fields]
  }
  let fields = case episode_of_care {
    [] -> fields
    _ -> [
      #("episodeOfCare", json.array(episode_of_care, reference_to_json)),
      ..fields
    ]
  }
  let fields = case subject {
    Some(v) -> [#("subject", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case priority {
    Some(v) -> [#("priority", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case service_type {
    Some(v) -> [#("serviceType", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    [] -> fields
    _ -> [#("type", json.array(type_, codeableconcept_to_json)), ..fields]
  }
  let fields = case class_history {
    [] -> fields
    _ -> [
      #(
        "classHistory",
        json.array(class_history, encounter_classhistory_to_json),
      ),
      ..fields
    ]
  }
  let fields = case status_history {
    [] -> fields
    _ -> [
      #(
        "statusHistory",
        json.array(status_history, encounter_statushistory_to_json),
      ),
      ..fields
    ]
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Encounter")), ..fields]
  json.object(fields)
}

pub fn encounter_decoder() -> Decoder(Encounter) {
  use part_of <- decode.optional_field(
    "partOf",
    None,
    decode.optional(reference_decoder()),
  )
  use service_provider <- decode.optional_field(
    "serviceProvider",
    None,
    decode.optional(reference_decoder()),
  )
  use location <- decode.optional_field(
    "location",
    [],
    decode.list(encounter_location_decoder()),
  )
  use hospitalization <- decode.optional_field(
    "hospitalization",
    None,
    decode.optional(encounter_hospitalization_decoder()),
  )
  use account <- decode.optional_field(
    "account",
    [],
    decode.list(reference_decoder()),
  )
  use diagnosis <- decode.optional_field(
    "diagnosis",
    [],
    decode.list(encounter_diagnosis_decoder()),
  )
  use reason_reference <- decode.optional_field(
    "reasonReference",
    [],
    decode.list(reference_decoder()),
  )
  use reason_code <- decode.optional_field(
    "reasonCode",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use length <- decode.optional_field(
    "length",
    None,
    decode.optional(duration_decoder()),
  )
  use period <- decode.optional_field(
    "period",
    None,
    decode.optional(period_decoder()),
  )
  use appointment <- decode.optional_field(
    "appointment",
    [],
    decode.list(reference_decoder()),
  )
  use participant <- decode.optional_field(
    "participant",
    [],
    decode.list(encounter_participant_decoder()),
  )
  use based_on <- decode.optional_field(
    "basedOn",
    [],
    decode.list(reference_decoder()),
  )
  use episode_of_care <- decode.optional_field(
    "episodeOfCare",
    [],
    decode.list(reference_decoder()),
  )
  use subject <- decode.optional_field(
    "subject",
    None,
    decode.optional(reference_decoder()),
  )
  use priority <- decode.optional_field(
    "priority",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use service_type <- decode.optional_field(
    "serviceType",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use class_history <- decode.optional_field(
    "classHistory",
    [],
    decode.list(encounter_classhistory_decoder()),
  )
  use class <- decode.field("class", coding_decoder())
  use status_history <- decode.optional_field(
    "statusHistory",
    [],
    decode.list(encounter_statushistory_decoder()),
  )
  use status <- decode.field("status", r4bvaluesets.encounterstatus_decoder())
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Encounter",
    decode.failure(encounter_new(class:, status:), "resourceType"),
  )
  decode.success(Encounter(
    part_of:,
    service_provider:,
    location:,
    hospitalization:,
    account:,
    diagnosis:,
    reason_reference:,
    reason_code:,
    length:,
    period:,
    appointment:,
    participant:,
    based_on:,
    episode_of_care:,
    subject:,
    priority:,
    service_type:,
    type_:,
    class_history:,
    class:,
    status_history:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/Endpoint#resource
pub type Endpoint {
  Endpoint(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    status: r4bvaluesets.Endpointstatus,
    connection_type: Coding,
    name: Option(String),
    managing_organization: Option(Reference),
    contact: List(Contactpoint),
    period: Option(Period),
    payload_type: List(Codeableconcept),
    payload_mime_type: List(String),
    address: String,
    header: List(String),
  )
}

pub fn endpoint_new(
  address address: String,
  connection_type connection_type: Coding,
  status status: r4bvaluesets.Endpointstatus,
) -> Endpoint {
  Endpoint(
    header: [],
    address:,
    payload_mime_type: [],
    payload_type: [],
    period: None,
    contact: [],
    managing_organization: None,
    name: None,
    connection_type:,
    status:,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

pub fn endpoint_to_json(endpoint: Endpoint) -> Json {
  let Endpoint(
    header:,
    address:,
    payload_mime_type:,
    payload_type:,
    period:,
    contact:,
    managing_organization:,
    name:,
    connection_type:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = endpoint
  let fields = [
    #("address", json.string(address)),
    #("connectionType", coding_to_json(connection_type)),
    #("status", r4bvaluesets.endpointstatus_to_json(status)),
  ]
  let fields = case header {
    [] -> fields
    _ -> [#("header", json.array(header, json.string)), ..fields]
  }
  let fields = case payload_mime_type {
    [] -> fields
    _ -> [
      #("payloadMimeType", json.array(payload_mime_type, json.string)),
      ..fields
    ]
  }
  let fields = case payload_type {
    [] -> fields
    _ -> [
      #("payloadType", json.array(payload_type, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case period {
    Some(v) -> [#("period", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case contact {
    [] -> fields
    _ -> [#("contact", json.array(contact, contactpoint_to_json)), ..fields]
  }
  let fields = case managing_organization {
    Some(v) -> [#("managingOrganization", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Endpoint")), ..fields]
  json.object(fields)
}

pub fn endpoint_decoder() -> Decoder(Endpoint) {
  use header <- decode.optional_field("header", [], decode.list(decode.string))
  use address <- decode.field("address", decode.string)
  use payload_mime_type <- decode.optional_field(
    "payloadMimeType",
    [],
    decode.list(decode.string),
  )
  use payload_type <- decode.optional_field(
    "payloadType",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use period <- decode.optional_field(
    "period",
    None,
    decode.optional(period_decoder()),
  )
  use contact <- decode.optional_field(
    "contact",
    [],
    decode.list(contactpoint_decoder()),
  )
  use managing_organization <- decode.optional_field(
    "managingOrganization",
    None,
    decode.optional(reference_decoder()),
  )
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use connection_type <- decode.field("connectionType", coding_decoder())
  use status <- decode.field("status", r4bvaluesets.endpointstatus_decoder())
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Endpoint",
    decode.failure(
      endpoint_new(address:, connection_type:, status:),
      "resourceType",
    ),
  )
  decode.success(Endpoint(
    header:,
    address:,
    payload_mime_type:,
    payload_type:,
    period:,
    contact:,
    managing_organization:,
    name:,
    connection_type:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/EnrollmentRequest#resource
pub type Enrollmentrequest {
  Enrollmentrequest(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    status: Option(r4bvaluesets.Fmstatus),
    created: Option(String),
    insurer: Option(Reference),
    provider: Option(Reference),
    candidate: Option(Reference),
    coverage: Option(Reference),
  )
}

pub fn enrollmentrequest_new() -> Enrollmentrequest {
  Enrollmentrequest(
    coverage: None,
    candidate: None,
    provider: None,
    insurer: None,
    created: None,
    status: None,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

pub fn enrollmentrequest_to_json(enrollmentrequest: Enrollmentrequest) -> Json {
  let Enrollmentrequest(
    coverage:,
    candidate:,
    provider:,
    insurer:,
    created:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = enrollmentrequest
  let fields = []
  let fields = case coverage {
    Some(v) -> [#("coverage", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case candidate {
    Some(v) -> [#("candidate", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case provider {
    Some(v) -> [#("provider", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case insurer {
    Some(v) -> [#("insurer", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case created {
    Some(v) -> [#("created", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case status {
    Some(v) -> [#("status", r4bvaluesets.fmstatus_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Enrollmentrequest")), ..fields]
  json.object(fields)
}

pub fn enrollmentrequest_decoder() -> Decoder(Enrollmentrequest) {
  use coverage <- decode.optional_field(
    "coverage",
    None,
    decode.optional(reference_decoder()),
  )
  use candidate <- decode.optional_field(
    "candidate",
    None,
    decode.optional(reference_decoder()),
  )
  use provider <- decode.optional_field(
    "provider",
    None,
    decode.optional(reference_decoder()),
  )
  use insurer <- decode.optional_field(
    "insurer",
    None,
    decode.optional(reference_decoder()),
  )
  use created <- decode.optional_field(
    "created",
    None,
    decode.optional(decode.string),
  )
  use status <- decode.optional_field(
    "status",
    None,
    decode.optional(r4bvaluesets.fmstatus_decoder()),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Enrollmentrequest",
    decode.failure(enrollmentrequest_new(), "resourceType"),
  )
  decode.success(Enrollmentrequest(
    coverage:,
    candidate:,
    provider:,
    insurer:,
    created:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/EnrollmentResponse#resource
pub type Enrollmentresponse {
  Enrollmentresponse(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    status: Option(r4bvaluesets.Fmstatus),
    request: Option(Reference),
    outcome: Option(r4bvaluesets.Remittanceoutcome),
    disposition: Option(String),
    created: Option(String),
    organization: Option(Reference),
    request_provider: Option(Reference),
  )
}

pub fn enrollmentresponse_new() -> Enrollmentresponse {
  Enrollmentresponse(
    request_provider: None,
    organization: None,
    created: None,
    disposition: None,
    outcome: None,
    request: None,
    status: None,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

pub fn enrollmentresponse_to_json(
  enrollmentresponse: Enrollmentresponse,
) -> Json {
  let Enrollmentresponse(
    request_provider:,
    organization:,
    created:,
    disposition:,
    outcome:,
    request:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = enrollmentresponse
  let fields = []
  let fields = case request_provider {
    Some(v) -> [#("requestProvider", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case organization {
    Some(v) -> [#("organization", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case created {
    Some(v) -> [#("created", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case disposition {
    Some(v) -> [#("disposition", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case outcome {
    Some(v) -> [
      #("outcome", r4bvaluesets.remittanceoutcome_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case request {
    Some(v) -> [#("request", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case status {
    Some(v) -> [#("status", r4bvaluesets.fmstatus_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Enrollmentresponse")), ..fields]
  json.object(fields)
}

pub fn enrollmentresponse_decoder() -> Decoder(Enrollmentresponse) {
  use request_provider <- decode.optional_field(
    "requestProvider",
    None,
    decode.optional(reference_decoder()),
  )
  use organization <- decode.optional_field(
    "organization",
    None,
    decode.optional(reference_decoder()),
  )
  use created <- decode.optional_field(
    "created",
    None,
    decode.optional(decode.string),
  )
  use disposition <- decode.optional_field(
    "disposition",
    None,
    decode.optional(decode.string),
  )
  use outcome <- decode.optional_field(
    "outcome",
    None,
    decode.optional(r4bvaluesets.remittanceoutcome_decoder()),
  )
  use request <- decode.optional_field(
    "request",
    None,
    decode.optional(reference_decoder()),
  )
  use status <- decode.optional_field(
    "status",
    None,
    decode.optional(r4bvaluesets.fmstatus_decoder()),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Enrollmentresponse",
    decode.failure(enrollmentresponse_new(), "resourceType"),
  )
  decode.success(Enrollmentresponse(
    request_provider:,
    organization:,
    created:,
    disposition:,
    outcome:,
    request:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/EpisodeOfCare#resource
pub type Episodeofcare {
  Episodeofcare(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    status: r4bvaluesets.Episodeofcarestatus,
    status_history: List(EpisodeofcareStatushistory),
    type_: List(Codeableconcept),
    diagnosis: List(EpisodeofcareDiagnosis),
    patient: Reference,
    managing_organization: Option(Reference),
    period: Option(Period),
    referral_request: List(Reference),
    care_manager: Option(Reference),
    team: List(Reference),
    account: List(Reference),
  )
}

pub fn episodeofcare_new(
  patient patient: Reference,
  status status: r4bvaluesets.Episodeofcarestatus,
) -> Episodeofcare {
  Episodeofcare(
    account: [],
    team: [],
    care_manager: None,
    referral_request: [],
    period: None,
    managing_organization: None,
    patient:,
    diagnosis: [],
    type_: [],
    status_history: [],
    status:,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/EpisodeOfCare#resource
pub type EpisodeofcareStatushistory {
  EpisodeofcareStatushistory(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    status: r4bvaluesets.Episodeofcarestatus,
    period: Period,
  )
}

pub fn episodeofcare_statushistory_new(
  period period: Period,
  status status: r4bvaluesets.Episodeofcarestatus,
) -> EpisodeofcareStatushistory {
  EpisodeofcareStatushistory(
    period:,
    status:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/EpisodeOfCare#resource
pub type EpisodeofcareDiagnosis {
  EpisodeofcareDiagnosis(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    condition: Reference,
    role: Option(Codeableconcept),
    rank: Option(Int),
  )
}

pub fn episodeofcare_diagnosis_new(
  condition condition: Reference,
) -> EpisodeofcareDiagnosis {
  EpisodeofcareDiagnosis(
    rank: None,
    role: None,
    condition:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn episodeofcare_diagnosis_to_json(
  episodeofcare_diagnosis: EpisodeofcareDiagnosis,
) -> Json {
  let EpisodeofcareDiagnosis(
    rank:,
    role:,
    condition:,
    modifier_extension:,
    extension:,
    id:,
  ) = episodeofcare_diagnosis
  let fields = [
    #("condition", reference_to_json(condition)),
  ]
  let fields = case rank {
    Some(v) -> [#("rank", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case role {
    Some(v) -> [#("role", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn episodeofcare_diagnosis_decoder() -> Decoder(EpisodeofcareDiagnosis) {
  use rank <- decode.optional_field("rank", None, decode.optional(decode.int))
  use role <- decode.optional_field(
    "role",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use condition <- decode.field("condition", reference_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(EpisodeofcareDiagnosis(
    rank:,
    role:,
    condition:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn episodeofcare_statushistory_to_json(
  episodeofcare_statushistory: EpisodeofcareStatushistory,
) -> Json {
  let EpisodeofcareStatushistory(
    period:,
    status:,
    modifier_extension:,
    extension:,
    id:,
  ) = episodeofcare_statushistory
  let fields = [
    #("period", period_to_json(period)),
    #("status", r4bvaluesets.episodeofcarestatus_to_json(status)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn episodeofcare_statushistory_decoder() -> Decoder(
  EpisodeofcareStatushistory,
) {
  use period <- decode.field("period", period_decoder())
  use status <- decode.field(
    "status",
    r4bvaluesets.episodeofcarestatus_decoder(),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(EpisodeofcareStatushistory(
    period:,
    status:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn episodeofcare_to_json(episodeofcare: Episodeofcare) -> Json {
  let Episodeofcare(
    account:,
    team:,
    care_manager:,
    referral_request:,
    period:,
    managing_organization:,
    patient:,
    diagnosis:,
    type_:,
    status_history:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = episodeofcare
  let fields = [
    #("patient", reference_to_json(patient)),
    #("status", r4bvaluesets.episodeofcarestatus_to_json(status)),
  ]
  let fields = case account {
    [] -> fields
    _ -> [#("account", json.array(account, reference_to_json)), ..fields]
  }
  let fields = case team {
    [] -> fields
    _ -> [#("team", json.array(team, reference_to_json)), ..fields]
  }
  let fields = case care_manager {
    Some(v) -> [#("careManager", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case referral_request {
    [] -> fields
    _ -> [
      #("referralRequest", json.array(referral_request, reference_to_json)),
      ..fields
    ]
  }
  let fields = case period {
    Some(v) -> [#("period", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case managing_organization {
    Some(v) -> [#("managingOrganization", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case diagnosis {
    [] -> fields
    _ -> [
      #("diagnosis", json.array(diagnosis, episodeofcare_diagnosis_to_json)),
      ..fields
    ]
  }
  let fields = case type_ {
    [] -> fields
    _ -> [#("type", json.array(type_, codeableconcept_to_json)), ..fields]
  }
  let fields = case status_history {
    [] -> fields
    _ -> [
      #(
        "statusHistory",
        json.array(status_history, episodeofcare_statushistory_to_json),
      ),
      ..fields
    ]
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Episodeofcare")), ..fields]
  json.object(fields)
}

pub fn episodeofcare_decoder() -> Decoder(Episodeofcare) {
  use account <- decode.optional_field(
    "account",
    [],
    decode.list(reference_decoder()),
  )
  use team <- decode.optional_field(
    "team",
    [],
    decode.list(reference_decoder()),
  )
  use care_manager <- decode.optional_field(
    "careManager",
    None,
    decode.optional(reference_decoder()),
  )
  use referral_request <- decode.optional_field(
    "referralRequest",
    [],
    decode.list(reference_decoder()),
  )
  use period <- decode.optional_field(
    "period",
    None,
    decode.optional(period_decoder()),
  )
  use managing_organization <- decode.optional_field(
    "managingOrganization",
    None,
    decode.optional(reference_decoder()),
  )
  use patient <- decode.field("patient", reference_decoder())
  use diagnosis <- decode.optional_field(
    "diagnosis",
    [],
    decode.list(episodeofcare_diagnosis_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use status_history <- decode.optional_field(
    "statusHistory",
    [],
    decode.list(episodeofcare_statushistory_decoder()),
  )
  use status <- decode.field(
    "status",
    r4bvaluesets.episodeofcarestatus_decoder(),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Episodeofcare",
    decode.failure(episodeofcare_new(patient:, status:), "resourceType"),
  )
  decode.success(Episodeofcare(
    account:,
    team:,
    care_manager:,
    referral_request:,
    period:,
    managing_organization:,
    patient:,
    diagnosis:,
    type_:,
    status_history:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/EventDefinition#resource
pub type Eventdefinition {
  Eventdefinition(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    url: Option(String),
    identifier: List(Identifier),
    version: Option(String),
    name: Option(String),
    title: Option(String),
    subtitle: Option(String),
    status: r4bvaluesets.Publicationstatus,
    experimental: Option(Bool),
    subject: Option(EventdefinitionSubject),
    date: Option(String),
    publisher: Option(String),
    contact: List(Contactdetail),
    description: Option(String),
    use_context: List(Usagecontext),
    jurisdiction: List(Codeableconcept),
    purpose: Option(String),
    usage: Option(String),
    copyright: Option(String),
    approval_date: Option(String),
    last_review_date: Option(String),
    effective_period: Option(Period),
    topic: List(Codeableconcept),
    author: List(Contactdetail),
    editor: List(Contactdetail),
    reviewer: List(Contactdetail),
    endorser: List(Contactdetail),
    related_artifact: List(Relatedartifact),
    trigger: List(Triggerdefinition),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/EventDefinition#resource
pub type EventdefinitionSubject {
  EventdefinitionSubjectCodeableconcept(subject: Codeableconcept)
  EventdefinitionSubjectReference(subject: Reference)
}

pub fn eventdefinition_subject_to_json(elt: EventdefinitionSubject) -> Json {
  case elt {
    EventdefinitionSubjectCodeableconcept(v) -> codeableconcept_to_json(v)
    EventdefinitionSubjectReference(v) -> reference_to_json(v)
  }
}

pub fn eventdefinition_subject_decoder() -> Decoder(EventdefinitionSubject) {
  decode.one_of(
    decode.field(
      "subjectCodeableConcept",
      codeableconcept_decoder(),
      decode.success,
    )
      |> decode.map(EventdefinitionSubjectCodeableconcept),
    [
      decode.field("subjectReference", reference_decoder(), decode.success)
      |> decode.map(EventdefinitionSubjectReference),
    ],
  )
}

pub fn eventdefinition_new(
  status status: r4bvaluesets.Publicationstatus,
) -> Eventdefinition {
  Eventdefinition(
    trigger: [],
    related_artifact: [],
    endorser: [],
    reviewer: [],
    editor: [],
    author: [],
    topic: [],
    effective_period: None,
    last_review_date: None,
    approval_date: None,
    copyright: None,
    usage: None,
    purpose: None,
    jurisdiction: [],
    use_context: [],
    description: None,
    contact: [],
    publisher: None,
    date: None,
    subject: None,
    experimental: None,
    status:,
    subtitle: None,
    title: None,
    name: None,
    version: None,
    identifier: [],
    url: None,
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

pub fn eventdefinition_to_json(eventdefinition: Eventdefinition) -> Json {
  let Eventdefinition(
    trigger:,
    related_artifact:,
    endorser:,
    reviewer:,
    editor:,
    author:,
    topic:,
    effective_period:,
    last_review_date:,
    approval_date:,
    copyright:,
    usage:,
    purpose:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    subject:,
    experimental:,
    status:,
    subtitle:,
    title:,
    name:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = eventdefinition
  let fields = [
    #("status", r4bvaluesets.publicationstatus_to_json(status)),
  ]
  let fields = case trigger {
    [] -> fields
    _ -> [
      #("trigger", json.array(trigger, triggerdefinition_to_json)),
      ..fields
    ]
  }
  let fields = case related_artifact {
    [] -> fields
    _ -> [
      #(
        "relatedArtifact",
        json.array(related_artifact, relatedartifact_to_json),
      ),
      ..fields
    ]
  }
  let fields = case endorser {
    [] -> fields
    _ -> [#("endorser", json.array(endorser, contactdetail_to_json)), ..fields]
  }
  let fields = case reviewer {
    [] -> fields
    _ -> [#("reviewer", json.array(reviewer, contactdetail_to_json)), ..fields]
  }
  let fields = case editor {
    [] -> fields
    _ -> [#("editor", json.array(editor, contactdetail_to_json)), ..fields]
  }
  let fields = case author {
    [] -> fields
    _ -> [#("author", json.array(author, contactdetail_to_json)), ..fields]
  }
  let fields = case topic {
    [] -> fields
    _ -> [#("topic", json.array(topic, codeableconcept_to_json)), ..fields]
  }
  let fields = case effective_period {
    Some(v) -> [#("effectivePeriod", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case last_review_date {
    Some(v) -> [#("lastReviewDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case approval_date {
    Some(v) -> [#("approvalDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case copyright {
    Some(v) -> [#("copyright", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case usage {
    Some(v) -> [#("usage", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case purpose {
    Some(v) -> [#("purpose", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case jurisdiction {
    [] -> fields
    _ -> [
      #("jurisdiction", json.array(jurisdiction, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case use_context {
    [] -> fields
    _ -> [
      #("useContext", json.array(use_context, usagecontext_to_json)),
      ..fields
    ]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case contact {
    [] -> fields
    _ -> [#("contact", json.array(contact, contactdetail_to_json)), ..fields]
  }
  let fields = case publisher {
    Some(v) -> [#("publisher", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case date {
    Some(v) -> [#("date", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case subject {
    Some(v) -> [
      #(
        "subject"
          <> case v {
          EventdefinitionSubjectCodeableconcept(_) -> "Codeableconcept"
          EventdefinitionSubjectReference(_) -> "Reference"
        },
        eventdefinition_subject_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case experimental {
    Some(v) -> [#("experimental", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case subtitle {
    Some(v) -> [#("subtitle", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case title {
    Some(v) -> [#("title", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case version {
    Some(v) -> [#("version", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case url {
    Some(v) -> [#("url", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Eventdefinition")), ..fields]
  json.object(fields)
}

pub fn eventdefinition_decoder() -> Decoder(Eventdefinition) {
  use trigger <- decode.optional_field(
    "trigger",
    [],
    decode.list(triggerdefinition_decoder()),
  )
  use related_artifact <- decode.optional_field(
    "relatedArtifact",
    [],
    decode.list(relatedartifact_decoder()),
  )
  use endorser <- decode.optional_field(
    "endorser",
    [],
    decode.list(contactdetail_decoder()),
  )
  use reviewer <- decode.optional_field(
    "reviewer",
    [],
    decode.list(contactdetail_decoder()),
  )
  use editor <- decode.optional_field(
    "editor",
    [],
    decode.list(contactdetail_decoder()),
  )
  use author <- decode.optional_field(
    "author",
    [],
    decode.list(contactdetail_decoder()),
  )
  use topic <- decode.optional_field(
    "topic",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use effective_period <- decode.optional_field(
    "effectivePeriod",
    None,
    decode.optional(period_decoder()),
  )
  use last_review_date <- decode.optional_field(
    "lastReviewDate",
    None,
    decode.optional(decode.string),
  )
  use approval_date <- decode.optional_field(
    "approvalDate",
    None,
    decode.optional(decode.string),
  )
  use copyright <- decode.optional_field(
    "copyright",
    None,
    decode.optional(decode.string),
  )
  use usage <- decode.optional_field(
    "usage",
    None,
    decode.optional(decode.string),
  )
  use purpose <- decode.optional_field(
    "purpose",
    None,
    decode.optional(decode.string),
  )
  use jurisdiction <- decode.optional_field(
    "jurisdiction",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use use_context <- decode.optional_field(
    "useContext",
    [],
    decode.list(usagecontext_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use contact <- decode.optional_field(
    "contact",
    [],
    decode.list(contactdetail_decoder()),
  )
  use publisher <- decode.optional_field(
    "publisher",
    None,
    decode.optional(decode.string),
  )
  use date <- decode.optional_field(
    "date",
    None,
    decode.optional(decode.string),
  )
  use subject <- decode.then(none_if_omitted(eventdefinition_subject_decoder()))
  use experimental <- decode.optional_field(
    "experimental",
    None,
    decode.optional(decode.bool),
  )
  use status <- decode.field("status", r4bvaluesets.publicationstatus_decoder())
  use subtitle <- decode.optional_field(
    "subtitle",
    None,
    decode.optional(decode.string),
  )
  use title <- decode.optional_field(
    "title",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use version <- decode.optional_field(
    "version",
    None,
    decode.optional(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use url <- decode.optional_field("url", None, decode.optional(decode.string))
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Eventdefinition",
    decode.failure(eventdefinition_new(status:), "resourceType"),
  )
  decode.success(Eventdefinition(
    trigger:,
    related_artifact:,
    endorser:,
    reviewer:,
    editor:,
    author:,
    topic:,
    effective_period:,
    last_review_date:,
    approval_date:,
    copyright:,
    usage:,
    purpose:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    subject:,
    experimental:,
    status:,
    subtitle:,
    title:,
    name:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/Evidence#resource
pub type Evidence {
  Evidence(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    url: Option(String),
    identifier: List(Identifier),
    version: Option(String),
    title: Option(String),
    cite_as: Option(EvidenceCiteas),
    status: r4bvaluesets.Publicationstatus,
    date: Option(String),
    use_context: List(Usagecontext),
    approval_date: Option(String),
    last_review_date: Option(String),
    publisher: Option(String),
    contact: List(Contactdetail),
    author: List(Contactdetail),
    editor: List(Contactdetail),
    reviewer: List(Contactdetail),
    endorser: List(Contactdetail),
    related_artifact: List(Relatedartifact),
    description: Option(String),
    assertion: Option(String),
    note: List(Annotation),
    variable_definition: List(EvidenceVariabledefinition),
    synthesis_type: Option(Codeableconcept),
    study_type: Option(Codeableconcept),
    statistic: List(EvidenceStatistic),
    certainty: List(EvidenceCertainty),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Evidence#resource
pub type EvidenceCiteas {
  EvidenceCiteasReference(cite_as: Reference)
  EvidenceCiteasMarkdown(cite_as: String)
}

pub fn evidence_citeas_to_json(elt: EvidenceCiteas) -> Json {
  case elt {
    EvidenceCiteasReference(v) -> reference_to_json(v)
    EvidenceCiteasMarkdown(v) -> json.string(v)
  }
}

pub fn evidence_citeas_decoder() -> Decoder(EvidenceCiteas) {
  decode.one_of(
    decode.field("citeAsReference", reference_decoder(), decode.success)
      |> decode.map(EvidenceCiteasReference),
    [
      decode.field("citeAsMarkdown", decode.string, decode.success)
      |> decode.map(EvidenceCiteasMarkdown),
    ],
  )
}

pub fn evidence_new(status status: r4bvaluesets.Publicationstatus) -> Evidence {
  Evidence(
    certainty: [],
    statistic: [],
    study_type: None,
    synthesis_type: None,
    variable_definition: [],
    note: [],
    assertion: None,
    description: None,
    related_artifact: [],
    endorser: [],
    reviewer: [],
    editor: [],
    author: [],
    contact: [],
    publisher: None,
    last_review_date: None,
    approval_date: None,
    use_context: [],
    date: None,
    status:,
    cite_as: None,
    title: None,
    version: None,
    identifier: [],
    url: None,
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Evidence#resource
pub type EvidenceVariabledefinition {
  EvidenceVariabledefinition(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    description: Option(String),
    note: List(Annotation),
    variable_role: Codeableconcept,
    observed: Option(Reference),
    intended: Option(Reference),
    directness_match: Option(Codeableconcept),
  )
}

pub fn evidence_variabledefinition_new(
  variable_role variable_role: Codeableconcept,
) -> EvidenceVariabledefinition {
  EvidenceVariabledefinition(
    directness_match: None,
    intended: None,
    observed: None,
    variable_role:,
    note: [],
    description: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Evidence#resource
pub type EvidenceStatistic {
  EvidenceStatistic(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    description: Option(String),
    note: List(Annotation),
    statistic_type: Option(Codeableconcept),
    category: Option(Codeableconcept),
    quantity: Option(Quantity),
    number_of_events: Option(Int),
    number_affected: Option(Int),
    sample_size: Option(EvidenceStatisticSamplesize),
    attribute_estimate: List(EvidenceStatisticAttributeestimate),
    model_characteristic: List(EvidenceStatisticModelcharacteristic),
  )
}

pub fn evidence_statistic_new() -> EvidenceStatistic {
  EvidenceStatistic(
    model_characteristic: [],
    attribute_estimate: [],
    sample_size: None,
    number_affected: None,
    number_of_events: None,
    quantity: None,
    category: None,
    statistic_type: None,
    note: [],
    description: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Evidence#resource
pub type EvidenceStatisticSamplesize {
  EvidenceStatisticSamplesize(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    description: Option(String),
    note: List(Annotation),
    number_of_studies: Option(Int),
    number_of_participants: Option(Int),
    known_data_count: Option(Int),
  )
}

pub fn evidence_statistic_samplesize_new() -> EvidenceStatisticSamplesize {
  EvidenceStatisticSamplesize(
    known_data_count: None,
    number_of_participants: None,
    number_of_studies: None,
    note: [],
    description: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Evidence#resource
pub type EvidenceStatisticAttributeestimate {
  EvidenceStatisticAttributeestimate(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    description: Option(String),
    note: List(Annotation),
    type_: Option(Codeableconcept),
    quantity: Option(Quantity),
    level: Option(Float),
    range: Option(Range),
  )
}

pub fn evidence_statistic_attributeestimate_new() -> EvidenceStatisticAttributeestimate {
  EvidenceStatisticAttributeestimate(
    range: None,
    level: None,
    quantity: None,
    type_: None,
    note: [],
    description: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Evidence#resource
pub type EvidenceStatisticModelcharacteristic {
  EvidenceStatisticModelcharacteristic(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    code: Codeableconcept,
    value: Option(Quantity),
    variable: List(EvidenceStatisticModelcharacteristicVariable),
  )
}

pub fn evidence_statistic_modelcharacteristic_new(
  code code: Codeableconcept,
) -> EvidenceStatisticModelcharacteristic {
  EvidenceStatisticModelcharacteristic(
    variable: [],
    value: None,
    code:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Evidence#resource
pub type EvidenceStatisticModelcharacteristicVariable {
  EvidenceStatisticModelcharacteristicVariable(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    variable_definition: Reference,
    handling: Option(r4bvaluesets.Variablehandling),
    value_category: List(Codeableconcept),
    value_quantity: List(Quantity),
    value_range: List(Range),
  )
}

pub fn evidence_statistic_modelcharacteristic_variable_new(
  variable_definition variable_definition: Reference,
) -> EvidenceStatisticModelcharacteristicVariable {
  EvidenceStatisticModelcharacteristicVariable(
    value_range: [],
    value_quantity: [],
    value_category: [],
    handling: None,
    variable_definition:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Evidence#resource
pub type EvidenceCertainty {
  EvidenceCertainty(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    description: Option(String),
    note: List(Annotation),
    type_: Option(Codeableconcept),
    rating: Option(Codeableconcept),
    rater: Option(String),
  )
}

pub fn evidence_certainty_new() -> EvidenceCertainty {
  EvidenceCertainty(
    rater: None,
    rating: None,
    type_: None,
    note: [],
    description: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn evidence_certainty_to_json(evidence_certainty: EvidenceCertainty) -> Json {
  let EvidenceCertainty(
    rater:,
    rating:,
    type_:,
    note:,
    description:,
    modifier_extension:,
    extension:,
    id:,
  ) = evidence_certainty
  let fields = []
  let fields = case rater {
    Some(v) -> [#("rater", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case rating {
    Some(v) -> [#("rating", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn evidence_certainty_decoder() -> Decoder(EvidenceCertainty) {
  use rater <- decode.optional_field(
    "rater",
    None,
    decode.optional(decode.string),
  )
  use rating <- decode.optional_field(
    "rating",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(EvidenceCertainty(
    rater:,
    rating:,
    type_:,
    note:,
    description:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn evidence_statistic_modelcharacteristic_variable_to_json(
  evidence_statistic_modelcharacteristic_variable: EvidenceStatisticModelcharacteristicVariable,
) -> Json {
  let EvidenceStatisticModelcharacteristicVariable(
    value_range:,
    value_quantity:,
    value_category:,
    handling:,
    variable_definition:,
    modifier_extension:,
    extension:,
    id:,
  ) = evidence_statistic_modelcharacteristic_variable
  let fields = [
    #("variableDefinition", reference_to_json(variable_definition)),
  ]
  let fields = case value_range {
    [] -> fields
    _ -> [#("valueRange", json.array(value_range, range_to_json)), ..fields]
  }
  let fields = case value_quantity {
    [] -> fields
    _ -> [
      #("valueQuantity", json.array(value_quantity, quantity_to_json)),
      ..fields
    ]
  }
  let fields = case value_category {
    [] -> fields
    _ -> [
      #("valueCategory", json.array(value_category, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case handling {
    Some(v) -> [
      #("handling", r4bvaluesets.variablehandling_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn evidence_statistic_modelcharacteristic_variable_decoder() -> Decoder(
  EvidenceStatisticModelcharacteristicVariable,
) {
  use value_range <- decode.optional_field(
    "valueRange",
    [],
    decode.list(range_decoder()),
  )
  use value_quantity <- decode.optional_field(
    "valueQuantity",
    [],
    decode.list(quantity_decoder()),
  )
  use value_category <- decode.optional_field(
    "valueCategory",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use handling <- decode.optional_field(
    "handling",
    None,
    decode.optional(r4bvaluesets.variablehandling_decoder()),
  )
  use variable_definition <- decode.field(
    "variableDefinition",
    reference_decoder(),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(EvidenceStatisticModelcharacteristicVariable(
    value_range:,
    value_quantity:,
    value_category:,
    handling:,
    variable_definition:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn evidence_statistic_modelcharacteristic_to_json(
  evidence_statistic_modelcharacteristic: EvidenceStatisticModelcharacteristic,
) -> Json {
  let EvidenceStatisticModelcharacteristic(
    variable:,
    value:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ) = evidence_statistic_modelcharacteristic
  let fields = [
    #("code", codeableconcept_to_json(code)),
  ]
  let fields = case variable {
    [] -> fields
    _ -> [
      #(
        "variable",
        json.array(
          variable,
          evidence_statistic_modelcharacteristic_variable_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case value {
    Some(v) -> [#("value", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn evidence_statistic_modelcharacteristic_decoder() -> Decoder(
  EvidenceStatisticModelcharacteristic,
) {
  use variable <- decode.optional_field(
    "variable",
    [],
    decode.list(evidence_statistic_modelcharacteristic_variable_decoder()),
  )
  use value <- decode.optional_field(
    "value",
    None,
    decode.optional(quantity_decoder()),
  )
  use code <- decode.field("code", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(EvidenceStatisticModelcharacteristic(
    variable:,
    value:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn evidence_statistic_attributeestimate_to_json(
  evidence_statistic_attributeestimate: EvidenceStatisticAttributeestimate,
) -> Json {
  let EvidenceStatisticAttributeestimate(
    range:,
    level:,
    quantity:,
    type_:,
    note:,
    description:,
    modifier_extension:,
    extension:,
    id:,
  ) = evidence_statistic_attributeestimate
  let fields = []
  let fields = case range {
    Some(v) -> [#("range", range_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case level {
    Some(v) -> [#("level", json.float(v)), ..fields]
    None -> fields
  }
  let fields = case quantity {
    Some(v) -> [#("quantity", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn evidence_statistic_attributeestimate_decoder() -> Decoder(
  EvidenceStatisticAttributeestimate,
) {
  use range <- decode.optional_field(
    "range",
    None,
    decode.optional(range_decoder()),
  )
  use level <- decode.optional_field(
    "level",
    None,
    decode.optional(decode.float),
  )
  use quantity <- decode.optional_field(
    "quantity",
    None,
    decode.optional(quantity_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(EvidenceStatisticAttributeestimate(
    range:,
    level:,
    quantity:,
    type_:,
    note:,
    description:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn evidence_statistic_samplesize_to_json(
  evidence_statistic_samplesize: EvidenceStatisticSamplesize,
) -> Json {
  let EvidenceStatisticSamplesize(
    known_data_count:,
    number_of_participants:,
    number_of_studies:,
    note:,
    description:,
    modifier_extension:,
    extension:,
    id:,
  ) = evidence_statistic_samplesize
  let fields = []
  let fields = case known_data_count {
    Some(v) -> [#("knownDataCount", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case number_of_participants {
    Some(v) -> [#("numberOfParticipants", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case number_of_studies {
    Some(v) -> [#("numberOfStudies", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn evidence_statistic_samplesize_decoder() -> Decoder(
  EvidenceStatisticSamplesize,
) {
  use known_data_count <- decode.optional_field(
    "knownDataCount",
    None,
    decode.optional(decode.int),
  )
  use number_of_participants <- decode.optional_field(
    "numberOfParticipants",
    None,
    decode.optional(decode.int),
  )
  use number_of_studies <- decode.optional_field(
    "numberOfStudies",
    None,
    decode.optional(decode.int),
  )
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(EvidenceStatisticSamplesize(
    known_data_count:,
    number_of_participants:,
    number_of_studies:,
    note:,
    description:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn evidence_statistic_to_json(evidence_statistic: EvidenceStatistic) -> Json {
  let EvidenceStatistic(
    model_characteristic:,
    attribute_estimate:,
    sample_size:,
    number_affected:,
    number_of_events:,
    quantity:,
    category:,
    statistic_type:,
    note:,
    description:,
    modifier_extension:,
    extension:,
    id:,
  ) = evidence_statistic
  let fields = []
  let fields = case model_characteristic {
    [] -> fields
    _ -> [
      #(
        "modelCharacteristic",
        json.array(
          model_characteristic,
          evidence_statistic_modelcharacteristic_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case attribute_estimate {
    [] -> fields
    _ -> [
      #(
        "attributeEstimate",
        json.array(
          attribute_estimate,
          evidence_statistic_attributeestimate_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case sample_size {
    Some(v) -> [
      #("sampleSize", evidence_statistic_samplesize_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case number_affected {
    Some(v) -> [#("numberAffected", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case number_of_events {
    Some(v) -> [#("numberOfEvents", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case quantity {
    Some(v) -> [#("quantity", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case category {
    Some(v) -> [#("category", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case statistic_type {
    Some(v) -> [#("statisticType", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn evidence_statistic_decoder() -> Decoder(EvidenceStatistic) {
  use model_characteristic <- decode.optional_field(
    "modelCharacteristic",
    [],
    decode.list(evidence_statistic_modelcharacteristic_decoder()),
  )
  use attribute_estimate <- decode.optional_field(
    "attributeEstimate",
    [],
    decode.list(evidence_statistic_attributeestimate_decoder()),
  )
  use sample_size <- decode.optional_field(
    "sampleSize",
    None,
    decode.optional(evidence_statistic_samplesize_decoder()),
  )
  use number_affected <- decode.optional_field(
    "numberAffected",
    None,
    decode.optional(decode.int),
  )
  use number_of_events <- decode.optional_field(
    "numberOfEvents",
    None,
    decode.optional(decode.int),
  )
  use quantity <- decode.optional_field(
    "quantity",
    None,
    decode.optional(quantity_decoder()),
  )
  use category <- decode.optional_field(
    "category",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use statistic_type <- decode.optional_field(
    "statisticType",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(EvidenceStatistic(
    model_characteristic:,
    attribute_estimate:,
    sample_size:,
    number_affected:,
    number_of_events:,
    quantity:,
    category:,
    statistic_type:,
    note:,
    description:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn evidence_variabledefinition_to_json(
  evidence_variabledefinition: EvidenceVariabledefinition,
) -> Json {
  let EvidenceVariabledefinition(
    directness_match:,
    intended:,
    observed:,
    variable_role:,
    note:,
    description:,
    modifier_extension:,
    extension:,
    id:,
  ) = evidence_variabledefinition
  let fields = [
    #("variableRole", codeableconcept_to_json(variable_role)),
  ]
  let fields = case directness_match {
    Some(v) -> [#("directnessMatch", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case intended {
    Some(v) -> [#("intended", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case observed {
    Some(v) -> [#("observed", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn evidence_variabledefinition_decoder() -> Decoder(
  EvidenceVariabledefinition,
) {
  use directness_match <- decode.optional_field(
    "directnessMatch",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use intended <- decode.optional_field(
    "intended",
    None,
    decode.optional(reference_decoder()),
  )
  use observed <- decode.optional_field(
    "observed",
    None,
    decode.optional(reference_decoder()),
  )
  use variable_role <- decode.field("variableRole", codeableconcept_decoder())
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(EvidenceVariabledefinition(
    directness_match:,
    intended:,
    observed:,
    variable_role:,
    note:,
    description:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn evidence_to_json(evidence: Evidence) -> Json {
  let Evidence(
    certainty:,
    statistic:,
    study_type:,
    synthesis_type:,
    variable_definition:,
    note:,
    assertion:,
    description:,
    related_artifact:,
    endorser:,
    reviewer:,
    editor:,
    author:,
    contact:,
    publisher:,
    last_review_date:,
    approval_date:,
    use_context:,
    date:,
    status:,
    cite_as:,
    title:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = evidence
  let fields = [
    #("status", r4bvaluesets.publicationstatus_to_json(status)),
  ]
  let fields = case certainty {
    [] -> fields
    _ -> [
      #("certainty", json.array(certainty, evidence_certainty_to_json)),
      ..fields
    ]
  }
  let fields = case statistic {
    [] -> fields
    _ -> [
      #("statistic", json.array(statistic, evidence_statistic_to_json)),
      ..fields
    ]
  }
  let fields = case study_type {
    Some(v) -> [#("studyType", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case synthesis_type {
    Some(v) -> [#("synthesisType", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case variable_definition {
    [] -> fields
    _ -> [
      #(
        "variableDefinition",
        json.array(variable_definition, evidence_variabledefinition_to_json),
      ),
      ..fields
    ]
  }
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case assertion {
    Some(v) -> [#("assertion", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case related_artifact {
    [] -> fields
    _ -> [
      #(
        "relatedArtifact",
        json.array(related_artifact, relatedartifact_to_json),
      ),
      ..fields
    ]
  }
  let fields = case endorser {
    [] -> fields
    _ -> [#("endorser", json.array(endorser, contactdetail_to_json)), ..fields]
  }
  let fields = case reviewer {
    [] -> fields
    _ -> [#("reviewer", json.array(reviewer, contactdetail_to_json)), ..fields]
  }
  let fields = case editor {
    [] -> fields
    _ -> [#("editor", json.array(editor, contactdetail_to_json)), ..fields]
  }
  let fields = case author {
    [] -> fields
    _ -> [#("author", json.array(author, contactdetail_to_json)), ..fields]
  }
  let fields = case contact {
    [] -> fields
    _ -> [#("contact", json.array(contact, contactdetail_to_json)), ..fields]
  }
  let fields = case publisher {
    Some(v) -> [#("publisher", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case last_review_date {
    Some(v) -> [#("lastReviewDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case approval_date {
    Some(v) -> [#("approvalDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case use_context {
    [] -> fields
    _ -> [
      #("useContext", json.array(use_context, usagecontext_to_json)),
      ..fields
    ]
  }
  let fields = case date {
    Some(v) -> [#("date", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case cite_as {
    Some(v) -> [
      #(
        "citeAs"
          <> case v {
          EvidenceCiteasReference(_) -> "Reference"
          EvidenceCiteasMarkdown(_) -> "Markdown"
        },
        evidence_citeas_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case title {
    Some(v) -> [#("title", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case version {
    Some(v) -> [#("version", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case url {
    Some(v) -> [#("url", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Evidence")), ..fields]
  json.object(fields)
}

pub fn evidence_decoder() -> Decoder(Evidence) {
  use certainty <- decode.optional_field(
    "certainty",
    [],
    decode.list(evidence_certainty_decoder()),
  )
  use statistic <- decode.optional_field(
    "statistic",
    [],
    decode.list(evidence_statistic_decoder()),
  )
  use study_type <- decode.optional_field(
    "studyType",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use synthesis_type <- decode.optional_field(
    "synthesisType",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use variable_definition <- decode.optional_field(
    "variableDefinition",
    [],
    decode.list(evidence_variabledefinition_decoder()),
  )
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use assertion <- decode.optional_field(
    "assertion",
    None,
    decode.optional(decode.string),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use related_artifact <- decode.optional_field(
    "relatedArtifact",
    [],
    decode.list(relatedartifact_decoder()),
  )
  use endorser <- decode.optional_field(
    "endorser",
    [],
    decode.list(contactdetail_decoder()),
  )
  use reviewer <- decode.optional_field(
    "reviewer",
    [],
    decode.list(contactdetail_decoder()),
  )
  use editor <- decode.optional_field(
    "editor",
    [],
    decode.list(contactdetail_decoder()),
  )
  use author <- decode.optional_field(
    "author",
    [],
    decode.list(contactdetail_decoder()),
  )
  use contact <- decode.optional_field(
    "contact",
    [],
    decode.list(contactdetail_decoder()),
  )
  use publisher <- decode.optional_field(
    "publisher",
    None,
    decode.optional(decode.string),
  )
  use last_review_date <- decode.optional_field(
    "lastReviewDate",
    None,
    decode.optional(decode.string),
  )
  use approval_date <- decode.optional_field(
    "approvalDate",
    None,
    decode.optional(decode.string),
  )
  use use_context <- decode.optional_field(
    "useContext",
    [],
    decode.list(usagecontext_decoder()),
  )
  use date <- decode.optional_field(
    "date",
    None,
    decode.optional(decode.string),
  )
  use status <- decode.field("status", r4bvaluesets.publicationstatus_decoder())
  use cite_as <- decode.then(none_if_omitted(evidence_citeas_decoder()))
  use title <- decode.optional_field(
    "title",
    None,
    decode.optional(decode.string),
  )
  use version <- decode.optional_field(
    "version",
    None,
    decode.optional(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use url <- decode.optional_field("url", None, decode.optional(decode.string))
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Evidence",
    decode.failure(evidence_new(status:), "resourceType"),
  )
  decode.success(Evidence(
    certainty:,
    statistic:,
    study_type:,
    synthesis_type:,
    variable_definition:,
    note:,
    assertion:,
    description:,
    related_artifact:,
    endorser:,
    reviewer:,
    editor:,
    author:,
    contact:,
    publisher:,
    last_review_date:,
    approval_date:,
    use_context:,
    date:,
    status:,
    cite_as:,
    title:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/EvidenceReport#resource
pub type Evidencereport {
  Evidencereport(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    url: Option(String),
    status: r4bvaluesets.Publicationstatus,
    use_context: List(Usagecontext),
    identifier: List(Identifier),
    related_identifier: List(Identifier),
    cite_as: Option(EvidencereportCiteas),
    type_: Option(Codeableconcept),
    note: List(Annotation),
    related_artifact: List(Relatedartifact),
    subject: EvidencereportSubject,
    publisher: Option(String),
    contact: List(Contactdetail),
    author: List(Contactdetail),
    editor: List(Contactdetail),
    reviewer: List(Contactdetail),
    endorser: List(Contactdetail),
    relates_to: List(EvidencereportRelatesto),
    section: List(EvidencereportSection),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/EvidenceReport#resource
pub type EvidencereportCiteas {
  EvidencereportCiteasReference(cite_as: Reference)
  EvidencereportCiteasMarkdown(cite_as: String)
}

pub fn evidencereport_citeas_to_json(elt: EvidencereportCiteas) -> Json {
  case elt {
    EvidencereportCiteasReference(v) -> reference_to_json(v)
    EvidencereportCiteasMarkdown(v) -> json.string(v)
  }
}

pub fn evidencereport_citeas_decoder() -> Decoder(EvidencereportCiteas) {
  decode.one_of(
    decode.field("citeAsReference", reference_decoder(), decode.success)
      |> decode.map(EvidencereportCiteasReference),
    [
      decode.field("citeAsMarkdown", decode.string, decode.success)
      |> decode.map(EvidencereportCiteasMarkdown),
    ],
  )
}

pub fn evidencereport_new(
  subject subject: EvidencereportSubject,
  status status: r4bvaluesets.Publicationstatus,
) -> Evidencereport {
  Evidencereport(
    section: [],
    relates_to: [],
    endorser: [],
    reviewer: [],
    editor: [],
    author: [],
    contact: [],
    publisher: None,
    subject:,
    related_artifact: [],
    note: [],
    type_: None,
    cite_as: None,
    related_identifier: [],
    identifier: [],
    use_context: [],
    status:,
    url: None,
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/EvidenceReport#resource
pub type EvidencereportSubject {
  EvidencereportSubject(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    characteristic: List(EvidencereportSubjectCharacteristic),
    note: List(Annotation),
  )
}

pub fn evidencereport_subject_new() -> EvidencereportSubject {
  EvidencereportSubject(
    note: [],
    characteristic: [],
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/EvidenceReport#resource
pub type EvidencereportSubjectCharacteristic {
  EvidencereportSubjectCharacteristic(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    code: Codeableconcept,
    value: EvidencereportSubjectCharacteristicValue,
    exclude: Option(Bool),
    period: Option(Period),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/EvidenceReport#resource
pub type EvidencereportSubjectCharacteristicValue {
  EvidencereportSubjectCharacteristicValueReference(value: Reference)
  EvidencereportSubjectCharacteristicValueCodeableconcept(
    value: Codeableconcept,
  )
  EvidencereportSubjectCharacteristicValueBoolean(value: Bool)
  EvidencereportSubjectCharacteristicValueQuantity(value: Quantity)
  EvidencereportSubjectCharacteristicValueRange(value: Range)
}

pub fn evidencereport_subject_characteristic_value_to_json(
  elt: EvidencereportSubjectCharacteristicValue,
) -> Json {
  case elt {
    EvidencereportSubjectCharacteristicValueReference(v) -> reference_to_json(v)
    EvidencereportSubjectCharacteristicValueCodeableconcept(v) ->
      codeableconcept_to_json(v)
    EvidencereportSubjectCharacteristicValueBoolean(v) -> json.bool(v)
    EvidencereportSubjectCharacteristicValueQuantity(v) -> quantity_to_json(v)
    EvidencereportSubjectCharacteristicValueRange(v) -> range_to_json(v)
  }
}

pub fn evidencereport_subject_characteristic_value_decoder() -> Decoder(
  EvidencereportSubjectCharacteristicValue,
) {
  decode.one_of(
    decode.field("valueReference", reference_decoder(), decode.success)
      |> decode.map(EvidencereportSubjectCharacteristicValueReference),
    [
      decode.field(
        "valueCodeableConcept",
        codeableconcept_decoder(),
        decode.success,
      )
        |> decode.map(EvidencereportSubjectCharacteristicValueCodeableconcept),
      decode.field("valueBoolean", decode.bool, decode.success)
        |> decode.map(EvidencereportSubjectCharacteristicValueBoolean),
      decode.field("valueQuantity", quantity_decoder(), decode.success)
        |> decode.map(EvidencereportSubjectCharacteristicValueQuantity),
      decode.field("valueRange", range_decoder(), decode.success)
        |> decode.map(EvidencereportSubjectCharacteristicValueRange),
    ],
  )
}

pub fn evidencereport_subject_characteristic_new(
  value value: EvidencereportSubjectCharacteristicValue,
  code code: Codeableconcept,
) -> EvidencereportSubjectCharacteristic {
  EvidencereportSubjectCharacteristic(
    period: None,
    exclude: None,
    value:,
    code:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/EvidenceReport#resource
pub type EvidencereportRelatesto {
  EvidencereportRelatesto(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    code: r4bvaluesets.Reportrelationtype,
    target: EvidencereportRelatestoTarget,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/EvidenceReport#resource
pub type EvidencereportRelatestoTarget {
  EvidencereportRelatestoTargetIdentifier(target: Identifier)
  EvidencereportRelatestoTargetReference(target: Reference)
}

pub fn evidencereport_relatesto_target_to_json(
  elt: EvidencereportRelatestoTarget,
) -> Json {
  case elt {
    EvidencereportRelatestoTargetIdentifier(v) -> identifier_to_json(v)
    EvidencereportRelatestoTargetReference(v) -> reference_to_json(v)
  }
}

pub fn evidencereport_relatesto_target_decoder() -> Decoder(
  EvidencereportRelatestoTarget,
) {
  decode.one_of(
    decode.field("targetIdentifier", identifier_decoder(), decode.success)
      |> decode.map(EvidencereportRelatestoTargetIdentifier),
    [
      decode.field("targetReference", reference_decoder(), decode.success)
      |> decode.map(EvidencereportRelatestoTargetReference),
    ],
  )
}

pub fn evidencereport_relatesto_new(
  target target: EvidencereportRelatestoTarget,
  code code: r4bvaluesets.Reportrelationtype,
) -> EvidencereportRelatesto {
  EvidencereportRelatesto(
    target:,
    code:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/EvidenceReport#resource
pub type EvidencereportSection {
  EvidencereportSection(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    title: Option(String),
    focus: Option(Codeableconcept),
    focus_reference: Option(Reference),
    author: List(Reference),
    text: Option(Narrative),
    mode: Option(r4bvaluesets.Listmode),
    ordered_by: Option(Codeableconcept),
    entry_classifier: List(Codeableconcept),
    entry_reference: List(Reference),
    entry_quantity: List(Quantity),
    empty_reason: Option(Codeableconcept),
  )
}

pub fn evidencereport_section_new() -> EvidencereportSection {
  EvidencereportSection(
    empty_reason: None,
    entry_quantity: [],
    entry_reference: [],
    entry_classifier: [],
    ordered_by: None,
    mode: None,
    text: None,
    author: [],
    focus_reference: None,
    focus: None,
    title: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn evidencereport_section_to_json(
  evidencereport_section: EvidencereportSection,
) -> Json {
  let EvidencereportSection(
    empty_reason:,
    entry_quantity:,
    entry_reference:,
    entry_classifier:,
    ordered_by:,
    mode:,
    text:,
    author:,
    focus_reference:,
    focus:,
    title:,
    modifier_extension:,
    extension:,
    id:,
  ) = evidencereport_section
  let fields = []
  let fields = case empty_reason {
    Some(v) -> [#("emptyReason", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case entry_quantity {
    [] -> fields
    _ -> [
      #("entryQuantity", json.array(entry_quantity, quantity_to_json)),
      ..fields
    ]
  }
  let fields = case entry_reference {
    [] -> fields
    _ -> [
      #("entryReference", json.array(entry_reference, reference_to_json)),
      ..fields
    ]
  }
  let fields = case entry_classifier {
    [] -> fields
    _ -> [
      #(
        "entryClassifier",
        json.array(entry_classifier, codeableconcept_to_json),
      ),
      ..fields
    ]
  }
  let fields = case ordered_by {
    Some(v) -> [#("orderedBy", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case mode {
    Some(v) -> [#("mode", r4bvaluesets.listmode_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case author {
    [] -> fields
    _ -> [#("author", json.array(author, reference_to_json)), ..fields]
  }
  let fields = case focus_reference {
    Some(v) -> [#("focusReference", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case focus {
    Some(v) -> [#("focus", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case title {
    Some(v) -> [#("title", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn evidencereport_section_decoder() -> Decoder(EvidencereportSection) {
  use empty_reason <- decode.optional_field(
    "emptyReason",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use entry_quantity <- decode.optional_field(
    "entryQuantity",
    [],
    decode.list(quantity_decoder()),
  )
  use entry_reference <- decode.optional_field(
    "entryReference",
    [],
    decode.list(reference_decoder()),
  )
  use entry_classifier <- decode.optional_field(
    "entryClassifier",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use ordered_by <- decode.optional_field(
    "orderedBy",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use mode <- decode.optional_field(
    "mode",
    None,
    decode.optional(r4bvaluesets.listmode_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use author <- decode.optional_field(
    "author",
    [],
    decode.list(reference_decoder()),
  )
  use focus_reference <- decode.optional_field(
    "focusReference",
    None,
    decode.optional(reference_decoder()),
  )
  use focus <- decode.optional_field(
    "focus",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use title <- decode.optional_field(
    "title",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(EvidencereportSection(
    empty_reason:,
    entry_quantity:,
    entry_reference:,
    entry_classifier:,
    ordered_by:,
    mode:,
    text:,
    author:,
    focus_reference:,
    focus:,
    title:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn evidencereport_relatesto_to_json(
  evidencereport_relatesto: EvidencereportRelatesto,
) -> Json {
  let EvidencereportRelatesto(
    target:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ) = evidencereport_relatesto
  let fields = [
    #("target", evidencereport_relatesto_target_to_json(target)),
    #("code", r4bvaluesets.reportrelationtype_to_json(code)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn evidencereport_relatesto_decoder() -> Decoder(EvidencereportRelatesto) {
  use target <- decode.then(evidencereport_relatesto_target_decoder())
  use code <- decode.field("code", r4bvaluesets.reportrelationtype_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(EvidencereportRelatesto(
    target:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn evidencereport_subject_characteristic_to_json(
  evidencereport_subject_characteristic: EvidencereportSubjectCharacteristic,
) -> Json {
  let EvidencereportSubjectCharacteristic(
    period:,
    exclude:,
    value:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ) = evidencereport_subject_characteristic
  let fields = [
    #("value", evidencereport_subject_characteristic_value_to_json(value)),
    #("code", codeableconcept_to_json(code)),
  ]
  let fields = case period {
    Some(v) -> [#("period", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case exclude {
    Some(v) -> [#("exclude", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn evidencereport_subject_characteristic_decoder() -> Decoder(
  EvidencereportSubjectCharacteristic,
) {
  use period <- decode.optional_field(
    "period",
    None,
    decode.optional(period_decoder()),
  )
  use exclude <- decode.optional_field(
    "exclude",
    None,
    decode.optional(decode.bool),
  )
  use value <- decode.then(
    evidencereport_subject_characteristic_value_decoder(),
  )
  use code <- decode.field("code", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(EvidencereportSubjectCharacteristic(
    period:,
    exclude:,
    value:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn evidencereport_subject_to_json(
  evidencereport_subject: EvidencereportSubject,
) -> Json {
  let EvidencereportSubject(
    note:,
    characteristic:,
    modifier_extension:,
    extension:,
    id:,
  ) = evidencereport_subject
  let fields = []
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case characteristic {
    [] -> fields
    _ -> [
      #(
        "characteristic",
        json.array(
          characteristic,
          evidencereport_subject_characteristic_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn evidencereport_subject_decoder() -> Decoder(EvidencereportSubject) {
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use characteristic <- decode.optional_field(
    "characteristic",
    [],
    decode.list(evidencereport_subject_characteristic_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(EvidencereportSubject(
    note:,
    characteristic:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn evidencereport_to_json(evidencereport: Evidencereport) -> Json {
  let Evidencereport(
    section:,
    relates_to:,
    endorser:,
    reviewer:,
    editor:,
    author:,
    contact:,
    publisher:,
    subject:,
    related_artifact:,
    note:,
    type_:,
    cite_as:,
    related_identifier:,
    identifier:,
    use_context:,
    status:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = evidencereport
  let fields = [
    #("subject", evidencereport_subject_to_json(subject)),
    #("status", r4bvaluesets.publicationstatus_to_json(status)),
  ]
  let fields = case section {
    [] -> fields
    _ -> [
      #("section", json.array(section, evidencereport_section_to_json)),
      ..fields
    ]
  }
  let fields = case relates_to {
    [] -> fields
    _ -> [
      #("relatesTo", json.array(relates_to, evidencereport_relatesto_to_json)),
      ..fields
    ]
  }
  let fields = case endorser {
    [] -> fields
    _ -> [#("endorser", json.array(endorser, contactdetail_to_json)), ..fields]
  }
  let fields = case reviewer {
    [] -> fields
    _ -> [#("reviewer", json.array(reviewer, contactdetail_to_json)), ..fields]
  }
  let fields = case editor {
    [] -> fields
    _ -> [#("editor", json.array(editor, contactdetail_to_json)), ..fields]
  }
  let fields = case author {
    [] -> fields
    _ -> [#("author", json.array(author, contactdetail_to_json)), ..fields]
  }
  let fields = case contact {
    [] -> fields
    _ -> [#("contact", json.array(contact, contactdetail_to_json)), ..fields]
  }
  let fields = case publisher {
    Some(v) -> [#("publisher", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case related_artifact {
    [] -> fields
    _ -> [
      #(
        "relatedArtifact",
        json.array(related_artifact, relatedartifact_to_json),
      ),
      ..fields
    ]
  }
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case cite_as {
    Some(v) -> [
      #(
        "citeAs"
          <> case v {
          EvidencereportCiteasReference(_) -> "Reference"
          EvidencereportCiteasMarkdown(_) -> "Markdown"
        },
        evidencereport_citeas_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case related_identifier {
    [] -> fields
    _ -> [
      #("relatedIdentifier", json.array(related_identifier, identifier_to_json)),
      ..fields
    ]
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case use_context {
    [] -> fields
    _ -> [
      #("useContext", json.array(use_context, usagecontext_to_json)),
      ..fields
    ]
  }
  let fields = case url {
    Some(v) -> [#("url", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Evidencereport")), ..fields]
  json.object(fields)
}

pub fn evidencereport_decoder() -> Decoder(Evidencereport) {
  use section <- decode.optional_field(
    "section",
    [],
    decode.list(evidencereport_section_decoder()),
  )
  use relates_to <- decode.optional_field(
    "relatesTo",
    [],
    decode.list(evidencereport_relatesto_decoder()),
  )
  use endorser <- decode.optional_field(
    "endorser",
    [],
    decode.list(contactdetail_decoder()),
  )
  use reviewer <- decode.optional_field(
    "reviewer",
    [],
    decode.list(contactdetail_decoder()),
  )
  use editor <- decode.optional_field(
    "editor",
    [],
    decode.list(contactdetail_decoder()),
  )
  use author <- decode.optional_field(
    "author",
    [],
    decode.list(contactdetail_decoder()),
  )
  use contact <- decode.optional_field(
    "contact",
    [],
    decode.list(contactdetail_decoder()),
  )
  use publisher <- decode.optional_field(
    "publisher",
    None,
    decode.optional(decode.string),
  )
  use subject <- decode.field("subject", evidencereport_subject_decoder())
  use related_artifact <- decode.optional_field(
    "relatedArtifact",
    [],
    decode.list(relatedartifact_decoder()),
  )
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use cite_as <- decode.then(none_if_omitted(evidencereport_citeas_decoder()))
  use related_identifier <- decode.optional_field(
    "relatedIdentifier",
    [],
    decode.list(identifier_decoder()),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use use_context <- decode.optional_field(
    "useContext",
    [],
    decode.list(usagecontext_decoder()),
  )
  use status <- decode.field("status", r4bvaluesets.publicationstatus_decoder())
  use url <- decode.optional_field("url", None, decode.optional(decode.string))
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Evidencereport",
    decode.failure(evidencereport_new(subject:, status:), "resourceType"),
  )
  decode.success(Evidencereport(
    section:,
    relates_to:,
    endorser:,
    reviewer:,
    editor:,
    author:,
    contact:,
    publisher:,
    subject:,
    related_artifact:,
    note:,
    type_:,
    cite_as:,
    related_identifier:,
    identifier:,
    use_context:,
    status:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/EvidenceVariable#resource
pub type Evidencevariable {
  Evidencevariable(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    url: Option(String),
    identifier: List(Identifier),
    version: Option(String),
    name: Option(String),
    title: Option(String),
    short_title: Option(String),
    subtitle: Option(String),
    status: r4bvaluesets.Publicationstatus,
    date: Option(String),
    description: Option(String),
    note: List(Annotation),
    use_context: List(Usagecontext),
    publisher: Option(String),
    contact: List(Contactdetail),
    author: List(Contactdetail),
    editor: List(Contactdetail),
    reviewer: List(Contactdetail),
    endorser: List(Contactdetail),
    related_artifact: List(Relatedartifact),
    actual: Option(Bool),
    characteristic_combination: Option(r4bvaluesets.Characteristiccombination),
    characteristic: List(EvidencevariableCharacteristic),
    handling: Option(r4bvaluesets.Variablehandling),
    category: List(EvidencevariableCategory),
  )
}

pub fn evidencevariable_new(
  status status: r4bvaluesets.Publicationstatus,
) -> Evidencevariable {
  Evidencevariable(
    category: [],
    handling: None,
    characteristic: [],
    characteristic_combination: None,
    actual: None,
    related_artifact: [],
    endorser: [],
    reviewer: [],
    editor: [],
    author: [],
    contact: [],
    publisher: None,
    use_context: [],
    note: [],
    description: None,
    date: None,
    status:,
    subtitle: None,
    short_title: None,
    title: None,
    name: None,
    version: None,
    identifier: [],
    url: None,
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/EvidenceVariable#resource
pub type EvidencevariableCharacteristic {
  EvidencevariableCharacteristic(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    description: Option(String),
    definition: EvidencevariableCharacteristicDefinition,
    method: Option(Codeableconcept),
    device: Option(Reference),
    exclude: Option(Bool),
    time_from_start: Option(EvidencevariableCharacteristicTimefromstart),
    group_measure: Option(r4bvaluesets.Groupmeasure),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/EvidenceVariable#resource
pub type EvidencevariableCharacteristicDefinition {
  EvidencevariableCharacteristicDefinitionReference(definition: Reference)
  EvidencevariableCharacteristicDefinitionCanonical(definition: String)
  EvidencevariableCharacteristicDefinitionCodeableconcept(
    definition: Codeableconcept,
  )
  EvidencevariableCharacteristicDefinitionExpression(definition: Expression)
}

pub fn evidencevariable_characteristic_definition_to_json(
  elt: EvidencevariableCharacteristicDefinition,
) -> Json {
  case elt {
    EvidencevariableCharacteristicDefinitionReference(v) -> reference_to_json(v)
    EvidencevariableCharacteristicDefinitionCanonical(v) -> json.string(v)
    EvidencevariableCharacteristicDefinitionCodeableconcept(v) ->
      codeableconcept_to_json(v)
    EvidencevariableCharacteristicDefinitionExpression(v) ->
      expression_to_json(v)
  }
}

pub fn evidencevariable_characteristic_definition_decoder() -> Decoder(
  EvidencevariableCharacteristicDefinition,
) {
  decode.one_of(
    decode.field("definitionReference", reference_decoder(), decode.success)
      |> decode.map(EvidencevariableCharacteristicDefinitionReference),
    [
      decode.field("definitionCanonical", decode.string, decode.success)
        |> decode.map(EvidencevariableCharacteristicDefinitionCanonical),
      decode.field(
        "definitionCodeableConcept",
        codeableconcept_decoder(),
        decode.success,
      )
        |> decode.map(EvidencevariableCharacteristicDefinitionCodeableconcept),
      decode.field("definitionExpression", expression_decoder(), decode.success)
        |> decode.map(EvidencevariableCharacteristicDefinitionExpression),
    ],
  )
}

pub fn evidencevariable_characteristic_new(
  definition definition: EvidencevariableCharacteristicDefinition,
) -> EvidencevariableCharacteristic {
  EvidencevariableCharacteristic(
    group_measure: None,
    time_from_start: None,
    exclude: None,
    device: None,
    method: None,
    definition:,
    description: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/EvidenceVariable#resource
pub type EvidencevariableCharacteristicTimefromstart {
  EvidencevariableCharacteristicTimefromstart(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    description: Option(String),
    quantity: Option(Quantity),
    range: Option(Range),
    note: List(Annotation),
  )
}

pub fn evidencevariable_characteristic_timefromstart_new() -> EvidencevariableCharacteristicTimefromstart {
  EvidencevariableCharacteristicTimefromstart(
    note: [],
    range: None,
    quantity: None,
    description: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/EvidenceVariable#resource
pub type EvidencevariableCategory {
  EvidencevariableCategory(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    name: Option(String),
    value: Option(EvidencevariableCategoryValue),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/EvidenceVariable#resource
pub type EvidencevariableCategoryValue {
  EvidencevariableCategoryValueCodeableconcept(value: Codeableconcept)
  EvidencevariableCategoryValueQuantity(value: Quantity)
  EvidencevariableCategoryValueRange(value: Range)
}

pub fn evidencevariable_category_value_to_json(
  elt: EvidencevariableCategoryValue,
) -> Json {
  case elt {
    EvidencevariableCategoryValueCodeableconcept(v) ->
      codeableconcept_to_json(v)
    EvidencevariableCategoryValueQuantity(v) -> quantity_to_json(v)
    EvidencevariableCategoryValueRange(v) -> range_to_json(v)
  }
}

pub fn evidencevariable_category_value_decoder() -> Decoder(
  EvidencevariableCategoryValue,
) {
  decode.one_of(
    decode.field(
      "valueCodeableConcept",
      codeableconcept_decoder(),
      decode.success,
    )
      |> decode.map(EvidencevariableCategoryValueCodeableconcept),
    [
      decode.field("valueQuantity", quantity_decoder(), decode.success)
        |> decode.map(EvidencevariableCategoryValueQuantity),
      decode.field("valueRange", range_decoder(), decode.success)
        |> decode.map(EvidencevariableCategoryValueRange),
    ],
  )
}

pub fn evidencevariable_category_new() -> EvidencevariableCategory {
  EvidencevariableCategory(
    value: None,
    name: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn evidencevariable_category_to_json(
  evidencevariable_category: EvidencevariableCategory,
) -> Json {
  let EvidencevariableCategory(
    value:,
    name:,
    modifier_extension:,
    extension:,
    id:,
  ) = evidencevariable_category
  let fields = []
  let fields = case value {
    Some(v) -> [
      #(
        "value"
          <> case v {
          EvidencevariableCategoryValueCodeableconcept(_) -> "Codeableconcept"
          EvidencevariableCategoryValueQuantity(_) -> "Quantity"
          EvidencevariableCategoryValueRange(_) -> "Range"
        },
        evidencevariable_category_value_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn evidencevariable_category_decoder() -> Decoder(EvidencevariableCategory) {
  use value <- decode.then(
    none_if_omitted(evidencevariable_category_value_decoder()),
  )
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(EvidencevariableCategory(
    value:,
    name:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn evidencevariable_characteristic_timefromstart_to_json(
  evidencevariable_characteristic_timefromstart: EvidencevariableCharacteristicTimefromstart,
) -> Json {
  let EvidencevariableCharacteristicTimefromstart(
    note:,
    range:,
    quantity:,
    description:,
    modifier_extension:,
    extension:,
    id:,
  ) = evidencevariable_characteristic_timefromstart
  let fields = []
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case range {
    Some(v) -> [#("range", range_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case quantity {
    Some(v) -> [#("quantity", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn evidencevariable_characteristic_timefromstart_decoder() -> Decoder(
  EvidencevariableCharacteristicTimefromstart,
) {
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use range <- decode.optional_field(
    "range",
    None,
    decode.optional(range_decoder()),
  )
  use quantity <- decode.optional_field(
    "quantity",
    None,
    decode.optional(quantity_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(EvidencevariableCharacteristicTimefromstart(
    note:,
    range:,
    quantity:,
    description:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn evidencevariable_characteristic_to_json(
  evidencevariable_characteristic: EvidencevariableCharacteristic,
) -> Json {
  let EvidencevariableCharacteristic(
    group_measure:,
    time_from_start:,
    exclude:,
    device:,
    method:,
    definition:,
    description:,
    modifier_extension:,
    extension:,
    id:,
  ) = evidencevariable_characteristic
  let fields = [
    #(
      "definition",
      evidencevariable_characteristic_definition_to_json(definition),
    ),
  ]
  let fields = case group_measure {
    Some(v) -> [
      #("groupMeasure", r4bvaluesets.groupmeasure_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case time_from_start {
    Some(v) -> [
      #(
        "timeFromStart",
        evidencevariable_characteristic_timefromstart_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case exclude {
    Some(v) -> [#("exclude", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case device {
    Some(v) -> [#("device", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case method {
    Some(v) -> [#("method", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn evidencevariable_characteristic_decoder() -> Decoder(
  EvidencevariableCharacteristic,
) {
  use group_measure <- decode.optional_field(
    "groupMeasure",
    None,
    decode.optional(r4bvaluesets.groupmeasure_decoder()),
  )
  use time_from_start <- decode.optional_field(
    "timeFromStart",
    None,
    decode.optional(evidencevariable_characteristic_timefromstart_decoder()),
  )
  use exclude <- decode.optional_field(
    "exclude",
    None,
    decode.optional(decode.bool),
  )
  use device <- decode.optional_field(
    "device",
    None,
    decode.optional(reference_decoder()),
  )
  use method <- decode.optional_field(
    "method",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use definition <- decode.then(
    evidencevariable_characteristic_definition_decoder(),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(EvidencevariableCharacteristic(
    group_measure:,
    time_from_start:,
    exclude:,
    device:,
    method:,
    definition:,
    description:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn evidencevariable_to_json(evidencevariable: Evidencevariable) -> Json {
  let Evidencevariable(
    category:,
    handling:,
    characteristic:,
    characteristic_combination:,
    actual:,
    related_artifact:,
    endorser:,
    reviewer:,
    editor:,
    author:,
    contact:,
    publisher:,
    use_context:,
    note:,
    description:,
    date:,
    status:,
    subtitle:,
    short_title:,
    title:,
    name:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = evidencevariable
  let fields = [
    #("status", r4bvaluesets.publicationstatus_to_json(status)),
  ]
  let fields = case category {
    [] -> fields
    _ -> [
      #("category", json.array(category, evidencevariable_category_to_json)),
      ..fields
    ]
  }
  let fields = case handling {
    Some(v) -> [
      #("handling", r4bvaluesets.variablehandling_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case characteristic {
    [] -> fields
    _ -> [
      #(
        "characteristic",
        json.array(characteristic, evidencevariable_characteristic_to_json),
      ),
      ..fields
    ]
  }
  let fields = case characteristic_combination {
    Some(v) -> [
      #(
        "characteristicCombination",
        r4bvaluesets.characteristiccombination_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case actual {
    Some(v) -> [#("actual", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case related_artifact {
    [] -> fields
    _ -> [
      #(
        "relatedArtifact",
        json.array(related_artifact, relatedartifact_to_json),
      ),
      ..fields
    ]
  }
  let fields = case endorser {
    [] -> fields
    _ -> [#("endorser", json.array(endorser, contactdetail_to_json)), ..fields]
  }
  let fields = case reviewer {
    [] -> fields
    _ -> [#("reviewer", json.array(reviewer, contactdetail_to_json)), ..fields]
  }
  let fields = case editor {
    [] -> fields
    _ -> [#("editor", json.array(editor, contactdetail_to_json)), ..fields]
  }
  let fields = case author {
    [] -> fields
    _ -> [#("author", json.array(author, contactdetail_to_json)), ..fields]
  }
  let fields = case contact {
    [] -> fields
    _ -> [#("contact", json.array(contact, contactdetail_to_json)), ..fields]
  }
  let fields = case publisher {
    Some(v) -> [#("publisher", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case use_context {
    [] -> fields
    _ -> [
      #("useContext", json.array(use_context, usagecontext_to_json)),
      ..fields
    ]
  }
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case date {
    Some(v) -> [#("date", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case subtitle {
    Some(v) -> [#("subtitle", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case short_title {
    Some(v) -> [#("shortTitle", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case title {
    Some(v) -> [#("title", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case version {
    Some(v) -> [#("version", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case url {
    Some(v) -> [#("url", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Evidencevariable")), ..fields]
  json.object(fields)
}

pub fn evidencevariable_decoder() -> Decoder(Evidencevariable) {
  use category <- decode.optional_field(
    "category",
    [],
    decode.list(evidencevariable_category_decoder()),
  )
  use handling <- decode.optional_field(
    "handling",
    None,
    decode.optional(r4bvaluesets.variablehandling_decoder()),
  )
  use characteristic <- decode.optional_field(
    "characteristic",
    [],
    decode.list(evidencevariable_characteristic_decoder()),
  )
  use characteristic_combination <- decode.optional_field(
    "characteristicCombination",
    None,
    decode.optional(r4bvaluesets.characteristiccombination_decoder()),
  )
  use actual <- decode.optional_field(
    "actual",
    None,
    decode.optional(decode.bool),
  )
  use related_artifact <- decode.optional_field(
    "relatedArtifact",
    [],
    decode.list(relatedartifact_decoder()),
  )
  use endorser <- decode.optional_field(
    "endorser",
    [],
    decode.list(contactdetail_decoder()),
  )
  use reviewer <- decode.optional_field(
    "reviewer",
    [],
    decode.list(contactdetail_decoder()),
  )
  use editor <- decode.optional_field(
    "editor",
    [],
    decode.list(contactdetail_decoder()),
  )
  use author <- decode.optional_field(
    "author",
    [],
    decode.list(contactdetail_decoder()),
  )
  use contact <- decode.optional_field(
    "contact",
    [],
    decode.list(contactdetail_decoder()),
  )
  use publisher <- decode.optional_field(
    "publisher",
    None,
    decode.optional(decode.string),
  )
  use use_context <- decode.optional_field(
    "useContext",
    [],
    decode.list(usagecontext_decoder()),
  )
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use date <- decode.optional_field(
    "date",
    None,
    decode.optional(decode.string),
  )
  use status <- decode.field("status", r4bvaluesets.publicationstatus_decoder())
  use subtitle <- decode.optional_field(
    "subtitle",
    None,
    decode.optional(decode.string),
  )
  use short_title <- decode.optional_field(
    "shortTitle",
    None,
    decode.optional(decode.string),
  )
  use title <- decode.optional_field(
    "title",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use version <- decode.optional_field(
    "version",
    None,
    decode.optional(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use url <- decode.optional_field("url", None, decode.optional(decode.string))
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Evidencevariable",
    decode.failure(evidencevariable_new(status:), "resourceType"),
  )
  decode.success(Evidencevariable(
    category:,
    handling:,
    characteristic:,
    characteristic_combination:,
    actual:,
    related_artifact:,
    endorser:,
    reviewer:,
    editor:,
    author:,
    contact:,
    publisher:,
    use_context:,
    note:,
    description:,
    date:,
    status:,
    subtitle:,
    short_title:,
    title:,
    name:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/ExampleScenario#resource
pub type Examplescenario {
  Examplescenario(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    url: Option(String),
    identifier: List(Identifier),
    version: Option(String),
    name: Option(String),
    status: r4bvaluesets.Publicationstatus,
    experimental: Option(Bool),
    date: Option(String),
    publisher: Option(String),
    contact: List(Contactdetail),
    use_context: List(Usagecontext),
    jurisdiction: List(Codeableconcept),
    copyright: Option(String),
    purpose: Option(String),
    actor: List(ExamplescenarioActor),
    instance: List(ExamplescenarioInstance),
    process: List(ExamplescenarioProcess),
    workflow: List(String),
  )
}

pub fn examplescenario_new(
  status status: r4bvaluesets.Publicationstatus,
) -> Examplescenario {
  Examplescenario(
    workflow: [],
    process: [],
    instance: [],
    actor: [],
    purpose: None,
    copyright: None,
    jurisdiction: [],
    use_context: [],
    contact: [],
    publisher: None,
    date: None,
    experimental: None,
    status:,
    name: None,
    version: None,
    identifier: [],
    url: None,
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ExampleScenario#resource
pub type ExamplescenarioActor {
  ExamplescenarioActor(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    actor_id: String,
    type_: r4bvaluesets.Examplescenarioactortype,
    name: Option(String),
    description: Option(String),
  )
}

pub fn examplescenario_actor_new(
  type_ type_: r4bvaluesets.Examplescenarioactortype,
  actor_id actor_id: String,
) -> ExamplescenarioActor {
  ExamplescenarioActor(
    description: None,
    name: None,
    type_:,
    actor_id:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ExampleScenario#resource
pub type ExamplescenarioInstance {
  ExamplescenarioInstance(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    resource_id: String,
    resource_type: r4bvaluesets.Resourcetypes,
    name: Option(String),
    description: Option(String),
    version: List(ExamplescenarioInstanceVersion),
    contained_instance: List(ExamplescenarioInstanceContainedinstance),
  )
}

pub fn examplescenario_instance_new(
  resource_type resource_type: r4bvaluesets.Resourcetypes,
  resource_id resource_id: String,
) -> ExamplescenarioInstance {
  ExamplescenarioInstance(
    contained_instance: [],
    version: [],
    description: None,
    name: None,
    resource_type:,
    resource_id:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ExampleScenario#resource
pub type ExamplescenarioInstanceVersion {
  ExamplescenarioInstanceVersion(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    version_id: String,
    description: String,
  )
}

pub fn examplescenario_instance_version_new(
  description description: String,
  version_id version_id: String,
) -> ExamplescenarioInstanceVersion {
  ExamplescenarioInstanceVersion(
    description:,
    version_id:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ExampleScenario#resource
pub type ExamplescenarioInstanceContainedinstance {
  ExamplescenarioInstanceContainedinstance(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    resource_id: String,
    version_id: Option(String),
  )
}

pub fn examplescenario_instance_containedinstance_new(
  resource_id resource_id: String,
) -> ExamplescenarioInstanceContainedinstance {
  ExamplescenarioInstanceContainedinstance(
    version_id: None,
    resource_id:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ExampleScenario#resource
pub type ExamplescenarioProcess {
  ExamplescenarioProcess(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    title: String,
    description: Option(String),
    pre_conditions: Option(String),
    post_conditions: Option(String),
    step: List(ExamplescenarioProcessStep),
  )
}

pub fn examplescenario_process_new(
  title title: String,
) -> ExamplescenarioProcess {
  ExamplescenarioProcess(
    step: [],
    post_conditions: None,
    pre_conditions: None,
    description: None,
    title:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ExampleScenario#resource
pub type ExamplescenarioProcessStep {
  ExamplescenarioProcessStep(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    pause: Option(Bool),
    operation: Option(ExamplescenarioProcessStepOperation),
    alternative: List(ExamplescenarioProcessStepAlternative),
  )
}

pub fn examplescenario_process_step_new() -> ExamplescenarioProcessStep {
  ExamplescenarioProcessStep(
    alternative: [],
    operation: None,
    pause: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ExampleScenario#resource
pub type ExamplescenarioProcessStepOperation {
  ExamplescenarioProcessStepOperation(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    number: String,
    type_: Option(String),
    name: Option(String),
    initiator: Option(String),
    receiver: Option(String),
    description: Option(String),
    initiator_active: Option(Bool),
    receiver_active: Option(Bool),
  )
}

pub fn examplescenario_process_step_operation_new(
  number number: String,
) -> ExamplescenarioProcessStepOperation {
  ExamplescenarioProcessStepOperation(
    receiver_active: None,
    initiator_active: None,
    description: None,
    receiver: None,
    initiator: None,
    name: None,
    type_: None,
    number:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ExampleScenario#resource
pub type ExamplescenarioProcessStepAlternative {
  ExamplescenarioProcessStepAlternative(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    title: String,
    description: Option(String),
  )
}

pub fn examplescenario_process_step_alternative_new(
  title title: String,
) -> ExamplescenarioProcessStepAlternative {
  ExamplescenarioProcessStepAlternative(
    description: None,
    title:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn examplescenario_process_step_alternative_to_json(
  examplescenario_process_step_alternative: ExamplescenarioProcessStepAlternative,
) -> Json {
  let ExamplescenarioProcessStepAlternative(
    description:,
    title:,
    modifier_extension:,
    extension:,
    id:,
  ) = examplescenario_process_step_alternative
  let fields = [
    #("title", json.string(title)),
  ]
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn examplescenario_process_step_alternative_decoder() -> Decoder(
  ExamplescenarioProcessStepAlternative,
) {
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use title <- decode.field("title", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ExamplescenarioProcessStepAlternative(
    description:,
    title:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn examplescenario_process_step_operation_to_json(
  examplescenario_process_step_operation: ExamplescenarioProcessStepOperation,
) -> Json {
  let ExamplescenarioProcessStepOperation(
    receiver_active:,
    initiator_active:,
    description:,
    receiver:,
    initiator:,
    name:,
    type_:,
    number:,
    modifier_extension:,
    extension:,
    id:,
  ) = examplescenario_process_step_operation
  let fields = [
    #("number", json.string(number)),
  ]
  let fields = case receiver_active {
    Some(v) -> [#("receiverActive", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case initiator_active {
    Some(v) -> [#("initiatorActive", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case receiver {
    Some(v) -> [#("receiver", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case initiator {
    Some(v) -> [#("initiator", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn examplescenario_process_step_operation_decoder() -> Decoder(
  ExamplescenarioProcessStepOperation,
) {
  use receiver_active <- decode.optional_field(
    "receiverActive",
    None,
    decode.optional(decode.bool),
  )
  use initiator_active <- decode.optional_field(
    "initiatorActive",
    None,
    decode.optional(decode.bool),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use receiver <- decode.optional_field(
    "receiver",
    None,
    decode.optional(decode.string),
  )
  use initiator <- decode.optional_field(
    "initiator",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(decode.string),
  )
  use number <- decode.field("number", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ExamplescenarioProcessStepOperation(
    receiver_active:,
    initiator_active:,
    description:,
    receiver:,
    initiator:,
    name:,
    type_:,
    number:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn examplescenario_process_step_to_json(
  examplescenario_process_step: ExamplescenarioProcessStep,
) -> Json {
  let ExamplescenarioProcessStep(
    alternative:,
    operation:,
    pause:,
    modifier_extension:,
    extension:,
    id:,
  ) = examplescenario_process_step
  let fields = []
  let fields = case alternative {
    [] -> fields
    _ -> [
      #(
        "alternative",
        json.array(
          alternative,
          examplescenario_process_step_alternative_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case operation {
    Some(v) -> [
      #("operation", examplescenario_process_step_operation_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case pause {
    Some(v) -> [#("pause", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn examplescenario_process_step_decoder() -> Decoder(
  ExamplescenarioProcessStep,
) {
  use alternative <- decode.optional_field(
    "alternative",
    [],
    decode.list(examplescenario_process_step_alternative_decoder()),
  )
  use operation <- decode.optional_field(
    "operation",
    None,
    decode.optional(examplescenario_process_step_operation_decoder()),
  )
  use pause <- decode.optional_field(
    "pause",
    None,
    decode.optional(decode.bool),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ExamplescenarioProcessStep(
    alternative:,
    operation:,
    pause:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn examplescenario_process_to_json(
  examplescenario_process: ExamplescenarioProcess,
) -> Json {
  let ExamplescenarioProcess(
    step:,
    post_conditions:,
    pre_conditions:,
    description:,
    title:,
    modifier_extension:,
    extension:,
    id:,
  ) = examplescenario_process
  let fields = [
    #("title", json.string(title)),
  ]
  let fields = case step {
    [] -> fields
    _ -> [
      #("step", json.array(step, examplescenario_process_step_to_json)),
      ..fields
    ]
  }
  let fields = case post_conditions {
    Some(v) -> [#("postConditions", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case pre_conditions {
    Some(v) -> [#("preConditions", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn examplescenario_process_decoder() -> Decoder(ExamplescenarioProcess) {
  use step <- decode.optional_field(
    "step",
    [],
    decode.list(examplescenario_process_step_decoder()),
  )
  use post_conditions <- decode.optional_field(
    "postConditions",
    None,
    decode.optional(decode.string),
  )
  use pre_conditions <- decode.optional_field(
    "preConditions",
    None,
    decode.optional(decode.string),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use title <- decode.field("title", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ExamplescenarioProcess(
    step:,
    post_conditions:,
    pre_conditions:,
    description:,
    title:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn examplescenario_instance_containedinstance_to_json(
  examplescenario_instance_containedinstance: ExamplescenarioInstanceContainedinstance,
) -> Json {
  let ExamplescenarioInstanceContainedinstance(
    version_id:,
    resource_id:,
    modifier_extension:,
    extension:,
    id:,
  ) = examplescenario_instance_containedinstance
  let fields = [
    #("resourceId", json.string(resource_id)),
  ]
  let fields = case version_id {
    Some(v) -> [#("versionId", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn examplescenario_instance_containedinstance_decoder() -> Decoder(
  ExamplescenarioInstanceContainedinstance,
) {
  use version_id <- decode.optional_field(
    "versionId",
    None,
    decode.optional(decode.string),
  )
  use resource_id <- decode.field("resourceId", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ExamplescenarioInstanceContainedinstance(
    version_id:,
    resource_id:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn examplescenario_instance_version_to_json(
  examplescenario_instance_version: ExamplescenarioInstanceVersion,
) -> Json {
  let ExamplescenarioInstanceVersion(
    description:,
    version_id:,
    modifier_extension:,
    extension:,
    id:,
  ) = examplescenario_instance_version
  let fields = [
    #("description", json.string(description)),
    #("versionId", json.string(version_id)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn examplescenario_instance_version_decoder() -> Decoder(
  ExamplescenarioInstanceVersion,
) {
  use description <- decode.field("description", decode.string)
  use version_id <- decode.field("versionId", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ExamplescenarioInstanceVersion(
    description:,
    version_id:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn examplescenario_instance_to_json(
  examplescenario_instance: ExamplescenarioInstance,
) -> Json {
  let ExamplescenarioInstance(
    contained_instance:,
    version:,
    description:,
    name:,
    resource_type:,
    resource_id:,
    modifier_extension:,
    extension:,
    id:,
  ) = examplescenario_instance
  let fields = [
    #("resourceType", r4bvaluesets.resourcetypes_to_json(resource_type)),
    #("resourceId", json.string(resource_id)),
  ]
  let fields = case contained_instance {
    [] -> fields
    _ -> [
      #(
        "containedInstance",
        json.array(
          contained_instance,
          examplescenario_instance_containedinstance_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case version {
    [] -> fields
    _ -> [
      #(
        "version",
        json.array(version, examplescenario_instance_version_to_json),
      ),
      ..fields
    ]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn examplescenario_instance_decoder() -> Decoder(ExamplescenarioInstance) {
  use contained_instance <- decode.optional_field(
    "containedInstance",
    [],
    decode.list(examplescenario_instance_containedinstance_decoder()),
  )
  use version <- decode.optional_field(
    "version",
    [],
    decode.list(examplescenario_instance_version_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use resource_type <- decode.field(
    "resourceType",
    r4bvaluesets.resourcetypes_decoder(),
  )
  use resource_id <- decode.field("resourceId", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ExamplescenarioInstance(
    contained_instance:,
    version:,
    description:,
    name:,
    resource_type:,
    resource_id:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn examplescenario_actor_to_json(
  examplescenario_actor: ExamplescenarioActor,
) -> Json {
  let ExamplescenarioActor(
    description:,
    name:,
    type_:,
    actor_id:,
    modifier_extension:,
    extension:,
    id:,
  ) = examplescenario_actor
  let fields = [
    #("type", r4bvaluesets.examplescenarioactortype_to_json(type_)),
    #("actorId", json.string(actor_id)),
  ]
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn examplescenario_actor_decoder() -> Decoder(ExamplescenarioActor) {
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use type_ <- decode.field(
    "type",
    r4bvaluesets.examplescenarioactortype_decoder(),
  )
  use actor_id <- decode.field("actorId", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ExamplescenarioActor(
    description:,
    name:,
    type_:,
    actor_id:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn examplescenario_to_json(examplescenario: Examplescenario) -> Json {
  let Examplescenario(
    workflow:,
    process:,
    instance:,
    actor:,
    purpose:,
    copyright:,
    jurisdiction:,
    use_context:,
    contact:,
    publisher:,
    date:,
    experimental:,
    status:,
    name:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = examplescenario
  let fields = [
    #("status", r4bvaluesets.publicationstatus_to_json(status)),
  ]
  let fields = case workflow {
    [] -> fields
    _ -> [#("workflow", json.array(workflow, json.string)), ..fields]
  }
  let fields = case process {
    [] -> fields
    _ -> [
      #("process", json.array(process, examplescenario_process_to_json)),
      ..fields
    ]
  }
  let fields = case instance {
    [] -> fields
    _ -> [
      #("instance", json.array(instance, examplescenario_instance_to_json)),
      ..fields
    ]
  }
  let fields = case actor {
    [] -> fields
    _ -> [
      #("actor", json.array(actor, examplescenario_actor_to_json)),
      ..fields
    ]
  }
  let fields = case purpose {
    Some(v) -> [#("purpose", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case copyright {
    Some(v) -> [#("copyright", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case jurisdiction {
    [] -> fields
    _ -> [
      #("jurisdiction", json.array(jurisdiction, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case use_context {
    [] -> fields
    _ -> [
      #("useContext", json.array(use_context, usagecontext_to_json)),
      ..fields
    ]
  }
  let fields = case contact {
    [] -> fields
    _ -> [#("contact", json.array(contact, contactdetail_to_json)), ..fields]
  }
  let fields = case publisher {
    Some(v) -> [#("publisher", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case date {
    Some(v) -> [#("date", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case experimental {
    Some(v) -> [#("experimental", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case version {
    Some(v) -> [#("version", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case url {
    Some(v) -> [#("url", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Examplescenario")), ..fields]
  json.object(fields)
}

pub fn examplescenario_decoder() -> Decoder(Examplescenario) {
  use workflow <- decode.optional_field(
    "workflow",
    [],
    decode.list(decode.string),
  )
  use process <- decode.optional_field(
    "process",
    [],
    decode.list(examplescenario_process_decoder()),
  )
  use instance <- decode.optional_field(
    "instance",
    [],
    decode.list(examplescenario_instance_decoder()),
  )
  use actor <- decode.optional_field(
    "actor",
    [],
    decode.list(examplescenario_actor_decoder()),
  )
  use purpose <- decode.optional_field(
    "purpose",
    None,
    decode.optional(decode.string),
  )
  use copyright <- decode.optional_field(
    "copyright",
    None,
    decode.optional(decode.string),
  )
  use jurisdiction <- decode.optional_field(
    "jurisdiction",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use use_context <- decode.optional_field(
    "useContext",
    [],
    decode.list(usagecontext_decoder()),
  )
  use contact <- decode.optional_field(
    "contact",
    [],
    decode.list(contactdetail_decoder()),
  )
  use publisher <- decode.optional_field(
    "publisher",
    None,
    decode.optional(decode.string),
  )
  use date <- decode.optional_field(
    "date",
    None,
    decode.optional(decode.string),
  )
  use experimental <- decode.optional_field(
    "experimental",
    None,
    decode.optional(decode.bool),
  )
  use status <- decode.field("status", r4bvaluesets.publicationstatus_decoder())
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use version <- decode.optional_field(
    "version",
    None,
    decode.optional(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use url <- decode.optional_field("url", None, decode.optional(decode.string))
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Examplescenario",
    decode.failure(examplescenario_new(status:), "resourceType"),
  )
  decode.success(Examplescenario(
    workflow:,
    process:,
    instance:,
    actor:,
    purpose:,
    copyright:,
    jurisdiction:,
    use_context:,
    contact:,
    publisher:,
    date:,
    experimental:,
    status:,
    name:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/ExplanationOfBenefit#resource
pub type Explanationofbenefit {
  Explanationofbenefit(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    status: r4bvaluesets.Explanationofbenefitstatus,
    type_: Codeableconcept,
    sub_type: Option(Codeableconcept),
    use_: r4bvaluesets.Claimuse,
    patient: Reference,
    billable_period: Option(Period),
    created: String,
    enterer: Option(Reference),
    insurer: Reference,
    provider: Reference,
    priority: Option(Codeableconcept),
    funds_reserve_requested: Option(Codeableconcept),
    funds_reserve: Option(Codeableconcept),
    related: List(ExplanationofbenefitRelated),
    prescription: Option(Reference),
    original_prescription: Option(Reference),
    payee: Option(ExplanationofbenefitPayee),
    referral: Option(Reference),
    facility: Option(Reference),
    claim: Option(Reference),
    claim_response: Option(Reference),
    outcome: r4bvaluesets.Remittanceoutcome,
    disposition: Option(String),
    pre_auth_ref: List(String),
    pre_auth_ref_period: List(Period),
    care_team: List(ExplanationofbenefitCareteam),
    supporting_info: List(ExplanationofbenefitSupportinginfo),
    diagnosis: List(ExplanationofbenefitDiagnosis),
    procedure: List(ExplanationofbenefitProcedure),
    precedence: Option(Int),
    insurance: List(ExplanationofbenefitInsurance),
    accident: Option(ExplanationofbenefitAccident),
    item: List(ExplanationofbenefitItem),
    add_item: List(ExplanationofbenefitAdditem),
    total: List(ExplanationofbenefitTotal),
    payment: Option(ExplanationofbenefitPayment),
    form_code: Option(Codeableconcept),
    form: Option(Attachment),
    process_note: List(ExplanationofbenefitProcessnote),
    benefit_period: Option(Period),
    benefit_balance: List(ExplanationofbenefitBenefitbalance),
  )
}

pub fn explanationofbenefit_new(
  outcome outcome: r4bvaluesets.Remittanceoutcome,
  provider provider: Reference,
  insurer insurer: Reference,
  created created: String,
  patient patient: Reference,
  use_ use_: r4bvaluesets.Claimuse,
  type_ type_: Codeableconcept,
  status status: r4bvaluesets.Explanationofbenefitstatus,
) -> Explanationofbenefit {
  Explanationofbenefit(
    benefit_balance: [],
    benefit_period: None,
    process_note: [],
    form: None,
    form_code: None,
    payment: None,
    total: [],
    add_item: [],
    item: [],
    accident: None,
    insurance: [],
    precedence: None,
    procedure: [],
    diagnosis: [],
    supporting_info: [],
    care_team: [],
    pre_auth_ref_period: [],
    pre_auth_ref: [],
    disposition: None,
    outcome:,
    claim_response: None,
    claim: None,
    facility: None,
    referral: None,
    payee: None,
    original_prescription: None,
    prescription: None,
    related: [],
    funds_reserve: None,
    funds_reserve_requested: None,
    priority: None,
    provider:,
    insurer:,
    enterer: None,
    created:,
    billable_period: None,
    patient:,
    use_:,
    sub_type: None,
    type_:,
    status:,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ExplanationOfBenefit#resource
pub type ExplanationofbenefitRelated {
  ExplanationofbenefitRelated(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    claim: Option(Reference),
    relationship: Option(Codeableconcept),
    reference: Option(Identifier),
  )
}

pub fn explanationofbenefit_related_new() -> ExplanationofbenefitRelated {
  ExplanationofbenefitRelated(
    reference: None,
    relationship: None,
    claim: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ExplanationOfBenefit#resource
pub type ExplanationofbenefitPayee {
  ExplanationofbenefitPayee(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Option(Codeableconcept),
    party: Option(Reference),
  )
}

pub fn explanationofbenefit_payee_new() -> ExplanationofbenefitPayee {
  ExplanationofbenefitPayee(
    party: None,
    type_: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ExplanationOfBenefit#resource
pub type ExplanationofbenefitCareteam {
  ExplanationofbenefitCareteam(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    sequence: Int,
    provider: Reference,
    responsible: Option(Bool),
    role: Option(Codeableconcept),
    qualification: Option(Codeableconcept),
  )
}

pub fn explanationofbenefit_careteam_new(
  provider provider: Reference,
  sequence sequence: Int,
) -> ExplanationofbenefitCareteam {
  ExplanationofbenefitCareteam(
    qualification: None,
    role: None,
    responsible: None,
    provider:,
    sequence:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ExplanationOfBenefit#resource
pub type ExplanationofbenefitSupportinginfo {
  ExplanationofbenefitSupportinginfo(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    sequence: Int,
    category: Codeableconcept,
    code: Option(Codeableconcept),
    timing: Option(ExplanationofbenefitSupportinginfoTiming),
    value: Option(ExplanationofbenefitSupportinginfoValue),
    reason: Option(Coding),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ExplanationOfBenefit#resource
pub type ExplanationofbenefitSupportinginfoTiming {
  ExplanationofbenefitSupportinginfoTimingDate(timing: String)
  ExplanationofbenefitSupportinginfoTimingPeriod(timing: Period)
}

pub fn explanationofbenefit_supportinginfo_timing_to_json(
  elt: ExplanationofbenefitSupportinginfoTiming,
) -> Json {
  case elt {
    ExplanationofbenefitSupportinginfoTimingDate(v) -> json.string(v)
    ExplanationofbenefitSupportinginfoTimingPeriod(v) -> period_to_json(v)
  }
}

pub fn explanationofbenefit_supportinginfo_timing_decoder() -> Decoder(
  ExplanationofbenefitSupportinginfoTiming,
) {
  decode.one_of(
    decode.field("timingDate", decode.string, decode.success)
      |> decode.map(ExplanationofbenefitSupportinginfoTimingDate),
    [
      decode.field("timingPeriod", period_decoder(), decode.success)
      |> decode.map(ExplanationofbenefitSupportinginfoTimingPeriod),
    ],
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ExplanationOfBenefit#resource
pub type ExplanationofbenefitSupportinginfoValue {
  ExplanationofbenefitSupportinginfoValueBoolean(value: Bool)
  ExplanationofbenefitSupportinginfoValueString(value: String)
  ExplanationofbenefitSupportinginfoValueQuantity(value: Quantity)
  ExplanationofbenefitSupportinginfoValueAttachment(value: Attachment)
  ExplanationofbenefitSupportinginfoValueReference(value: Reference)
}

pub fn explanationofbenefit_supportinginfo_value_to_json(
  elt: ExplanationofbenefitSupportinginfoValue,
) -> Json {
  case elt {
    ExplanationofbenefitSupportinginfoValueBoolean(v) -> json.bool(v)
    ExplanationofbenefitSupportinginfoValueString(v) -> json.string(v)
    ExplanationofbenefitSupportinginfoValueQuantity(v) -> quantity_to_json(v)
    ExplanationofbenefitSupportinginfoValueAttachment(v) ->
      attachment_to_json(v)
    ExplanationofbenefitSupportinginfoValueReference(v) -> reference_to_json(v)
  }
}

pub fn explanationofbenefit_supportinginfo_value_decoder() -> Decoder(
  ExplanationofbenefitSupportinginfoValue,
) {
  decode.one_of(
    decode.field("valueBoolean", decode.bool, decode.success)
      |> decode.map(ExplanationofbenefitSupportinginfoValueBoolean),
    [
      decode.field("valueString", decode.string, decode.success)
        |> decode.map(ExplanationofbenefitSupportinginfoValueString),
      decode.field("valueQuantity", quantity_decoder(), decode.success)
        |> decode.map(ExplanationofbenefitSupportinginfoValueQuantity),
      decode.field("valueAttachment", attachment_decoder(), decode.success)
        |> decode.map(ExplanationofbenefitSupportinginfoValueAttachment),
      decode.field("valueReference", reference_decoder(), decode.success)
        |> decode.map(ExplanationofbenefitSupportinginfoValueReference),
    ],
  )
}

pub fn explanationofbenefit_supportinginfo_new(
  category category: Codeableconcept,
  sequence sequence: Int,
) -> ExplanationofbenefitSupportinginfo {
  ExplanationofbenefitSupportinginfo(
    reason: None,
    value: None,
    timing: None,
    code: None,
    category:,
    sequence:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ExplanationOfBenefit#resource
pub type ExplanationofbenefitDiagnosis {
  ExplanationofbenefitDiagnosis(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    sequence: Int,
    diagnosis: ExplanationofbenefitDiagnosisDiagnosis,
    type_: List(Codeableconcept),
    on_admission: Option(Codeableconcept),
    package_code: Option(Codeableconcept),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ExplanationOfBenefit#resource
pub type ExplanationofbenefitDiagnosisDiagnosis {
  ExplanationofbenefitDiagnosisDiagnosisCodeableconcept(
    diagnosis: Codeableconcept,
  )
  ExplanationofbenefitDiagnosisDiagnosisReference(diagnosis: Reference)
}

pub fn explanationofbenefit_diagnosis_diagnosis_to_json(
  elt: ExplanationofbenefitDiagnosisDiagnosis,
) -> Json {
  case elt {
    ExplanationofbenefitDiagnosisDiagnosisCodeableconcept(v) ->
      codeableconcept_to_json(v)
    ExplanationofbenefitDiagnosisDiagnosisReference(v) -> reference_to_json(v)
  }
}

pub fn explanationofbenefit_diagnosis_diagnosis_decoder() -> Decoder(
  ExplanationofbenefitDiagnosisDiagnosis,
) {
  decode.one_of(
    decode.field(
      "diagnosisCodeableConcept",
      codeableconcept_decoder(),
      decode.success,
    )
      |> decode.map(ExplanationofbenefitDiagnosisDiagnosisCodeableconcept),
    [
      decode.field("diagnosisReference", reference_decoder(), decode.success)
      |> decode.map(ExplanationofbenefitDiagnosisDiagnosisReference),
    ],
  )
}

pub fn explanationofbenefit_diagnosis_new(
  diagnosis diagnosis: ExplanationofbenefitDiagnosisDiagnosis,
  sequence sequence: Int,
) -> ExplanationofbenefitDiagnosis {
  ExplanationofbenefitDiagnosis(
    package_code: None,
    on_admission: None,
    type_: [],
    diagnosis:,
    sequence:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ExplanationOfBenefit#resource
pub type ExplanationofbenefitProcedure {
  ExplanationofbenefitProcedure(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    sequence: Int,
    type_: List(Codeableconcept),
    date: Option(String),
    procedure: ExplanationofbenefitProcedureProcedure,
    udi: List(Reference),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ExplanationOfBenefit#resource
pub type ExplanationofbenefitProcedureProcedure {
  ExplanationofbenefitProcedureProcedureCodeableconcept(
    procedure: Codeableconcept,
  )
  ExplanationofbenefitProcedureProcedureReference(procedure: Reference)
}

pub fn explanationofbenefit_procedure_procedure_to_json(
  elt: ExplanationofbenefitProcedureProcedure,
) -> Json {
  case elt {
    ExplanationofbenefitProcedureProcedureCodeableconcept(v) ->
      codeableconcept_to_json(v)
    ExplanationofbenefitProcedureProcedureReference(v) -> reference_to_json(v)
  }
}

pub fn explanationofbenefit_procedure_procedure_decoder() -> Decoder(
  ExplanationofbenefitProcedureProcedure,
) {
  decode.one_of(
    decode.field(
      "procedureCodeableConcept",
      codeableconcept_decoder(),
      decode.success,
    )
      |> decode.map(ExplanationofbenefitProcedureProcedureCodeableconcept),
    [
      decode.field("procedureReference", reference_decoder(), decode.success)
      |> decode.map(ExplanationofbenefitProcedureProcedureReference),
    ],
  )
}

pub fn explanationofbenefit_procedure_new(
  procedure procedure: ExplanationofbenefitProcedureProcedure,
  sequence sequence: Int,
) -> ExplanationofbenefitProcedure {
  ExplanationofbenefitProcedure(
    udi: [],
    procedure:,
    date: None,
    type_: [],
    sequence:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ExplanationOfBenefit#resource
pub type ExplanationofbenefitInsurance {
  ExplanationofbenefitInsurance(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    focal: Bool,
    coverage: Reference,
    pre_auth_ref: List(String),
  )
}

pub fn explanationofbenefit_insurance_new(
  coverage coverage: Reference,
  focal focal: Bool,
) -> ExplanationofbenefitInsurance {
  ExplanationofbenefitInsurance(
    pre_auth_ref: [],
    coverage:,
    focal:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ExplanationOfBenefit#resource
pub type ExplanationofbenefitAccident {
  ExplanationofbenefitAccident(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    date: Option(String),
    type_: Option(Codeableconcept),
    location: Option(ExplanationofbenefitAccidentLocation),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ExplanationOfBenefit#resource
pub type ExplanationofbenefitAccidentLocation {
  ExplanationofbenefitAccidentLocationAddress(location: Address)
  ExplanationofbenefitAccidentLocationReference(location: Reference)
}

pub fn explanationofbenefit_accident_location_to_json(
  elt: ExplanationofbenefitAccidentLocation,
) -> Json {
  case elt {
    ExplanationofbenefitAccidentLocationAddress(v) -> address_to_json(v)
    ExplanationofbenefitAccidentLocationReference(v) -> reference_to_json(v)
  }
}

pub fn explanationofbenefit_accident_location_decoder() -> Decoder(
  ExplanationofbenefitAccidentLocation,
) {
  decode.one_of(
    decode.field("locationAddress", address_decoder(), decode.success)
      |> decode.map(ExplanationofbenefitAccidentLocationAddress),
    [
      decode.field("locationReference", reference_decoder(), decode.success)
      |> decode.map(ExplanationofbenefitAccidentLocationReference),
    ],
  )
}

pub fn explanationofbenefit_accident_new() -> ExplanationofbenefitAccident {
  ExplanationofbenefitAccident(
    location: None,
    type_: None,
    date: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ExplanationOfBenefit#resource
pub type ExplanationofbenefitItem {
  ExplanationofbenefitItem(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    sequence: Int,
    care_team_sequence: List(Int),
    diagnosis_sequence: List(Int),
    procedure_sequence: List(Int),
    information_sequence: List(Int),
    revenue: Option(Codeableconcept),
    category: Option(Codeableconcept),
    product_or_service: Codeableconcept,
    modifier: List(Codeableconcept),
    program_code: List(Codeableconcept),
    serviced: Option(ExplanationofbenefitItemServiced),
    location: Option(ExplanationofbenefitItemLocation),
    quantity: Option(Quantity),
    unit_price: Option(Money),
    factor: Option(Float),
    net: Option(Money),
    udi: List(Reference),
    body_site: Option(Codeableconcept),
    sub_site: List(Codeableconcept),
    encounter: List(Reference),
    note_number: List(Int),
    adjudication: List(ExplanationofbenefitItemAdjudication),
    detail: List(ExplanationofbenefitItemDetail),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ExplanationOfBenefit#resource
pub type ExplanationofbenefitItemServiced {
  ExplanationofbenefitItemServicedDate(serviced: String)
  ExplanationofbenefitItemServicedPeriod(serviced: Period)
}

pub fn explanationofbenefit_item_serviced_to_json(
  elt: ExplanationofbenefitItemServiced,
) -> Json {
  case elt {
    ExplanationofbenefitItemServicedDate(v) -> json.string(v)
    ExplanationofbenefitItemServicedPeriod(v) -> period_to_json(v)
  }
}

pub fn explanationofbenefit_item_serviced_decoder() -> Decoder(
  ExplanationofbenefitItemServiced,
) {
  decode.one_of(
    decode.field("servicedDate", decode.string, decode.success)
      |> decode.map(ExplanationofbenefitItemServicedDate),
    [
      decode.field("servicedPeriod", period_decoder(), decode.success)
      |> decode.map(ExplanationofbenefitItemServicedPeriod),
    ],
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ExplanationOfBenefit#resource
pub type ExplanationofbenefitItemLocation {
  ExplanationofbenefitItemLocationCodeableconcept(location: Codeableconcept)
  ExplanationofbenefitItemLocationAddress(location: Address)
  ExplanationofbenefitItemLocationReference(location: Reference)
}

pub fn explanationofbenefit_item_location_to_json(
  elt: ExplanationofbenefitItemLocation,
) -> Json {
  case elt {
    ExplanationofbenefitItemLocationCodeableconcept(v) ->
      codeableconcept_to_json(v)
    ExplanationofbenefitItemLocationAddress(v) -> address_to_json(v)
    ExplanationofbenefitItemLocationReference(v) -> reference_to_json(v)
  }
}

pub fn explanationofbenefit_item_location_decoder() -> Decoder(
  ExplanationofbenefitItemLocation,
) {
  decode.one_of(
    decode.field(
      "locationCodeableConcept",
      codeableconcept_decoder(),
      decode.success,
    )
      |> decode.map(ExplanationofbenefitItemLocationCodeableconcept),
    [
      decode.field("locationAddress", address_decoder(), decode.success)
        |> decode.map(ExplanationofbenefitItemLocationAddress),
      decode.field("locationReference", reference_decoder(), decode.success)
        |> decode.map(ExplanationofbenefitItemLocationReference),
    ],
  )
}

pub fn explanationofbenefit_item_new(
  product_or_service product_or_service: Codeableconcept,
  sequence sequence: Int,
) -> ExplanationofbenefitItem {
  ExplanationofbenefitItem(
    detail: [],
    adjudication: [],
    note_number: [],
    encounter: [],
    sub_site: [],
    body_site: None,
    udi: [],
    net: None,
    factor: None,
    unit_price: None,
    quantity: None,
    location: None,
    serviced: None,
    program_code: [],
    modifier: [],
    product_or_service:,
    category: None,
    revenue: None,
    information_sequence: [],
    procedure_sequence: [],
    diagnosis_sequence: [],
    care_team_sequence: [],
    sequence:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ExplanationOfBenefit#resource
pub type ExplanationofbenefitItemAdjudication {
  ExplanationofbenefitItemAdjudication(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    category: Codeableconcept,
    reason: Option(Codeableconcept),
    amount: Option(Money),
    value: Option(Float),
  )
}

pub fn explanationofbenefit_item_adjudication_new(
  category category: Codeableconcept,
) -> ExplanationofbenefitItemAdjudication {
  ExplanationofbenefitItemAdjudication(
    value: None,
    amount: None,
    reason: None,
    category:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ExplanationOfBenefit#resource
pub type ExplanationofbenefitItemDetail {
  ExplanationofbenefitItemDetail(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    sequence: Int,
    revenue: Option(Codeableconcept),
    category: Option(Codeableconcept),
    product_or_service: Codeableconcept,
    modifier: List(Codeableconcept),
    program_code: List(Codeableconcept),
    quantity: Option(Quantity),
    unit_price: Option(Money),
    factor: Option(Float),
    net: Option(Money),
    udi: List(Reference),
    note_number: List(Int),
    sub_detail: List(ExplanationofbenefitItemDetailSubdetail),
  )
}

pub fn explanationofbenefit_item_detail_new(
  product_or_service product_or_service: Codeableconcept,
  sequence sequence: Int,
) -> ExplanationofbenefitItemDetail {
  ExplanationofbenefitItemDetail(
    sub_detail: [],
    note_number: [],
    udi: [],
    net: None,
    factor: None,
    unit_price: None,
    quantity: None,
    program_code: [],
    modifier: [],
    product_or_service:,
    category: None,
    revenue: None,
    sequence:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ExplanationOfBenefit#resource
pub type ExplanationofbenefitItemDetailSubdetail {
  ExplanationofbenefitItemDetailSubdetail(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    sequence: Int,
    revenue: Option(Codeableconcept),
    category: Option(Codeableconcept),
    product_or_service: Codeableconcept,
    modifier: List(Codeableconcept),
    program_code: List(Codeableconcept),
    quantity: Option(Quantity),
    unit_price: Option(Money),
    factor: Option(Float),
    net: Option(Money),
    udi: List(Reference),
    note_number: List(Int),
  )
}

pub fn explanationofbenefit_item_detail_subdetail_new(
  product_or_service product_or_service: Codeableconcept,
  sequence sequence: Int,
) -> ExplanationofbenefitItemDetailSubdetail {
  ExplanationofbenefitItemDetailSubdetail(
    note_number: [],
    udi: [],
    net: None,
    factor: None,
    unit_price: None,
    quantity: None,
    program_code: [],
    modifier: [],
    product_or_service:,
    category: None,
    revenue: None,
    sequence:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ExplanationOfBenefit#resource
pub type ExplanationofbenefitAdditem {
  ExplanationofbenefitAdditem(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    item_sequence: List(Int),
    detail_sequence: List(Int),
    sub_detail_sequence: List(Int),
    provider: List(Reference),
    product_or_service: Codeableconcept,
    modifier: List(Codeableconcept),
    program_code: List(Codeableconcept),
    serviced: Option(ExplanationofbenefitAdditemServiced),
    location: Option(ExplanationofbenefitAdditemLocation),
    quantity: Option(Quantity),
    unit_price: Option(Money),
    factor: Option(Float),
    net: Option(Money),
    body_site: Option(Codeableconcept),
    sub_site: List(Codeableconcept),
    note_number: List(Int),
    detail: List(ExplanationofbenefitAdditemDetail),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ExplanationOfBenefit#resource
pub type ExplanationofbenefitAdditemServiced {
  ExplanationofbenefitAdditemServicedDate(serviced: String)
  ExplanationofbenefitAdditemServicedPeriod(serviced: Period)
}

pub fn explanationofbenefit_additem_serviced_to_json(
  elt: ExplanationofbenefitAdditemServiced,
) -> Json {
  case elt {
    ExplanationofbenefitAdditemServicedDate(v) -> json.string(v)
    ExplanationofbenefitAdditemServicedPeriod(v) -> period_to_json(v)
  }
}

pub fn explanationofbenefit_additem_serviced_decoder() -> Decoder(
  ExplanationofbenefitAdditemServiced,
) {
  decode.one_of(
    decode.field("servicedDate", decode.string, decode.success)
      |> decode.map(ExplanationofbenefitAdditemServicedDate),
    [
      decode.field("servicedPeriod", period_decoder(), decode.success)
      |> decode.map(ExplanationofbenefitAdditemServicedPeriod),
    ],
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ExplanationOfBenefit#resource
pub type ExplanationofbenefitAdditemLocation {
  ExplanationofbenefitAdditemLocationCodeableconcept(location: Codeableconcept)
  ExplanationofbenefitAdditemLocationAddress(location: Address)
  ExplanationofbenefitAdditemLocationReference(location: Reference)
}

pub fn explanationofbenefit_additem_location_to_json(
  elt: ExplanationofbenefitAdditemLocation,
) -> Json {
  case elt {
    ExplanationofbenefitAdditemLocationCodeableconcept(v) ->
      codeableconcept_to_json(v)
    ExplanationofbenefitAdditemLocationAddress(v) -> address_to_json(v)
    ExplanationofbenefitAdditemLocationReference(v) -> reference_to_json(v)
  }
}

pub fn explanationofbenefit_additem_location_decoder() -> Decoder(
  ExplanationofbenefitAdditemLocation,
) {
  decode.one_of(
    decode.field(
      "locationCodeableConcept",
      codeableconcept_decoder(),
      decode.success,
    )
      |> decode.map(ExplanationofbenefitAdditemLocationCodeableconcept),
    [
      decode.field("locationAddress", address_decoder(), decode.success)
        |> decode.map(ExplanationofbenefitAdditemLocationAddress),
      decode.field("locationReference", reference_decoder(), decode.success)
        |> decode.map(ExplanationofbenefitAdditemLocationReference),
    ],
  )
}

pub fn explanationofbenefit_additem_new(
  product_or_service product_or_service: Codeableconcept,
) -> ExplanationofbenefitAdditem {
  ExplanationofbenefitAdditem(
    detail: [],
    note_number: [],
    sub_site: [],
    body_site: None,
    net: None,
    factor: None,
    unit_price: None,
    quantity: None,
    location: None,
    serviced: None,
    program_code: [],
    modifier: [],
    product_or_service:,
    provider: [],
    sub_detail_sequence: [],
    detail_sequence: [],
    item_sequence: [],
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ExplanationOfBenefit#resource
pub type ExplanationofbenefitAdditemDetail {
  ExplanationofbenefitAdditemDetail(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    product_or_service: Codeableconcept,
    modifier: List(Codeableconcept),
    quantity: Option(Quantity),
    unit_price: Option(Money),
    factor: Option(Float),
    net: Option(Money),
    note_number: List(Int),
    sub_detail: List(ExplanationofbenefitAdditemDetailSubdetail),
  )
}

pub fn explanationofbenefit_additem_detail_new(
  product_or_service product_or_service: Codeableconcept,
) -> ExplanationofbenefitAdditemDetail {
  ExplanationofbenefitAdditemDetail(
    sub_detail: [],
    note_number: [],
    net: None,
    factor: None,
    unit_price: None,
    quantity: None,
    modifier: [],
    product_or_service:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ExplanationOfBenefit#resource
pub type ExplanationofbenefitAdditemDetailSubdetail {
  ExplanationofbenefitAdditemDetailSubdetail(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    product_or_service: Codeableconcept,
    modifier: List(Codeableconcept),
    quantity: Option(Quantity),
    unit_price: Option(Money),
    factor: Option(Float),
    net: Option(Money),
    note_number: List(Int),
  )
}

pub fn explanationofbenefit_additem_detail_subdetail_new(
  product_or_service product_or_service: Codeableconcept,
) -> ExplanationofbenefitAdditemDetailSubdetail {
  ExplanationofbenefitAdditemDetailSubdetail(
    note_number: [],
    net: None,
    factor: None,
    unit_price: None,
    quantity: None,
    modifier: [],
    product_or_service:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ExplanationOfBenefit#resource
pub type ExplanationofbenefitTotal {
  ExplanationofbenefitTotal(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    category: Codeableconcept,
    amount: Money,
  )
}

pub fn explanationofbenefit_total_new(
  amount amount: Money,
  category category: Codeableconcept,
) -> ExplanationofbenefitTotal {
  ExplanationofbenefitTotal(
    amount:,
    category:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ExplanationOfBenefit#resource
pub type ExplanationofbenefitPayment {
  ExplanationofbenefitPayment(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Option(Codeableconcept),
    adjustment: Option(Money),
    adjustment_reason: Option(Codeableconcept),
    date: Option(String),
    amount: Option(Money),
    identifier: Option(Identifier),
  )
}

pub fn explanationofbenefit_payment_new() -> ExplanationofbenefitPayment {
  ExplanationofbenefitPayment(
    identifier: None,
    amount: None,
    date: None,
    adjustment_reason: None,
    adjustment: None,
    type_: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ExplanationOfBenefit#resource
pub type ExplanationofbenefitProcessnote {
  ExplanationofbenefitProcessnote(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    number: Option(Int),
    type_: Option(r4bvaluesets.Notetype),
    text: Option(String),
    language: Option(Codeableconcept),
  )
}

pub fn explanationofbenefit_processnote_new() -> ExplanationofbenefitProcessnote {
  ExplanationofbenefitProcessnote(
    language: None,
    text: None,
    type_: None,
    number: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ExplanationOfBenefit#resource
pub type ExplanationofbenefitBenefitbalance {
  ExplanationofbenefitBenefitbalance(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    category: Codeableconcept,
    excluded: Option(Bool),
    name: Option(String),
    description: Option(String),
    network: Option(Codeableconcept),
    unit: Option(Codeableconcept),
    term: Option(Codeableconcept),
    financial: List(ExplanationofbenefitBenefitbalanceFinancial),
  )
}

pub fn explanationofbenefit_benefitbalance_new(
  category category: Codeableconcept,
) -> ExplanationofbenefitBenefitbalance {
  ExplanationofbenefitBenefitbalance(
    financial: [],
    term: None,
    unit: None,
    network: None,
    description: None,
    name: None,
    excluded: None,
    category:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ExplanationOfBenefit#resource
pub type ExplanationofbenefitBenefitbalanceFinancial {
  ExplanationofbenefitBenefitbalanceFinancial(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Codeableconcept,
    allowed: Option(ExplanationofbenefitBenefitbalanceFinancialAllowed),
    used: Option(ExplanationofbenefitBenefitbalanceFinancialUsed),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ExplanationOfBenefit#resource
pub type ExplanationofbenefitBenefitbalanceFinancialAllowed {
  ExplanationofbenefitBenefitbalanceFinancialAllowedUnsignedint(allowed: Int)
  ExplanationofbenefitBenefitbalanceFinancialAllowedString(allowed: String)
  ExplanationofbenefitBenefitbalanceFinancialAllowedMoney(allowed: Money)
}

pub fn explanationofbenefit_benefitbalance_financial_allowed_to_json(
  elt: ExplanationofbenefitBenefitbalanceFinancialAllowed,
) -> Json {
  case elt {
    ExplanationofbenefitBenefitbalanceFinancialAllowedUnsignedint(v) ->
      json.int(v)
    ExplanationofbenefitBenefitbalanceFinancialAllowedString(v) ->
      json.string(v)
    ExplanationofbenefitBenefitbalanceFinancialAllowedMoney(v) ->
      money_to_json(v)
  }
}

pub fn explanationofbenefit_benefitbalance_financial_allowed_decoder() -> Decoder(
  ExplanationofbenefitBenefitbalanceFinancialAllowed,
) {
  decode.one_of(
    decode.field("allowedUnsignedInt", decode.int, decode.success)
      |> decode.map(
        ExplanationofbenefitBenefitbalanceFinancialAllowedUnsignedint,
      ),
    [
      decode.field("allowedString", decode.string, decode.success)
        |> decode.map(ExplanationofbenefitBenefitbalanceFinancialAllowedString),
      decode.field("allowedMoney", money_decoder(), decode.success)
        |> decode.map(ExplanationofbenefitBenefitbalanceFinancialAllowedMoney),
    ],
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ExplanationOfBenefit#resource
pub type ExplanationofbenefitBenefitbalanceFinancialUsed {
  ExplanationofbenefitBenefitbalanceFinancialUsedUnsignedint(used: Int)
  ExplanationofbenefitBenefitbalanceFinancialUsedMoney(used: Money)
}

pub fn explanationofbenefit_benefitbalance_financial_used_to_json(
  elt: ExplanationofbenefitBenefitbalanceFinancialUsed,
) -> Json {
  case elt {
    ExplanationofbenefitBenefitbalanceFinancialUsedUnsignedint(v) -> json.int(v)
    ExplanationofbenefitBenefitbalanceFinancialUsedMoney(v) -> money_to_json(v)
  }
}

pub fn explanationofbenefit_benefitbalance_financial_used_decoder() -> Decoder(
  ExplanationofbenefitBenefitbalanceFinancialUsed,
) {
  decode.one_of(
    decode.field("usedUnsignedInt", decode.int, decode.success)
      |> decode.map(ExplanationofbenefitBenefitbalanceFinancialUsedUnsignedint),
    [
      decode.field("usedMoney", money_decoder(), decode.success)
      |> decode.map(ExplanationofbenefitBenefitbalanceFinancialUsedMoney),
    ],
  )
}

pub fn explanationofbenefit_benefitbalance_financial_new(
  type_ type_: Codeableconcept,
) -> ExplanationofbenefitBenefitbalanceFinancial {
  ExplanationofbenefitBenefitbalanceFinancial(
    used: None,
    allowed: None,
    type_:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn explanationofbenefit_benefitbalance_financial_to_json(
  explanationofbenefit_benefitbalance_financial: ExplanationofbenefitBenefitbalanceFinancial,
) -> Json {
  let ExplanationofbenefitBenefitbalanceFinancial(
    used:,
    allowed:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = explanationofbenefit_benefitbalance_financial
  let fields = [
    #("type", codeableconcept_to_json(type_)),
  ]
  let fields = case used {
    Some(v) -> [
      #(
        "used"
          <> case v {
          ExplanationofbenefitBenefitbalanceFinancialUsedUnsignedint(_) ->
            "Unsignedint"
          ExplanationofbenefitBenefitbalanceFinancialUsedMoney(_) -> "Money"
        },
        explanationofbenefit_benefitbalance_financial_used_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case allowed {
    Some(v) -> [
      #(
        "allowed"
          <> case v {
          ExplanationofbenefitBenefitbalanceFinancialAllowedUnsignedint(_) ->
            "Unsignedint"
          ExplanationofbenefitBenefitbalanceFinancialAllowedString(_) ->
            "String"
          ExplanationofbenefitBenefitbalanceFinancialAllowedMoney(_) -> "Money"
        },
        explanationofbenefit_benefitbalance_financial_allowed_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn explanationofbenefit_benefitbalance_financial_decoder() -> Decoder(
  ExplanationofbenefitBenefitbalanceFinancial,
) {
  use used <- decode.then(
    none_if_omitted(
      explanationofbenefit_benefitbalance_financial_used_decoder(),
    ),
  )
  use allowed <- decode.then(
    none_if_omitted(
      explanationofbenefit_benefitbalance_financial_allowed_decoder(),
    ),
  )
  use type_ <- decode.field("type", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ExplanationofbenefitBenefitbalanceFinancial(
    used:,
    allowed:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn explanationofbenefit_benefitbalance_to_json(
  explanationofbenefit_benefitbalance: ExplanationofbenefitBenefitbalance,
) -> Json {
  let ExplanationofbenefitBenefitbalance(
    financial:,
    term:,
    unit:,
    network:,
    description:,
    name:,
    excluded:,
    category:,
    modifier_extension:,
    extension:,
    id:,
  ) = explanationofbenefit_benefitbalance
  let fields = [
    #("category", codeableconcept_to_json(category)),
  ]
  let fields = case financial {
    [] -> fields
    _ -> [
      #(
        "financial",
        json.array(
          financial,
          explanationofbenefit_benefitbalance_financial_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case term {
    Some(v) -> [#("term", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case unit {
    Some(v) -> [#("unit", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case network {
    Some(v) -> [#("network", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case excluded {
    Some(v) -> [#("excluded", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn explanationofbenefit_benefitbalance_decoder() -> Decoder(
  ExplanationofbenefitBenefitbalance,
) {
  use financial <- decode.optional_field(
    "financial",
    [],
    decode.list(explanationofbenefit_benefitbalance_financial_decoder()),
  )
  use term <- decode.optional_field(
    "term",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use unit <- decode.optional_field(
    "unit",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use network <- decode.optional_field(
    "network",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use excluded <- decode.optional_field(
    "excluded",
    None,
    decode.optional(decode.bool),
  )
  use category <- decode.field("category", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ExplanationofbenefitBenefitbalance(
    financial:,
    term:,
    unit:,
    network:,
    description:,
    name:,
    excluded:,
    category:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn explanationofbenefit_processnote_to_json(
  explanationofbenefit_processnote: ExplanationofbenefitProcessnote,
) -> Json {
  let ExplanationofbenefitProcessnote(
    language:,
    text:,
    type_:,
    number:,
    modifier_extension:,
    extension:,
    id:,
  ) = explanationofbenefit_processnote
  let fields = []
  let fields = case language {
    Some(v) -> [#("language", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case text {
    Some(v) -> [#("text", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", r4bvaluesets.notetype_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case number {
    Some(v) -> [#("number", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn explanationofbenefit_processnote_decoder() -> Decoder(
  ExplanationofbenefitProcessnote,
) {
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(decode.string),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(r4bvaluesets.notetype_decoder()),
  )
  use number <- decode.optional_field(
    "number",
    None,
    decode.optional(decode.int),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ExplanationofbenefitProcessnote(
    language:,
    text:,
    type_:,
    number:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn explanationofbenefit_payment_to_json(
  explanationofbenefit_payment: ExplanationofbenefitPayment,
) -> Json {
  let ExplanationofbenefitPayment(
    identifier:,
    amount:,
    date:,
    adjustment_reason:,
    adjustment:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = explanationofbenefit_payment
  let fields = []
  let fields = case identifier {
    Some(v) -> [#("identifier", identifier_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case amount {
    Some(v) -> [#("amount", money_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case date {
    Some(v) -> [#("date", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case adjustment_reason {
    Some(v) -> [#("adjustmentReason", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case adjustment {
    Some(v) -> [#("adjustment", money_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn explanationofbenefit_payment_decoder() -> Decoder(
  ExplanationofbenefitPayment,
) {
  use identifier <- decode.optional_field(
    "identifier",
    None,
    decode.optional(identifier_decoder()),
  )
  use amount <- decode.optional_field(
    "amount",
    None,
    decode.optional(money_decoder()),
  )
  use date <- decode.optional_field(
    "date",
    None,
    decode.optional(decode.string),
  )
  use adjustment_reason <- decode.optional_field(
    "adjustmentReason",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use adjustment <- decode.optional_field(
    "adjustment",
    None,
    decode.optional(money_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ExplanationofbenefitPayment(
    identifier:,
    amount:,
    date:,
    adjustment_reason:,
    adjustment:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn explanationofbenefit_total_to_json(
  explanationofbenefit_total: ExplanationofbenefitTotal,
) -> Json {
  let ExplanationofbenefitTotal(
    amount:,
    category:,
    modifier_extension:,
    extension:,
    id:,
  ) = explanationofbenefit_total
  let fields = [
    #("amount", money_to_json(amount)),
    #("category", codeableconcept_to_json(category)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn explanationofbenefit_total_decoder() -> Decoder(
  ExplanationofbenefitTotal,
) {
  use amount <- decode.field("amount", money_decoder())
  use category <- decode.field("category", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ExplanationofbenefitTotal(
    amount:,
    category:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn explanationofbenefit_additem_detail_subdetail_to_json(
  explanationofbenefit_additem_detail_subdetail: ExplanationofbenefitAdditemDetailSubdetail,
) -> Json {
  let ExplanationofbenefitAdditemDetailSubdetail(
    note_number:,
    net:,
    factor:,
    unit_price:,
    quantity:,
    modifier:,
    product_or_service:,
    modifier_extension:,
    extension:,
    id:,
  ) = explanationofbenefit_additem_detail_subdetail
  let fields = [
    #("productOrService", codeableconcept_to_json(product_or_service)),
  ]
  let fields = case note_number {
    [] -> fields
    _ -> [#("noteNumber", json.array(note_number, json.int)), ..fields]
  }
  let fields = case net {
    Some(v) -> [#("net", money_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case factor {
    Some(v) -> [#("factor", json.float(v)), ..fields]
    None -> fields
  }
  let fields = case unit_price {
    Some(v) -> [#("unitPrice", money_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case quantity {
    Some(v) -> [#("quantity", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier {
    [] -> fields
    _ -> [
      #("modifier", json.array(modifier, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn explanationofbenefit_additem_detail_subdetail_decoder() -> Decoder(
  ExplanationofbenefitAdditemDetailSubdetail,
) {
  use note_number <- decode.optional_field(
    "noteNumber",
    [],
    decode.list(decode.int),
  )
  use net <- decode.optional_field(
    "net",
    None,
    decode.optional(money_decoder()),
  )
  use factor <- decode.optional_field(
    "factor",
    None,
    decode.optional(decode.float),
  )
  use unit_price <- decode.optional_field(
    "unitPrice",
    None,
    decode.optional(money_decoder()),
  )
  use quantity <- decode.optional_field(
    "quantity",
    None,
    decode.optional(quantity_decoder()),
  )
  use modifier <- decode.optional_field(
    "modifier",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use product_or_service <- decode.field(
    "productOrService",
    codeableconcept_decoder(),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ExplanationofbenefitAdditemDetailSubdetail(
    note_number:,
    net:,
    factor:,
    unit_price:,
    quantity:,
    modifier:,
    product_or_service:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn explanationofbenefit_additem_detail_to_json(
  explanationofbenefit_additem_detail: ExplanationofbenefitAdditemDetail,
) -> Json {
  let ExplanationofbenefitAdditemDetail(
    sub_detail:,
    note_number:,
    net:,
    factor:,
    unit_price:,
    quantity:,
    modifier:,
    product_or_service:,
    modifier_extension:,
    extension:,
    id:,
  ) = explanationofbenefit_additem_detail
  let fields = [
    #("productOrService", codeableconcept_to_json(product_or_service)),
  ]
  let fields = case sub_detail {
    [] -> fields
    _ -> [
      #(
        "subDetail",
        json.array(
          sub_detail,
          explanationofbenefit_additem_detail_subdetail_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case note_number {
    [] -> fields
    _ -> [#("noteNumber", json.array(note_number, json.int)), ..fields]
  }
  let fields = case net {
    Some(v) -> [#("net", money_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case factor {
    Some(v) -> [#("factor", json.float(v)), ..fields]
    None -> fields
  }
  let fields = case unit_price {
    Some(v) -> [#("unitPrice", money_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case quantity {
    Some(v) -> [#("quantity", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier {
    [] -> fields
    _ -> [
      #("modifier", json.array(modifier, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn explanationofbenefit_additem_detail_decoder() -> Decoder(
  ExplanationofbenefitAdditemDetail,
) {
  use sub_detail <- decode.optional_field(
    "subDetail",
    [],
    decode.list(explanationofbenefit_additem_detail_subdetail_decoder()),
  )
  use note_number <- decode.optional_field(
    "noteNumber",
    [],
    decode.list(decode.int),
  )
  use net <- decode.optional_field(
    "net",
    None,
    decode.optional(money_decoder()),
  )
  use factor <- decode.optional_field(
    "factor",
    None,
    decode.optional(decode.float),
  )
  use unit_price <- decode.optional_field(
    "unitPrice",
    None,
    decode.optional(money_decoder()),
  )
  use quantity <- decode.optional_field(
    "quantity",
    None,
    decode.optional(quantity_decoder()),
  )
  use modifier <- decode.optional_field(
    "modifier",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use product_or_service <- decode.field(
    "productOrService",
    codeableconcept_decoder(),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ExplanationofbenefitAdditemDetail(
    sub_detail:,
    note_number:,
    net:,
    factor:,
    unit_price:,
    quantity:,
    modifier:,
    product_or_service:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn explanationofbenefit_additem_to_json(
  explanationofbenefit_additem: ExplanationofbenefitAdditem,
) -> Json {
  let ExplanationofbenefitAdditem(
    detail:,
    note_number:,
    sub_site:,
    body_site:,
    net:,
    factor:,
    unit_price:,
    quantity:,
    location:,
    serviced:,
    program_code:,
    modifier:,
    product_or_service:,
    provider:,
    sub_detail_sequence:,
    detail_sequence:,
    item_sequence:,
    modifier_extension:,
    extension:,
    id:,
  ) = explanationofbenefit_additem
  let fields = [
    #("productOrService", codeableconcept_to_json(product_or_service)),
  ]
  let fields = case detail {
    [] -> fields
    _ -> [
      #(
        "detail",
        json.array(detail, explanationofbenefit_additem_detail_to_json),
      ),
      ..fields
    ]
  }
  let fields = case note_number {
    [] -> fields
    _ -> [#("noteNumber", json.array(note_number, json.int)), ..fields]
  }
  let fields = case sub_site {
    [] -> fields
    _ -> [#("subSite", json.array(sub_site, codeableconcept_to_json)), ..fields]
  }
  let fields = case body_site {
    Some(v) -> [#("bodySite", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case net {
    Some(v) -> [#("net", money_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case factor {
    Some(v) -> [#("factor", json.float(v)), ..fields]
    None -> fields
  }
  let fields = case unit_price {
    Some(v) -> [#("unitPrice", money_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case quantity {
    Some(v) -> [#("quantity", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case location {
    Some(v) -> [
      #(
        "location"
          <> case v {
          ExplanationofbenefitAdditemLocationCodeableconcept(_) ->
            "Codeableconcept"
          ExplanationofbenefitAdditemLocationAddress(_) -> "Address"
          ExplanationofbenefitAdditemLocationReference(_) -> "Reference"
        },
        explanationofbenefit_additem_location_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case serviced {
    Some(v) -> [
      #(
        "serviced"
          <> case v {
          ExplanationofbenefitAdditemServicedDate(_) -> "Date"
          ExplanationofbenefitAdditemServicedPeriod(_) -> "Period"
        },
        explanationofbenefit_additem_serviced_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case program_code {
    [] -> fields
    _ -> [
      #("programCode", json.array(program_code, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case modifier {
    [] -> fields
    _ -> [
      #("modifier", json.array(modifier, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case provider {
    [] -> fields
    _ -> [#("provider", json.array(provider, reference_to_json)), ..fields]
  }
  let fields = case sub_detail_sequence {
    [] -> fields
    _ -> [
      #("subDetailSequence", json.array(sub_detail_sequence, json.int)),
      ..fields
    ]
  }
  let fields = case detail_sequence {
    [] -> fields
    _ -> [#("detailSequence", json.array(detail_sequence, json.int)), ..fields]
  }
  let fields = case item_sequence {
    [] -> fields
    _ -> [#("itemSequence", json.array(item_sequence, json.int)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn explanationofbenefit_additem_decoder() -> Decoder(
  ExplanationofbenefitAdditem,
) {
  use detail <- decode.optional_field(
    "detail",
    [],
    decode.list(explanationofbenefit_additem_detail_decoder()),
  )
  use note_number <- decode.optional_field(
    "noteNumber",
    [],
    decode.list(decode.int),
  )
  use sub_site <- decode.optional_field(
    "subSite",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use body_site <- decode.optional_field(
    "bodySite",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use net <- decode.optional_field(
    "net",
    None,
    decode.optional(money_decoder()),
  )
  use factor <- decode.optional_field(
    "factor",
    None,
    decode.optional(decode.float),
  )
  use unit_price <- decode.optional_field(
    "unitPrice",
    None,
    decode.optional(money_decoder()),
  )
  use quantity <- decode.optional_field(
    "quantity",
    None,
    decode.optional(quantity_decoder()),
  )
  use location <- decode.then(
    none_if_omitted(explanationofbenefit_additem_location_decoder()),
  )
  use serviced <- decode.then(
    none_if_omitted(explanationofbenefit_additem_serviced_decoder()),
  )
  use program_code <- decode.optional_field(
    "programCode",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use modifier <- decode.optional_field(
    "modifier",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use product_or_service <- decode.field(
    "productOrService",
    codeableconcept_decoder(),
  )
  use provider <- decode.optional_field(
    "provider",
    [],
    decode.list(reference_decoder()),
  )
  use sub_detail_sequence <- decode.optional_field(
    "subDetailSequence",
    [],
    decode.list(decode.int),
  )
  use detail_sequence <- decode.optional_field(
    "detailSequence",
    [],
    decode.list(decode.int),
  )
  use item_sequence <- decode.optional_field(
    "itemSequence",
    [],
    decode.list(decode.int),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ExplanationofbenefitAdditem(
    detail:,
    note_number:,
    sub_site:,
    body_site:,
    net:,
    factor:,
    unit_price:,
    quantity:,
    location:,
    serviced:,
    program_code:,
    modifier:,
    product_or_service:,
    provider:,
    sub_detail_sequence:,
    detail_sequence:,
    item_sequence:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn explanationofbenefit_item_detail_subdetail_to_json(
  explanationofbenefit_item_detail_subdetail: ExplanationofbenefitItemDetailSubdetail,
) -> Json {
  let ExplanationofbenefitItemDetailSubdetail(
    note_number:,
    udi:,
    net:,
    factor:,
    unit_price:,
    quantity:,
    program_code:,
    modifier:,
    product_or_service:,
    category:,
    revenue:,
    sequence:,
    modifier_extension:,
    extension:,
    id:,
  ) = explanationofbenefit_item_detail_subdetail
  let fields = [
    #("productOrService", codeableconcept_to_json(product_or_service)),
    #("sequence", json.int(sequence)),
  ]
  let fields = case note_number {
    [] -> fields
    _ -> [#("noteNumber", json.array(note_number, json.int)), ..fields]
  }
  let fields = case udi {
    [] -> fields
    _ -> [#("udi", json.array(udi, reference_to_json)), ..fields]
  }
  let fields = case net {
    Some(v) -> [#("net", money_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case factor {
    Some(v) -> [#("factor", json.float(v)), ..fields]
    None -> fields
  }
  let fields = case unit_price {
    Some(v) -> [#("unitPrice", money_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case quantity {
    Some(v) -> [#("quantity", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case program_code {
    [] -> fields
    _ -> [
      #("programCode", json.array(program_code, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case modifier {
    [] -> fields
    _ -> [
      #("modifier", json.array(modifier, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case category {
    Some(v) -> [#("category", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case revenue {
    Some(v) -> [#("revenue", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn explanationofbenefit_item_detail_subdetail_decoder() -> Decoder(
  ExplanationofbenefitItemDetailSubdetail,
) {
  use note_number <- decode.optional_field(
    "noteNumber",
    [],
    decode.list(decode.int),
  )
  use udi <- decode.optional_field("udi", [], decode.list(reference_decoder()))
  use net <- decode.optional_field(
    "net",
    None,
    decode.optional(money_decoder()),
  )
  use factor <- decode.optional_field(
    "factor",
    None,
    decode.optional(decode.float),
  )
  use unit_price <- decode.optional_field(
    "unitPrice",
    None,
    decode.optional(money_decoder()),
  )
  use quantity <- decode.optional_field(
    "quantity",
    None,
    decode.optional(quantity_decoder()),
  )
  use program_code <- decode.optional_field(
    "programCode",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use modifier <- decode.optional_field(
    "modifier",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use product_or_service <- decode.field(
    "productOrService",
    codeableconcept_decoder(),
  )
  use category <- decode.optional_field(
    "category",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use revenue <- decode.optional_field(
    "revenue",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use sequence <- decode.field("sequence", decode.int)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ExplanationofbenefitItemDetailSubdetail(
    note_number:,
    udi:,
    net:,
    factor:,
    unit_price:,
    quantity:,
    program_code:,
    modifier:,
    product_or_service:,
    category:,
    revenue:,
    sequence:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn explanationofbenefit_item_detail_to_json(
  explanationofbenefit_item_detail: ExplanationofbenefitItemDetail,
) -> Json {
  let ExplanationofbenefitItemDetail(
    sub_detail:,
    note_number:,
    udi:,
    net:,
    factor:,
    unit_price:,
    quantity:,
    program_code:,
    modifier:,
    product_or_service:,
    category:,
    revenue:,
    sequence:,
    modifier_extension:,
    extension:,
    id:,
  ) = explanationofbenefit_item_detail
  let fields = [
    #("productOrService", codeableconcept_to_json(product_or_service)),
    #("sequence", json.int(sequence)),
  ]
  let fields = case sub_detail {
    [] -> fields
    _ -> [
      #(
        "subDetail",
        json.array(
          sub_detail,
          explanationofbenefit_item_detail_subdetail_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case note_number {
    [] -> fields
    _ -> [#("noteNumber", json.array(note_number, json.int)), ..fields]
  }
  let fields = case udi {
    [] -> fields
    _ -> [#("udi", json.array(udi, reference_to_json)), ..fields]
  }
  let fields = case net {
    Some(v) -> [#("net", money_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case factor {
    Some(v) -> [#("factor", json.float(v)), ..fields]
    None -> fields
  }
  let fields = case unit_price {
    Some(v) -> [#("unitPrice", money_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case quantity {
    Some(v) -> [#("quantity", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case program_code {
    [] -> fields
    _ -> [
      #("programCode", json.array(program_code, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case modifier {
    [] -> fields
    _ -> [
      #("modifier", json.array(modifier, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case category {
    Some(v) -> [#("category", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case revenue {
    Some(v) -> [#("revenue", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn explanationofbenefit_item_detail_decoder() -> Decoder(
  ExplanationofbenefitItemDetail,
) {
  use sub_detail <- decode.optional_field(
    "subDetail",
    [],
    decode.list(explanationofbenefit_item_detail_subdetail_decoder()),
  )
  use note_number <- decode.optional_field(
    "noteNumber",
    [],
    decode.list(decode.int),
  )
  use udi <- decode.optional_field("udi", [], decode.list(reference_decoder()))
  use net <- decode.optional_field(
    "net",
    None,
    decode.optional(money_decoder()),
  )
  use factor <- decode.optional_field(
    "factor",
    None,
    decode.optional(decode.float),
  )
  use unit_price <- decode.optional_field(
    "unitPrice",
    None,
    decode.optional(money_decoder()),
  )
  use quantity <- decode.optional_field(
    "quantity",
    None,
    decode.optional(quantity_decoder()),
  )
  use program_code <- decode.optional_field(
    "programCode",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use modifier <- decode.optional_field(
    "modifier",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use product_or_service <- decode.field(
    "productOrService",
    codeableconcept_decoder(),
  )
  use category <- decode.optional_field(
    "category",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use revenue <- decode.optional_field(
    "revenue",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use sequence <- decode.field("sequence", decode.int)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ExplanationofbenefitItemDetail(
    sub_detail:,
    note_number:,
    udi:,
    net:,
    factor:,
    unit_price:,
    quantity:,
    program_code:,
    modifier:,
    product_or_service:,
    category:,
    revenue:,
    sequence:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn explanationofbenefit_item_adjudication_to_json(
  explanationofbenefit_item_adjudication: ExplanationofbenefitItemAdjudication,
) -> Json {
  let ExplanationofbenefitItemAdjudication(
    value:,
    amount:,
    reason:,
    category:,
    modifier_extension:,
    extension:,
    id:,
  ) = explanationofbenefit_item_adjudication
  let fields = [
    #("category", codeableconcept_to_json(category)),
  ]
  let fields = case value {
    Some(v) -> [#("value", json.float(v)), ..fields]
    None -> fields
  }
  let fields = case amount {
    Some(v) -> [#("amount", money_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case reason {
    Some(v) -> [#("reason", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn explanationofbenefit_item_adjudication_decoder() -> Decoder(
  ExplanationofbenefitItemAdjudication,
) {
  use value <- decode.optional_field(
    "value",
    None,
    decode.optional(decode.float),
  )
  use amount <- decode.optional_field(
    "amount",
    None,
    decode.optional(money_decoder()),
  )
  use reason <- decode.optional_field(
    "reason",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use category <- decode.field("category", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ExplanationofbenefitItemAdjudication(
    value:,
    amount:,
    reason:,
    category:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn explanationofbenefit_item_to_json(
  explanationofbenefit_item: ExplanationofbenefitItem,
) -> Json {
  let ExplanationofbenefitItem(
    detail:,
    adjudication:,
    note_number:,
    encounter:,
    sub_site:,
    body_site:,
    udi:,
    net:,
    factor:,
    unit_price:,
    quantity:,
    location:,
    serviced:,
    program_code:,
    modifier:,
    product_or_service:,
    category:,
    revenue:,
    information_sequence:,
    procedure_sequence:,
    diagnosis_sequence:,
    care_team_sequence:,
    sequence:,
    modifier_extension:,
    extension:,
    id:,
  ) = explanationofbenefit_item
  let fields = [
    #("productOrService", codeableconcept_to_json(product_or_service)),
    #("sequence", json.int(sequence)),
  ]
  let fields = case detail {
    [] -> fields
    _ -> [
      #("detail", json.array(detail, explanationofbenefit_item_detail_to_json)),
      ..fields
    ]
  }
  let fields = case adjudication {
    [] -> fields
    _ -> [
      #(
        "adjudication",
        json.array(adjudication, explanationofbenefit_item_adjudication_to_json),
      ),
      ..fields
    ]
  }
  let fields = case note_number {
    [] -> fields
    _ -> [#("noteNumber", json.array(note_number, json.int)), ..fields]
  }
  let fields = case encounter {
    [] -> fields
    _ -> [#("encounter", json.array(encounter, reference_to_json)), ..fields]
  }
  let fields = case sub_site {
    [] -> fields
    _ -> [#("subSite", json.array(sub_site, codeableconcept_to_json)), ..fields]
  }
  let fields = case body_site {
    Some(v) -> [#("bodySite", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case udi {
    [] -> fields
    _ -> [#("udi", json.array(udi, reference_to_json)), ..fields]
  }
  let fields = case net {
    Some(v) -> [#("net", money_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case factor {
    Some(v) -> [#("factor", json.float(v)), ..fields]
    None -> fields
  }
  let fields = case unit_price {
    Some(v) -> [#("unitPrice", money_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case quantity {
    Some(v) -> [#("quantity", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case location {
    Some(v) -> [
      #(
        "location"
          <> case v {
          ExplanationofbenefitItemLocationCodeableconcept(_) ->
            "Codeableconcept"
          ExplanationofbenefitItemLocationAddress(_) -> "Address"
          ExplanationofbenefitItemLocationReference(_) -> "Reference"
        },
        explanationofbenefit_item_location_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case serviced {
    Some(v) -> [
      #(
        "serviced"
          <> case v {
          ExplanationofbenefitItemServicedDate(_) -> "Date"
          ExplanationofbenefitItemServicedPeriod(_) -> "Period"
        },
        explanationofbenefit_item_serviced_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case program_code {
    [] -> fields
    _ -> [
      #("programCode", json.array(program_code, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case modifier {
    [] -> fields
    _ -> [
      #("modifier", json.array(modifier, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case category {
    Some(v) -> [#("category", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case revenue {
    Some(v) -> [#("revenue", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case information_sequence {
    [] -> fields
    _ -> [
      #("informationSequence", json.array(information_sequence, json.int)),
      ..fields
    ]
  }
  let fields = case procedure_sequence {
    [] -> fields
    _ -> [
      #("procedureSequence", json.array(procedure_sequence, json.int)),
      ..fields
    ]
  }
  let fields = case diagnosis_sequence {
    [] -> fields
    _ -> [
      #("diagnosisSequence", json.array(diagnosis_sequence, json.int)),
      ..fields
    ]
  }
  let fields = case care_team_sequence {
    [] -> fields
    _ -> [
      #("careTeamSequence", json.array(care_team_sequence, json.int)),
      ..fields
    ]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn explanationofbenefit_item_decoder() -> Decoder(ExplanationofbenefitItem) {
  use detail <- decode.optional_field(
    "detail",
    [],
    decode.list(explanationofbenefit_item_detail_decoder()),
  )
  use adjudication <- decode.optional_field(
    "adjudication",
    [],
    decode.list(explanationofbenefit_item_adjudication_decoder()),
  )
  use note_number <- decode.optional_field(
    "noteNumber",
    [],
    decode.list(decode.int),
  )
  use encounter <- decode.optional_field(
    "encounter",
    [],
    decode.list(reference_decoder()),
  )
  use sub_site <- decode.optional_field(
    "subSite",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use body_site <- decode.optional_field(
    "bodySite",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use udi <- decode.optional_field("udi", [], decode.list(reference_decoder()))
  use net <- decode.optional_field(
    "net",
    None,
    decode.optional(money_decoder()),
  )
  use factor <- decode.optional_field(
    "factor",
    None,
    decode.optional(decode.float),
  )
  use unit_price <- decode.optional_field(
    "unitPrice",
    None,
    decode.optional(money_decoder()),
  )
  use quantity <- decode.optional_field(
    "quantity",
    None,
    decode.optional(quantity_decoder()),
  )
  use location <- decode.then(
    none_if_omitted(explanationofbenefit_item_location_decoder()),
  )
  use serviced <- decode.then(
    none_if_omitted(explanationofbenefit_item_serviced_decoder()),
  )
  use program_code <- decode.optional_field(
    "programCode",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use modifier <- decode.optional_field(
    "modifier",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use product_or_service <- decode.field(
    "productOrService",
    codeableconcept_decoder(),
  )
  use category <- decode.optional_field(
    "category",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use revenue <- decode.optional_field(
    "revenue",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use information_sequence <- decode.optional_field(
    "informationSequence",
    [],
    decode.list(decode.int),
  )
  use procedure_sequence <- decode.optional_field(
    "procedureSequence",
    [],
    decode.list(decode.int),
  )
  use diagnosis_sequence <- decode.optional_field(
    "diagnosisSequence",
    [],
    decode.list(decode.int),
  )
  use care_team_sequence <- decode.optional_field(
    "careTeamSequence",
    [],
    decode.list(decode.int),
  )
  use sequence <- decode.field("sequence", decode.int)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ExplanationofbenefitItem(
    detail:,
    adjudication:,
    note_number:,
    encounter:,
    sub_site:,
    body_site:,
    udi:,
    net:,
    factor:,
    unit_price:,
    quantity:,
    location:,
    serviced:,
    program_code:,
    modifier:,
    product_or_service:,
    category:,
    revenue:,
    information_sequence:,
    procedure_sequence:,
    diagnosis_sequence:,
    care_team_sequence:,
    sequence:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn explanationofbenefit_accident_to_json(
  explanationofbenefit_accident: ExplanationofbenefitAccident,
) -> Json {
  let ExplanationofbenefitAccident(
    location:,
    type_:,
    date:,
    modifier_extension:,
    extension:,
    id:,
  ) = explanationofbenefit_accident
  let fields = []
  let fields = case location {
    Some(v) -> [
      #(
        "location"
          <> case v {
          ExplanationofbenefitAccidentLocationAddress(_) -> "Address"
          ExplanationofbenefitAccidentLocationReference(_) -> "Reference"
        },
        explanationofbenefit_accident_location_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case date {
    Some(v) -> [#("date", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn explanationofbenefit_accident_decoder() -> Decoder(
  ExplanationofbenefitAccident,
) {
  use location <- decode.then(
    none_if_omitted(explanationofbenefit_accident_location_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use date <- decode.optional_field(
    "date",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ExplanationofbenefitAccident(
    location:,
    type_:,
    date:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn explanationofbenefit_insurance_to_json(
  explanationofbenefit_insurance: ExplanationofbenefitInsurance,
) -> Json {
  let ExplanationofbenefitInsurance(
    pre_auth_ref:,
    coverage:,
    focal:,
    modifier_extension:,
    extension:,
    id:,
  ) = explanationofbenefit_insurance
  let fields = [
    #("coverage", reference_to_json(coverage)),
    #("focal", json.bool(focal)),
  ]
  let fields = case pre_auth_ref {
    [] -> fields
    _ -> [#("preAuthRef", json.array(pre_auth_ref, json.string)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn explanationofbenefit_insurance_decoder() -> Decoder(
  ExplanationofbenefitInsurance,
) {
  use pre_auth_ref <- decode.optional_field(
    "preAuthRef",
    [],
    decode.list(decode.string),
  )
  use coverage <- decode.field("coverage", reference_decoder())
  use focal <- decode.field("focal", decode.bool)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ExplanationofbenefitInsurance(
    pre_auth_ref:,
    coverage:,
    focal:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn explanationofbenefit_procedure_to_json(
  explanationofbenefit_procedure: ExplanationofbenefitProcedure,
) -> Json {
  let ExplanationofbenefitProcedure(
    udi:,
    procedure:,
    date:,
    type_:,
    sequence:,
    modifier_extension:,
    extension:,
    id:,
  ) = explanationofbenefit_procedure
  let fields = [
    #("procedure", explanationofbenefit_procedure_procedure_to_json(procedure)),
    #("sequence", json.int(sequence)),
  ]
  let fields = case udi {
    [] -> fields
    _ -> [#("udi", json.array(udi, reference_to_json)), ..fields]
  }
  let fields = case date {
    Some(v) -> [#("date", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    [] -> fields
    _ -> [#("type", json.array(type_, codeableconcept_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn explanationofbenefit_procedure_decoder() -> Decoder(
  ExplanationofbenefitProcedure,
) {
  use udi <- decode.optional_field("udi", [], decode.list(reference_decoder()))
  use procedure <- decode.then(
    explanationofbenefit_procedure_procedure_decoder(),
  )
  use date <- decode.optional_field(
    "date",
    None,
    decode.optional(decode.string),
  )
  use type_ <- decode.optional_field(
    "type",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use sequence <- decode.field("sequence", decode.int)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ExplanationofbenefitProcedure(
    udi:,
    procedure:,
    date:,
    type_:,
    sequence:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn explanationofbenefit_diagnosis_to_json(
  explanationofbenefit_diagnosis: ExplanationofbenefitDiagnosis,
) -> Json {
  let ExplanationofbenefitDiagnosis(
    package_code:,
    on_admission:,
    type_:,
    diagnosis:,
    sequence:,
    modifier_extension:,
    extension:,
    id:,
  ) = explanationofbenefit_diagnosis
  let fields = [
    #("diagnosis", explanationofbenefit_diagnosis_diagnosis_to_json(diagnosis)),
    #("sequence", json.int(sequence)),
  ]
  let fields = case package_code {
    Some(v) -> [#("packageCode", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case on_admission {
    Some(v) -> [#("onAdmission", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    [] -> fields
    _ -> [#("type", json.array(type_, codeableconcept_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn explanationofbenefit_diagnosis_decoder() -> Decoder(
  ExplanationofbenefitDiagnosis,
) {
  use package_code <- decode.optional_field(
    "packageCode",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use on_admission <- decode.optional_field(
    "onAdmission",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use diagnosis <- decode.then(
    explanationofbenefit_diagnosis_diagnosis_decoder(),
  )
  use sequence <- decode.field("sequence", decode.int)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ExplanationofbenefitDiagnosis(
    package_code:,
    on_admission:,
    type_:,
    diagnosis:,
    sequence:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn explanationofbenefit_supportinginfo_to_json(
  explanationofbenefit_supportinginfo: ExplanationofbenefitSupportinginfo,
) -> Json {
  let ExplanationofbenefitSupportinginfo(
    reason:,
    value:,
    timing:,
    code:,
    category:,
    sequence:,
    modifier_extension:,
    extension:,
    id:,
  ) = explanationofbenefit_supportinginfo
  let fields = [
    #("category", codeableconcept_to_json(category)),
    #("sequence", json.int(sequence)),
  ]
  let fields = case reason {
    Some(v) -> [#("reason", coding_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case value {
    Some(v) -> [
      #(
        "value"
          <> case v {
          ExplanationofbenefitSupportinginfoValueBoolean(_) -> "Boolean"
          ExplanationofbenefitSupportinginfoValueString(_) -> "String"
          ExplanationofbenefitSupportinginfoValueQuantity(_) -> "Quantity"
          ExplanationofbenefitSupportinginfoValueAttachment(_) -> "Attachment"
          ExplanationofbenefitSupportinginfoValueReference(_) -> "Reference"
        },
        explanationofbenefit_supportinginfo_value_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case timing {
    Some(v) -> [
      #(
        "timing"
          <> case v {
          ExplanationofbenefitSupportinginfoTimingDate(_) -> "Date"
          ExplanationofbenefitSupportinginfoTimingPeriod(_) -> "Period"
        },
        explanationofbenefit_supportinginfo_timing_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case code {
    Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn explanationofbenefit_supportinginfo_decoder() -> Decoder(
  ExplanationofbenefitSupportinginfo,
) {
  use reason <- decode.optional_field(
    "reason",
    None,
    decode.optional(coding_decoder()),
  )
  use value <- decode.then(
    none_if_omitted(explanationofbenefit_supportinginfo_value_decoder()),
  )
  use timing <- decode.then(
    none_if_omitted(explanationofbenefit_supportinginfo_timing_decoder()),
  )
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use category <- decode.field("category", codeableconcept_decoder())
  use sequence <- decode.field("sequence", decode.int)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ExplanationofbenefitSupportinginfo(
    reason:,
    value:,
    timing:,
    code:,
    category:,
    sequence:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn explanationofbenefit_careteam_to_json(
  explanationofbenefit_careteam: ExplanationofbenefitCareteam,
) -> Json {
  let ExplanationofbenefitCareteam(
    qualification:,
    role:,
    responsible:,
    provider:,
    sequence:,
    modifier_extension:,
    extension:,
    id:,
  ) = explanationofbenefit_careteam
  let fields = [
    #("provider", reference_to_json(provider)),
    #("sequence", json.int(sequence)),
  ]
  let fields = case qualification {
    Some(v) -> [#("qualification", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case role {
    Some(v) -> [#("role", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case responsible {
    Some(v) -> [#("responsible", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn explanationofbenefit_careteam_decoder() -> Decoder(
  ExplanationofbenefitCareteam,
) {
  use qualification <- decode.optional_field(
    "qualification",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use role <- decode.optional_field(
    "role",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use responsible <- decode.optional_field(
    "responsible",
    None,
    decode.optional(decode.bool),
  )
  use provider <- decode.field("provider", reference_decoder())
  use sequence <- decode.field("sequence", decode.int)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ExplanationofbenefitCareteam(
    qualification:,
    role:,
    responsible:,
    provider:,
    sequence:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn explanationofbenefit_payee_to_json(
  explanationofbenefit_payee: ExplanationofbenefitPayee,
) -> Json {
  let ExplanationofbenefitPayee(
    party:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = explanationofbenefit_payee
  let fields = []
  let fields = case party {
    Some(v) -> [#("party", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn explanationofbenefit_payee_decoder() -> Decoder(
  ExplanationofbenefitPayee,
) {
  use party <- decode.optional_field(
    "party",
    None,
    decode.optional(reference_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ExplanationofbenefitPayee(
    party:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn explanationofbenefit_related_to_json(
  explanationofbenefit_related: ExplanationofbenefitRelated,
) -> Json {
  let ExplanationofbenefitRelated(
    reference:,
    relationship:,
    claim:,
    modifier_extension:,
    extension:,
    id:,
  ) = explanationofbenefit_related
  let fields = []
  let fields = case reference {
    Some(v) -> [#("reference", identifier_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case relationship {
    Some(v) -> [#("relationship", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case claim {
    Some(v) -> [#("claim", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn explanationofbenefit_related_decoder() -> Decoder(
  ExplanationofbenefitRelated,
) {
  use reference <- decode.optional_field(
    "reference",
    None,
    decode.optional(identifier_decoder()),
  )
  use relationship <- decode.optional_field(
    "relationship",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use claim <- decode.optional_field(
    "claim",
    None,
    decode.optional(reference_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ExplanationofbenefitRelated(
    reference:,
    relationship:,
    claim:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn explanationofbenefit_to_json(
  explanationofbenefit: Explanationofbenefit,
) -> Json {
  let Explanationofbenefit(
    benefit_balance:,
    benefit_period:,
    process_note:,
    form:,
    form_code:,
    payment:,
    total:,
    add_item:,
    item:,
    accident:,
    insurance:,
    precedence:,
    procedure:,
    diagnosis:,
    supporting_info:,
    care_team:,
    pre_auth_ref_period:,
    pre_auth_ref:,
    disposition:,
    outcome:,
    claim_response:,
    claim:,
    facility:,
    referral:,
    payee:,
    original_prescription:,
    prescription:,
    related:,
    funds_reserve:,
    funds_reserve_requested:,
    priority:,
    provider:,
    insurer:,
    enterer:,
    created:,
    billable_period:,
    patient:,
    use_:,
    sub_type:,
    type_:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = explanationofbenefit
  let fields = [
    #("outcome", r4bvaluesets.remittanceoutcome_to_json(outcome)),
    #("provider", reference_to_json(provider)),
    #("insurer", reference_to_json(insurer)),
    #("created", json.string(created)),
    #("patient", reference_to_json(patient)),
    #("use", r4bvaluesets.claimuse_to_json(use_)),
    #("type", codeableconcept_to_json(type_)),
    #("status", r4bvaluesets.explanationofbenefitstatus_to_json(status)),
  ]
  let fields = case benefit_balance {
    [] -> fields
    _ -> [
      #(
        "benefitBalance",
        json.array(benefit_balance, explanationofbenefit_benefitbalance_to_json),
      ),
      ..fields
    ]
  }
  let fields = case benefit_period {
    Some(v) -> [#("benefitPeriod", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case process_note {
    [] -> fields
    _ -> [
      #(
        "processNote",
        json.array(process_note, explanationofbenefit_processnote_to_json),
      ),
      ..fields
    ]
  }
  let fields = case form {
    Some(v) -> [#("form", attachment_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case form_code {
    Some(v) -> [#("formCode", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case payment {
    Some(v) -> [#("payment", explanationofbenefit_payment_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case total {
    [] -> fields
    _ -> [
      #("total", json.array(total, explanationofbenefit_total_to_json)),
      ..fields
    ]
  }
  let fields = case add_item {
    [] -> fields
    _ -> [
      #("addItem", json.array(add_item, explanationofbenefit_additem_to_json)),
      ..fields
    ]
  }
  let fields = case item {
    [] -> fields
    _ -> [
      #("item", json.array(item, explanationofbenefit_item_to_json)),
      ..fields
    ]
  }
  let fields = case accident {
    Some(v) -> [
      #("accident", explanationofbenefit_accident_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case insurance {
    [] -> fields
    _ -> [
      #(
        "insurance",
        json.array(insurance, explanationofbenefit_insurance_to_json),
      ),
      ..fields
    ]
  }
  let fields = case precedence {
    Some(v) -> [#("precedence", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case procedure {
    [] -> fields
    _ -> [
      #(
        "procedure",
        json.array(procedure, explanationofbenefit_procedure_to_json),
      ),
      ..fields
    ]
  }
  let fields = case diagnosis {
    [] -> fields
    _ -> [
      #(
        "diagnosis",
        json.array(diagnosis, explanationofbenefit_diagnosis_to_json),
      ),
      ..fields
    ]
  }
  let fields = case supporting_info {
    [] -> fields
    _ -> [
      #(
        "supportingInfo",
        json.array(supporting_info, explanationofbenefit_supportinginfo_to_json),
      ),
      ..fields
    ]
  }
  let fields = case care_team {
    [] -> fields
    _ -> [
      #(
        "careTeam",
        json.array(care_team, explanationofbenefit_careteam_to_json),
      ),
      ..fields
    ]
  }
  let fields = case pre_auth_ref_period {
    [] -> fields
    _ -> [
      #("preAuthRefPeriod", json.array(pre_auth_ref_period, period_to_json)),
      ..fields
    ]
  }
  let fields = case pre_auth_ref {
    [] -> fields
    _ -> [#("preAuthRef", json.array(pre_auth_ref, json.string)), ..fields]
  }
  let fields = case disposition {
    Some(v) -> [#("disposition", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case claim_response {
    Some(v) -> [#("claimResponse", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case claim {
    Some(v) -> [#("claim", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case facility {
    Some(v) -> [#("facility", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case referral {
    Some(v) -> [#("referral", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case payee {
    Some(v) -> [#("payee", explanationofbenefit_payee_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case original_prescription {
    Some(v) -> [#("originalPrescription", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case prescription {
    Some(v) -> [#("prescription", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case related {
    [] -> fields
    _ -> [
      #("related", json.array(related, explanationofbenefit_related_to_json)),
      ..fields
    ]
  }
  let fields = case funds_reserve {
    Some(v) -> [#("fundsReserve", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case funds_reserve_requested {
    Some(v) -> [
      #("fundsReserveRequested", codeableconcept_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case priority {
    Some(v) -> [#("priority", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case enterer {
    Some(v) -> [#("enterer", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case billable_period {
    Some(v) -> [#("billablePeriod", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case sub_type {
    Some(v) -> [#("subType", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [
    #("resourceType", json.string("Explanationofbenefit")),
    ..fields
  ]
  json.object(fields)
}

pub fn explanationofbenefit_decoder() -> Decoder(Explanationofbenefit) {
  use benefit_balance <- decode.optional_field(
    "benefitBalance",
    [],
    decode.list(explanationofbenefit_benefitbalance_decoder()),
  )
  use benefit_period <- decode.optional_field(
    "benefitPeriod",
    None,
    decode.optional(period_decoder()),
  )
  use process_note <- decode.optional_field(
    "processNote",
    [],
    decode.list(explanationofbenefit_processnote_decoder()),
  )
  use form <- decode.optional_field(
    "form",
    None,
    decode.optional(attachment_decoder()),
  )
  use form_code <- decode.optional_field(
    "formCode",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use payment <- decode.optional_field(
    "payment",
    None,
    decode.optional(explanationofbenefit_payment_decoder()),
  )
  use total <- decode.optional_field(
    "total",
    [],
    decode.list(explanationofbenefit_total_decoder()),
  )
  use add_item <- decode.optional_field(
    "addItem",
    [],
    decode.list(explanationofbenefit_additem_decoder()),
  )
  use item <- decode.optional_field(
    "item",
    [],
    decode.list(explanationofbenefit_item_decoder()),
  )
  use accident <- decode.optional_field(
    "accident",
    None,
    decode.optional(explanationofbenefit_accident_decoder()),
  )
  use insurance <- decode.optional_field(
    "insurance",
    [],
    decode.list(explanationofbenefit_insurance_decoder()),
  )
  use precedence <- decode.optional_field(
    "precedence",
    None,
    decode.optional(decode.int),
  )
  use procedure <- decode.optional_field(
    "procedure",
    [],
    decode.list(explanationofbenefit_procedure_decoder()),
  )
  use diagnosis <- decode.optional_field(
    "diagnosis",
    [],
    decode.list(explanationofbenefit_diagnosis_decoder()),
  )
  use supporting_info <- decode.optional_field(
    "supportingInfo",
    [],
    decode.list(explanationofbenefit_supportinginfo_decoder()),
  )
  use care_team <- decode.optional_field(
    "careTeam",
    [],
    decode.list(explanationofbenefit_careteam_decoder()),
  )
  use pre_auth_ref_period <- decode.optional_field(
    "preAuthRefPeriod",
    [],
    decode.list(period_decoder()),
  )
  use pre_auth_ref <- decode.optional_field(
    "preAuthRef",
    [],
    decode.list(decode.string),
  )
  use disposition <- decode.optional_field(
    "disposition",
    None,
    decode.optional(decode.string),
  )
  use outcome <- decode.field(
    "outcome",
    r4bvaluesets.remittanceoutcome_decoder(),
  )
  use claim_response <- decode.optional_field(
    "claimResponse",
    None,
    decode.optional(reference_decoder()),
  )
  use claim <- decode.optional_field(
    "claim",
    None,
    decode.optional(reference_decoder()),
  )
  use facility <- decode.optional_field(
    "facility",
    None,
    decode.optional(reference_decoder()),
  )
  use referral <- decode.optional_field(
    "referral",
    None,
    decode.optional(reference_decoder()),
  )
  use payee <- decode.optional_field(
    "payee",
    None,
    decode.optional(explanationofbenefit_payee_decoder()),
  )
  use original_prescription <- decode.optional_field(
    "originalPrescription",
    None,
    decode.optional(reference_decoder()),
  )
  use prescription <- decode.optional_field(
    "prescription",
    None,
    decode.optional(reference_decoder()),
  )
  use related <- decode.optional_field(
    "related",
    [],
    decode.list(explanationofbenefit_related_decoder()),
  )
  use funds_reserve <- decode.optional_field(
    "fundsReserve",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use funds_reserve_requested <- decode.optional_field(
    "fundsReserveRequested",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use priority <- decode.optional_field(
    "priority",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use provider <- decode.field("provider", reference_decoder())
  use insurer <- decode.field("insurer", reference_decoder())
  use enterer <- decode.optional_field(
    "enterer",
    None,
    decode.optional(reference_decoder()),
  )
  use created <- decode.field("created", decode.string)
  use billable_period <- decode.optional_field(
    "billablePeriod",
    None,
    decode.optional(period_decoder()),
  )
  use patient <- decode.field("patient", reference_decoder())
  use use_ <- decode.field("use", r4bvaluesets.claimuse_decoder())
  use sub_type <- decode.optional_field(
    "subType",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use type_ <- decode.field("type", codeableconcept_decoder())
  use status <- decode.field(
    "status",
    r4bvaluesets.explanationofbenefitstatus_decoder(),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Explanationofbenefit",
    decode.failure(
      explanationofbenefit_new(
        outcome:,
        provider:,
        insurer:,
        created:,
        patient:,
        use_:,
        type_:,
        status:,
      ),
      "resourceType",
    ),
  )
  decode.success(Explanationofbenefit(
    benefit_balance:,
    benefit_period:,
    process_note:,
    form:,
    form_code:,
    payment:,
    total:,
    add_item:,
    item:,
    accident:,
    insurance:,
    precedence:,
    procedure:,
    diagnosis:,
    supporting_info:,
    care_team:,
    pre_auth_ref_period:,
    pre_auth_ref:,
    disposition:,
    outcome:,
    claim_response:,
    claim:,
    facility:,
    referral:,
    payee:,
    original_prescription:,
    prescription:,
    related:,
    funds_reserve:,
    funds_reserve_requested:,
    priority:,
    provider:,
    insurer:,
    enterer:,
    created:,
    billable_period:,
    patient:,
    use_:,
    sub_type:,
    type_:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/FamilyMemberHistory#resource
pub type Familymemberhistory {
  Familymemberhistory(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    instantiates_canonical: List(String),
    instantiates_uri: List(String),
    status: r4bvaluesets.Historystatus,
    data_absent_reason: Option(Codeableconcept),
    patient: Reference,
    date: Option(String),
    name: Option(String),
    relationship: Codeableconcept,
    sex: Option(Codeableconcept),
    born: Option(FamilymemberhistoryBorn),
    age: Option(FamilymemberhistoryAge),
    estimated_age: Option(Bool),
    deceased: Option(FamilymemberhistoryDeceased),
    reason_code: List(Codeableconcept),
    reason_reference: List(Reference),
    note: List(Annotation),
    condition: List(FamilymemberhistoryCondition),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/FamilyMemberHistory#resource
pub type FamilymemberhistoryBorn {
  FamilymemberhistoryBornPeriod(born: Period)
  FamilymemberhistoryBornDate(born: String)
  FamilymemberhistoryBornString(born: String)
}

pub fn familymemberhistory_born_to_json(elt: FamilymemberhistoryBorn) -> Json {
  case elt {
    FamilymemberhistoryBornPeriod(v) -> period_to_json(v)
    FamilymemberhistoryBornDate(v) -> json.string(v)
    FamilymemberhistoryBornString(v) -> json.string(v)
  }
}

pub fn familymemberhistory_born_decoder() -> Decoder(FamilymemberhistoryBorn) {
  decode.one_of(
    decode.field("bornPeriod", period_decoder(), decode.success)
      |> decode.map(FamilymemberhistoryBornPeriod),
    [
      decode.field("bornDate", decode.string, decode.success)
        |> decode.map(FamilymemberhistoryBornDate),
      decode.field("bornString", decode.string, decode.success)
        |> decode.map(FamilymemberhistoryBornString),
    ],
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/FamilyMemberHistory#resource
pub type FamilymemberhistoryAge {
  FamilymemberhistoryAgeAge(age: Age)
  FamilymemberhistoryAgeRange(age: Range)
  FamilymemberhistoryAgeString(age: String)
}

pub fn familymemberhistory_age_to_json(elt: FamilymemberhistoryAge) -> Json {
  case elt {
    FamilymemberhistoryAgeAge(v) -> age_to_json(v)
    FamilymemberhistoryAgeRange(v) -> range_to_json(v)
    FamilymemberhistoryAgeString(v) -> json.string(v)
  }
}

pub fn familymemberhistory_age_decoder() -> Decoder(FamilymemberhistoryAge) {
  decode.one_of(
    decode.field("ageAge", age_decoder(), decode.success)
      |> decode.map(FamilymemberhistoryAgeAge),
    [
      decode.field("ageRange", range_decoder(), decode.success)
        |> decode.map(FamilymemberhistoryAgeRange),
      decode.field("ageString", decode.string, decode.success)
        |> decode.map(FamilymemberhistoryAgeString),
    ],
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/FamilyMemberHistory#resource
pub type FamilymemberhistoryDeceased {
  FamilymemberhistoryDeceasedBoolean(deceased: Bool)
  FamilymemberhistoryDeceasedAge(deceased: Age)
  FamilymemberhistoryDeceasedRange(deceased: Range)
  FamilymemberhistoryDeceasedDate(deceased: String)
  FamilymemberhistoryDeceasedString(deceased: String)
}

pub fn familymemberhistory_deceased_to_json(
  elt: FamilymemberhistoryDeceased,
) -> Json {
  case elt {
    FamilymemberhistoryDeceasedBoolean(v) -> json.bool(v)
    FamilymemberhistoryDeceasedAge(v) -> age_to_json(v)
    FamilymemberhistoryDeceasedRange(v) -> range_to_json(v)
    FamilymemberhistoryDeceasedDate(v) -> json.string(v)
    FamilymemberhistoryDeceasedString(v) -> json.string(v)
  }
}

pub fn familymemberhistory_deceased_decoder() -> Decoder(
  FamilymemberhistoryDeceased,
) {
  decode.one_of(
    decode.field("deceasedBoolean", decode.bool, decode.success)
      |> decode.map(FamilymemberhistoryDeceasedBoolean),
    [
      decode.field("deceasedAge", age_decoder(), decode.success)
        |> decode.map(FamilymemberhistoryDeceasedAge),
      decode.field("deceasedRange", range_decoder(), decode.success)
        |> decode.map(FamilymemberhistoryDeceasedRange),
      decode.field("deceasedDate", decode.string, decode.success)
        |> decode.map(FamilymemberhistoryDeceasedDate),
      decode.field("deceasedString", decode.string, decode.success)
        |> decode.map(FamilymemberhistoryDeceasedString),
    ],
  )
}

pub fn familymemberhistory_new(
  relationship relationship: Codeableconcept,
  patient patient: Reference,
  status status: r4bvaluesets.Historystatus,
) -> Familymemberhistory {
  Familymemberhistory(
    condition: [],
    note: [],
    reason_reference: [],
    reason_code: [],
    deceased: None,
    estimated_age: None,
    age: None,
    born: None,
    sex: None,
    relationship:,
    name: None,
    date: None,
    patient:,
    data_absent_reason: None,
    status:,
    instantiates_uri: [],
    instantiates_canonical: [],
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/FamilyMemberHistory#resource
pub type FamilymemberhistoryCondition {
  FamilymemberhistoryCondition(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    code: Codeableconcept,
    outcome: Option(Codeableconcept),
    contributed_to_death: Option(Bool),
    onset: Option(FamilymemberhistoryConditionOnset),
    note: List(Annotation),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/FamilyMemberHistory#resource
pub type FamilymemberhistoryConditionOnset {
  FamilymemberhistoryConditionOnsetAge(onset: Age)
  FamilymemberhistoryConditionOnsetRange(onset: Range)
  FamilymemberhistoryConditionOnsetPeriod(onset: Period)
  FamilymemberhistoryConditionOnsetString(onset: String)
}

pub fn familymemberhistory_condition_onset_to_json(
  elt: FamilymemberhistoryConditionOnset,
) -> Json {
  case elt {
    FamilymemberhistoryConditionOnsetAge(v) -> age_to_json(v)
    FamilymemberhistoryConditionOnsetRange(v) -> range_to_json(v)
    FamilymemberhistoryConditionOnsetPeriod(v) -> period_to_json(v)
    FamilymemberhistoryConditionOnsetString(v) -> json.string(v)
  }
}

pub fn familymemberhistory_condition_onset_decoder() -> Decoder(
  FamilymemberhistoryConditionOnset,
) {
  decode.one_of(
    decode.field("onsetAge", age_decoder(), decode.success)
      |> decode.map(FamilymemberhistoryConditionOnsetAge),
    [
      decode.field("onsetRange", range_decoder(), decode.success)
        |> decode.map(FamilymemberhistoryConditionOnsetRange),
      decode.field("onsetPeriod", period_decoder(), decode.success)
        |> decode.map(FamilymemberhistoryConditionOnsetPeriod),
      decode.field("onsetString", decode.string, decode.success)
        |> decode.map(FamilymemberhistoryConditionOnsetString),
    ],
  )
}

pub fn familymemberhistory_condition_new(
  code code: Codeableconcept,
) -> FamilymemberhistoryCondition {
  FamilymemberhistoryCondition(
    note: [],
    onset: None,
    contributed_to_death: None,
    outcome: None,
    code:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn familymemberhistory_condition_to_json(
  familymemberhistory_condition: FamilymemberhistoryCondition,
) -> Json {
  let FamilymemberhistoryCondition(
    note:,
    onset:,
    contributed_to_death:,
    outcome:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ) = familymemberhistory_condition
  let fields = [
    #("code", codeableconcept_to_json(code)),
  ]
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case onset {
    Some(v) -> [
      #(
        "onset"
          <> case v {
          FamilymemberhistoryConditionOnsetAge(_) -> "Age"
          FamilymemberhistoryConditionOnsetRange(_) -> "Range"
          FamilymemberhistoryConditionOnsetPeriod(_) -> "Period"
          FamilymemberhistoryConditionOnsetString(_) -> "String"
        },
        familymemberhistory_condition_onset_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case contributed_to_death {
    Some(v) -> [#("contributedToDeath", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case outcome {
    Some(v) -> [#("outcome", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn familymemberhistory_condition_decoder() -> Decoder(
  FamilymemberhistoryCondition,
) {
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use onset <- decode.then(
    none_if_omitted(familymemberhistory_condition_onset_decoder()),
  )
  use contributed_to_death <- decode.optional_field(
    "contributedToDeath",
    None,
    decode.optional(decode.bool),
  )
  use outcome <- decode.optional_field(
    "outcome",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use code <- decode.field("code", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(FamilymemberhistoryCondition(
    note:,
    onset:,
    contributed_to_death:,
    outcome:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn familymemberhistory_to_json(
  familymemberhistory: Familymemberhistory,
) -> Json {
  let Familymemberhistory(
    condition:,
    note:,
    reason_reference:,
    reason_code:,
    deceased:,
    estimated_age:,
    age:,
    born:,
    sex:,
    relationship:,
    name:,
    date:,
    patient:,
    data_absent_reason:,
    status:,
    instantiates_uri:,
    instantiates_canonical:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = familymemberhistory
  let fields = [
    #("relationship", codeableconcept_to_json(relationship)),
    #("patient", reference_to_json(patient)),
    #("status", r4bvaluesets.historystatus_to_json(status)),
  ]
  let fields = case condition {
    [] -> fields
    _ -> [
      #(
        "condition",
        json.array(condition, familymemberhistory_condition_to_json),
      ),
      ..fields
    ]
  }
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case reason_reference {
    [] -> fields
    _ -> [
      #("reasonReference", json.array(reason_reference, reference_to_json)),
      ..fields
    ]
  }
  let fields = case reason_code {
    [] -> fields
    _ -> [
      #("reasonCode", json.array(reason_code, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case deceased {
    Some(v) -> [
      #(
        "deceased"
          <> case v {
          FamilymemberhistoryDeceasedBoolean(_) -> "Boolean"
          FamilymemberhistoryDeceasedAge(_) -> "Age"
          FamilymemberhistoryDeceasedRange(_) -> "Range"
          FamilymemberhistoryDeceasedDate(_) -> "Date"
          FamilymemberhistoryDeceasedString(_) -> "String"
        },
        familymemberhistory_deceased_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case estimated_age {
    Some(v) -> [#("estimatedAge", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case age {
    Some(v) -> [
      #(
        "age"
          <> case v {
          FamilymemberhistoryAgeAge(_) -> "Age"
          FamilymemberhistoryAgeRange(_) -> "Range"
          FamilymemberhistoryAgeString(_) -> "String"
        },
        familymemberhistory_age_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case born {
    Some(v) -> [
      #(
        "born"
          <> case v {
          FamilymemberhistoryBornPeriod(_) -> "Period"
          FamilymemberhistoryBornDate(_) -> "Date"
          FamilymemberhistoryBornString(_) -> "String"
        },
        familymemberhistory_born_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case sex {
    Some(v) -> [#("sex", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case date {
    Some(v) -> [#("date", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case data_absent_reason {
    Some(v) -> [#("dataAbsentReason", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case instantiates_uri {
    [] -> fields
    _ -> [
      #("instantiatesUri", json.array(instantiates_uri, json.string)),
      ..fields
    ]
  }
  let fields = case instantiates_canonical {
    [] -> fields
    _ -> [
      #(
        "instantiatesCanonical",
        json.array(instantiates_canonical, json.string),
      ),
      ..fields
    ]
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Familymemberhistory")), ..fields]
  json.object(fields)
}

pub fn familymemberhistory_decoder() -> Decoder(Familymemberhistory) {
  use condition <- decode.optional_field(
    "condition",
    [],
    decode.list(familymemberhistory_condition_decoder()),
  )
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use reason_reference <- decode.optional_field(
    "reasonReference",
    [],
    decode.list(reference_decoder()),
  )
  use reason_code <- decode.optional_field(
    "reasonCode",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use deceased <- decode.then(
    none_if_omitted(familymemberhistory_deceased_decoder()),
  )
  use estimated_age <- decode.optional_field(
    "estimatedAge",
    None,
    decode.optional(decode.bool),
  )
  use age <- decode.then(none_if_omitted(familymemberhistory_age_decoder()))
  use born <- decode.then(none_if_omitted(familymemberhistory_born_decoder()))
  use sex <- decode.optional_field(
    "sex",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use relationship <- decode.field("relationship", codeableconcept_decoder())
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use date <- decode.optional_field(
    "date",
    None,
    decode.optional(decode.string),
  )
  use patient <- decode.field("patient", reference_decoder())
  use data_absent_reason <- decode.optional_field(
    "dataAbsentReason",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use status <- decode.field("status", r4bvaluesets.historystatus_decoder())
  use instantiates_uri <- decode.optional_field(
    "instantiatesUri",
    [],
    decode.list(decode.string),
  )
  use instantiates_canonical <- decode.optional_field(
    "instantiatesCanonical",
    [],
    decode.list(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Familymemberhistory",
    decode.failure(
      familymemberhistory_new(relationship:, patient:, status:),
      "resourceType",
    ),
  )
  decode.success(Familymemberhistory(
    condition:,
    note:,
    reason_reference:,
    reason_code:,
    deceased:,
    estimated_age:,
    age:,
    born:,
    sex:,
    relationship:,
    name:,
    date:,
    patient:,
    data_absent_reason:,
    status:,
    instantiates_uri:,
    instantiates_canonical:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/Flag#resource
pub type Flag {
  Flag(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    status: r4bvaluesets.Flagstatus,
    category: List(Codeableconcept),
    code: Codeableconcept,
    subject: Reference,
    period: Option(Period),
    encounter: Option(Reference),
    author: Option(Reference),
  )
}

pub fn flag_new(
  subject subject: Reference,
  code code: Codeableconcept,
  status status: r4bvaluesets.Flagstatus,
) -> Flag {
  Flag(
    author: None,
    encounter: None,
    period: None,
    subject:,
    code:,
    category: [],
    status:,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

pub fn flag_to_json(flag: Flag) -> Json {
  let Flag(
    author:,
    encounter:,
    period:,
    subject:,
    code:,
    category:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = flag
  let fields = [
    #("subject", reference_to_json(subject)),
    #("code", codeableconcept_to_json(code)),
    #("status", r4bvaluesets.flagstatus_to_json(status)),
  ]
  let fields = case author {
    Some(v) -> [#("author", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case encounter {
    Some(v) -> [#("encounter", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case period {
    Some(v) -> [#("period", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case category {
    [] -> fields
    _ -> [
      #("category", json.array(category, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Flag")), ..fields]
  json.object(fields)
}

pub fn flag_decoder() -> Decoder(Flag) {
  use author <- decode.optional_field(
    "author",
    None,
    decode.optional(reference_decoder()),
  )
  use encounter <- decode.optional_field(
    "encounter",
    None,
    decode.optional(reference_decoder()),
  )
  use period <- decode.optional_field(
    "period",
    None,
    decode.optional(period_decoder()),
  )
  use subject <- decode.field("subject", reference_decoder())
  use code <- decode.field("code", codeableconcept_decoder())
  use category <- decode.optional_field(
    "category",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use status <- decode.field("status", r4bvaluesets.flagstatus_decoder())
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Flag",
    decode.failure(flag_new(subject:, code:, status:), "resourceType"),
  )
  decode.success(Flag(
    author:,
    encounter:,
    period:,
    subject:,
    code:,
    category:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/Goal#resource
pub type Goal {
  Goal(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    lifecycle_status: r4bvaluesets.Goalstatus,
    achievement_status: Option(Codeableconcept),
    category: List(Codeableconcept),
    priority: Option(Codeableconcept),
    description: Codeableconcept,
    subject: Reference,
    start: Option(GoalStart),
    target: List(GoalTarget),
    status_date: Option(String),
    status_reason: Option(String),
    expressed_by: Option(Reference),
    addresses: List(Reference),
    note: List(Annotation),
    outcome_code: List(Codeableconcept),
    outcome_reference: List(Reference),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Goal#resource
pub type GoalStart {
  GoalStartDate(start: String)
  GoalStartCodeableconcept(start: Codeableconcept)
}

pub fn goal_start_to_json(elt: GoalStart) -> Json {
  case elt {
    GoalStartDate(v) -> json.string(v)
    GoalStartCodeableconcept(v) -> codeableconcept_to_json(v)
  }
}

pub fn goal_start_decoder() -> Decoder(GoalStart) {
  decode.one_of(
    decode.field("startDate", decode.string, decode.success)
      |> decode.map(GoalStartDate),
    [
      decode.field(
        "startCodeableConcept",
        codeableconcept_decoder(),
        decode.success,
      )
      |> decode.map(GoalStartCodeableconcept),
    ],
  )
}

pub fn goal_new(
  subject subject: Reference,
  description description: Codeableconcept,
  lifecycle_status lifecycle_status: r4bvaluesets.Goalstatus,
) -> Goal {
  Goal(
    outcome_reference: [],
    outcome_code: [],
    note: [],
    addresses: [],
    expressed_by: None,
    status_reason: None,
    status_date: None,
    target: [],
    start: None,
    subject:,
    description:,
    priority: None,
    category: [],
    achievement_status: None,
    lifecycle_status:,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Goal#resource
pub type GoalTarget {
  GoalTarget(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    measure: Option(Codeableconcept),
    detail: Option(GoalTargetDetail),
    due: Option(GoalTargetDue),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Goal#resource
pub type GoalTargetDetail {
  GoalTargetDetailQuantity(detail: Quantity)
  GoalTargetDetailRange(detail: Range)
  GoalTargetDetailCodeableconcept(detail: Codeableconcept)
  GoalTargetDetailString(detail: String)
  GoalTargetDetailBoolean(detail: Bool)
  GoalTargetDetailInteger(detail: Int)
  GoalTargetDetailRatio(detail: Ratio)
}

pub fn goal_target_detail_to_json(elt: GoalTargetDetail) -> Json {
  case elt {
    GoalTargetDetailQuantity(v) -> quantity_to_json(v)
    GoalTargetDetailRange(v) -> range_to_json(v)
    GoalTargetDetailCodeableconcept(v) -> codeableconcept_to_json(v)
    GoalTargetDetailString(v) -> json.string(v)
    GoalTargetDetailBoolean(v) -> json.bool(v)
    GoalTargetDetailInteger(v) -> json.int(v)
    GoalTargetDetailRatio(v) -> ratio_to_json(v)
  }
}

pub fn goal_target_detail_decoder() -> Decoder(GoalTargetDetail) {
  decode.one_of(
    decode.field("detailQuantity", quantity_decoder(), decode.success)
      |> decode.map(GoalTargetDetailQuantity),
    [
      decode.field("detailRange", range_decoder(), decode.success)
        |> decode.map(GoalTargetDetailRange),
      decode.field(
        "detailCodeableConcept",
        codeableconcept_decoder(),
        decode.success,
      )
        |> decode.map(GoalTargetDetailCodeableconcept),
      decode.field("detailString", decode.string, decode.success)
        |> decode.map(GoalTargetDetailString),
      decode.field("detailBoolean", decode.bool, decode.success)
        |> decode.map(GoalTargetDetailBoolean),
      decode.field("detailInteger", decode.int, decode.success)
        |> decode.map(GoalTargetDetailInteger),
      decode.field("detailRatio", ratio_decoder(), decode.success)
        |> decode.map(GoalTargetDetailRatio),
    ],
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Goal#resource
pub type GoalTargetDue {
  GoalTargetDueDate(due: String)
  GoalTargetDueDuration(due: Duration)
}

pub fn goal_target_due_to_json(elt: GoalTargetDue) -> Json {
  case elt {
    GoalTargetDueDate(v) -> json.string(v)
    GoalTargetDueDuration(v) -> duration_to_json(v)
  }
}

pub fn goal_target_due_decoder() -> Decoder(GoalTargetDue) {
  decode.one_of(
    decode.field("dueDate", decode.string, decode.success)
      |> decode.map(GoalTargetDueDate),
    [
      decode.field("dueDuration", duration_decoder(), decode.success)
      |> decode.map(GoalTargetDueDuration),
    ],
  )
}

pub fn goal_target_new() -> GoalTarget {
  GoalTarget(
    due: None,
    detail: None,
    measure: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn goal_target_to_json(goal_target: GoalTarget) -> Json {
  let GoalTarget(due:, detail:, measure:, modifier_extension:, extension:, id:) =
    goal_target
  let fields = []
  let fields = case due {
    Some(v) -> [
      #(
        "due"
          <> case v {
          GoalTargetDueDate(_) -> "Date"
          GoalTargetDueDuration(_) -> "Duration"
        },
        goal_target_due_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case detail {
    Some(v) -> [
      #(
        "detail"
          <> case v {
          GoalTargetDetailQuantity(_) -> "Quantity"
          GoalTargetDetailRange(_) -> "Range"
          GoalTargetDetailCodeableconcept(_) -> "Codeableconcept"
          GoalTargetDetailString(_) -> "String"
          GoalTargetDetailBoolean(_) -> "Boolean"
          GoalTargetDetailInteger(_) -> "Integer"
          GoalTargetDetailRatio(_) -> "Ratio"
        },
        goal_target_detail_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case measure {
    Some(v) -> [#("measure", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn goal_target_decoder() -> Decoder(GoalTarget) {
  use due <- decode.then(none_if_omitted(goal_target_due_decoder()))
  use detail <- decode.then(none_if_omitted(goal_target_detail_decoder()))
  use measure <- decode.optional_field(
    "measure",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(GoalTarget(
    due:,
    detail:,
    measure:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn goal_to_json(goal: Goal) -> Json {
  let Goal(
    outcome_reference:,
    outcome_code:,
    note:,
    addresses:,
    expressed_by:,
    status_reason:,
    status_date:,
    target:,
    start:,
    subject:,
    description:,
    priority:,
    category:,
    achievement_status:,
    lifecycle_status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = goal
  let fields = [
    #("subject", reference_to_json(subject)),
    #("description", codeableconcept_to_json(description)),
    #("lifecycleStatus", r4bvaluesets.goalstatus_to_json(lifecycle_status)),
  ]
  let fields = case outcome_reference {
    [] -> fields
    _ -> [
      #("outcomeReference", json.array(outcome_reference, reference_to_json)),
      ..fields
    ]
  }
  let fields = case outcome_code {
    [] -> fields
    _ -> [
      #("outcomeCode", json.array(outcome_code, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case addresses {
    [] -> fields
    _ -> [#("addresses", json.array(addresses, reference_to_json)), ..fields]
  }
  let fields = case expressed_by {
    Some(v) -> [#("expressedBy", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case status_reason {
    Some(v) -> [#("statusReason", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case status_date {
    Some(v) -> [#("statusDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case target {
    [] -> fields
    _ -> [#("target", json.array(target, goal_target_to_json)), ..fields]
  }
  let fields = case start {
    Some(v) -> [
      #(
        "start"
          <> case v {
          GoalStartDate(_) -> "Date"
          GoalStartCodeableconcept(_) -> "Codeableconcept"
        },
        goal_start_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case priority {
    Some(v) -> [#("priority", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case category {
    [] -> fields
    _ -> [
      #("category", json.array(category, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case achievement_status {
    Some(v) -> [#("achievementStatus", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Goal")), ..fields]
  json.object(fields)
}

pub fn goal_decoder() -> Decoder(Goal) {
  use outcome_reference <- decode.optional_field(
    "outcomeReference",
    [],
    decode.list(reference_decoder()),
  )
  use outcome_code <- decode.optional_field(
    "outcomeCode",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use addresses <- decode.optional_field(
    "addresses",
    [],
    decode.list(reference_decoder()),
  )
  use expressed_by <- decode.optional_field(
    "expressedBy",
    None,
    decode.optional(reference_decoder()),
  )
  use status_reason <- decode.optional_field(
    "statusReason",
    None,
    decode.optional(decode.string),
  )
  use status_date <- decode.optional_field(
    "statusDate",
    None,
    decode.optional(decode.string),
  )
  use target <- decode.optional_field(
    "target",
    [],
    decode.list(goal_target_decoder()),
  )
  use start <- decode.then(none_if_omitted(goal_start_decoder()))
  use subject <- decode.field("subject", reference_decoder())
  use description <- decode.field("description", codeableconcept_decoder())
  use priority <- decode.optional_field(
    "priority",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use category <- decode.optional_field(
    "category",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use achievement_status <- decode.optional_field(
    "achievementStatus",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use lifecycle_status <- decode.field(
    "lifecycleStatus",
    r4bvaluesets.goalstatus_decoder(),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Goal",
    decode.failure(
      goal_new(subject:, description:, lifecycle_status:),
      "resourceType",
    ),
  )
  decode.success(Goal(
    outcome_reference:,
    outcome_code:,
    note:,
    addresses:,
    expressed_by:,
    status_reason:,
    status_date:,
    target:,
    start:,
    subject:,
    description:,
    priority:,
    category:,
    achievement_status:,
    lifecycle_status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/GraphDefinition#resource
pub type Graphdefinition {
  Graphdefinition(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    url: Option(String),
    version: Option(String),
    name: String,
    status: r4bvaluesets.Publicationstatus,
    experimental: Option(Bool),
    date: Option(String),
    publisher: Option(String),
    contact: List(Contactdetail),
    description: Option(String),
    use_context: List(Usagecontext),
    jurisdiction: List(Codeableconcept),
    purpose: Option(String),
    start: r4bvaluesets.Resourcetypes,
    profile: Option(String),
    link: List(GraphdefinitionLink),
  )
}

pub fn graphdefinition_new(
  start start: r4bvaluesets.Resourcetypes,
  status status: r4bvaluesets.Publicationstatus,
  name name: String,
) -> Graphdefinition {
  Graphdefinition(
    link: [],
    profile: None,
    start:,
    purpose: None,
    jurisdiction: [],
    use_context: [],
    description: None,
    contact: [],
    publisher: None,
    date: None,
    experimental: None,
    status:,
    name:,
    version: None,
    url: None,
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/GraphDefinition#resource
pub type GraphdefinitionLink {
  GraphdefinitionLink(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    path: Option(String),
    slice_name: Option(String),
    min: Option(Int),
    max: Option(String),
    description: Option(String),
    target: List(GraphdefinitionLinkTarget),
  )
}

pub fn graphdefinition_link_new() -> GraphdefinitionLink {
  GraphdefinitionLink(
    target: [],
    description: None,
    max: None,
    min: None,
    slice_name: None,
    path: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/GraphDefinition#resource
pub type GraphdefinitionLinkTarget {
  GraphdefinitionLinkTarget(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: r4bvaluesets.Resourcetypes,
    params: Option(String),
    profile: Option(String),
    compartment: List(GraphdefinitionLinkTargetCompartment),
  )
}

pub fn graphdefinition_link_target_new(
  type_ type_: r4bvaluesets.Resourcetypes,
) -> GraphdefinitionLinkTarget {
  GraphdefinitionLinkTarget(
    compartment: [],
    profile: None,
    params: None,
    type_:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/GraphDefinition#resource
pub type GraphdefinitionLinkTargetCompartment {
  GraphdefinitionLinkTargetCompartment(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    use_: r4bvaluesets.Graphcompartmentuse,
    code: r4bvaluesets.Compartmenttype,
    rule: r4bvaluesets.Graphcompartmentrule,
    expression: Option(String),
    description: Option(String),
  )
}

pub fn graphdefinition_link_target_compartment_new(
  rule rule: r4bvaluesets.Graphcompartmentrule,
  code code: r4bvaluesets.Compartmenttype,
  use_ use_: r4bvaluesets.Graphcompartmentuse,
) -> GraphdefinitionLinkTargetCompartment {
  GraphdefinitionLinkTargetCompartment(
    description: None,
    expression: None,
    rule:,
    code:,
    use_:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn graphdefinition_link_target_compartment_to_json(
  graphdefinition_link_target_compartment: GraphdefinitionLinkTargetCompartment,
) -> Json {
  let GraphdefinitionLinkTargetCompartment(
    description:,
    expression:,
    rule:,
    code:,
    use_:,
    modifier_extension:,
    extension:,
    id:,
  ) = graphdefinition_link_target_compartment
  let fields = [
    #("rule", r4bvaluesets.graphcompartmentrule_to_json(rule)),
    #("code", r4bvaluesets.compartmenttype_to_json(code)),
    #("use", r4bvaluesets.graphcompartmentuse_to_json(use_)),
  ]
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case expression {
    Some(v) -> [#("expression", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn graphdefinition_link_target_compartment_decoder() -> Decoder(
  GraphdefinitionLinkTargetCompartment,
) {
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use expression <- decode.optional_field(
    "expression",
    None,
    decode.optional(decode.string),
  )
  use rule <- decode.field("rule", r4bvaluesets.graphcompartmentrule_decoder())
  use code <- decode.field("code", r4bvaluesets.compartmenttype_decoder())
  use use_ <- decode.field("use", r4bvaluesets.graphcompartmentuse_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(GraphdefinitionLinkTargetCompartment(
    description:,
    expression:,
    rule:,
    code:,
    use_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn graphdefinition_link_target_to_json(
  graphdefinition_link_target: GraphdefinitionLinkTarget,
) -> Json {
  let GraphdefinitionLinkTarget(
    compartment:,
    profile:,
    params:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = graphdefinition_link_target
  let fields = [
    #("type", r4bvaluesets.resourcetypes_to_json(type_)),
  ]
  let fields = case compartment {
    [] -> fields
    _ -> [
      #(
        "compartment",
        json.array(compartment, graphdefinition_link_target_compartment_to_json),
      ),
      ..fields
    ]
  }
  let fields = case profile {
    Some(v) -> [#("profile", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case params {
    Some(v) -> [#("params", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn graphdefinition_link_target_decoder() -> Decoder(
  GraphdefinitionLinkTarget,
) {
  use compartment <- decode.optional_field(
    "compartment",
    [],
    decode.list(graphdefinition_link_target_compartment_decoder()),
  )
  use profile <- decode.optional_field(
    "profile",
    None,
    decode.optional(decode.string),
  )
  use params <- decode.optional_field(
    "params",
    None,
    decode.optional(decode.string),
  )
  use type_ <- decode.field("type", r4bvaluesets.resourcetypes_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(GraphdefinitionLinkTarget(
    compartment:,
    profile:,
    params:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn graphdefinition_link_to_json(
  graphdefinition_link: GraphdefinitionLink,
) -> Json {
  let GraphdefinitionLink(
    target:,
    description:,
    max:,
    min:,
    slice_name:,
    path:,
    modifier_extension:,
    extension:,
    id:,
  ) = graphdefinition_link
  let fields = []
  let fields = case target {
    [] -> fields
    _ -> [
      #("target", json.array(target, graphdefinition_link_target_to_json)),
      ..fields
    ]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case max {
    Some(v) -> [#("max", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case min {
    Some(v) -> [#("min", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case slice_name {
    Some(v) -> [#("sliceName", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case path {
    Some(v) -> [#("path", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn graphdefinition_link_decoder() -> Decoder(GraphdefinitionLink) {
  use target <- decode.optional_field(
    "target",
    [],
    decode.list(graphdefinition_link_target_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use max <- decode.optional_field("max", None, decode.optional(decode.string))
  use min <- decode.optional_field("min", None, decode.optional(decode.int))
  use slice_name <- decode.optional_field(
    "sliceName",
    None,
    decode.optional(decode.string),
  )
  use path <- decode.optional_field(
    "path",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(GraphdefinitionLink(
    target:,
    description:,
    max:,
    min:,
    slice_name:,
    path:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn graphdefinition_to_json(graphdefinition: Graphdefinition) -> Json {
  let Graphdefinition(
    link:,
    profile:,
    start:,
    purpose:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    experimental:,
    status:,
    name:,
    version:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = graphdefinition
  let fields = [
    #("start", r4bvaluesets.resourcetypes_to_json(start)),
    #("status", r4bvaluesets.publicationstatus_to_json(status)),
    #("name", json.string(name)),
  ]
  let fields = case link {
    [] -> fields
    _ -> [#("link", json.array(link, graphdefinition_link_to_json)), ..fields]
  }
  let fields = case profile {
    Some(v) -> [#("profile", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case purpose {
    Some(v) -> [#("purpose", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case jurisdiction {
    [] -> fields
    _ -> [
      #("jurisdiction", json.array(jurisdiction, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case use_context {
    [] -> fields
    _ -> [
      #("useContext", json.array(use_context, usagecontext_to_json)),
      ..fields
    ]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case contact {
    [] -> fields
    _ -> [#("contact", json.array(contact, contactdetail_to_json)), ..fields]
  }
  let fields = case publisher {
    Some(v) -> [#("publisher", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case date {
    Some(v) -> [#("date", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case experimental {
    Some(v) -> [#("experimental", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case version {
    Some(v) -> [#("version", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case url {
    Some(v) -> [#("url", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Graphdefinition")), ..fields]
  json.object(fields)
}

pub fn graphdefinition_decoder() -> Decoder(Graphdefinition) {
  use link <- decode.optional_field(
    "link",
    [],
    decode.list(graphdefinition_link_decoder()),
  )
  use profile <- decode.optional_field(
    "profile",
    None,
    decode.optional(decode.string),
  )
  use start <- decode.field("start", r4bvaluesets.resourcetypes_decoder())
  use purpose <- decode.optional_field(
    "purpose",
    None,
    decode.optional(decode.string),
  )
  use jurisdiction <- decode.optional_field(
    "jurisdiction",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use use_context <- decode.optional_field(
    "useContext",
    [],
    decode.list(usagecontext_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use contact <- decode.optional_field(
    "contact",
    [],
    decode.list(contactdetail_decoder()),
  )
  use publisher <- decode.optional_field(
    "publisher",
    None,
    decode.optional(decode.string),
  )
  use date <- decode.optional_field(
    "date",
    None,
    decode.optional(decode.string),
  )
  use experimental <- decode.optional_field(
    "experimental",
    None,
    decode.optional(decode.bool),
  )
  use status <- decode.field("status", r4bvaluesets.publicationstatus_decoder())
  use name <- decode.field("name", decode.string)
  use version <- decode.optional_field(
    "version",
    None,
    decode.optional(decode.string),
  )
  use url <- decode.optional_field("url", None, decode.optional(decode.string))
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Graphdefinition",
    decode.failure(graphdefinition_new(start:, status:, name:), "resourceType"),
  )
  decode.success(Graphdefinition(
    link:,
    profile:,
    start:,
    purpose:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    experimental:,
    status:,
    name:,
    version:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/Group#resource
pub type Group {
  Group(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    active: Option(Bool),
    type_: r4bvaluesets.Grouptype,
    actual: Bool,
    code: Option(Codeableconcept),
    name: Option(String),
    quantity: Option(Int),
    managing_entity: Option(Reference),
    characteristic: List(GroupCharacteristic),
    member: List(GroupMember),
  )
}

pub fn group_new(
  actual actual: Bool,
  type_ type_: r4bvaluesets.Grouptype,
) -> Group {
  Group(
    member: [],
    characteristic: [],
    managing_entity: None,
    quantity: None,
    name: None,
    code: None,
    actual:,
    type_:,
    active: None,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Group#resource
pub type GroupCharacteristic {
  GroupCharacteristic(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    code: Codeableconcept,
    value: GroupCharacteristicValue,
    exclude: Bool,
    period: Option(Period),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Group#resource
pub type GroupCharacteristicValue {
  GroupCharacteristicValueCodeableconcept(value: Codeableconcept)
  GroupCharacteristicValueBoolean(value: Bool)
  GroupCharacteristicValueQuantity(value: Quantity)
  GroupCharacteristicValueRange(value: Range)
  GroupCharacteristicValueReference(value: Reference)
}

pub fn group_characteristic_value_to_json(elt: GroupCharacteristicValue) -> Json {
  case elt {
    GroupCharacteristicValueCodeableconcept(v) -> codeableconcept_to_json(v)
    GroupCharacteristicValueBoolean(v) -> json.bool(v)
    GroupCharacteristicValueQuantity(v) -> quantity_to_json(v)
    GroupCharacteristicValueRange(v) -> range_to_json(v)
    GroupCharacteristicValueReference(v) -> reference_to_json(v)
  }
}

pub fn group_characteristic_value_decoder() -> Decoder(GroupCharacteristicValue) {
  decode.one_of(
    decode.field(
      "valueCodeableConcept",
      codeableconcept_decoder(),
      decode.success,
    )
      |> decode.map(GroupCharacteristicValueCodeableconcept),
    [
      decode.field("valueBoolean", decode.bool, decode.success)
        |> decode.map(GroupCharacteristicValueBoolean),
      decode.field("valueQuantity", quantity_decoder(), decode.success)
        |> decode.map(GroupCharacteristicValueQuantity),
      decode.field("valueRange", range_decoder(), decode.success)
        |> decode.map(GroupCharacteristicValueRange),
      decode.field("valueReference", reference_decoder(), decode.success)
        |> decode.map(GroupCharacteristicValueReference),
    ],
  )
}

pub fn group_characteristic_new(
  exclude exclude: Bool,
  value value: GroupCharacteristicValue,
  code code: Codeableconcept,
) -> GroupCharacteristic {
  GroupCharacteristic(
    period: None,
    exclude:,
    value:,
    code:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Group#resource
pub type GroupMember {
  GroupMember(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    entity: Reference,
    period: Option(Period),
    inactive: Option(Bool),
  )
}

pub fn group_member_new(entity entity: Reference) -> GroupMember {
  GroupMember(
    inactive: None,
    period: None,
    entity:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn group_member_to_json(group_member: GroupMember) -> Json {
  let GroupMember(
    inactive:,
    period:,
    entity:,
    modifier_extension:,
    extension:,
    id:,
  ) = group_member
  let fields = [
    #("entity", reference_to_json(entity)),
  ]
  let fields = case inactive {
    Some(v) -> [#("inactive", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case period {
    Some(v) -> [#("period", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn group_member_decoder() -> Decoder(GroupMember) {
  use inactive <- decode.optional_field(
    "inactive",
    None,
    decode.optional(decode.bool),
  )
  use period <- decode.optional_field(
    "period",
    None,
    decode.optional(period_decoder()),
  )
  use entity <- decode.field("entity", reference_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(GroupMember(
    inactive:,
    period:,
    entity:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn group_characteristic_to_json(
  group_characteristic: GroupCharacteristic,
) -> Json {
  let GroupCharacteristic(
    period:,
    exclude:,
    value:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ) = group_characteristic
  let fields = [
    #("exclude", json.bool(exclude)),
    #("value", group_characteristic_value_to_json(value)),
    #("code", codeableconcept_to_json(code)),
  ]
  let fields = case period {
    Some(v) -> [#("period", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn group_characteristic_decoder() -> Decoder(GroupCharacteristic) {
  use period <- decode.optional_field(
    "period",
    None,
    decode.optional(period_decoder()),
  )
  use exclude <- decode.field("exclude", decode.bool)
  use value <- decode.then(group_characteristic_value_decoder())
  use code <- decode.field("code", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(GroupCharacteristic(
    period:,
    exclude:,
    value:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn group_to_json(group: Group) -> Json {
  let Group(
    member:,
    characteristic:,
    managing_entity:,
    quantity:,
    name:,
    code:,
    actual:,
    type_:,
    active:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = group
  let fields = [
    #("actual", json.bool(actual)),
    #("type", r4bvaluesets.grouptype_to_json(type_)),
  ]
  let fields = case member {
    [] -> fields
    _ -> [#("member", json.array(member, group_member_to_json)), ..fields]
  }
  let fields = case characteristic {
    [] -> fields
    _ -> [
      #(
        "characteristic",
        json.array(characteristic, group_characteristic_to_json),
      ),
      ..fields
    ]
  }
  let fields = case managing_entity {
    Some(v) -> [#("managingEntity", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case quantity {
    Some(v) -> [#("quantity", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case code {
    Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case active {
    Some(v) -> [#("active", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Group")), ..fields]
  json.object(fields)
}

pub fn group_decoder() -> Decoder(Group) {
  use member <- decode.optional_field(
    "member",
    [],
    decode.list(group_member_decoder()),
  )
  use characteristic <- decode.optional_field(
    "characteristic",
    [],
    decode.list(group_characteristic_decoder()),
  )
  use managing_entity <- decode.optional_field(
    "managingEntity",
    None,
    decode.optional(reference_decoder()),
  )
  use quantity <- decode.optional_field(
    "quantity",
    None,
    decode.optional(decode.int),
  )
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use actual <- decode.field("actual", decode.bool)
  use type_ <- decode.field("type", r4bvaluesets.grouptype_decoder())
  use active <- decode.optional_field(
    "active",
    None,
    decode.optional(decode.bool),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Group",
    decode.failure(group_new(actual:, type_:), "resourceType"),
  )
  decode.success(Group(
    member:,
    characteristic:,
    managing_entity:,
    quantity:,
    name:,
    code:,
    actual:,
    type_:,
    active:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/GuidanceResponse#resource
pub type Guidanceresponse {
  Guidanceresponse(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    request_identifier: Option(Identifier),
    identifier: List(Identifier),
    module: GuidanceresponseModule,
    status: r4bvaluesets.Guidanceresponsestatus,
    subject: Option(Reference),
    encounter: Option(Reference),
    occurrence_date_time: Option(String),
    performer: Option(Reference),
    reason_code: List(Codeableconcept),
    reason_reference: List(Reference),
    note: List(Annotation),
    evaluation_message: List(Reference),
    output_parameters: Option(Reference),
    result: Option(Reference),
    data_requirement: List(Datarequirement),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/GuidanceResponse#resource
pub type GuidanceresponseModule {
  GuidanceresponseModuleUri(module: String)
  GuidanceresponseModuleCanonical(module: String)
  GuidanceresponseModuleCodeableconcept(module: Codeableconcept)
}

pub fn guidanceresponse_module_to_json(elt: GuidanceresponseModule) -> Json {
  case elt {
    GuidanceresponseModuleUri(v) -> json.string(v)
    GuidanceresponseModuleCanonical(v) -> json.string(v)
    GuidanceresponseModuleCodeableconcept(v) -> codeableconcept_to_json(v)
  }
}

pub fn guidanceresponse_module_decoder() -> Decoder(GuidanceresponseModule) {
  decode.one_of(
    decode.field("moduleUri", decode.string, decode.success)
      |> decode.map(GuidanceresponseModuleUri),
    [
      decode.field("moduleCanonical", decode.string, decode.success)
        |> decode.map(GuidanceresponseModuleCanonical),
      decode.field(
        "moduleCodeableConcept",
        codeableconcept_decoder(),
        decode.success,
      )
        |> decode.map(GuidanceresponseModuleCodeableconcept),
    ],
  )
}

pub fn guidanceresponse_new(
  status status: r4bvaluesets.Guidanceresponsestatus,
  module module: GuidanceresponseModule,
) -> Guidanceresponse {
  Guidanceresponse(
    data_requirement: [],
    result: None,
    output_parameters: None,
    evaluation_message: [],
    note: [],
    reason_reference: [],
    reason_code: [],
    performer: None,
    occurrence_date_time: None,
    encounter: None,
    subject: None,
    status:,
    module:,
    identifier: [],
    request_identifier: None,
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

pub fn guidanceresponse_to_json(guidanceresponse: Guidanceresponse) -> Json {
  let Guidanceresponse(
    data_requirement:,
    result:,
    output_parameters:,
    evaluation_message:,
    note:,
    reason_reference:,
    reason_code:,
    performer:,
    occurrence_date_time:,
    encounter:,
    subject:,
    status:,
    module:,
    identifier:,
    request_identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = guidanceresponse
  let fields = [
    #("status", r4bvaluesets.guidanceresponsestatus_to_json(status)),
    #("module", guidanceresponse_module_to_json(module)),
  ]
  let fields = case data_requirement {
    [] -> fields
    _ -> [
      #(
        "dataRequirement",
        json.array(data_requirement, datarequirement_to_json),
      ),
      ..fields
    ]
  }
  let fields = case result {
    Some(v) -> [#("result", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case output_parameters {
    Some(v) -> [#("outputParameters", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case evaluation_message {
    [] -> fields
    _ -> [
      #("evaluationMessage", json.array(evaluation_message, reference_to_json)),
      ..fields
    ]
  }
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case reason_reference {
    [] -> fields
    _ -> [
      #("reasonReference", json.array(reason_reference, reference_to_json)),
      ..fields
    ]
  }
  let fields = case reason_code {
    [] -> fields
    _ -> [
      #("reasonCode", json.array(reason_code, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case performer {
    Some(v) -> [#("performer", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case occurrence_date_time {
    Some(v) -> [#("occurrenceDateTime", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case encounter {
    Some(v) -> [#("encounter", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case subject {
    Some(v) -> [#("subject", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case request_identifier {
    Some(v) -> [#("requestIdentifier", identifier_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Guidanceresponse")), ..fields]
  json.object(fields)
}

pub fn guidanceresponse_decoder() -> Decoder(Guidanceresponse) {
  use data_requirement <- decode.optional_field(
    "dataRequirement",
    [],
    decode.list(datarequirement_decoder()),
  )
  use result <- decode.optional_field(
    "result",
    None,
    decode.optional(reference_decoder()),
  )
  use output_parameters <- decode.optional_field(
    "outputParameters",
    None,
    decode.optional(reference_decoder()),
  )
  use evaluation_message <- decode.optional_field(
    "evaluationMessage",
    [],
    decode.list(reference_decoder()),
  )
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use reason_reference <- decode.optional_field(
    "reasonReference",
    [],
    decode.list(reference_decoder()),
  )
  use reason_code <- decode.optional_field(
    "reasonCode",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use performer <- decode.optional_field(
    "performer",
    None,
    decode.optional(reference_decoder()),
  )
  use occurrence_date_time <- decode.optional_field(
    "occurrenceDateTime",
    None,
    decode.optional(decode.string),
  )
  use encounter <- decode.optional_field(
    "encounter",
    None,
    decode.optional(reference_decoder()),
  )
  use subject <- decode.optional_field(
    "subject",
    None,
    decode.optional(reference_decoder()),
  )
  use status <- decode.field(
    "status",
    r4bvaluesets.guidanceresponsestatus_decoder(),
  )
  use module <- decode.then(guidanceresponse_module_decoder())
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use request_identifier <- decode.optional_field(
    "requestIdentifier",
    None,
    decode.optional(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Guidanceresponse",
    decode.failure(guidanceresponse_new(status:, module:), "resourceType"),
  )
  decode.success(Guidanceresponse(
    data_requirement:,
    result:,
    output_parameters:,
    evaluation_message:,
    note:,
    reason_reference:,
    reason_code:,
    performer:,
    occurrence_date_time:,
    encounter:,
    subject:,
    status:,
    module:,
    identifier:,
    request_identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/HealthcareService#resource
pub type Healthcareservice {
  Healthcareservice(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    active: Option(Bool),
    provided_by: Option(Reference),
    category: List(Codeableconcept),
    type_: List(Codeableconcept),
    specialty: List(Codeableconcept),
    location: List(Reference),
    name: Option(String),
    comment: Option(String),
    extra_details: Option(String),
    photo: Option(Attachment),
    telecom: List(Contactpoint),
    coverage_area: List(Reference),
    service_provision_code: List(Codeableconcept),
    eligibility: List(HealthcareserviceEligibility),
    program: List(Codeableconcept),
    characteristic: List(Codeableconcept),
    communication: List(Codeableconcept),
    referral_method: List(Codeableconcept),
    appointment_required: Option(Bool),
    available_time: List(HealthcareserviceAvailabletime),
    not_available: List(HealthcareserviceNotavailable),
    availability_exceptions: Option(String),
    endpoint: List(Reference),
  )
}

pub fn healthcareservice_new() -> Healthcareservice {
  Healthcareservice(
    endpoint: [],
    availability_exceptions: None,
    not_available: [],
    available_time: [],
    appointment_required: None,
    referral_method: [],
    communication: [],
    characteristic: [],
    program: [],
    eligibility: [],
    service_provision_code: [],
    coverage_area: [],
    telecom: [],
    photo: None,
    extra_details: None,
    comment: None,
    name: None,
    location: [],
    specialty: [],
    type_: [],
    category: [],
    provided_by: None,
    active: None,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/HealthcareService#resource
pub type HealthcareserviceEligibility {
  HealthcareserviceEligibility(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    code: Option(Codeableconcept),
    comment: Option(String),
  )
}

pub fn healthcareservice_eligibility_new() -> HealthcareserviceEligibility {
  HealthcareserviceEligibility(
    comment: None,
    code: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/HealthcareService#resource
pub type HealthcareserviceAvailabletime {
  HealthcareserviceAvailabletime(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    days_of_week: List(r4bvaluesets.Daysofweek),
    all_day: Option(Bool),
    available_start_time: Option(String),
    available_end_time: Option(String),
  )
}

pub fn healthcareservice_availabletime_new() -> HealthcareserviceAvailabletime {
  HealthcareserviceAvailabletime(
    available_end_time: None,
    available_start_time: None,
    all_day: None,
    days_of_week: [],
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/HealthcareService#resource
pub type HealthcareserviceNotavailable {
  HealthcareserviceNotavailable(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    description: String,
    during: Option(Period),
  )
}

pub fn healthcareservice_notavailable_new(
  description description: String,
) -> HealthcareserviceNotavailable {
  HealthcareserviceNotavailable(
    during: None,
    description:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn healthcareservice_notavailable_to_json(
  healthcareservice_notavailable: HealthcareserviceNotavailable,
) -> Json {
  let HealthcareserviceNotavailable(
    during:,
    description:,
    modifier_extension:,
    extension:,
    id:,
  ) = healthcareservice_notavailable
  let fields = [
    #("description", json.string(description)),
  ]
  let fields = case during {
    Some(v) -> [#("during", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn healthcareservice_notavailable_decoder() -> Decoder(
  HealthcareserviceNotavailable,
) {
  use during <- decode.optional_field(
    "during",
    None,
    decode.optional(period_decoder()),
  )
  use description <- decode.field("description", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(HealthcareserviceNotavailable(
    during:,
    description:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn healthcareservice_availabletime_to_json(
  healthcareservice_availabletime: HealthcareserviceAvailabletime,
) -> Json {
  let HealthcareserviceAvailabletime(
    available_end_time:,
    available_start_time:,
    all_day:,
    days_of_week:,
    modifier_extension:,
    extension:,
    id:,
  ) = healthcareservice_availabletime
  let fields = []
  let fields = case available_end_time {
    Some(v) -> [#("availableEndTime", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case available_start_time {
    Some(v) -> [#("availableStartTime", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case all_day {
    Some(v) -> [#("allDay", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case days_of_week {
    [] -> fields
    _ -> [
      #("daysOfWeek", json.array(days_of_week, r4bvaluesets.daysofweek_to_json)),
      ..fields
    ]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn healthcareservice_availabletime_decoder() -> Decoder(
  HealthcareserviceAvailabletime,
) {
  use available_end_time <- decode.optional_field(
    "availableEndTime",
    None,
    decode.optional(decode.string),
  )
  use available_start_time <- decode.optional_field(
    "availableStartTime",
    None,
    decode.optional(decode.string),
  )
  use all_day <- decode.optional_field(
    "allDay",
    None,
    decode.optional(decode.bool),
  )
  use days_of_week <- decode.optional_field(
    "daysOfWeek",
    [],
    decode.list(r4bvaluesets.daysofweek_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(HealthcareserviceAvailabletime(
    available_end_time:,
    available_start_time:,
    all_day:,
    days_of_week:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn healthcareservice_eligibility_to_json(
  healthcareservice_eligibility: HealthcareserviceEligibility,
) -> Json {
  let HealthcareserviceEligibility(
    comment:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ) = healthcareservice_eligibility
  let fields = []
  let fields = case comment {
    Some(v) -> [#("comment", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case code {
    Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn healthcareservice_eligibility_decoder() -> Decoder(
  HealthcareserviceEligibility,
) {
  use comment <- decode.optional_field(
    "comment",
    None,
    decode.optional(decode.string),
  )
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(HealthcareserviceEligibility(
    comment:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn healthcareservice_to_json(healthcareservice: Healthcareservice) -> Json {
  let Healthcareservice(
    endpoint:,
    availability_exceptions:,
    not_available:,
    available_time:,
    appointment_required:,
    referral_method:,
    communication:,
    characteristic:,
    program:,
    eligibility:,
    service_provision_code:,
    coverage_area:,
    telecom:,
    photo:,
    extra_details:,
    comment:,
    name:,
    location:,
    specialty:,
    type_:,
    category:,
    provided_by:,
    active:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = healthcareservice
  let fields = []
  let fields = case endpoint {
    [] -> fields
    _ -> [#("endpoint", json.array(endpoint, reference_to_json)), ..fields]
  }
  let fields = case availability_exceptions {
    Some(v) -> [#("availabilityExceptions", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case not_available {
    [] -> fields
    _ -> [
      #(
        "notAvailable",
        json.array(not_available, healthcareservice_notavailable_to_json),
      ),
      ..fields
    ]
  }
  let fields = case available_time {
    [] -> fields
    _ -> [
      #(
        "availableTime",
        json.array(available_time, healthcareservice_availabletime_to_json),
      ),
      ..fields
    ]
  }
  let fields = case appointment_required {
    Some(v) -> [#("appointmentRequired", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case referral_method {
    [] -> fields
    _ -> [
      #("referralMethod", json.array(referral_method, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case communication {
    [] -> fields
    _ -> [
      #("communication", json.array(communication, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case characteristic {
    [] -> fields
    _ -> [
      #("characteristic", json.array(characteristic, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case program {
    [] -> fields
    _ -> [#("program", json.array(program, codeableconcept_to_json)), ..fields]
  }
  let fields = case eligibility {
    [] -> fields
    _ -> [
      #(
        "eligibility",
        json.array(eligibility, healthcareservice_eligibility_to_json),
      ),
      ..fields
    ]
  }
  let fields = case service_provision_code {
    [] -> fields
    _ -> [
      #(
        "serviceProvisionCode",
        json.array(service_provision_code, codeableconcept_to_json),
      ),
      ..fields
    ]
  }
  let fields = case coverage_area {
    [] -> fields
    _ -> [
      #("coverageArea", json.array(coverage_area, reference_to_json)),
      ..fields
    ]
  }
  let fields = case telecom {
    [] -> fields
    _ -> [#("telecom", json.array(telecom, contactpoint_to_json)), ..fields]
  }
  let fields = case photo {
    Some(v) -> [#("photo", attachment_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case extra_details {
    Some(v) -> [#("extraDetails", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case comment {
    Some(v) -> [#("comment", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case location {
    [] -> fields
    _ -> [#("location", json.array(location, reference_to_json)), ..fields]
  }
  let fields = case specialty {
    [] -> fields
    _ -> [
      #("specialty", json.array(specialty, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case type_ {
    [] -> fields
    _ -> [#("type", json.array(type_, codeableconcept_to_json)), ..fields]
  }
  let fields = case category {
    [] -> fields
    _ -> [
      #("category", json.array(category, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case provided_by {
    Some(v) -> [#("providedBy", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case active {
    Some(v) -> [#("active", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Healthcareservice")), ..fields]
  json.object(fields)
}

pub fn healthcareservice_decoder() -> Decoder(Healthcareservice) {
  use endpoint <- decode.optional_field(
    "endpoint",
    [],
    decode.list(reference_decoder()),
  )
  use availability_exceptions <- decode.optional_field(
    "availabilityExceptions",
    None,
    decode.optional(decode.string),
  )
  use not_available <- decode.optional_field(
    "notAvailable",
    [],
    decode.list(healthcareservice_notavailable_decoder()),
  )
  use available_time <- decode.optional_field(
    "availableTime",
    [],
    decode.list(healthcareservice_availabletime_decoder()),
  )
  use appointment_required <- decode.optional_field(
    "appointmentRequired",
    None,
    decode.optional(decode.bool),
  )
  use referral_method <- decode.optional_field(
    "referralMethod",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use communication <- decode.optional_field(
    "communication",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use characteristic <- decode.optional_field(
    "characteristic",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use program <- decode.optional_field(
    "program",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use eligibility <- decode.optional_field(
    "eligibility",
    [],
    decode.list(healthcareservice_eligibility_decoder()),
  )
  use service_provision_code <- decode.optional_field(
    "serviceProvisionCode",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use coverage_area <- decode.optional_field(
    "coverageArea",
    [],
    decode.list(reference_decoder()),
  )
  use telecom <- decode.optional_field(
    "telecom",
    [],
    decode.list(contactpoint_decoder()),
  )
  use photo <- decode.optional_field(
    "photo",
    None,
    decode.optional(attachment_decoder()),
  )
  use extra_details <- decode.optional_field(
    "extraDetails",
    None,
    decode.optional(decode.string),
  )
  use comment <- decode.optional_field(
    "comment",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use location <- decode.optional_field(
    "location",
    [],
    decode.list(reference_decoder()),
  )
  use specialty <- decode.optional_field(
    "specialty",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use category <- decode.optional_field(
    "category",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use provided_by <- decode.optional_field(
    "providedBy",
    None,
    decode.optional(reference_decoder()),
  )
  use active <- decode.optional_field(
    "active",
    None,
    decode.optional(decode.bool),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Healthcareservice",
    decode.failure(healthcareservice_new(), "resourceType"),
  )
  decode.success(Healthcareservice(
    endpoint:,
    availability_exceptions:,
    not_available:,
    available_time:,
    appointment_required:,
    referral_method:,
    communication:,
    characteristic:,
    program:,
    eligibility:,
    service_provision_code:,
    coverage_area:,
    telecom:,
    photo:,
    extra_details:,
    comment:,
    name:,
    location:,
    specialty:,
    type_:,
    category:,
    provided_by:,
    active:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/ImagingStudy#resource
pub type Imagingstudy {
  Imagingstudy(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    status: r4bvaluesets.Imagingstudystatus,
    modality: List(Coding),
    subject: Reference,
    encounter: Option(Reference),
    started: Option(String),
    based_on: List(Reference),
    referrer: Option(Reference),
    interpreter: List(Reference),
    endpoint: List(Reference),
    number_of_series: Option(Int),
    number_of_instances: Option(Int),
    procedure_reference: Option(Reference),
    procedure_code: List(Codeableconcept),
    location: Option(Reference),
    reason_code: List(Codeableconcept),
    reason_reference: List(Reference),
    note: List(Annotation),
    description: Option(String),
    series: List(ImagingstudySeries),
  )
}

pub fn imagingstudy_new(
  subject subject: Reference,
  status status: r4bvaluesets.Imagingstudystatus,
) -> Imagingstudy {
  Imagingstudy(
    series: [],
    description: None,
    note: [],
    reason_reference: [],
    reason_code: [],
    location: None,
    procedure_code: [],
    procedure_reference: None,
    number_of_instances: None,
    number_of_series: None,
    endpoint: [],
    interpreter: [],
    referrer: None,
    based_on: [],
    started: None,
    encounter: None,
    subject:,
    modality: [],
    status:,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ImagingStudy#resource
pub type ImagingstudySeries {
  ImagingstudySeries(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    uid: String,
    number: Option(Int),
    modality: Coding,
    description: Option(String),
    number_of_instances: Option(Int),
    endpoint: List(Reference),
    body_site: Option(Coding),
    laterality: Option(Coding),
    specimen: List(Reference),
    started: Option(String),
    performer: List(ImagingstudySeriesPerformer),
    instance: List(ImagingstudySeriesInstance),
  )
}

pub fn imagingstudy_series_new(
  modality modality: Coding,
  uid uid: String,
) -> ImagingstudySeries {
  ImagingstudySeries(
    instance: [],
    performer: [],
    started: None,
    specimen: [],
    laterality: None,
    body_site: None,
    endpoint: [],
    number_of_instances: None,
    description: None,
    modality:,
    number: None,
    uid:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ImagingStudy#resource
pub type ImagingstudySeriesPerformer {
  ImagingstudySeriesPerformer(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    function: Option(Codeableconcept),
    actor: Reference,
  )
}

pub fn imagingstudy_series_performer_new(
  actor actor: Reference,
) -> ImagingstudySeriesPerformer {
  ImagingstudySeriesPerformer(
    actor:,
    function: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ImagingStudy#resource
pub type ImagingstudySeriesInstance {
  ImagingstudySeriesInstance(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    uid: String,
    sop_class: Coding,
    number: Option(Int),
    title: Option(String),
  )
}

pub fn imagingstudy_series_instance_new(
  sop_class sop_class: Coding,
  uid uid: String,
) -> ImagingstudySeriesInstance {
  ImagingstudySeriesInstance(
    title: None,
    number: None,
    sop_class:,
    uid:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn imagingstudy_series_instance_to_json(
  imagingstudy_series_instance: ImagingstudySeriesInstance,
) -> Json {
  let ImagingstudySeriesInstance(
    title:,
    number:,
    sop_class:,
    uid:,
    modifier_extension:,
    extension:,
    id:,
  ) = imagingstudy_series_instance
  let fields = [
    #("sopClass", coding_to_json(sop_class)),
    #("uid", json.string(uid)),
  ]
  let fields = case title {
    Some(v) -> [#("title", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case number {
    Some(v) -> [#("number", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn imagingstudy_series_instance_decoder() -> Decoder(
  ImagingstudySeriesInstance,
) {
  use title <- decode.optional_field(
    "title",
    None,
    decode.optional(decode.string),
  )
  use number <- decode.optional_field(
    "number",
    None,
    decode.optional(decode.int),
  )
  use sop_class <- decode.field("sopClass", coding_decoder())
  use uid <- decode.field("uid", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ImagingstudySeriesInstance(
    title:,
    number:,
    sop_class:,
    uid:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn imagingstudy_series_performer_to_json(
  imagingstudy_series_performer: ImagingstudySeriesPerformer,
) -> Json {
  let ImagingstudySeriesPerformer(
    actor:,
    function:,
    modifier_extension:,
    extension:,
    id:,
  ) = imagingstudy_series_performer
  let fields = [
    #("actor", reference_to_json(actor)),
  ]
  let fields = case function {
    Some(v) -> [#("function", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn imagingstudy_series_performer_decoder() -> Decoder(
  ImagingstudySeriesPerformer,
) {
  use actor <- decode.field("actor", reference_decoder())
  use function <- decode.optional_field(
    "function",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ImagingstudySeriesPerformer(
    actor:,
    function:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn imagingstudy_series_to_json(
  imagingstudy_series: ImagingstudySeries,
) -> Json {
  let ImagingstudySeries(
    instance:,
    performer:,
    started:,
    specimen:,
    laterality:,
    body_site:,
    endpoint:,
    number_of_instances:,
    description:,
    modality:,
    number:,
    uid:,
    modifier_extension:,
    extension:,
    id:,
  ) = imagingstudy_series
  let fields = [
    #("modality", coding_to_json(modality)),
    #("uid", json.string(uid)),
  ]
  let fields = case instance {
    [] -> fields
    _ -> [
      #("instance", json.array(instance, imagingstudy_series_instance_to_json)),
      ..fields
    ]
  }
  let fields = case performer {
    [] -> fields
    _ -> [
      #(
        "performer",
        json.array(performer, imagingstudy_series_performer_to_json),
      ),
      ..fields
    ]
  }
  let fields = case started {
    Some(v) -> [#("started", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case specimen {
    [] -> fields
    _ -> [#("specimen", json.array(specimen, reference_to_json)), ..fields]
  }
  let fields = case laterality {
    Some(v) -> [#("laterality", coding_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case body_site {
    Some(v) -> [#("bodySite", coding_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case endpoint {
    [] -> fields
    _ -> [#("endpoint", json.array(endpoint, reference_to_json)), ..fields]
  }
  let fields = case number_of_instances {
    Some(v) -> [#("numberOfInstances", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case number {
    Some(v) -> [#("number", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn imagingstudy_series_decoder() -> Decoder(ImagingstudySeries) {
  use instance <- decode.optional_field(
    "instance",
    [],
    decode.list(imagingstudy_series_instance_decoder()),
  )
  use performer <- decode.optional_field(
    "performer",
    [],
    decode.list(imagingstudy_series_performer_decoder()),
  )
  use started <- decode.optional_field(
    "started",
    None,
    decode.optional(decode.string),
  )
  use specimen <- decode.optional_field(
    "specimen",
    [],
    decode.list(reference_decoder()),
  )
  use laterality <- decode.optional_field(
    "laterality",
    None,
    decode.optional(coding_decoder()),
  )
  use body_site <- decode.optional_field(
    "bodySite",
    None,
    decode.optional(coding_decoder()),
  )
  use endpoint <- decode.optional_field(
    "endpoint",
    [],
    decode.list(reference_decoder()),
  )
  use number_of_instances <- decode.optional_field(
    "numberOfInstances",
    None,
    decode.optional(decode.int),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use modality <- decode.field("modality", coding_decoder())
  use number <- decode.optional_field(
    "number",
    None,
    decode.optional(decode.int),
  )
  use uid <- decode.field("uid", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ImagingstudySeries(
    instance:,
    performer:,
    started:,
    specimen:,
    laterality:,
    body_site:,
    endpoint:,
    number_of_instances:,
    description:,
    modality:,
    number:,
    uid:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn imagingstudy_to_json(imagingstudy: Imagingstudy) -> Json {
  let Imagingstudy(
    series:,
    description:,
    note:,
    reason_reference:,
    reason_code:,
    location:,
    procedure_code:,
    procedure_reference:,
    number_of_instances:,
    number_of_series:,
    endpoint:,
    interpreter:,
    referrer:,
    based_on:,
    started:,
    encounter:,
    subject:,
    modality:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = imagingstudy
  let fields = [
    #("subject", reference_to_json(subject)),
    #("status", r4bvaluesets.imagingstudystatus_to_json(status)),
  ]
  let fields = case series {
    [] -> fields
    _ -> [
      #("series", json.array(series, imagingstudy_series_to_json)),
      ..fields
    ]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case reason_reference {
    [] -> fields
    _ -> [
      #("reasonReference", json.array(reason_reference, reference_to_json)),
      ..fields
    ]
  }
  let fields = case reason_code {
    [] -> fields
    _ -> [
      #("reasonCode", json.array(reason_code, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case location {
    Some(v) -> [#("location", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case procedure_code {
    [] -> fields
    _ -> [
      #("procedureCode", json.array(procedure_code, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case procedure_reference {
    Some(v) -> [#("procedureReference", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case number_of_instances {
    Some(v) -> [#("numberOfInstances", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case number_of_series {
    Some(v) -> [#("numberOfSeries", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case endpoint {
    [] -> fields
    _ -> [#("endpoint", json.array(endpoint, reference_to_json)), ..fields]
  }
  let fields = case interpreter {
    [] -> fields
    _ -> [
      #("interpreter", json.array(interpreter, reference_to_json)),
      ..fields
    ]
  }
  let fields = case referrer {
    Some(v) -> [#("referrer", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case based_on {
    [] -> fields
    _ -> [#("basedOn", json.array(based_on, reference_to_json)), ..fields]
  }
  let fields = case started {
    Some(v) -> [#("started", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case encounter {
    Some(v) -> [#("encounter", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modality {
    [] -> fields
    _ -> [#("modality", json.array(modality, coding_to_json)), ..fields]
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Imagingstudy")), ..fields]
  json.object(fields)
}

pub fn imagingstudy_decoder() -> Decoder(Imagingstudy) {
  use series <- decode.optional_field(
    "series",
    [],
    decode.list(imagingstudy_series_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use reason_reference <- decode.optional_field(
    "reasonReference",
    [],
    decode.list(reference_decoder()),
  )
  use reason_code <- decode.optional_field(
    "reasonCode",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use location <- decode.optional_field(
    "location",
    None,
    decode.optional(reference_decoder()),
  )
  use procedure_code <- decode.optional_field(
    "procedureCode",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use procedure_reference <- decode.optional_field(
    "procedureReference",
    None,
    decode.optional(reference_decoder()),
  )
  use number_of_instances <- decode.optional_field(
    "numberOfInstances",
    None,
    decode.optional(decode.int),
  )
  use number_of_series <- decode.optional_field(
    "numberOfSeries",
    None,
    decode.optional(decode.int),
  )
  use endpoint <- decode.optional_field(
    "endpoint",
    [],
    decode.list(reference_decoder()),
  )
  use interpreter <- decode.optional_field(
    "interpreter",
    [],
    decode.list(reference_decoder()),
  )
  use referrer <- decode.optional_field(
    "referrer",
    None,
    decode.optional(reference_decoder()),
  )
  use based_on <- decode.optional_field(
    "basedOn",
    [],
    decode.list(reference_decoder()),
  )
  use started <- decode.optional_field(
    "started",
    None,
    decode.optional(decode.string),
  )
  use encounter <- decode.optional_field(
    "encounter",
    None,
    decode.optional(reference_decoder()),
  )
  use subject <- decode.field("subject", reference_decoder())
  use modality <- decode.optional_field(
    "modality",
    [],
    decode.list(coding_decoder()),
  )
  use status <- decode.field(
    "status",
    r4bvaluesets.imagingstudystatus_decoder(),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Imagingstudy",
    decode.failure(imagingstudy_new(subject:, status:), "resourceType"),
  )
  decode.success(Imagingstudy(
    series:,
    description:,
    note:,
    reason_reference:,
    reason_code:,
    location:,
    procedure_code:,
    procedure_reference:,
    number_of_instances:,
    number_of_series:,
    endpoint:,
    interpreter:,
    referrer:,
    based_on:,
    started:,
    encounter:,
    subject:,
    modality:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/Immunization#resource
pub type Immunization {
  Immunization(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    status: r4bvaluesets.Immunizationstatus,
    status_reason: Option(Codeableconcept),
    vaccine_code: Codeableconcept,
    patient: Reference,
    encounter: Option(Reference),
    occurrence: ImmunizationOccurrence,
    recorded: Option(String),
    primary_source: Option(Bool),
    report_origin: Option(Codeableconcept),
    location: Option(Reference),
    manufacturer: Option(Reference),
    lot_number: Option(String),
    expiration_date: Option(String),
    site: Option(Codeableconcept),
    route: Option(Codeableconcept),
    dose_quantity: Option(Quantity),
    performer: List(ImmunizationPerformer),
    note: List(Annotation),
    reason_code: List(Codeableconcept),
    reason_reference: List(Reference),
    is_subpotent: Option(Bool),
    subpotent_reason: List(Codeableconcept),
    education: List(ImmunizationEducation),
    program_eligibility: List(Codeableconcept),
    funding_source: Option(Codeableconcept),
    reaction: List(ImmunizationReaction),
    protocol_applied: List(ImmunizationProtocolapplied),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Immunization#resource
pub type ImmunizationOccurrence {
  ImmunizationOccurrenceDatetime(occurrence: String)
  ImmunizationOccurrenceString(occurrence: String)
}

pub fn immunization_occurrence_to_json(elt: ImmunizationOccurrence) -> Json {
  case elt {
    ImmunizationOccurrenceDatetime(v) -> json.string(v)
    ImmunizationOccurrenceString(v) -> json.string(v)
  }
}

pub fn immunization_occurrence_decoder() -> Decoder(ImmunizationOccurrence) {
  decode.one_of(
    decode.field("occurrenceDateTime", decode.string, decode.success)
      |> decode.map(ImmunizationOccurrenceDatetime),
    [
      decode.field("occurrenceString", decode.string, decode.success)
      |> decode.map(ImmunizationOccurrenceString),
    ],
  )
}

pub fn immunization_new(
  occurrence occurrence: ImmunizationOccurrence,
  patient patient: Reference,
  vaccine_code vaccine_code: Codeableconcept,
  status status: r4bvaluesets.Immunizationstatus,
) -> Immunization {
  Immunization(
    protocol_applied: [],
    reaction: [],
    funding_source: None,
    program_eligibility: [],
    education: [],
    subpotent_reason: [],
    is_subpotent: None,
    reason_reference: [],
    reason_code: [],
    note: [],
    performer: [],
    dose_quantity: None,
    route: None,
    site: None,
    expiration_date: None,
    lot_number: None,
    manufacturer: None,
    location: None,
    report_origin: None,
    primary_source: None,
    recorded: None,
    occurrence:,
    encounter: None,
    patient:,
    vaccine_code:,
    status_reason: None,
    status:,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Immunization#resource
pub type ImmunizationPerformer {
  ImmunizationPerformer(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    function: Option(Codeableconcept),
    actor: Reference,
  )
}

pub fn immunization_performer_new(
  actor actor: Reference,
) -> ImmunizationPerformer {
  ImmunizationPerformer(
    actor:,
    function: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Immunization#resource
pub type ImmunizationEducation {
  ImmunizationEducation(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    document_type: Option(String),
    reference: Option(String),
    publication_date: Option(String),
    presentation_date: Option(String),
  )
}

pub fn immunization_education_new() -> ImmunizationEducation {
  ImmunizationEducation(
    presentation_date: None,
    publication_date: None,
    reference: None,
    document_type: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Immunization#resource
pub type ImmunizationReaction {
  ImmunizationReaction(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    date: Option(String),
    detail: Option(Reference),
    reported: Option(Bool),
  )
}

pub fn immunization_reaction_new() -> ImmunizationReaction {
  ImmunizationReaction(
    reported: None,
    detail: None,
    date: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Immunization#resource
pub type ImmunizationProtocolapplied {
  ImmunizationProtocolapplied(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    series: Option(String),
    authority: Option(Reference),
    target_disease: List(Codeableconcept),
    dose_number: ImmunizationProtocolappliedDosenumber,
    series_doses: Option(ImmunizationProtocolappliedSeriesdoses),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Immunization#resource
pub type ImmunizationProtocolappliedDosenumber {
  ImmunizationProtocolappliedDosenumberPositiveint(dose_number: Int)
  ImmunizationProtocolappliedDosenumberString(dose_number: String)
}

pub fn immunization_protocolapplied_dosenumber_to_json(
  elt: ImmunizationProtocolappliedDosenumber,
) -> Json {
  case elt {
    ImmunizationProtocolappliedDosenumberPositiveint(v) -> json.int(v)
    ImmunizationProtocolappliedDosenumberString(v) -> json.string(v)
  }
}

pub fn immunization_protocolapplied_dosenumber_decoder() -> Decoder(
  ImmunizationProtocolappliedDosenumber,
) {
  decode.one_of(
    decode.field("doseNumberPositiveInt", decode.int, decode.success)
      |> decode.map(ImmunizationProtocolappliedDosenumberPositiveint),
    [
      decode.field("doseNumberString", decode.string, decode.success)
      |> decode.map(ImmunizationProtocolappliedDosenumberString),
    ],
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Immunization#resource
pub type ImmunizationProtocolappliedSeriesdoses {
  ImmunizationProtocolappliedSeriesdosesPositiveint(series_doses: Int)
  ImmunizationProtocolappliedSeriesdosesString(series_doses: String)
}

pub fn immunization_protocolapplied_seriesdoses_to_json(
  elt: ImmunizationProtocolappliedSeriesdoses,
) -> Json {
  case elt {
    ImmunizationProtocolappliedSeriesdosesPositiveint(v) -> json.int(v)
    ImmunizationProtocolappliedSeriesdosesString(v) -> json.string(v)
  }
}

pub fn immunization_protocolapplied_seriesdoses_decoder() -> Decoder(
  ImmunizationProtocolappliedSeriesdoses,
) {
  decode.one_of(
    decode.field("seriesDosesPositiveInt", decode.int, decode.success)
      |> decode.map(ImmunizationProtocolappliedSeriesdosesPositiveint),
    [
      decode.field("seriesDosesString", decode.string, decode.success)
      |> decode.map(ImmunizationProtocolappliedSeriesdosesString),
    ],
  )
}

pub fn immunization_protocolapplied_new(
  dose_number dose_number: ImmunizationProtocolappliedDosenumber,
) -> ImmunizationProtocolapplied {
  ImmunizationProtocolapplied(
    series_doses: None,
    dose_number:,
    target_disease: [],
    authority: None,
    series: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn immunization_protocolapplied_to_json(
  immunization_protocolapplied: ImmunizationProtocolapplied,
) -> Json {
  let ImmunizationProtocolapplied(
    series_doses:,
    dose_number:,
    target_disease:,
    authority:,
    series:,
    modifier_extension:,
    extension:,
    id:,
  ) = immunization_protocolapplied
  let fields = [
    #(
      "doseNumber",
      immunization_protocolapplied_dosenumber_to_json(dose_number),
    ),
  ]
  let fields = case series_doses {
    Some(v) -> [
      #(
        "seriesDoses"
          <> case v {
          ImmunizationProtocolappliedSeriesdosesPositiveint(_) -> "Positiveint"
          ImmunizationProtocolappliedSeriesdosesString(_) -> "String"
        },
        immunization_protocolapplied_seriesdoses_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case target_disease {
    [] -> fields
    _ -> [
      #("targetDisease", json.array(target_disease, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case authority {
    Some(v) -> [#("authority", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case series {
    Some(v) -> [#("series", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn immunization_protocolapplied_decoder() -> Decoder(
  ImmunizationProtocolapplied,
) {
  use series_doses <- decode.then(
    none_if_omitted(immunization_protocolapplied_seriesdoses_decoder()),
  )
  use dose_number <- decode.then(
    immunization_protocolapplied_dosenumber_decoder(),
  )
  use target_disease <- decode.optional_field(
    "targetDisease",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use authority <- decode.optional_field(
    "authority",
    None,
    decode.optional(reference_decoder()),
  )
  use series <- decode.optional_field(
    "series",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ImmunizationProtocolapplied(
    series_doses:,
    dose_number:,
    target_disease:,
    authority:,
    series:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn immunization_reaction_to_json(
  immunization_reaction: ImmunizationReaction,
) -> Json {
  let ImmunizationReaction(
    reported:,
    detail:,
    date:,
    modifier_extension:,
    extension:,
    id:,
  ) = immunization_reaction
  let fields = []
  let fields = case reported {
    Some(v) -> [#("reported", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case detail {
    Some(v) -> [#("detail", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case date {
    Some(v) -> [#("date", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn immunization_reaction_decoder() -> Decoder(ImmunizationReaction) {
  use reported <- decode.optional_field(
    "reported",
    None,
    decode.optional(decode.bool),
  )
  use detail <- decode.optional_field(
    "detail",
    None,
    decode.optional(reference_decoder()),
  )
  use date <- decode.optional_field(
    "date",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ImmunizationReaction(
    reported:,
    detail:,
    date:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn immunization_education_to_json(
  immunization_education: ImmunizationEducation,
) -> Json {
  let ImmunizationEducation(
    presentation_date:,
    publication_date:,
    reference:,
    document_type:,
    modifier_extension:,
    extension:,
    id:,
  ) = immunization_education
  let fields = []
  let fields = case presentation_date {
    Some(v) -> [#("presentationDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case publication_date {
    Some(v) -> [#("publicationDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case reference {
    Some(v) -> [#("reference", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case document_type {
    Some(v) -> [#("documentType", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn immunization_education_decoder() -> Decoder(ImmunizationEducation) {
  use presentation_date <- decode.optional_field(
    "presentationDate",
    None,
    decode.optional(decode.string),
  )
  use publication_date <- decode.optional_field(
    "publicationDate",
    None,
    decode.optional(decode.string),
  )
  use reference <- decode.optional_field(
    "reference",
    None,
    decode.optional(decode.string),
  )
  use document_type <- decode.optional_field(
    "documentType",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ImmunizationEducation(
    presentation_date:,
    publication_date:,
    reference:,
    document_type:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn immunization_performer_to_json(
  immunization_performer: ImmunizationPerformer,
) -> Json {
  let ImmunizationPerformer(
    actor:,
    function:,
    modifier_extension:,
    extension:,
    id:,
  ) = immunization_performer
  let fields = [
    #("actor", reference_to_json(actor)),
  ]
  let fields = case function {
    Some(v) -> [#("function", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn immunization_performer_decoder() -> Decoder(ImmunizationPerformer) {
  use actor <- decode.field("actor", reference_decoder())
  use function <- decode.optional_field(
    "function",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ImmunizationPerformer(
    actor:,
    function:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn immunization_to_json(immunization: Immunization) -> Json {
  let Immunization(
    protocol_applied:,
    reaction:,
    funding_source:,
    program_eligibility:,
    education:,
    subpotent_reason:,
    is_subpotent:,
    reason_reference:,
    reason_code:,
    note:,
    performer:,
    dose_quantity:,
    route:,
    site:,
    expiration_date:,
    lot_number:,
    manufacturer:,
    location:,
    report_origin:,
    primary_source:,
    recorded:,
    occurrence:,
    encounter:,
    patient:,
    vaccine_code:,
    status_reason:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = immunization
  let fields = [
    #("occurrence", immunization_occurrence_to_json(occurrence)),
    #("patient", reference_to_json(patient)),
    #("vaccineCode", codeableconcept_to_json(vaccine_code)),
    #("status", r4bvaluesets.immunizationstatus_to_json(status)),
  ]
  let fields = case protocol_applied {
    [] -> fields
    _ -> [
      #(
        "protocolApplied",
        json.array(protocol_applied, immunization_protocolapplied_to_json),
      ),
      ..fields
    ]
  }
  let fields = case reaction {
    [] -> fields
    _ -> [
      #("reaction", json.array(reaction, immunization_reaction_to_json)),
      ..fields
    ]
  }
  let fields = case funding_source {
    Some(v) -> [#("fundingSource", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case program_eligibility {
    [] -> fields
    _ -> [
      #(
        "programEligibility",
        json.array(program_eligibility, codeableconcept_to_json),
      ),
      ..fields
    ]
  }
  let fields = case education {
    [] -> fields
    _ -> [
      #("education", json.array(education, immunization_education_to_json)),
      ..fields
    ]
  }
  let fields = case subpotent_reason {
    [] -> fields
    _ -> [
      #(
        "subpotentReason",
        json.array(subpotent_reason, codeableconcept_to_json),
      ),
      ..fields
    ]
  }
  let fields = case is_subpotent {
    Some(v) -> [#("isSubpotent", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case reason_reference {
    [] -> fields
    _ -> [
      #("reasonReference", json.array(reason_reference, reference_to_json)),
      ..fields
    ]
  }
  let fields = case reason_code {
    [] -> fields
    _ -> [
      #("reasonCode", json.array(reason_code, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case performer {
    [] -> fields
    _ -> [
      #("performer", json.array(performer, immunization_performer_to_json)),
      ..fields
    ]
  }
  let fields = case dose_quantity {
    Some(v) -> [#("doseQuantity", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case route {
    Some(v) -> [#("route", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case site {
    Some(v) -> [#("site", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case expiration_date {
    Some(v) -> [#("expirationDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case lot_number {
    Some(v) -> [#("lotNumber", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case manufacturer {
    Some(v) -> [#("manufacturer", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case location {
    Some(v) -> [#("location", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case report_origin {
    Some(v) -> [#("reportOrigin", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case primary_source {
    Some(v) -> [#("primarySource", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case recorded {
    Some(v) -> [#("recorded", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case encounter {
    Some(v) -> [#("encounter", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case status_reason {
    Some(v) -> [#("statusReason", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Immunization")), ..fields]
  json.object(fields)
}

pub fn immunization_decoder() -> Decoder(Immunization) {
  use protocol_applied <- decode.optional_field(
    "protocolApplied",
    [],
    decode.list(immunization_protocolapplied_decoder()),
  )
  use reaction <- decode.optional_field(
    "reaction",
    [],
    decode.list(immunization_reaction_decoder()),
  )
  use funding_source <- decode.optional_field(
    "fundingSource",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use program_eligibility <- decode.optional_field(
    "programEligibility",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use education <- decode.optional_field(
    "education",
    [],
    decode.list(immunization_education_decoder()),
  )
  use subpotent_reason <- decode.optional_field(
    "subpotentReason",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use is_subpotent <- decode.optional_field(
    "isSubpotent",
    None,
    decode.optional(decode.bool),
  )
  use reason_reference <- decode.optional_field(
    "reasonReference",
    [],
    decode.list(reference_decoder()),
  )
  use reason_code <- decode.optional_field(
    "reasonCode",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use performer <- decode.optional_field(
    "performer",
    [],
    decode.list(immunization_performer_decoder()),
  )
  use dose_quantity <- decode.optional_field(
    "doseQuantity",
    None,
    decode.optional(quantity_decoder()),
  )
  use route <- decode.optional_field(
    "route",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use site <- decode.optional_field(
    "site",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use expiration_date <- decode.optional_field(
    "expirationDate",
    None,
    decode.optional(decode.string),
  )
  use lot_number <- decode.optional_field(
    "lotNumber",
    None,
    decode.optional(decode.string),
  )
  use manufacturer <- decode.optional_field(
    "manufacturer",
    None,
    decode.optional(reference_decoder()),
  )
  use location <- decode.optional_field(
    "location",
    None,
    decode.optional(reference_decoder()),
  )
  use report_origin <- decode.optional_field(
    "reportOrigin",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use primary_source <- decode.optional_field(
    "primarySource",
    None,
    decode.optional(decode.bool),
  )
  use recorded <- decode.optional_field(
    "recorded",
    None,
    decode.optional(decode.string),
  )
  use occurrence <- decode.then(immunization_occurrence_decoder())
  use encounter <- decode.optional_field(
    "encounter",
    None,
    decode.optional(reference_decoder()),
  )
  use patient <- decode.field("patient", reference_decoder())
  use vaccine_code <- decode.field("vaccineCode", codeableconcept_decoder())
  use status_reason <- decode.optional_field(
    "statusReason",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use status <- decode.field(
    "status",
    r4bvaluesets.immunizationstatus_decoder(),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Immunization",
    decode.failure(
      immunization_new(occurrence:, patient:, vaccine_code:, status:),
      "resourceType",
    ),
  )
  decode.success(Immunization(
    protocol_applied:,
    reaction:,
    funding_source:,
    program_eligibility:,
    education:,
    subpotent_reason:,
    is_subpotent:,
    reason_reference:,
    reason_code:,
    note:,
    performer:,
    dose_quantity:,
    route:,
    site:,
    expiration_date:,
    lot_number:,
    manufacturer:,
    location:,
    report_origin:,
    primary_source:,
    recorded:,
    occurrence:,
    encounter:,
    patient:,
    vaccine_code:,
    status_reason:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/ImmunizationEvaluation#resource
pub type Immunizationevaluation {
  Immunizationevaluation(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    status: r4bvaluesets.Immunizationevaluationstatus,
    patient: Reference,
    date: Option(String),
    authority: Option(Reference),
    target_disease: Codeableconcept,
    immunization_event: Reference,
    dose_status: Codeableconcept,
    dose_status_reason: List(Codeableconcept),
    description: Option(String),
    series: Option(String),
    dose_number: Option(ImmunizationevaluationDosenumber),
    series_doses: Option(ImmunizationevaluationSeriesdoses),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ImmunizationEvaluation#resource
pub type ImmunizationevaluationDosenumber {
  ImmunizationevaluationDosenumberPositiveint(dose_number: Int)
  ImmunizationevaluationDosenumberString(dose_number: String)
}

pub fn immunizationevaluation_dosenumber_to_json(
  elt: ImmunizationevaluationDosenumber,
) -> Json {
  case elt {
    ImmunizationevaluationDosenumberPositiveint(v) -> json.int(v)
    ImmunizationevaluationDosenumberString(v) -> json.string(v)
  }
}

pub fn immunizationevaluation_dosenumber_decoder() -> Decoder(
  ImmunizationevaluationDosenumber,
) {
  decode.one_of(
    decode.field("doseNumberPositiveInt", decode.int, decode.success)
      |> decode.map(ImmunizationevaluationDosenumberPositiveint),
    [
      decode.field("doseNumberString", decode.string, decode.success)
      |> decode.map(ImmunizationevaluationDosenumberString),
    ],
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ImmunizationEvaluation#resource
pub type ImmunizationevaluationSeriesdoses {
  ImmunizationevaluationSeriesdosesPositiveint(series_doses: Int)
  ImmunizationevaluationSeriesdosesString(series_doses: String)
}

pub fn immunizationevaluation_seriesdoses_to_json(
  elt: ImmunizationevaluationSeriesdoses,
) -> Json {
  case elt {
    ImmunizationevaluationSeriesdosesPositiveint(v) -> json.int(v)
    ImmunizationevaluationSeriesdosesString(v) -> json.string(v)
  }
}

pub fn immunizationevaluation_seriesdoses_decoder() -> Decoder(
  ImmunizationevaluationSeriesdoses,
) {
  decode.one_of(
    decode.field("seriesDosesPositiveInt", decode.int, decode.success)
      |> decode.map(ImmunizationevaluationSeriesdosesPositiveint),
    [
      decode.field("seriesDosesString", decode.string, decode.success)
      |> decode.map(ImmunizationevaluationSeriesdosesString),
    ],
  )
}

pub fn immunizationevaluation_new(
  dose_status dose_status: Codeableconcept,
  immunization_event immunization_event: Reference,
  target_disease target_disease: Codeableconcept,
  patient patient: Reference,
  status status: r4bvaluesets.Immunizationevaluationstatus,
) -> Immunizationevaluation {
  Immunizationevaluation(
    series_doses: None,
    dose_number: None,
    series: None,
    description: None,
    dose_status_reason: [],
    dose_status:,
    immunization_event:,
    target_disease:,
    authority: None,
    date: None,
    patient:,
    status:,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

pub fn immunizationevaluation_to_json(
  immunizationevaluation: Immunizationevaluation,
) -> Json {
  let Immunizationevaluation(
    series_doses:,
    dose_number:,
    series:,
    description:,
    dose_status_reason:,
    dose_status:,
    immunization_event:,
    target_disease:,
    authority:,
    date:,
    patient:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = immunizationevaluation
  let fields = [
    #("doseStatus", codeableconcept_to_json(dose_status)),
    #("immunizationEvent", reference_to_json(immunization_event)),
    #("targetDisease", codeableconcept_to_json(target_disease)),
    #("patient", reference_to_json(patient)),
    #("status", r4bvaluesets.immunizationevaluationstatus_to_json(status)),
  ]
  let fields = case series_doses {
    Some(v) -> [
      #(
        "seriesDoses"
          <> case v {
          ImmunizationevaluationSeriesdosesPositiveint(_) -> "Positiveint"
          ImmunizationevaluationSeriesdosesString(_) -> "String"
        },
        immunizationevaluation_seriesdoses_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case dose_number {
    Some(v) -> [
      #(
        "doseNumber"
          <> case v {
          ImmunizationevaluationDosenumberPositiveint(_) -> "Positiveint"
          ImmunizationevaluationDosenumberString(_) -> "String"
        },
        immunizationevaluation_dosenumber_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case series {
    Some(v) -> [#("series", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case dose_status_reason {
    [] -> fields
    _ -> [
      #(
        "doseStatusReason",
        json.array(dose_status_reason, codeableconcept_to_json),
      ),
      ..fields
    ]
  }
  let fields = case authority {
    Some(v) -> [#("authority", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case date {
    Some(v) -> [#("date", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [
    #("resourceType", json.string("Immunizationevaluation")),
    ..fields
  ]
  json.object(fields)
}

pub fn immunizationevaluation_decoder() -> Decoder(Immunizationevaluation) {
  use series_doses <- decode.then(
    none_if_omitted(immunizationevaluation_seriesdoses_decoder()),
  )
  use dose_number <- decode.then(
    none_if_omitted(immunizationevaluation_dosenumber_decoder()),
  )
  use series <- decode.optional_field(
    "series",
    None,
    decode.optional(decode.string),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use dose_status_reason <- decode.optional_field(
    "doseStatusReason",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use dose_status <- decode.field("doseStatus", codeableconcept_decoder())
  use immunization_event <- decode.field(
    "immunizationEvent",
    reference_decoder(),
  )
  use target_disease <- decode.field("targetDisease", codeableconcept_decoder())
  use authority <- decode.optional_field(
    "authority",
    None,
    decode.optional(reference_decoder()),
  )
  use date <- decode.optional_field(
    "date",
    None,
    decode.optional(decode.string),
  )
  use patient <- decode.field("patient", reference_decoder())
  use status <- decode.field(
    "status",
    r4bvaluesets.immunizationevaluationstatus_decoder(),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Immunizationevaluation",
    decode.failure(
      immunizationevaluation_new(
        dose_status:,
        immunization_event:,
        target_disease:,
        patient:,
        status:,
      ),
      "resourceType",
    ),
  )
  decode.success(Immunizationevaluation(
    series_doses:,
    dose_number:,
    series:,
    description:,
    dose_status_reason:,
    dose_status:,
    immunization_event:,
    target_disease:,
    authority:,
    date:,
    patient:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/ImmunizationRecommendation#resource
pub type Immunizationrecommendation {
  Immunizationrecommendation(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    patient: Reference,
    date: String,
    authority: Option(Reference),
    recommendation: List(ImmunizationrecommendationRecommendation),
  )
}

pub fn immunizationrecommendation_new(
  date date: String,
  patient patient: Reference,
) -> Immunizationrecommendation {
  Immunizationrecommendation(
    recommendation: [],
    authority: None,
    date:,
    patient:,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ImmunizationRecommendation#resource
pub type ImmunizationrecommendationRecommendation {
  ImmunizationrecommendationRecommendation(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    vaccine_code: List(Codeableconcept),
    target_disease: Option(Codeableconcept),
    contraindicated_vaccine_code: List(Codeableconcept),
    forecast_status: Codeableconcept,
    forecast_reason: List(Codeableconcept),
    date_criterion: List(ImmunizationrecommendationRecommendationDatecriterion),
    description: Option(String),
    series: Option(String),
    dose_number: Option(ImmunizationrecommendationRecommendationDosenumber),
    series_doses: Option(ImmunizationrecommendationRecommendationSeriesdoses),
    supporting_immunization: List(Reference),
    supporting_patient_information: List(Reference),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ImmunizationRecommendation#resource
pub type ImmunizationrecommendationRecommendationDosenumber {
  ImmunizationrecommendationRecommendationDosenumberPositiveint(
    dose_number: Int,
  )
  ImmunizationrecommendationRecommendationDosenumberString(dose_number: String)
}

pub fn immunizationrecommendation_recommendation_dosenumber_to_json(
  elt: ImmunizationrecommendationRecommendationDosenumber,
) -> Json {
  case elt {
    ImmunizationrecommendationRecommendationDosenumberPositiveint(v) ->
      json.int(v)
    ImmunizationrecommendationRecommendationDosenumberString(v) ->
      json.string(v)
  }
}

pub fn immunizationrecommendation_recommendation_dosenumber_decoder() -> Decoder(
  ImmunizationrecommendationRecommendationDosenumber,
) {
  decode.one_of(
    decode.field("doseNumberPositiveInt", decode.int, decode.success)
      |> decode.map(
        ImmunizationrecommendationRecommendationDosenumberPositiveint,
      ),
    [
      decode.field("doseNumberString", decode.string, decode.success)
      |> decode.map(ImmunizationrecommendationRecommendationDosenumberString),
    ],
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ImmunizationRecommendation#resource
pub type ImmunizationrecommendationRecommendationSeriesdoses {
  ImmunizationrecommendationRecommendationSeriesdosesPositiveint(
    series_doses: Int,
  )
  ImmunizationrecommendationRecommendationSeriesdosesString(
    series_doses: String,
  )
}

pub fn immunizationrecommendation_recommendation_seriesdoses_to_json(
  elt: ImmunizationrecommendationRecommendationSeriesdoses,
) -> Json {
  case elt {
    ImmunizationrecommendationRecommendationSeriesdosesPositiveint(v) ->
      json.int(v)
    ImmunizationrecommendationRecommendationSeriesdosesString(v) ->
      json.string(v)
  }
}

pub fn immunizationrecommendation_recommendation_seriesdoses_decoder() -> Decoder(
  ImmunizationrecommendationRecommendationSeriesdoses,
) {
  decode.one_of(
    decode.field("seriesDosesPositiveInt", decode.int, decode.success)
      |> decode.map(
        ImmunizationrecommendationRecommendationSeriesdosesPositiveint,
      ),
    [
      decode.field("seriesDosesString", decode.string, decode.success)
      |> decode.map(ImmunizationrecommendationRecommendationSeriesdosesString),
    ],
  )
}

pub fn immunizationrecommendation_recommendation_new(
  forecast_status forecast_status: Codeableconcept,
) -> ImmunizationrecommendationRecommendation {
  ImmunizationrecommendationRecommendation(
    supporting_patient_information: [],
    supporting_immunization: [],
    series_doses: None,
    dose_number: None,
    series: None,
    description: None,
    date_criterion: [],
    forecast_reason: [],
    forecast_status:,
    contraindicated_vaccine_code: [],
    target_disease: None,
    vaccine_code: [],
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ImmunizationRecommendation#resource
pub type ImmunizationrecommendationRecommendationDatecriterion {
  ImmunizationrecommendationRecommendationDatecriterion(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    code: Codeableconcept,
    value: String,
  )
}

pub fn immunizationrecommendation_recommendation_datecriterion_new(
  value value: String,
  code code: Codeableconcept,
) -> ImmunizationrecommendationRecommendationDatecriterion {
  ImmunizationrecommendationRecommendationDatecriterion(
    value:,
    code:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn immunizationrecommendation_recommendation_datecriterion_to_json(
  immunizationrecommendation_recommendation_datecriterion: ImmunizationrecommendationRecommendationDatecriterion,
) -> Json {
  let ImmunizationrecommendationRecommendationDatecriterion(
    value:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ) = immunizationrecommendation_recommendation_datecriterion
  let fields = [
    #("value", json.string(value)),
    #("code", codeableconcept_to_json(code)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn immunizationrecommendation_recommendation_datecriterion_decoder() -> Decoder(
  ImmunizationrecommendationRecommendationDatecriterion,
) {
  use value <- decode.field("value", decode.string)
  use code <- decode.field("code", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ImmunizationrecommendationRecommendationDatecriterion(
    value:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn immunizationrecommendation_recommendation_to_json(
  immunizationrecommendation_recommendation: ImmunizationrecommendationRecommendation,
) -> Json {
  let ImmunizationrecommendationRecommendation(
    supporting_patient_information:,
    supporting_immunization:,
    series_doses:,
    dose_number:,
    series:,
    description:,
    date_criterion:,
    forecast_reason:,
    forecast_status:,
    contraindicated_vaccine_code:,
    target_disease:,
    vaccine_code:,
    modifier_extension:,
    extension:,
    id:,
  ) = immunizationrecommendation_recommendation
  let fields = [
    #("forecastStatus", codeableconcept_to_json(forecast_status)),
  ]
  let fields = case supporting_patient_information {
    [] -> fields
    _ -> [
      #(
        "supportingPatientInformation",
        json.array(supporting_patient_information, reference_to_json),
      ),
      ..fields
    ]
  }
  let fields = case supporting_immunization {
    [] -> fields
    _ -> [
      #(
        "supportingImmunization",
        json.array(supporting_immunization, reference_to_json),
      ),
      ..fields
    ]
  }
  let fields = case series_doses {
    Some(v) -> [
      #(
        "seriesDoses"
          <> case v {
          ImmunizationrecommendationRecommendationSeriesdosesPositiveint(_) ->
            "Positiveint"
          ImmunizationrecommendationRecommendationSeriesdosesString(_) ->
            "String"
        },
        immunizationrecommendation_recommendation_seriesdoses_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case dose_number {
    Some(v) -> [
      #(
        "doseNumber"
          <> case v {
          ImmunizationrecommendationRecommendationDosenumberPositiveint(_) ->
            "Positiveint"
          ImmunizationrecommendationRecommendationDosenumberString(_) ->
            "String"
        },
        immunizationrecommendation_recommendation_dosenumber_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case series {
    Some(v) -> [#("series", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case date_criterion {
    [] -> fields
    _ -> [
      #(
        "dateCriterion",
        json.array(
          date_criterion,
          immunizationrecommendation_recommendation_datecriterion_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case forecast_reason {
    [] -> fields
    _ -> [
      #("forecastReason", json.array(forecast_reason, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case contraindicated_vaccine_code {
    [] -> fields
    _ -> [
      #(
        "contraindicatedVaccineCode",
        json.array(contraindicated_vaccine_code, codeableconcept_to_json),
      ),
      ..fields
    ]
  }
  let fields = case target_disease {
    Some(v) -> [#("targetDisease", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case vaccine_code {
    [] -> fields
    _ -> [
      #("vaccineCode", json.array(vaccine_code, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn immunizationrecommendation_recommendation_decoder() -> Decoder(
  ImmunizationrecommendationRecommendation,
) {
  use supporting_patient_information <- decode.optional_field(
    "supportingPatientInformation",
    [],
    decode.list(reference_decoder()),
  )
  use supporting_immunization <- decode.optional_field(
    "supportingImmunization",
    [],
    decode.list(reference_decoder()),
  )
  use series_doses <- decode.then(
    none_if_omitted(
      immunizationrecommendation_recommendation_seriesdoses_decoder(),
    ),
  )
  use dose_number <- decode.then(
    none_if_omitted(
      immunizationrecommendation_recommendation_dosenumber_decoder(),
    ),
  )
  use series <- decode.optional_field(
    "series",
    None,
    decode.optional(decode.string),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use date_criterion <- decode.optional_field(
    "dateCriterion",
    [],
    decode.list(
      immunizationrecommendation_recommendation_datecriterion_decoder(),
    ),
  )
  use forecast_reason <- decode.optional_field(
    "forecastReason",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use forecast_status <- decode.field(
    "forecastStatus",
    codeableconcept_decoder(),
  )
  use contraindicated_vaccine_code <- decode.optional_field(
    "contraindicatedVaccineCode",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use target_disease <- decode.optional_field(
    "targetDisease",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use vaccine_code <- decode.optional_field(
    "vaccineCode",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ImmunizationrecommendationRecommendation(
    supporting_patient_information:,
    supporting_immunization:,
    series_doses:,
    dose_number:,
    series:,
    description:,
    date_criterion:,
    forecast_reason:,
    forecast_status:,
    contraindicated_vaccine_code:,
    target_disease:,
    vaccine_code:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn immunizationrecommendation_to_json(
  immunizationrecommendation: Immunizationrecommendation,
) -> Json {
  let Immunizationrecommendation(
    recommendation:,
    authority:,
    date:,
    patient:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = immunizationrecommendation
  let fields = [
    #("date", json.string(date)),
    #("patient", reference_to_json(patient)),
  ]
  let fields = case recommendation {
    [] -> fields
    _ -> [
      #(
        "recommendation",
        json.array(
          recommendation,
          immunizationrecommendation_recommendation_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case authority {
    Some(v) -> [#("authority", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [
    #("resourceType", json.string("Immunizationrecommendation")),
    ..fields
  ]
  json.object(fields)
}

pub fn immunizationrecommendation_decoder() -> Decoder(
  Immunizationrecommendation,
) {
  use recommendation <- decode.optional_field(
    "recommendation",
    [],
    decode.list(immunizationrecommendation_recommendation_decoder()),
  )
  use authority <- decode.optional_field(
    "authority",
    None,
    decode.optional(reference_decoder()),
  )
  use date <- decode.field("date", decode.string)
  use patient <- decode.field("patient", reference_decoder())
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Immunizationrecommendation",
    decode.failure(
      immunizationrecommendation_new(date:, patient:),
      "resourceType",
    ),
  )
  decode.success(Immunizationrecommendation(
    recommendation:,
    authority:,
    date:,
    patient:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/ImplementationGuide#resource
pub type Implementationguide {
  Implementationguide(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    url: String,
    version: Option(String),
    name: String,
    title: Option(String),
    status: r4bvaluesets.Publicationstatus,
    experimental: Option(Bool),
    date: Option(String),
    publisher: Option(String),
    contact: List(Contactdetail),
    description: Option(String),
    use_context: List(Usagecontext),
    jurisdiction: List(Codeableconcept),
    copyright: Option(String),
    package_id: String,
    license: Option(r4bvaluesets.Spdxlicense),
    fhir_version: List(r4bvaluesets.Fhirversion),
    depends_on: List(ImplementationguideDependson),
    global: List(ImplementationguideGlobal),
    definition: Option(ImplementationguideDefinition),
    manifest: Option(ImplementationguideManifest),
  )
}

pub fn implementationguide_new(
  package_id package_id: String,
  status status: r4bvaluesets.Publicationstatus,
  name name: String,
  url url: String,
) -> Implementationguide {
  Implementationguide(
    manifest: None,
    definition: None,
    global: [],
    depends_on: [],
    fhir_version: [],
    license: None,
    package_id:,
    copyright: None,
    jurisdiction: [],
    use_context: [],
    description: None,
    contact: [],
    publisher: None,
    date: None,
    experimental: None,
    status:,
    title: None,
    name:,
    version: None,
    url:,
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ImplementationGuide#resource
pub type ImplementationguideDependson {
  ImplementationguideDependson(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    uri: String,
    package_id: Option(String),
    version: Option(String),
  )
}

pub fn implementationguide_dependson_new(
  uri uri: String,
) -> ImplementationguideDependson {
  ImplementationguideDependson(
    version: None,
    package_id: None,
    uri:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ImplementationGuide#resource
pub type ImplementationguideGlobal {
  ImplementationguideGlobal(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: r4bvaluesets.Resourcetypes,
    profile: String,
  )
}

pub fn implementationguide_global_new(
  profile profile: String,
  type_ type_: r4bvaluesets.Resourcetypes,
) -> ImplementationguideGlobal {
  ImplementationguideGlobal(
    profile:,
    type_:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ImplementationGuide#resource
pub type ImplementationguideDefinition {
  ImplementationguideDefinition(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    grouping: List(ImplementationguideDefinitionGrouping),
    resource: List(ImplementationguideDefinitionResource),
    page: Option(ImplementationguideDefinitionPage),
    parameter: List(ImplementationguideDefinitionParameter),
    template: List(ImplementationguideDefinitionTemplate),
  )
}

pub fn implementationguide_definition_new() -> ImplementationguideDefinition {
  ImplementationguideDefinition(
    template: [],
    parameter: [],
    page: None,
    resource: [],
    grouping: [],
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ImplementationGuide#resource
pub type ImplementationguideDefinitionGrouping {
  ImplementationguideDefinitionGrouping(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    name: String,
    description: Option(String),
  )
}

pub fn implementationguide_definition_grouping_new(
  name name: String,
) -> ImplementationguideDefinitionGrouping {
  ImplementationguideDefinitionGrouping(
    description: None,
    name:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ImplementationGuide#resource
pub type ImplementationguideDefinitionResource {
  ImplementationguideDefinitionResource(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    reference: Reference,
    fhir_version: List(r4bvaluesets.Fhirversion),
    name: Option(String),
    description: Option(String),
    example: Option(ImplementationguideDefinitionResourceExample),
    grouping_id: Option(String),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ImplementationGuide#resource
pub type ImplementationguideDefinitionResourceExample {
  ImplementationguideDefinitionResourceExampleBoolean(example: Bool)
  ImplementationguideDefinitionResourceExampleCanonical(example: String)
}

pub fn implementationguide_definition_resource_example_to_json(
  elt: ImplementationguideDefinitionResourceExample,
) -> Json {
  case elt {
    ImplementationguideDefinitionResourceExampleBoolean(v) -> json.bool(v)
    ImplementationguideDefinitionResourceExampleCanonical(v) -> json.string(v)
  }
}

pub fn implementationguide_definition_resource_example_decoder() -> Decoder(
  ImplementationguideDefinitionResourceExample,
) {
  decode.one_of(
    decode.field("exampleBoolean", decode.bool, decode.success)
      |> decode.map(ImplementationguideDefinitionResourceExampleBoolean),
    [
      decode.field("exampleCanonical", decode.string, decode.success)
      |> decode.map(ImplementationguideDefinitionResourceExampleCanonical),
    ],
  )
}

pub fn implementationguide_definition_resource_new(
  reference reference: Reference,
) -> ImplementationguideDefinitionResource {
  ImplementationguideDefinitionResource(
    grouping_id: None,
    example: None,
    description: None,
    name: None,
    fhir_version: [],
    reference:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ImplementationGuide#resource
pub type ImplementationguideDefinitionPage {
  ImplementationguideDefinitionPage(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    name: ImplementationguideDefinitionPageName,
    title: String,
    generation: r4bvaluesets.Guidepagegeneration,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ImplementationGuide#resource
pub type ImplementationguideDefinitionPageName {
  ImplementationguideDefinitionPageNameUrl(name: String)
  ImplementationguideDefinitionPageNameReference(name: Reference)
}

pub fn implementationguide_definition_page_name_to_json(
  elt: ImplementationguideDefinitionPageName,
) -> Json {
  case elt {
    ImplementationguideDefinitionPageNameUrl(v) -> json.string(v)
    ImplementationguideDefinitionPageNameReference(v) -> reference_to_json(v)
  }
}

pub fn implementationguide_definition_page_name_decoder() -> Decoder(
  ImplementationguideDefinitionPageName,
) {
  decode.one_of(
    decode.field("nameUrl", decode.string, decode.success)
      |> decode.map(ImplementationguideDefinitionPageNameUrl),
    [
      decode.field("nameReference", reference_decoder(), decode.success)
      |> decode.map(ImplementationguideDefinitionPageNameReference),
    ],
  )
}

pub fn implementationguide_definition_page_new(
  generation generation: r4bvaluesets.Guidepagegeneration,
  title title: String,
  name name: ImplementationguideDefinitionPageName,
) -> ImplementationguideDefinitionPage {
  ImplementationguideDefinitionPage(
    generation:,
    title:,
    name:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ImplementationGuide#resource
pub type ImplementationguideDefinitionParameter {
  ImplementationguideDefinitionParameter(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    code: r4bvaluesets.Guideparametercode,
    value: String,
  )
}

pub fn implementationguide_definition_parameter_new(
  value value: String,
  code code: r4bvaluesets.Guideparametercode,
) -> ImplementationguideDefinitionParameter {
  ImplementationguideDefinitionParameter(
    value:,
    code:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ImplementationGuide#resource
pub type ImplementationguideDefinitionTemplate {
  ImplementationguideDefinitionTemplate(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    code: String,
    source: String,
    scope: Option(String),
  )
}

pub fn implementationguide_definition_template_new(
  source source: String,
  code code: String,
) -> ImplementationguideDefinitionTemplate {
  ImplementationguideDefinitionTemplate(
    scope: None,
    source:,
    code:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ImplementationGuide#resource
pub type ImplementationguideManifest {
  ImplementationguideManifest(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    rendering: Option(String),
    resource: List(ImplementationguideManifestResource),
    page: List(ImplementationguideManifestPage),
    image: List(String),
    other: List(String),
  )
}

pub fn implementationguide_manifest_new() -> ImplementationguideManifest {
  ImplementationguideManifest(
    other: [],
    image: [],
    page: [],
    resource: [],
    rendering: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ImplementationGuide#resource
pub type ImplementationguideManifestResource {
  ImplementationguideManifestResource(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    reference: Reference,
    example: Option(ImplementationguideManifestResourceExample),
    relative_path: Option(String),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ImplementationGuide#resource
pub type ImplementationguideManifestResourceExample {
  ImplementationguideManifestResourceExampleBoolean(example: Bool)
  ImplementationguideManifestResourceExampleCanonical(example: String)
}

pub fn implementationguide_manifest_resource_example_to_json(
  elt: ImplementationguideManifestResourceExample,
) -> Json {
  case elt {
    ImplementationguideManifestResourceExampleBoolean(v) -> json.bool(v)
    ImplementationguideManifestResourceExampleCanonical(v) -> json.string(v)
  }
}

pub fn implementationguide_manifest_resource_example_decoder() -> Decoder(
  ImplementationguideManifestResourceExample,
) {
  decode.one_of(
    decode.field("exampleBoolean", decode.bool, decode.success)
      |> decode.map(ImplementationguideManifestResourceExampleBoolean),
    [
      decode.field("exampleCanonical", decode.string, decode.success)
      |> decode.map(ImplementationguideManifestResourceExampleCanonical),
    ],
  )
}

pub fn implementationguide_manifest_resource_new(
  reference reference: Reference,
) -> ImplementationguideManifestResource {
  ImplementationguideManifestResource(
    relative_path: None,
    example: None,
    reference:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ImplementationGuide#resource
pub type ImplementationguideManifestPage {
  ImplementationguideManifestPage(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    name: String,
    title: Option(String),
    anchor: List(String),
  )
}

pub fn implementationguide_manifest_page_new(
  name name: String,
) -> ImplementationguideManifestPage {
  ImplementationguideManifestPage(
    anchor: [],
    title: None,
    name:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn implementationguide_manifest_page_to_json(
  implementationguide_manifest_page: ImplementationguideManifestPage,
) -> Json {
  let ImplementationguideManifestPage(
    anchor:,
    title:,
    name:,
    modifier_extension:,
    extension:,
    id:,
  ) = implementationguide_manifest_page
  let fields = [
    #("name", json.string(name)),
  ]
  let fields = case anchor {
    [] -> fields
    _ -> [#("anchor", json.array(anchor, json.string)), ..fields]
  }
  let fields = case title {
    Some(v) -> [#("title", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn implementationguide_manifest_page_decoder() -> Decoder(
  ImplementationguideManifestPage,
) {
  use anchor <- decode.optional_field("anchor", [], decode.list(decode.string))
  use title <- decode.optional_field(
    "title",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.field("name", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ImplementationguideManifestPage(
    anchor:,
    title:,
    name:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn implementationguide_manifest_resource_to_json(
  implementationguide_manifest_resource: ImplementationguideManifestResource,
) -> Json {
  let ImplementationguideManifestResource(
    relative_path:,
    example:,
    reference:,
    modifier_extension:,
    extension:,
    id:,
  ) = implementationguide_manifest_resource
  let fields = [
    #("reference", reference_to_json(reference)),
  ]
  let fields = case relative_path {
    Some(v) -> [#("relativePath", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case example {
    Some(v) -> [
      #(
        "example"
          <> case v {
          ImplementationguideManifestResourceExampleBoolean(_) -> "Boolean"
          ImplementationguideManifestResourceExampleCanonical(_) -> "Canonical"
        },
        implementationguide_manifest_resource_example_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn implementationguide_manifest_resource_decoder() -> Decoder(
  ImplementationguideManifestResource,
) {
  use relative_path <- decode.optional_field(
    "relativePath",
    None,
    decode.optional(decode.string),
  )
  use example <- decode.then(
    none_if_omitted(implementationguide_manifest_resource_example_decoder()),
  )
  use reference <- decode.field("reference", reference_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ImplementationguideManifestResource(
    relative_path:,
    example:,
    reference:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn implementationguide_manifest_to_json(
  implementationguide_manifest: ImplementationguideManifest,
) -> Json {
  let ImplementationguideManifest(
    other:,
    image:,
    page:,
    resource:,
    rendering:,
    modifier_extension:,
    extension:,
    id:,
  ) = implementationguide_manifest
  let fields = []
  let fields = case other {
    [] -> fields
    _ -> [#("other", json.array(other, json.string)), ..fields]
  }
  let fields = case image {
    [] -> fields
    _ -> [#("image", json.array(image, json.string)), ..fields]
  }
  let fields = case page {
    [] -> fields
    _ -> [
      #("page", json.array(page, implementationguide_manifest_page_to_json)),
      ..fields
    ]
  }
  let fields = case resource {
    [] -> fields
    _ -> [
      #(
        "resource",
        json.array(resource, implementationguide_manifest_resource_to_json),
      ),
      ..fields
    ]
  }
  let fields = case rendering {
    Some(v) -> [#("rendering", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn implementationguide_manifest_decoder() -> Decoder(
  ImplementationguideManifest,
) {
  use other <- decode.optional_field("other", [], decode.list(decode.string))
  use image <- decode.optional_field("image", [], decode.list(decode.string))
  use page <- decode.optional_field(
    "page",
    [],
    decode.list(implementationguide_manifest_page_decoder()),
  )
  use resource <- decode.optional_field(
    "resource",
    [],
    decode.list(implementationguide_manifest_resource_decoder()),
  )
  use rendering <- decode.optional_field(
    "rendering",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ImplementationguideManifest(
    other:,
    image:,
    page:,
    resource:,
    rendering:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn implementationguide_definition_template_to_json(
  implementationguide_definition_template: ImplementationguideDefinitionTemplate,
) -> Json {
  let ImplementationguideDefinitionTemplate(
    scope:,
    source:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ) = implementationguide_definition_template
  let fields = [
    #("source", json.string(source)),
    #("code", json.string(code)),
  ]
  let fields = case scope {
    Some(v) -> [#("scope", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn implementationguide_definition_template_decoder() -> Decoder(
  ImplementationguideDefinitionTemplate,
) {
  use scope <- decode.optional_field(
    "scope",
    None,
    decode.optional(decode.string),
  )
  use source <- decode.field("source", decode.string)
  use code <- decode.field("code", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ImplementationguideDefinitionTemplate(
    scope:,
    source:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn implementationguide_definition_parameter_to_json(
  implementationguide_definition_parameter: ImplementationguideDefinitionParameter,
) -> Json {
  let ImplementationguideDefinitionParameter(
    value:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ) = implementationguide_definition_parameter
  let fields = [
    #("value", json.string(value)),
    #("code", r4bvaluesets.guideparametercode_to_json(code)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn implementationguide_definition_parameter_decoder() -> Decoder(
  ImplementationguideDefinitionParameter,
) {
  use value <- decode.field("value", decode.string)
  use code <- decode.field("code", r4bvaluesets.guideparametercode_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ImplementationguideDefinitionParameter(
    value:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn implementationguide_definition_page_to_json(
  implementationguide_definition_page: ImplementationguideDefinitionPage,
) -> Json {
  let ImplementationguideDefinitionPage(
    generation:,
    title:,
    name:,
    modifier_extension:,
    extension:,
    id:,
  ) = implementationguide_definition_page
  let fields = [
    #("generation", r4bvaluesets.guidepagegeneration_to_json(generation)),
    #("title", json.string(title)),
    #("name", implementationguide_definition_page_name_to_json(name)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn implementationguide_definition_page_decoder() -> Decoder(
  ImplementationguideDefinitionPage,
) {
  use generation <- decode.field(
    "generation",
    r4bvaluesets.guidepagegeneration_decoder(),
  )
  use title <- decode.field("title", decode.string)
  use name <- decode.then(implementationguide_definition_page_name_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ImplementationguideDefinitionPage(
    generation:,
    title:,
    name:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn implementationguide_definition_resource_to_json(
  implementationguide_definition_resource: ImplementationguideDefinitionResource,
) -> Json {
  let ImplementationguideDefinitionResource(
    grouping_id:,
    example:,
    description:,
    name:,
    fhir_version:,
    reference:,
    modifier_extension:,
    extension:,
    id:,
  ) = implementationguide_definition_resource
  let fields = [
    #("reference", reference_to_json(reference)),
  ]
  let fields = case grouping_id {
    Some(v) -> [#("groupingId", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case example {
    Some(v) -> [
      #(
        "example"
          <> case v {
          ImplementationguideDefinitionResourceExampleBoolean(_) -> "Boolean"
          ImplementationguideDefinitionResourceExampleCanonical(_) ->
            "Canonical"
        },
        implementationguide_definition_resource_example_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case fhir_version {
    [] -> fields
    _ -> [
      #(
        "fhirVersion",
        json.array(fhir_version, r4bvaluesets.fhirversion_to_json),
      ),
      ..fields
    ]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn implementationguide_definition_resource_decoder() -> Decoder(
  ImplementationguideDefinitionResource,
) {
  use grouping_id <- decode.optional_field(
    "groupingId",
    None,
    decode.optional(decode.string),
  )
  use example <- decode.then(
    none_if_omitted(implementationguide_definition_resource_example_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use fhir_version <- decode.optional_field(
    "fhirVersion",
    [],
    decode.list(r4bvaluesets.fhirversion_decoder()),
  )
  use reference <- decode.field("reference", reference_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ImplementationguideDefinitionResource(
    grouping_id:,
    example:,
    description:,
    name:,
    fhir_version:,
    reference:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn implementationguide_definition_grouping_to_json(
  implementationguide_definition_grouping: ImplementationguideDefinitionGrouping,
) -> Json {
  let ImplementationguideDefinitionGrouping(
    description:,
    name:,
    modifier_extension:,
    extension:,
    id:,
  ) = implementationguide_definition_grouping
  let fields = [
    #("name", json.string(name)),
  ]
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn implementationguide_definition_grouping_decoder() -> Decoder(
  ImplementationguideDefinitionGrouping,
) {
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.field("name", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ImplementationguideDefinitionGrouping(
    description:,
    name:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn implementationguide_definition_to_json(
  implementationguide_definition: ImplementationguideDefinition,
) -> Json {
  let ImplementationguideDefinition(
    template:,
    parameter:,
    page:,
    resource:,
    grouping:,
    modifier_extension:,
    extension:,
    id:,
  ) = implementationguide_definition
  let fields = []
  let fields = case template {
    [] -> fields
    _ -> [
      #(
        "template",
        json.array(template, implementationguide_definition_template_to_json),
      ),
      ..fields
    ]
  }
  let fields = case parameter {
    [] -> fields
    _ -> [
      #(
        "parameter",
        json.array(parameter, implementationguide_definition_parameter_to_json),
      ),
      ..fields
    ]
  }
  let fields = case page {
    Some(v) -> [
      #("page", implementationguide_definition_page_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case resource {
    [] -> fields
    _ -> [
      #(
        "resource",
        json.array(resource, implementationguide_definition_resource_to_json),
      ),
      ..fields
    ]
  }
  let fields = case grouping {
    [] -> fields
    _ -> [
      #(
        "grouping",
        json.array(grouping, implementationguide_definition_grouping_to_json),
      ),
      ..fields
    ]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn implementationguide_definition_decoder() -> Decoder(
  ImplementationguideDefinition,
) {
  use template <- decode.optional_field(
    "template",
    [],
    decode.list(implementationguide_definition_template_decoder()),
  )
  use parameter <- decode.optional_field(
    "parameter",
    [],
    decode.list(implementationguide_definition_parameter_decoder()),
  )
  use page <- decode.optional_field(
    "page",
    None,
    decode.optional(implementationguide_definition_page_decoder()),
  )
  use resource <- decode.optional_field(
    "resource",
    [],
    decode.list(implementationguide_definition_resource_decoder()),
  )
  use grouping <- decode.optional_field(
    "grouping",
    [],
    decode.list(implementationguide_definition_grouping_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ImplementationguideDefinition(
    template:,
    parameter:,
    page:,
    resource:,
    grouping:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn implementationguide_global_to_json(
  implementationguide_global: ImplementationguideGlobal,
) -> Json {
  let ImplementationguideGlobal(
    profile:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = implementationguide_global
  let fields = [
    #("profile", json.string(profile)),
    #("type", r4bvaluesets.resourcetypes_to_json(type_)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn implementationguide_global_decoder() -> Decoder(
  ImplementationguideGlobal,
) {
  use profile <- decode.field("profile", decode.string)
  use type_ <- decode.field("type", r4bvaluesets.resourcetypes_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ImplementationguideGlobal(
    profile:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn implementationguide_dependson_to_json(
  implementationguide_dependson: ImplementationguideDependson,
) -> Json {
  let ImplementationguideDependson(
    version:,
    package_id:,
    uri:,
    modifier_extension:,
    extension:,
    id:,
  ) = implementationguide_dependson
  let fields = [
    #("uri", json.string(uri)),
  ]
  let fields = case version {
    Some(v) -> [#("version", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case package_id {
    Some(v) -> [#("packageId", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn implementationguide_dependson_decoder() -> Decoder(
  ImplementationguideDependson,
) {
  use version <- decode.optional_field(
    "version",
    None,
    decode.optional(decode.string),
  )
  use package_id <- decode.optional_field(
    "packageId",
    None,
    decode.optional(decode.string),
  )
  use uri <- decode.field("uri", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ImplementationguideDependson(
    version:,
    package_id:,
    uri:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn implementationguide_to_json(
  implementationguide: Implementationguide,
) -> Json {
  let Implementationguide(
    manifest:,
    definition:,
    global:,
    depends_on:,
    fhir_version:,
    license:,
    package_id:,
    copyright:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    experimental:,
    status:,
    title:,
    name:,
    version:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = implementationguide
  let fields = [
    #("packageId", json.string(package_id)),
    #("status", r4bvaluesets.publicationstatus_to_json(status)),
    #("name", json.string(name)),
    #("url", json.string(url)),
  ]
  let fields = case manifest {
    Some(v) -> [
      #("manifest", implementationguide_manifest_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case definition {
    Some(v) -> [
      #("definition", implementationguide_definition_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case global {
    [] -> fields
    _ -> [
      #("global", json.array(global, implementationguide_global_to_json)),
      ..fields
    ]
  }
  let fields = case depends_on {
    [] -> fields
    _ -> [
      #(
        "dependsOn",
        json.array(depends_on, implementationguide_dependson_to_json),
      ),
      ..fields
    ]
  }
  let fields = case fhir_version {
    [] -> fields
    _ -> [
      #(
        "fhirVersion",
        json.array(fhir_version, r4bvaluesets.fhirversion_to_json),
      ),
      ..fields
    ]
  }
  let fields = case license {
    Some(v) -> [#("license", r4bvaluesets.spdxlicense_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case copyright {
    Some(v) -> [#("copyright", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case jurisdiction {
    [] -> fields
    _ -> [
      #("jurisdiction", json.array(jurisdiction, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case use_context {
    [] -> fields
    _ -> [
      #("useContext", json.array(use_context, usagecontext_to_json)),
      ..fields
    ]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case contact {
    [] -> fields
    _ -> [#("contact", json.array(contact, contactdetail_to_json)), ..fields]
  }
  let fields = case publisher {
    Some(v) -> [#("publisher", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case date {
    Some(v) -> [#("date", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case experimental {
    Some(v) -> [#("experimental", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case title {
    Some(v) -> [#("title", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case version {
    Some(v) -> [#("version", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Implementationguide")), ..fields]
  json.object(fields)
}

pub fn implementationguide_decoder() -> Decoder(Implementationguide) {
  use manifest <- decode.optional_field(
    "manifest",
    None,
    decode.optional(implementationguide_manifest_decoder()),
  )
  use definition <- decode.optional_field(
    "definition",
    None,
    decode.optional(implementationguide_definition_decoder()),
  )
  use global <- decode.optional_field(
    "global",
    [],
    decode.list(implementationguide_global_decoder()),
  )
  use depends_on <- decode.optional_field(
    "dependsOn",
    [],
    decode.list(implementationguide_dependson_decoder()),
  )
  use fhir_version <- decode.optional_field(
    "fhirVersion",
    [],
    decode.list(r4bvaluesets.fhirversion_decoder()),
  )
  use license <- decode.optional_field(
    "license",
    None,
    decode.optional(r4bvaluesets.spdxlicense_decoder()),
  )
  use package_id <- decode.field("packageId", decode.string)
  use copyright <- decode.optional_field(
    "copyright",
    None,
    decode.optional(decode.string),
  )
  use jurisdiction <- decode.optional_field(
    "jurisdiction",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use use_context <- decode.optional_field(
    "useContext",
    [],
    decode.list(usagecontext_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use contact <- decode.optional_field(
    "contact",
    [],
    decode.list(contactdetail_decoder()),
  )
  use publisher <- decode.optional_field(
    "publisher",
    None,
    decode.optional(decode.string),
  )
  use date <- decode.optional_field(
    "date",
    None,
    decode.optional(decode.string),
  )
  use experimental <- decode.optional_field(
    "experimental",
    None,
    decode.optional(decode.bool),
  )
  use status <- decode.field("status", r4bvaluesets.publicationstatus_decoder())
  use title <- decode.optional_field(
    "title",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.field("name", decode.string)
  use version <- decode.optional_field(
    "version",
    None,
    decode.optional(decode.string),
  )
  use url <- decode.field("url", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Implementationguide",
    decode.failure(
      implementationguide_new(package_id:, status:, name:, url:),
      "resourceType",
    ),
  )
  decode.success(Implementationguide(
    manifest:,
    definition:,
    global:,
    depends_on:,
    fhir_version:,
    license:,
    package_id:,
    copyright:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    experimental:,
    status:,
    title:,
    name:,
    version:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/Ingredient#resource
pub type Ingredient {
  Ingredient(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: Option(Identifier),
    status: r4bvaluesets.Publicationstatus,
    for: List(Reference),
    role: Codeableconcept,
    function: List(Codeableconcept),
    allergenic_indicator: Option(Bool),
    manufacturer: List(IngredientManufacturer),
    substance: IngredientSubstance,
  )
}

pub fn ingredient_new(
  substance substance: IngredientSubstance,
  role role: Codeableconcept,
  status status: r4bvaluesets.Publicationstatus,
) -> Ingredient {
  Ingredient(
    substance:,
    manufacturer: [],
    allergenic_indicator: None,
    function: [],
    role:,
    for: [],
    status:,
    identifier: None,
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Ingredient#resource
pub type IngredientManufacturer {
  IngredientManufacturer(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    role: Option(r4bvaluesets.Ingredientmanufacturerrole),
    manufacturer: Reference,
  )
}

pub fn ingredient_manufacturer_new(
  manufacturer manufacturer: Reference,
) -> IngredientManufacturer {
  IngredientManufacturer(
    manufacturer:,
    role: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Ingredient#resource
pub type IngredientSubstance {
  IngredientSubstance(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    code: Codeablereference,
    strength: List(IngredientSubstanceStrength),
  )
}

pub fn ingredient_substance_new(
  code code: Codeablereference,
) -> IngredientSubstance {
  IngredientSubstance(
    strength: [],
    code:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Ingredient#resource
pub type IngredientSubstanceStrength {
  IngredientSubstanceStrength(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    presentation: Option(IngredientSubstanceStrengthPresentation),
    text_presentation: Option(String),
    concentration: Option(IngredientSubstanceStrengthConcentration),
    text_concentration: Option(String),
    measurement_point: Option(String),
    country: List(Codeableconcept),
    reference_strength: List(IngredientSubstanceStrengthReferencestrength),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Ingredient#resource
pub type IngredientSubstanceStrengthPresentation {
  IngredientSubstanceStrengthPresentationRatio(presentation: Ratio)
  IngredientSubstanceStrengthPresentationRatiorange(presentation: Ratiorange)
}

pub fn ingredient_substance_strength_presentation_to_json(
  elt: IngredientSubstanceStrengthPresentation,
) -> Json {
  case elt {
    IngredientSubstanceStrengthPresentationRatio(v) -> ratio_to_json(v)
    IngredientSubstanceStrengthPresentationRatiorange(v) ->
      ratiorange_to_json(v)
  }
}

pub fn ingredient_substance_strength_presentation_decoder() -> Decoder(
  IngredientSubstanceStrengthPresentation,
) {
  decode.one_of(
    decode.field("presentationRatio", ratio_decoder(), decode.success)
      |> decode.map(IngredientSubstanceStrengthPresentationRatio),
    [
      decode.field(
        "presentationRatioRange",
        ratiorange_decoder(),
        decode.success,
      )
      |> decode.map(IngredientSubstanceStrengthPresentationRatiorange),
    ],
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Ingredient#resource
pub type IngredientSubstanceStrengthConcentration {
  IngredientSubstanceStrengthConcentrationRatio(concentration: Ratio)
  IngredientSubstanceStrengthConcentrationRatiorange(concentration: Ratiorange)
}

pub fn ingredient_substance_strength_concentration_to_json(
  elt: IngredientSubstanceStrengthConcentration,
) -> Json {
  case elt {
    IngredientSubstanceStrengthConcentrationRatio(v) -> ratio_to_json(v)
    IngredientSubstanceStrengthConcentrationRatiorange(v) ->
      ratiorange_to_json(v)
  }
}

pub fn ingredient_substance_strength_concentration_decoder() -> Decoder(
  IngredientSubstanceStrengthConcentration,
) {
  decode.one_of(
    decode.field("concentrationRatio", ratio_decoder(), decode.success)
      |> decode.map(IngredientSubstanceStrengthConcentrationRatio),
    [
      decode.field(
        "concentrationRatioRange",
        ratiorange_decoder(),
        decode.success,
      )
      |> decode.map(IngredientSubstanceStrengthConcentrationRatiorange),
    ],
  )
}

pub fn ingredient_substance_strength_new() -> IngredientSubstanceStrength {
  IngredientSubstanceStrength(
    reference_strength: [],
    country: [],
    measurement_point: None,
    text_concentration: None,
    concentration: None,
    text_presentation: None,
    presentation: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Ingredient#resource
pub type IngredientSubstanceStrengthReferencestrength {
  IngredientSubstanceStrengthReferencestrength(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    substance: Option(Codeablereference),
    strength: IngredientSubstanceStrengthReferencestrengthStrength,
    measurement_point: Option(String),
    country: List(Codeableconcept),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Ingredient#resource
pub type IngredientSubstanceStrengthReferencestrengthStrength {
  IngredientSubstanceStrengthReferencestrengthStrengthRatio(strength: Ratio)
  IngredientSubstanceStrengthReferencestrengthStrengthRatiorange(
    strength: Ratiorange,
  )
}

pub fn ingredient_substance_strength_referencestrength_strength_to_json(
  elt: IngredientSubstanceStrengthReferencestrengthStrength,
) -> Json {
  case elt {
    IngredientSubstanceStrengthReferencestrengthStrengthRatio(v) ->
      ratio_to_json(v)
    IngredientSubstanceStrengthReferencestrengthStrengthRatiorange(v) ->
      ratiorange_to_json(v)
  }
}

pub fn ingredient_substance_strength_referencestrength_strength_decoder() -> Decoder(
  IngredientSubstanceStrengthReferencestrengthStrength,
) {
  decode.one_of(
    decode.field("strengthRatio", ratio_decoder(), decode.success)
      |> decode.map(IngredientSubstanceStrengthReferencestrengthStrengthRatio),
    [
      decode.field("strengthRatioRange", ratiorange_decoder(), decode.success)
      |> decode.map(
        IngredientSubstanceStrengthReferencestrengthStrengthRatiorange,
      ),
    ],
  )
}

pub fn ingredient_substance_strength_referencestrength_new(
  strength strength: IngredientSubstanceStrengthReferencestrengthStrength,
) -> IngredientSubstanceStrengthReferencestrength {
  IngredientSubstanceStrengthReferencestrength(
    country: [],
    measurement_point: None,
    strength:,
    substance: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn ingredient_substance_strength_referencestrength_to_json(
  ingredient_substance_strength_referencestrength: IngredientSubstanceStrengthReferencestrength,
) -> Json {
  let IngredientSubstanceStrengthReferencestrength(
    country:,
    measurement_point:,
    strength:,
    substance:,
    modifier_extension:,
    extension:,
    id:,
  ) = ingredient_substance_strength_referencestrength
  let fields = [
    #(
      "strength",
      ingredient_substance_strength_referencestrength_strength_to_json(strength),
    ),
  ]
  let fields = case country {
    [] -> fields
    _ -> [#("country", json.array(country, codeableconcept_to_json)), ..fields]
  }
  let fields = case measurement_point {
    Some(v) -> [#("measurementPoint", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case substance {
    Some(v) -> [#("substance", codeablereference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn ingredient_substance_strength_referencestrength_decoder() -> Decoder(
  IngredientSubstanceStrengthReferencestrength,
) {
  use country <- decode.optional_field(
    "country",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use measurement_point <- decode.optional_field(
    "measurementPoint",
    None,
    decode.optional(decode.string),
  )
  use strength <- decode.then(
    ingredient_substance_strength_referencestrength_strength_decoder(),
  )
  use substance <- decode.optional_field(
    "substance",
    None,
    decode.optional(codeablereference_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(IngredientSubstanceStrengthReferencestrength(
    country:,
    measurement_point:,
    strength:,
    substance:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn ingredient_substance_strength_to_json(
  ingredient_substance_strength: IngredientSubstanceStrength,
) -> Json {
  let IngredientSubstanceStrength(
    reference_strength:,
    country:,
    measurement_point:,
    text_concentration:,
    concentration:,
    text_presentation:,
    presentation:,
    modifier_extension:,
    extension:,
    id:,
  ) = ingredient_substance_strength
  let fields = []
  let fields = case reference_strength {
    [] -> fields
    _ -> [
      #(
        "referenceStrength",
        json.array(
          reference_strength,
          ingredient_substance_strength_referencestrength_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case country {
    [] -> fields
    _ -> [#("country", json.array(country, codeableconcept_to_json)), ..fields]
  }
  let fields = case measurement_point {
    Some(v) -> [#("measurementPoint", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case text_concentration {
    Some(v) -> [#("textConcentration", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case concentration {
    Some(v) -> [
      #(
        "concentration"
          <> case v {
          IngredientSubstanceStrengthConcentrationRatio(_) -> "Ratio"
          IngredientSubstanceStrengthConcentrationRatiorange(_) -> "Ratiorange"
        },
        ingredient_substance_strength_concentration_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case text_presentation {
    Some(v) -> [#("textPresentation", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case presentation {
    Some(v) -> [
      #(
        "presentation"
          <> case v {
          IngredientSubstanceStrengthPresentationRatio(_) -> "Ratio"
          IngredientSubstanceStrengthPresentationRatiorange(_) -> "Ratiorange"
        },
        ingredient_substance_strength_presentation_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn ingredient_substance_strength_decoder() -> Decoder(
  IngredientSubstanceStrength,
) {
  use reference_strength <- decode.optional_field(
    "referenceStrength",
    [],
    decode.list(ingredient_substance_strength_referencestrength_decoder()),
  )
  use country <- decode.optional_field(
    "country",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use measurement_point <- decode.optional_field(
    "measurementPoint",
    None,
    decode.optional(decode.string),
  )
  use text_concentration <- decode.optional_field(
    "textConcentration",
    None,
    decode.optional(decode.string),
  )
  use concentration <- decode.then(
    none_if_omitted(ingredient_substance_strength_concentration_decoder()),
  )
  use text_presentation <- decode.optional_field(
    "textPresentation",
    None,
    decode.optional(decode.string),
  )
  use presentation <- decode.then(
    none_if_omitted(ingredient_substance_strength_presentation_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(IngredientSubstanceStrength(
    reference_strength:,
    country:,
    measurement_point:,
    text_concentration:,
    concentration:,
    text_presentation:,
    presentation:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn ingredient_substance_to_json(
  ingredient_substance: IngredientSubstance,
) -> Json {
  let IngredientSubstance(
    strength:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ) = ingredient_substance
  let fields = [
    #("code", codeablereference_to_json(code)),
  ]
  let fields = case strength {
    [] -> fields
    _ -> [
      #("strength", json.array(strength, ingredient_substance_strength_to_json)),
      ..fields
    ]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn ingredient_substance_decoder() -> Decoder(IngredientSubstance) {
  use strength <- decode.optional_field(
    "strength",
    [],
    decode.list(ingredient_substance_strength_decoder()),
  )
  use code <- decode.field("code", codeablereference_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(IngredientSubstance(
    strength:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn ingredient_manufacturer_to_json(
  ingredient_manufacturer: IngredientManufacturer,
) -> Json {
  let IngredientManufacturer(
    manufacturer:,
    role:,
    modifier_extension:,
    extension:,
    id:,
  ) = ingredient_manufacturer
  let fields = [
    #("manufacturer", reference_to_json(manufacturer)),
  ]
  let fields = case role {
    Some(v) -> [
      #("role", r4bvaluesets.ingredientmanufacturerrole_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn ingredient_manufacturer_decoder() -> Decoder(IngredientManufacturer) {
  use manufacturer <- decode.field("manufacturer", reference_decoder())
  use role <- decode.optional_field(
    "role",
    None,
    decode.optional(r4bvaluesets.ingredientmanufacturerrole_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(IngredientManufacturer(
    manufacturer:,
    role:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn ingredient_to_json(ingredient: Ingredient) -> Json {
  let Ingredient(
    substance:,
    manufacturer:,
    allergenic_indicator:,
    function:,
    role:,
    for:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = ingredient
  let fields = [
    #("substance", ingredient_substance_to_json(substance)),
    #("role", codeableconcept_to_json(role)),
    #("status", r4bvaluesets.publicationstatus_to_json(status)),
  ]
  let fields = case manufacturer {
    [] -> fields
    _ -> [
      #(
        "manufacturer",
        json.array(manufacturer, ingredient_manufacturer_to_json),
      ),
      ..fields
    ]
  }
  let fields = case allergenic_indicator {
    Some(v) -> [#("allergenicIndicator", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case function {
    [] -> fields
    _ -> [
      #("function", json.array(function, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case for {
    [] -> fields
    _ -> [#("for", json.array(for, reference_to_json)), ..fields]
  }
  let fields = case identifier {
    Some(v) -> [#("identifier", identifier_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Ingredient")), ..fields]
  json.object(fields)
}

pub fn ingredient_decoder() -> Decoder(Ingredient) {
  use substance <- decode.field("substance", ingredient_substance_decoder())
  use manufacturer <- decode.optional_field(
    "manufacturer",
    [],
    decode.list(ingredient_manufacturer_decoder()),
  )
  use allergenic_indicator <- decode.optional_field(
    "allergenicIndicator",
    None,
    decode.optional(decode.bool),
  )
  use function <- decode.optional_field(
    "function",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use role <- decode.field("role", codeableconcept_decoder())
  use for <- decode.optional_field("for", [], decode.list(reference_decoder()))
  use status <- decode.field("status", r4bvaluesets.publicationstatus_decoder())
  use identifier <- decode.optional_field(
    "identifier",
    None,
    decode.optional(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Ingredient",
    decode.failure(ingredient_new(substance:, role:, status:), "resourceType"),
  )
  decode.success(Ingredient(
    substance:,
    manufacturer:,
    allergenic_indicator:,
    function:,
    role:,
    for:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/InsurancePlan#resource
pub type Insuranceplan {
  Insuranceplan(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    status: Option(r4bvaluesets.Publicationstatus),
    type_: List(Codeableconcept),
    name: Option(String),
    alias: List(String),
    period: Option(Period),
    owned_by: Option(Reference),
    administered_by: Option(Reference),
    coverage_area: List(Reference),
    contact: List(InsuranceplanContact),
    endpoint: List(Reference),
    network: List(Reference),
    coverage: List(InsuranceplanCoverage),
    plan: List(InsuranceplanPlan),
  )
}

pub fn insuranceplan_new() -> Insuranceplan {
  Insuranceplan(
    plan: [],
    coverage: [],
    network: [],
    endpoint: [],
    contact: [],
    coverage_area: [],
    administered_by: None,
    owned_by: None,
    period: None,
    alias: [],
    name: None,
    type_: [],
    status: None,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/InsurancePlan#resource
pub type InsuranceplanContact {
  InsuranceplanContact(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    purpose: Option(Codeableconcept),
    name: Option(Humanname),
    telecom: List(Contactpoint),
    address: Option(Address),
  )
}

pub fn insuranceplan_contact_new() -> InsuranceplanContact {
  InsuranceplanContact(
    address: None,
    telecom: [],
    name: None,
    purpose: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/InsurancePlan#resource
pub type InsuranceplanCoverage {
  InsuranceplanCoverage(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Codeableconcept,
    network: List(Reference),
    benefit: List(InsuranceplanCoverageBenefit),
  )
}

pub fn insuranceplan_coverage_new(
  type_ type_: Codeableconcept,
) -> InsuranceplanCoverage {
  InsuranceplanCoverage(
    benefit: [],
    network: [],
    type_:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/InsurancePlan#resource
pub type InsuranceplanCoverageBenefit {
  InsuranceplanCoverageBenefit(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Codeableconcept,
    requirement: Option(String),
    limit: List(InsuranceplanCoverageBenefitLimit),
  )
}

pub fn insuranceplan_coverage_benefit_new(
  type_ type_: Codeableconcept,
) -> InsuranceplanCoverageBenefit {
  InsuranceplanCoverageBenefit(
    limit: [],
    requirement: None,
    type_:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/InsurancePlan#resource
pub type InsuranceplanCoverageBenefitLimit {
  InsuranceplanCoverageBenefitLimit(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    value: Option(Quantity),
    code: Option(Codeableconcept),
  )
}

pub fn insuranceplan_coverage_benefit_limit_new() -> InsuranceplanCoverageBenefitLimit {
  InsuranceplanCoverageBenefitLimit(
    code: None,
    value: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/InsurancePlan#resource
pub type InsuranceplanPlan {
  InsuranceplanPlan(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    type_: Option(Codeableconcept),
    coverage_area: List(Reference),
    network: List(Reference),
    general_cost: List(InsuranceplanPlanGeneralcost),
    specific_cost: List(InsuranceplanPlanSpecificcost),
  )
}

pub fn insuranceplan_plan_new() -> InsuranceplanPlan {
  InsuranceplanPlan(
    specific_cost: [],
    general_cost: [],
    network: [],
    coverage_area: [],
    type_: None,
    identifier: [],
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/InsurancePlan#resource
pub type InsuranceplanPlanGeneralcost {
  InsuranceplanPlanGeneralcost(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Option(Codeableconcept),
    group_size: Option(Int),
    cost: Option(Money),
    comment: Option(String),
  )
}

pub fn insuranceplan_plan_generalcost_new() -> InsuranceplanPlanGeneralcost {
  InsuranceplanPlanGeneralcost(
    comment: None,
    cost: None,
    group_size: None,
    type_: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/InsurancePlan#resource
pub type InsuranceplanPlanSpecificcost {
  InsuranceplanPlanSpecificcost(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    category: Codeableconcept,
    benefit: List(InsuranceplanPlanSpecificcostBenefit),
  )
}

pub fn insuranceplan_plan_specificcost_new(
  category category: Codeableconcept,
) -> InsuranceplanPlanSpecificcost {
  InsuranceplanPlanSpecificcost(
    benefit: [],
    category:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/InsurancePlan#resource
pub type InsuranceplanPlanSpecificcostBenefit {
  InsuranceplanPlanSpecificcostBenefit(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Codeableconcept,
    cost: List(InsuranceplanPlanSpecificcostBenefitCost),
  )
}

pub fn insuranceplan_plan_specificcost_benefit_new(
  type_ type_: Codeableconcept,
) -> InsuranceplanPlanSpecificcostBenefit {
  InsuranceplanPlanSpecificcostBenefit(
    cost: [],
    type_:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/InsurancePlan#resource
pub type InsuranceplanPlanSpecificcostBenefitCost {
  InsuranceplanPlanSpecificcostBenefitCost(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Codeableconcept,
    applicability: Option(Codeableconcept),
    qualifiers: List(Codeableconcept),
    value: Option(Quantity),
  )
}

pub fn insuranceplan_plan_specificcost_benefit_cost_new(
  type_ type_: Codeableconcept,
) -> InsuranceplanPlanSpecificcostBenefitCost {
  InsuranceplanPlanSpecificcostBenefitCost(
    value: None,
    qualifiers: [],
    applicability: None,
    type_:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn insuranceplan_plan_specificcost_benefit_cost_to_json(
  insuranceplan_plan_specificcost_benefit_cost: InsuranceplanPlanSpecificcostBenefitCost,
) -> Json {
  let InsuranceplanPlanSpecificcostBenefitCost(
    value:,
    qualifiers:,
    applicability:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = insuranceplan_plan_specificcost_benefit_cost
  let fields = [
    #("type", codeableconcept_to_json(type_)),
  ]
  let fields = case value {
    Some(v) -> [#("value", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case qualifiers {
    [] -> fields
    _ -> [
      #("qualifiers", json.array(qualifiers, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case applicability {
    Some(v) -> [#("applicability", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn insuranceplan_plan_specificcost_benefit_cost_decoder() -> Decoder(
  InsuranceplanPlanSpecificcostBenefitCost,
) {
  use value <- decode.optional_field(
    "value",
    None,
    decode.optional(quantity_decoder()),
  )
  use qualifiers <- decode.optional_field(
    "qualifiers",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use applicability <- decode.optional_field(
    "applicability",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use type_ <- decode.field("type", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(InsuranceplanPlanSpecificcostBenefitCost(
    value:,
    qualifiers:,
    applicability:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn insuranceplan_plan_specificcost_benefit_to_json(
  insuranceplan_plan_specificcost_benefit: InsuranceplanPlanSpecificcostBenefit,
) -> Json {
  let InsuranceplanPlanSpecificcostBenefit(
    cost:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = insuranceplan_plan_specificcost_benefit
  let fields = [
    #("type", codeableconcept_to_json(type_)),
  ]
  let fields = case cost {
    [] -> fields
    _ -> [
      #(
        "cost",
        json.array(cost, insuranceplan_plan_specificcost_benefit_cost_to_json),
      ),
      ..fields
    ]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn insuranceplan_plan_specificcost_benefit_decoder() -> Decoder(
  InsuranceplanPlanSpecificcostBenefit,
) {
  use cost <- decode.optional_field(
    "cost",
    [],
    decode.list(insuranceplan_plan_specificcost_benefit_cost_decoder()),
  )
  use type_ <- decode.field("type", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(InsuranceplanPlanSpecificcostBenefit(
    cost:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn insuranceplan_plan_specificcost_to_json(
  insuranceplan_plan_specificcost: InsuranceplanPlanSpecificcost,
) -> Json {
  let InsuranceplanPlanSpecificcost(
    benefit:,
    category:,
    modifier_extension:,
    extension:,
    id:,
  ) = insuranceplan_plan_specificcost
  let fields = [
    #("category", codeableconcept_to_json(category)),
  ]
  let fields = case benefit {
    [] -> fields
    _ -> [
      #(
        "benefit",
        json.array(benefit, insuranceplan_plan_specificcost_benefit_to_json),
      ),
      ..fields
    ]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn insuranceplan_plan_specificcost_decoder() -> Decoder(
  InsuranceplanPlanSpecificcost,
) {
  use benefit <- decode.optional_field(
    "benefit",
    [],
    decode.list(insuranceplan_plan_specificcost_benefit_decoder()),
  )
  use category <- decode.field("category", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(InsuranceplanPlanSpecificcost(
    benefit:,
    category:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn insuranceplan_plan_generalcost_to_json(
  insuranceplan_plan_generalcost: InsuranceplanPlanGeneralcost,
) -> Json {
  let InsuranceplanPlanGeneralcost(
    comment:,
    cost:,
    group_size:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = insuranceplan_plan_generalcost
  let fields = []
  let fields = case comment {
    Some(v) -> [#("comment", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case cost {
    Some(v) -> [#("cost", money_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case group_size {
    Some(v) -> [#("groupSize", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn insuranceplan_plan_generalcost_decoder() -> Decoder(
  InsuranceplanPlanGeneralcost,
) {
  use comment <- decode.optional_field(
    "comment",
    None,
    decode.optional(decode.string),
  )
  use cost <- decode.optional_field(
    "cost",
    None,
    decode.optional(money_decoder()),
  )
  use group_size <- decode.optional_field(
    "groupSize",
    None,
    decode.optional(decode.int),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(InsuranceplanPlanGeneralcost(
    comment:,
    cost:,
    group_size:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn insuranceplan_plan_to_json(insuranceplan_plan: InsuranceplanPlan) -> Json {
  let InsuranceplanPlan(
    specific_cost:,
    general_cost:,
    network:,
    coverage_area:,
    type_:,
    identifier:,
    modifier_extension:,
    extension:,
    id:,
  ) = insuranceplan_plan
  let fields = []
  let fields = case specific_cost {
    [] -> fields
    _ -> [
      #(
        "specificCost",
        json.array(specific_cost, insuranceplan_plan_specificcost_to_json),
      ),
      ..fields
    ]
  }
  let fields = case general_cost {
    [] -> fields
    _ -> [
      #(
        "generalCost",
        json.array(general_cost, insuranceplan_plan_generalcost_to_json),
      ),
      ..fields
    ]
  }
  let fields = case network {
    [] -> fields
    _ -> [#("network", json.array(network, reference_to_json)), ..fields]
  }
  let fields = case coverage_area {
    [] -> fields
    _ -> [
      #("coverageArea", json.array(coverage_area, reference_to_json)),
      ..fields
    ]
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn insuranceplan_plan_decoder() -> Decoder(InsuranceplanPlan) {
  use specific_cost <- decode.optional_field(
    "specificCost",
    [],
    decode.list(insuranceplan_plan_specificcost_decoder()),
  )
  use general_cost <- decode.optional_field(
    "generalCost",
    [],
    decode.list(insuranceplan_plan_generalcost_decoder()),
  )
  use network <- decode.optional_field(
    "network",
    [],
    decode.list(reference_decoder()),
  )
  use coverage_area <- decode.optional_field(
    "coverageArea",
    [],
    decode.list(reference_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(InsuranceplanPlan(
    specific_cost:,
    general_cost:,
    network:,
    coverage_area:,
    type_:,
    identifier:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn insuranceplan_coverage_benefit_limit_to_json(
  insuranceplan_coverage_benefit_limit: InsuranceplanCoverageBenefitLimit,
) -> Json {
  let InsuranceplanCoverageBenefitLimit(
    code:,
    value:,
    modifier_extension:,
    extension:,
    id:,
  ) = insuranceplan_coverage_benefit_limit
  let fields = []
  let fields = case code {
    Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case value {
    Some(v) -> [#("value", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn insuranceplan_coverage_benefit_limit_decoder() -> Decoder(
  InsuranceplanCoverageBenefitLimit,
) {
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use value <- decode.optional_field(
    "value",
    None,
    decode.optional(quantity_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(InsuranceplanCoverageBenefitLimit(
    code:,
    value:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn insuranceplan_coverage_benefit_to_json(
  insuranceplan_coverage_benefit: InsuranceplanCoverageBenefit,
) -> Json {
  let InsuranceplanCoverageBenefit(
    limit:,
    requirement:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = insuranceplan_coverage_benefit
  let fields = [
    #("type", codeableconcept_to_json(type_)),
  ]
  let fields = case limit {
    [] -> fields
    _ -> [
      #(
        "limit",
        json.array(limit, insuranceplan_coverage_benefit_limit_to_json),
      ),
      ..fields
    ]
  }
  let fields = case requirement {
    Some(v) -> [#("requirement", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn insuranceplan_coverage_benefit_decoder() -> Decoder(
  InsuranceplanCoverageBenefit,
) {
  use limit <- decode.optional_field(
    "limit",
    [],
    decode.list(insuranceplan_coverage_benefit_limit_decoder()),
  )
  use requirement <- decode.optional_field(
    "requirement",
    None,
    decode.optional(decode.string),
  )
  use type_ <- decode.field("type", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(InsuranceplanCoverageBenefit(
    limit:,
    requirement:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn insuranceplan_coverage_to_json(
  insuranceplan_coverage: InsuranceplanCoverage,
) -> Json {
  let InsuranceplanCoverage(
    benefit:,
    network:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = insuranceplan_coverage
  let fields = [
    #("type", codeableconcept_to_json(type_)),
  ]
  let fields = case benefit {
    [] -> fields
    _ -> [
      #("benefit", json.array(benefit, insuranceplan_coverage_benefit_to_json)),
      ..fields
    ]
  }
  let fields = case network {
    [] -> fields
    _ -> [#("network", json.array(network, reference_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn insuranceplan_coverage_decoder() -> Decoder(InsuranceplanCoverage) {
  use benefit <- decode.optional_field(
    "benefit",
    [],
    decode.list(insuranceplan_coverage_benefit_decoder()),
  )
  use network <- decode.optional_field(
    "network",
    [],
    decode.list(reference_decoder()),
  )
  use type_ <- decode.field("type", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(InsuranceplanCoverage(
    benefit:,
    network:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn insuranceplan_contact_to_json(
  insuranceplan_contact: InsuranceplanContact,
) -> Json {
  let InsuranceplanContact(
    address:,
    telecom:,
    name:,
    purpose:,
    modifier_extension:,
    extension:,
    id:,
  ) = insuranceplan_contact
  let fields = []
  let fields = case address {
    Some(v) -> [#("address", address_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case telecom {
    [] -> fields
    _ -> [#("telecom", json.array(telecom, contactpoint_to_json)), ..fields]
  }
  let fields = case name {
    Some(v) -> [#("name", humanname_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case purpose {
    Some(v) -> [#("purpose", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn insuranceplan_contact_decoder() -> Decoder(InsuranceplanContact) {
  use address <- decode.optional_field(
    "address",
    None,
    decode.optional(address_decoder()),
  )
  use telecom <- decode.optional_field(
    "telecom",
    [],
    decode.list(contactpoint_decoder()),
  )
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(humanname_decoder()),
  )
  use purpose <- decode.optional_field(
    "purpose",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(InsuranceplanContact(
    address:,
    telecom:,
    name:,
    purpose:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn insuranceplan_to_json(insuranceplan: Insuranceplan) -> Json {
  let Insuranceplan(
    plan:,
    coverage:,
    network:,
    endpoint:,
    contact:,
    coverage_area:,
    administered_by:,
    owned_by:,
    period:,
    alias:,
    name:,
    type_:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = insuranceplan
  let fields = []
  let fields = case plan {
    [] -> fields
    _ -> [#("plan", json.array(plan, insuranceplan_plan_to_json)), ..fields]
  }
  let fields = case coverage {
    [] -> fields
    _ -> [
      #("coverage", json.array(coverage, insuranceplan_coverage_to_json)),
      ..fields
    ]
  }
  let fields = case network {
    [] -> fields
    _ -> [#("network", json.array(network, reference_to_json)), ..fields]
  }
  let fields = case endpoint {
    [] -> fields
    _ -> [#("endpoint", json.array(endpoint, reference_to_json)), ..fields]
  }
  let fields = case contact {
    [] -> fields
    _ -> [
      #("contact", json.array(contact, insuranceplan_contact_to_json)),
      ..fields
    ]
  }
  let fields = case coverage_area {
    [] -> fields
    _ -> [
      #("coverageArea", json.array(coverage_area, reference_to_json)),
      ..fields
    ]
  }
  let fields = case administered_by {
    Some(v) -> [#("administeredBy", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case owned_by {
    Some(v) -> [#("ownedBy", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case period {
    Some(v) -> [#("period", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case alias {
    [] -> fields
    _ -> [#("alias", json.array(alias, json.string)), ..fields]
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    [] -> fields
    _ -> [#("type", json.array(type_, codeableconcept_to_json)), ..fields]
  }
  let fields = case status {
    Some(v) -> [
      #("status", r4bvaluesets.publicationstatus_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Insuranceplan")), ..fields]
  json.object(fields)
}

pub fn insuranceplan_decoder() -> Decoder(Insuranceplan) {
  use plan <- decode.optional_field(
    "plan",
    [],
    decode.list(insuranceplan_plan_decoder()),
  )
  use coverage <- decode.optional_field(
    "coverage",
    [],
    decode.list(insuranceplan_coverage_decoder()),
  )
  use network <- decode.optional_field(
    "network",
    [],
    decode.list(reference_decoder()),
  )
  use endpoint <- decode.optional_field(
    "endpoint",
    [],
    decode.list(reference_decoder()),
  )
  use contact <- decode.optional_field(
    "contact",
    [],
    decode.list(insuranceplan_contact_decoder()),
  )
  use coverage_area <- decode.optional_field(
    "coverageArea",
    [],
    decode.list(reference_decoder()),
  )
  use administered_by <- decode.optional_field(
    "administeredBy",
    None,
    decode.optional(reference_decoder()),
  )
  use owned_by <- decode.optional_field(
    "ownedBy",
    None,
    decode.optional(reference_decoder()),
  )
  use period <- decode.optional_field(
    "period",
    None,
    decode.optional(period_decoder()),
  )
  use alias <- decode.optional_field("alias", [], decode.list(decode.string))
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use type_ <- decode.optional_field(
    "type",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use status <- decode.optional_field(
    "status",
    None,
    decode.optional(r4bvaluesets.publicationstatus_decoder()),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Insuranceplan",
    decode.failure(insuranceplan_new(), "resourceType"),
  )
  decode.success(Insuranceplan(
    plan:,
    coverage:,
    network:,
    endpoint:,
    contact:,
    coverage_area:,
    administered_by:,
    owned_by:,
    period:,
    alias:,
    name:,
    type_:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/Invoice#resource
pub type Invoice {
  Invoice(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    status: r4bvaluesets.Invoicestatus,
    cancelled_reason: Option(String),
    type_: Option(Codeableconcept),
    subject: Option(Reference),
    recipient: Option(Reference),
    date: Option(String),
    participant: List(InvoiceParticipant),
    issuer: Option(Reference),
    account: Option(Reference),
    line_item: List(InvoiceLineitem),
    total_net: Option(Money),
    total_gross: Option(Money),
    payment_terms: Option(String),
    note: List(Annotation),
  )
}

pub fn invoice_new(status status: r4bvaluesets.Invoicestatus) -> Invoice {
  Invoice(
    note: [],
    payment_terms: None,
    total_gross: None,
    total_net: None,
    line_item: [],
    account: None,
    issuer: None,
    participant: [],
    date: None,
    recipient: None,
    subject: None,
    type_: None,
    cancelled_reason: None,
    status:,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Invoice#resource
pub type InvoiceParticipant {
  InvoiceParticipant(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    role: Option(Codeableconcept),
    actor: Reference,
  )
}

pub fn invoice_participant_new(actor actor: Reference) -> InvoiceParticipant {
  InvoiceParticipant(
    actor:,
    role: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Invoice#resource
pub type InvoiceLineitem {
  InvoiceLineitem(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    sequence: Option(Int),
    charge_item: InvoiceLineitemChargeitem,
    price_component: List(InvoiceLineitemPricecomponent),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Invoice#resource
pub type InvoiceLineitemChargeitem {
  InvoiceLineitemChargeitemReference(charge_item: Reference)
  InvoiceLineitemChargeitemCodeableconcept(charge_item: Codeableconcept)
}

pub fn invoice_lineitem_chargeitem_to_json(
  elt: InvoiceLineitemChargeitem,
) -> Json {
  case elt {
    InvoiceLineitemChargeitemReference(v) -> reference_to_json(v)
    InvoiceLineitemChargeitemCodeableconcept(v) -> codeableconcept_to_json(v)
  }
}

pub fn invoice_lineitem_chargeitem_decoder() -> Decoder(
  InvoiceLineitemChargeitem,
) {
  decode.one_of(
    decode.field("chargeItemReference", reference_decoder(), decode.success)
      |> decode.map(InvoiceLineitemChargeitemReference),
    [
      decode.field(
        "chargeItemCodeableConcept",
        codeableconcept_decoder(),
        decode.success,
      )
      |> decode.map(InvoiceLineitemChargeitemCodeableconcept),
    ],
  )
}

pub fn invoice_lineitem_new(
  charge_item charge_item: InvoiceLineitemChargeitem,
) -> InvoiceLineitem {
  InvoiceLineitem(
    price_component: [],
    charge_item:,
    sequence: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Invoice#resource
pub type InvoiceLineitemPricecomponent {
  InvoiceLineitemPricecomponent(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: r4bvaluesets.Invoicepricecomponenttype,
    code: Option(Codeableconcept),
    factor: Option(Float),
    amount: Option(Money),
  )
}

pub fn invoice_lineitem_pricecomponent_new(
  type_ type_: r4bvaluesets.Invoicepricecomponenttype,
) -> InvoiceLineitemPricecomponent {
  InvoiceLineitemPricecomponent(
    amount: None,
    factor: None,
    code: None,
    type_:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn invoice_lineitem_pricecomponent_to_json(
  invoice_lineitem_pricecomponent: InvoiceLineitemPricecomponent,
) -> Json {
  let InvoiceLineitemPricecomponent(
    amount:,
    factor:,
    code:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = invoice_lineitem_pricecomponent
  let fields = [
    #("type", r4bvaluesets.invoicepricecomponenttype_to_json(type_)),
  ]
  let fields = case amount {
    Some(v) -> [#("amount", money_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case factor {
    Some(v) -> [#("factor", json.float(v)), ..fields]
    None -> fields
  }
  let fields = case code {
    Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn invoice_lineitem_pricecomponent_decoder() -> Decoder(
  InvoiceLineitemPricecomponent,
) {
  use amount <- decode.optional_field(
    "amount",
    None,
    decode.optional(money_decoder()),
  )
  use factor <- decode.optional_field(
    "factor",
    None,
    decode.optional(decode.float),
  )
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use type_ <- decode.field(
    "type",
    r4bvaluesets.invoicepricecomponenttype_decoder(),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(InvoiceLineitemPricecomponent(
    amount:,
    factor:,
    code:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn invoice_lineitem_to_json(invoice_lineitem: InvoiceLineitem) -> Json {
  let InvoiceLineitem(
    price_component:,
    charge_item:,
    sequence:,
    modifier_extension:,
    extension:,
    id:,
  ) = invoice_lineitem
  let fields = [
    #("chargeItem", invoice_lineitem_chargeitem_to_json(charge_item)),
  ]
  let fields = case price_component {
    [] -> fields
    _ -> [
      #(
        "priceComponent",
        json.array(price_component, invoice_lineitem_pricecomponent_to_json),
      ),
      ..fields
    ]
  }
  let fields = case sequence {
    Some(v) -> [#("sequence", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn invoice_lineitem_decoder() -> Decoder(InvoiceLineitem) {
  use price_component <- decode.optional_field(
    "priceComponent",
    [],
    decode.list(invoice_lineitem_pricecomponent_decoder()),
  )
  use charge_item <- decode.then(invoice_lineitem_chargeitem_decoder())
  use sequence <- decode.optional_field(
    "sequence",
    None,
    decode.optional(decode.int),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(InvoiceLineitem(
    price_component:,
    charge_item:,
    sequence:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn invoice_participant_to_json(
  invoice_participant: InvoiceParticipant,
) -> Json {
  let InvoiceParticipant(actor:, role:, modifier_extension:, extension:, id:) =
    invoice_participant
  let fields = [
    #("actor", reference_to_json(actor)),
  ]
  let fields = case role {
    Some(v) -> [#("role", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn invoice_participant_decoder() -> Decoder(InvoiceParticipant) {
  use actor <- decode.field("actor", reference_decoder())
  use role <- decode.optional_field(
    "role",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(InvoiceParticipant(
    actor:,
    role:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn invoice_to_json(invoice: Invoice) -> Json {
  let Invoice(
    note:,
    payment_terms:,
    total_gross:,
    total_net:,
    line_item:,
    account:,
    issuer:,
    participant:,
    date:,
    recipient:,
    subject:,
    type_:,
    cancelled_reason:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = invoice
  let fields = [
    #("status", r4bvaluesets.invoicestatus_to_json(status)),
  ]
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case payment_terms {
    Some(v) -> [#("paymentTerms", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case total_gross {
    Some(v) -> [#("totalGross", money_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case total_net {
    Some(v) -> [#("totalNet", money_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case line_item {
    [] -> fields
    _ -> [
      #("lineItem", json.array(line_item, invoice_lineitem_to_json)),
      ..fields
    ]
  }
  let fields = case account {
    Some(v) -> [#("account", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case issuer {
    Some(v) -> [#("issuer", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case participant {
    [] -> fields
    _ -> [
      #("participant", json.array(participant, invoice_participant_to_json)),
      ..fields
    ]
  }
  let fields = case date {
    Some(v) -> [#("date", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case recipient {
    Some(v) -> [#("recipient", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case subject {
    Some(v) -> [#("subject", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case cancelled_reason {
    Some(v) -> [#("cancelledReason", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Invoice")), ..fields]
  json.object(fields)
}

pub fn invoice_decoder() -> Decoder(Invoice) {
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use payment_terms <- decode.optional_field(
    "paymentTerms",
    None,
    decode.optional(decode.string),
  )
  use total_gross <- decode.optional_field(
    "totalGross",
    None,
    decode.optional(money_decoder()),
  )
  use total_net <- decode.optional_field(
    "totalNet",
    None,
    decode.optional(money_decoder()),
  )
  use line_item <- decode.optional_field(
    "lineItem",
    [],
    decode.list(invoice_lineitem_decoder()),
  )
  use account <- decode.optional_field(
    "account",
    None,
    decode.optional(reference_decoder()),
  )
  use issuer <- decode.optional_field(
    "issuer",
    None,
    decode.optional(reference_decoder()),
  )
  use participant <- decode.optional_field(
    "participant",
    [],
    decode.list(invoice_participant_decoder()),
  )
  use date <- decode.optional_field(
    "date",
    None,
    decode.optional(decode.string),
  )
  use recipient <- decode.optional_field(
    "recipient",
    None,
    decode.optional(reference_decoder()),
  )
  use subject <- decode.optional_field(
    "subject",
    None,
    decode.optional(reference_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use cancelled_reason <- decode.optional_field(
    "cancelledReason",
    None,
    decode.optional(decode.string),
  )
  use status <- decode.field("status", r4bvaluesets.invoicestatus_decoder())
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Invoice",
    decode.failure(invoice_new(status:), "resourceType"),
  )
  decode.success(Invoice(
    note:,
    payment_terms:,
    total_gross:,
    total_net:,
    line_item:,
    account:,
    issuer:,
    participant:,
    date:,
    recipient:,
    subject:,
    type_:,
    cancelled_reason:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/Library#resource
pub type Library {
  Library(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    url: Option(String),
    identifier: List(Identifier),
    version: Option(String),
    name: Option(String),
    title: Option(String),
    subtitle: Option(String),
    status: r4bvaluesets.Publicationstatus,
    experimental: Option(Bool),
    type_: Codeableconcept,
    subject: Option(LibrarySubject),
    date: Option(String),
    publisher: Option(String),
    contact: List(Contactdetail),
    description: Option(String),
    use_context: List(Usagecontext),
    jurisdiction: List(Codeableconcept),
    purpose: Option(String),
    usage: Option(String),
    copyright: Option(String),
    approval_date: Option(String),
    last_review_date: Option(String),
    effective_period: Option(Period),
    topic: List(Codeableconcept),
    author: List(Contactdetail),
    editor: List(Contactdetail),
    reviewer: List(Contactdetail),
    endorser: List(Contactdetail),
    related_artifact: List(Relatedartifact),
    parameter: List(Parameterdefinition),
    data_requirement: List(Datarequirement),
    content: List(Attachment),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Library#resource
pub type LibrarySubject {
  LibrarySubjectCodeableconcept(subject: Codeableconcept)
  LibrarySubjectReference(subject: Reference)
}

pub fn library_subject_to_json(elt: LibrarySubject) -> Json {
  case elt {
    LibrarySubjectCodeableconcept(v) -> codeableconcept_to_json(v)
    LibrarySubjectReference(v) -> reference_to_json(v)
  }
}

pub fn library_subject_decoder() -> Decoder(LibrarySubject) {
  decode.one_of(
    decode.field(
      "subjectCodeableConcept",
      codeableconcept_decoder(),
      decode.success,
    )
      |> decode.map(LibrarySubjectCodeableconcept),
    [
      decode.field("subjectReference", reference_decoder(), decode.success)
      |> decode.map(LibrarySubjectReference),
    ],
  )
}

pub fn library_new(
  type_ type_: Codeableconcept,
  status status: r4bvaluesets.Publicationstatus,
) -> Library {
  Library(
    content: [],
    data_requirement: [],
    parameter: [],
    related_artifact: [],
    endorser: [],
    reviewer: [],
    editor: [],
    author: [],
    topic: [],
    effective_period: None,
    last_review_date: None,
    approval_date: None,
    copyright: None,
    usage: None,
    purpose: None,
    jurisdiction: [],
    use_context: [],
    description: None,
    contact: [],
    publisher: None,
    date: None,
    subject: None,
    type_:,
    experimental: None,
    status:,
    subtitle: None,
    title: None,
    name: None,
    version: None,
    identifier: [],
    url: None,
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

pub fn library_to_json(library: Library) -> Json {
  let Library(
    content:,
    data_requirement:,
    parameter:,
    related_artifact:,
    endorser:,
    reviewer:,
    editor:,
    author:,
    topic:,
    effective_period:,
    last_review_date:,
    approval_date:,
    copyright:,
    usage:,
    purpose:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    subject:,
    type_:,
    experimental:,
    status:,
    subtitle:,
    title:,
    name:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = library
  let fields = [
    #("type", codeableconcept_to_json(type_)),
    #("status", r4bvaluesets.publicationstatus_to_json(status)),
  ]
  let fields = case content {
    [] -> fields
    _ -> [#("content", json.array(content, attachment_to_json)), ..fields]
  }
  let fields = case data_requirement {
    [] -> fields
    _ -> [
      #(
        "dataRequirement",
        json.array(data_requirement, datarequirement_to_json),
      ),
      ..fields
    ]
  }
  let fields = case parameter {
    [] -> fields
    _ -> [
      #("parameter", json.array(parameter, parameterdefinition_to_json)),
      ..fields
    ]
  }
  let fields = case related_artifact {
    [] -> fields
    _ -> [
      #(
        "relatedArtifact",
        json.array(related_artifact, relatedartifact_to_json),
      ),
      ..fields
    ]
  }
  let fields = case endorser {
    [] -> fields
    _ -> [#("endorser", json.array(endorser, contactdetail_to_json)), ..fields]
  }
  let fields = case reviewer {
    [] -> fields
    _ -> [#("reviewer", json.array(reviewer, contactdetail_to_json)), ..fields]
  }
  let fields = case editor {
    [] -> fields
    _ -> [#("editor", json.array(editor, contactdetail_to_json)), ..fields]
  }
  let fields = case author {
    [] -> fields
    _ -> [#("author", json.array(author, contactdetail_to_json)), ..fields]
  }
  let fields = case topic {
    [] -> fields
    _ -> [#("topic", json.array(topic, codeableconcept_to_json)), ..fields]
  }
  let fields = case effective_period {
    Some(v) -> [#("effectivePeriod", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case last_review_date {
    Some(v) -> [#("lastReviewDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case approval_date {
    Some(v) -> [#("approvalDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case copyright {
    Some(v) -> [#("copyright", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case usage {
    Some(v) -> [#("usage", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case purpose {
    Some(v) -> [#("purpose", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case jurisdiction {
    [] -> fields
    _ -> [
      #("jurisdiction", json.array(jurisdiction, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case use_context {
    [] -> fields
    _ -> [
      #("useContext", json.array(use_context, usagecontext_to_json)),
      ..fields
    ]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case contact {
    [] -> fields
    _ -> [#("contact", json.array(contact, contactdetail_to_json)), ..fields]
  }
  let fields = case publisher {
    Some(v) -> [#("publisher", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case date {
    Some(v) -> [#("date", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case subject {
    Some(v) -> [
      #(
        "subject"
          <> case v {
          LibrarySubjectCodeableconcept(_) -> "Codeableconcept"
          LibrarySubjectReference(_) -> "Reference"
        },
        library_subject_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case experimental {
    Some(v) -> [#("experimental", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case subtitle {
    Some(v) -> [#("subtitle", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case title {
    Some(v) -> [#("title", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case version {
    Some(v) -> [#("version", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case url {
    Some(v) -> [#("url", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Library")), ..fields]
  json.object(fields)
}

pub fn library_decoder() -> Decoder(Library) {
  use content <- decode.optional_field(
    "content",
    [],
    decode.list(attachment_decoder()),
  )
  use data_requirement <- decode.optional_field(
    "dataRequirement",
    [],
    decode.list(datarequirement_decoder()),
  )
  use parameter <- decode.optional_field(
    "parameter",
    [],
    decode.list(parameterdefinition_decoder()),
  )
  use related_artifact <- decode.optional_field(
    "relatedArtifact",
    [],
    decode.list(relatedartifact_decoder()),
  )
  use endorser <- decode.optional_field(
    "endorser",
    [],
    decode.list(contactdetail_decoder()),
  )
  use reviewer <- decode.optional_field(
    "reviewer",
    [],
    decode.list(contactdetail_decoder()),
  )
  use editor <- decode.optional_field(
    "editor",
    [],
    decode.list(contactdetail_decoder()),
  )
  use author <- decode.optional_field(
    "author",
    [],
    decode.list(contactdetail_decoder()),
  )
  use topic <- decode.optional_field(
    "topic",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use effective_period <- decode.optional_field(
    "effectivePeriod",
    None,
    decode.optional(period_decoder()),
  )
  use last_review_date <- decode.optional_field(
    "lastReviewDate",
    None,
    decode.optional(decode.string),
  )
  use approval_date <- decode.optional_field(
    "approvalDate",
    None,
    decode.optional(decode.string),
  )
  use copyright <- decode.optional_field(
    "copyright",
    None,
    decode.optional(decode.string),
  )
  use usage <- decode.optional_field(
    "usage",
    None,
    decode.optional(decode.string),
  )
  use purpose <- decode.optional_field(
    "purpose",
    None,
    decode.optional(decode.string),
  )
  use jurisdiction <- decode.optional_field(
    "jurisdiction",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use use_context <- decode.optional_field(
    "useContext",
    [],
    decode.list(usagecontext_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use contact <- decode.optional_field(
    "contact",
    [],
    decode.list(contactdetail_decoder()),
  )
  use publisher <- decode.optional_field(
    "publisher",
    None,
    decode.optional(decode.string),
  )
  use date <- decode.optional_field(
    "date",
    None,
    decode.optional(decode.string),
  )
  use subject <- decode.then(none_if_omitted(library_subject_decoder()))
  use type_ <- decode.field("type", codeableconcept_decoder())
  use experimental <- decode.optional_field(
    "experimental",
    None,
    decode.optional(decode.bool),
  )
  use status <- decode.field("status", r4bvaluesets.publicationstatus_decoder())
  use subtitle <- decode.optional_field(
    "subtitle",
    None,
    decode.optional(decode.string),
  )
  use title <- decode.optional_field(
    "title",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use version <- decode.optional_field(
    "version",
    None,
    decode.optional(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use url <- decode.optional_field("url", None, decode.optional(decode.string))
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Library",
    decode.failure(library_new(type_:, status:), "resourceType"),
  )
  decode.success(Library(
    content:,
    data_requirement:,
    parameter:,
    related_artifact:,
    endorser:,
    reviewer:,
    editor:,
    author:,
    topic:,
    effective_period:,
    last_review_date:,
    approval_date:,
    copyright:,
    usage:,
    purpose:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    subject:,
    type_:,
    experimental:,
    status:,
    subtitle:,
    title:,
    name:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/Linkage#resource
pub type Linkage {
  Linkage(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    active: Option(Bool),
    author: Option(Reference),
    item: List(LinkageItem),
  )
}

pub fn linkage_new() -> Linkage {
  Linkage(
    item: [],
    author: None,
    active: None,
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Linkage#resource
pub type LinkageItem {
  LinkageItem(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: r4bvaluesets.Linkagetype,
    resource: Reference,
  )
}

pub fn linkage_item_new(
  resource resource: Reference,
  type_ type_: r4bvaluesets.Linkagetype,
) -> LinkageItem {
  LinkageItem(
    resource:,
    type_:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn linkage_item_to_json(linkage_item: LinkageItem) -> Json {
  let LinkageItem(resource:, type_:, modifier_extension:, extension:, id:) =
    linkage_item
  let fields = [
    #("resource", reference_to_json(resource)),
    #("type", r4bvaluesets.linkagetype_to_json(type_)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn linkage_item_decoder() -> Decoder(LinkageItem) {
  use resource <- decode.field("resource", reference_decoder())
  use type_ <- decode.field("type", r4bvaluesets.linkagetype_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(LinkageItem(
    resource:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn linkage_to_json(linkage: Linkage) -> Json {
  let Linkage(
    item:,
    author:,
    active:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = linkage
  let fields = []
  let fields = case item {
    [] -> fields
    _ -> [#("item", json.array(item, linkage_item_to_json)), ..fields]
  }
  let fields = case author {
    Some(v) -> [#("author", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case active {
    Some(v) -> [#("active", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Linkage")), ..fields]
  json.object(fields)
}

pub fn linkage_decoder() -> Decoder(Linkage) {
  use item <- decode.optional_field(
    "item",
    [],
    decode.list(linkage_item_decoder()),
  )
  use author <- decode.optional_field(
    "author",
    None,
    decode.optional(reference_decoder()),
  )
  use active <- decode.optional_field(
    "active",
    None,
    decode.optional(decode.bool),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Linkage",
    decode.failure(linkage_new(), "resourceType"),
  )
  decode.success(Linkage(
    item:,
    author:,
    active:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/List#resource
pub type Listfhir {
  Listfhir(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    status: r4bvaluesets.Liststatus,
    mode: r4bvaluesets.Listmode,
    title: Option(String),
    code: Option(Codeableconcept),
    subject: Option(Reference),
    encounter: Option(Reference),
    date: Option(String),
    source: Option(Reference),
    ordered_by: Option(Codeableconcept),
    note: List(Annotation),
    entry: List(ListEntry),
    empty_reason: Option(Codeableconcept),
  )
}

pub fn listfhir_new(
  mode mode: r4bvaluesets.Listmode,
  status status: r4bvaluesets.Liststatus,
) -> Listfhir {
  Listfhir(
    empty_reason: None,
    entry: [],
    note: [],
    ordered_by: None,
    source: None,
    date: None,
    encounter: None,
    subject: None,
    code: None,
    title: None,
    mode:,
    status:,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/List#resource
pub type ListEntry {
  ListEntry(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    flag: Option(Codeableconcept),
    deleted: Option(Bool),
    date: Option(String),
    item: Reference,
  )
}

pub fn list_entry_new(item item: Reference) -> ListEntry {
  ListEntry(
    item:,
    date: None,
    deleted: None,
    flag: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn list_entry_to_json(list_entry: ListEntry) -> Json {
  let ListEntry(
    item:,
    date:,
    deleted:,
    flag:,
    modifier_extension:,
    extension:,
    id:,
  ) = list_entry
  let fields = [
    #("item", reference_to_json(item)),
  ]
  let fields = case date {
    Some(v) -> [#("date", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case deleted {
    Some(v) -> [#("deleted", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case flag {
    Some(v) -> [#("flag", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn list_entry_decoder() -> Decoder(ListEntry) {
  use item <- decode.field("item", reference_decoder())
  use date <- decode.optional_field(
    "date",
    None,
    decode.optional(decode.string),
  )
  use deleted <- decode.optional_field(
    "deleted",
    None,
    decode.optional(decode.bool),
  )
  use flag <- decode.optional_field(
    "flag",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ListEntry(
    item:,
    date:,
    deleted:,
    flag:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn listfhir_to_json(listfhir: Listfhir) -> Json {
  let Listfhir(
    empty_reason:,
    entry:,
    note:,
    ordered_by:,
    source:,
    date:,
    encounter:,
    subject:,
    code:,
    title:,
    mode:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = listfhir
  let fields = [
    #("mode", r4bvaluesets.listmode_to_json(mode)),
    #("status", r4bvaluesets.liststatus_to_json(status)),
  ]
  let fields = case empty_reason {
    Some(v) -> [#("emptyReason", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case entry {
    [] -> fields
    _ -> [#("entry", json.array(entry, list_entry_to_json)), ..fields]
  }
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case ordered_by {
    Some(v) -> [#("orderedBy", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case source {
    Some(v) -> [#("source", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case date {
    Some(v) -> [#("date", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case encounter {
    Some(v) -> [#("encounter", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case subject {
    Some(v) -> [#("subject", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case code {
    Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case title {
    Some(v) -> [#("title", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Listfhir")), ..fields]
  json.object(fields)
}

pub fn listfhir_decoder() -> Decoder(Listfhir) {
  use empty_reason <- decode.optional_field(
    "emptyReason",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use entry <- decode.optional_field(
    "entry",
    [],
    decode.list(list_entry_decoder()),
  )
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use ordered_by <- decode.optional_field(
    "orderedBy",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use source <- decode.optional_field(
    "source",
    None,
    decode.optional(reference_decoder()),
  )
  use date <- decode.optional_field(
    "date",
    None,
    decode.optional(decode.string),
  )
  use encounter <- decode.optional_field(
    "encounter",
    None,
    decode.optional(reference_decoder()),
  )
  use subject <- decode.optional_field(
    "subject",
    None,
    decode.optional(reference_decoder()),
  )
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use title <- decode.optional_field(
    "title",
    None,
    decode.optional(decode.string),
  )
  use mode <- decode.field("mode", r4bvaluesets.listmode_decoder())
  use status <- decode.field("status", r4bvaluesets.liststatus_decoder())
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Listfhir",
    decode.failure(listfhir_new(mode:, status:), "resourceType"),
  )
  decode.success(Listfhir(
    empty_reason:,
    entry:,
    note:,
    ordered_by:,
    source:,
    date:,
    encounter:,
    subject:,
    code:,
    title:,
    mode:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/Location#resource
pub type Location {
  Location(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    status: Option(r4bvaluesets.Locationstatus),
    operational_status: Option(Coding),
    name: Option(String),
    alias: List(String),
    description: Option(String),
    mode: Option(r4bvaluesets.Locationmode),
    type_: List(Codeableconcept),
    telecom: List(Contactpoint),
    address: Option(Address),
    physical_type: Option(Codeableconcept),
    position: Option(LocationPosition),
    managing_organization: Option(Reference),
    part_of: Option(Reference),
    hours_of_operation: List(LocationHoursofoperation),
    availability_exceptions: Option(String),
    endpoint: List(Reference),
  )
}

pub fn location_new() -> Location {
  Location(
    endpoint: [],
    availability_exceptions: None,
    hours_of_operation: [],
    part_of: None,
    managing_organization: None,
    position: None,
    physical_type: None,
    address: None,
    telecom: [],
    type_: [],
    mode: None,
    description: None,
    alias: [],
    name: None,
    operational_status: None,
    status: None,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Location#resource
pub type LocationPosition {
  LocationPosition(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    longitude: Float,
    latitude: Float,
    altitude: Option(Float),
  )
}

pub fn location_position_new(
  latitude latitude: Float,
  longitude longitude: Float,
) -> LocationPosition {
  LocationPosition(
    altitude: None,
    latitude:,
    longitude:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Location#resource
pub type LocationHoursofoperation {
  LocationHoursofoperation(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    days_of_week: List(r4bvaluesets.Daysofweek),
    all_day: Option(Bool),
    opening_time: Option(String),
    closing_time: Option(String),
  )
}

pub fn location_hoursofoperation_new() -> LocationHoursofoperation {
  LocationHoursofoperation(
    closing_time: None,
    opening_time: None,
    all_day: None,
    days_of_week: [],
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn location_hoursofoperation_to_json(
  location_hoursofoperation: LocationHoursofoperation,
) -> Json {
  let LocationHoursofoperation(
    closing_time:,
    opening_time:,
    all_day:,
    days_of_week:,
    modifier_extension:,
    extension:,
    id:,
  ) = location_hoursofoperation
  let fields = []
  let fields = case closing_time {
    Some(v) -> [#("closingTime", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case opening_time {
    Some(v) -> [#("openingTime", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case all_day {
    Some(v) -> [#("allDay", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case days_of_week {
    [] -> fields
    _ -> [
      #("daysOfWeek", json.array(days_of_week, r4bvaluesets.daysofweek_to_json)),
      ..fields
    ]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn location_hoursofoperation_decoder() -> Decoder(LocationHoursofoperation) {
  use closing_time <- decode.optional_field(
    "closingTime",
    None,
    decode.optional(decode.string),
  )
  use opening_time <- decode.optional_field(
    "openingTime",
    None,
    decode.optional(decode.string),
  )
  use all_day <- decode.optional_field(
    "allDay",
    None,
    decode.optional(decode.bool),
  )
  use days_of_week <- decode.optional_field(
    "daysOfWeek",
    [],
    decode.list(r4bvaluesets.daysofweek_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(LocationHoursofoperation(
    closing_time:,
    opening_time:,
    all_day:,
    days_of_week:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn location_position_to_json(location_position: LocationPosition) -> Json {
  let LocationPosition(
    altitude:,
    latitude:,
    longitude:,
    modifier_extension:,
    extension:,
    id:,
  ) = location_position
  let fields = [
    #("latitude", json.float(latitude)),
    #("longitude", json.float(longitude)),
  ]
  let fields = case altitude {
    Some(v) -> [#("altitude", json.float(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn location_position_decoder() -> Decoder(LocationPosition) {
  use altitude <- decode.optional_field(
    "altitude",
    None,
    decode.optional(decode.float),
  )
  use latitude <- decode.field("latitude", decode.float)
  use longitude <- decode.field("longitude", decode.float)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(LocationPosition(
    altitude:,
    latitude:,
    longitude:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn location_to_json(location: Location) -> Json {
  let Location(
    endpoint:,
    availability_exceptions:,
    hours_of_operation:,
    part_of:,
    managing_organization:,
    position:,
    physical_type:,
    address:,
    telecom:,
    type_:,
    mode:,
    description:,
    alias:,
    name:,
    operational_status:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = location
  let fields = []
  let fields = case endpoint {
    [] -> fields
    _ -> [#("endpoint", json.array(endpoint, reference_to_json)), ..fields]
  }
  let fields = case availability_exceptions {
    Some(v) -> [#("availabilityExceptions", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case hours_of_operation {
    [] -> fields
    _ -> [
      #(
        "hoursOfOperation",
        json.array(hours_of_operation, location_hoursofoperation_to_json),
      ),
      ..fields
    ]
  }
  let fields = case part_of {
    Some(v) -> [#("partOf", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case managing_organization {
    Some(v) -> [#("managingOrganization", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case position {
    Some(v) -> [#("position", location_position_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case physical_type {
    Some(v) -> [#("physicalType", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case address {
    Some(v) -> [#("address", address_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case telecom {
    [] -> fields
    _ -> [#("telecom", json.array(telecom, contactpoint_to_json)), ..fields]
  }
  let fields = case type_ {
    [] -> fields
    _ -> [#("type", json.array(type_, codeableconcept_to_json)), ..fields]
  }
  let fields = case mode {
    Some(v) -> [#("mode", r4bvaluesets.locationmode_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case alias {
    [] -> fields
    _ -> [#("alias", json.array(alias, json.string)), ..fields]
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case operational_status {
    Some(v) -> [#("operationalStatus", coding_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case status {
    Some(v) -> [#("status", r4bvaluesets.locationstatus_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Location")), ..fields]
  json.object(fields)
}

pub fn location_decoder() -> Decoder(Location) {
  use endpoint <- decode.optional_field(
    "endpoint",
    [],
    decode.list(reference_decoder()),
  )
  use availability_exceptions <- decode.optional_field(
    "availabilityExceptions",
    None,
    decode.optional(decode.string),
  )
  use hours_of_operation <- decode.optional_field(
    "hoursOfOperation",
    [],
    decode.list(location_hoursofoperation_decoder()),
  )
  use part_of <- decode.optional_field(
    "partOf",
    None,
    decode.optional(reference_decoder()),
  )
  use managing_organization <- decode.optional_field(
    "managingOrganization",
    None,
    decode.optional(reference_decoder()),
  )
  use position <- decode.optional_field(
    "position",
    None,
    decode.optional(location_position_decoder()),
  )
  use physical_type <- decode.optional_field(
    "physicalType",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use address <- decode.optional_field(
    "address",
    None,
    decode.optional(address_decoder()),
  )
  use telecom <- decode.optional_field(
    "telecom",
    [],
    decode.list(contactpoint_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use mode <- decode.optional_field(
    "mode",
    None,
    decode.optional(r4bvaluesets.locationmode_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use alias <- decode.optional_field("alias", [], decode.list(decode.string))
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use operational_status <- decode.optional_field(
    "operationalStatus",
    None,
    decode.optional(coding_decoder()),
  )
  use status <- decode.optional_field(
    "status",
    None,
    decode.optional(r4bvaluesets.locationstatus_decoder()),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Location",
    decode.failure(location_new(), "resourceType"),
  )
  decode.success(Location(
    endpoint:,
    availability_exceptions:,
    hours_of_operation:,
    part_of:,
    managing_organization:,
    position:,
    physical_type:,
    address:,
    telecom:,
    type_:,
    mode:,
    description:,
    alias:,
    name:,
    operational_status:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/ManufacturedItemDefinition#resource
pub type Manufactureditemdefinition {
  Manufactureditemdefinition(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    status: r4bvaluesets.Publicationstatus,
    manufactured_dose_form: Codeableconcept,
    unit_of_presentation: Option(Codeableconcept),
    manufacturer: List(Reference),
    ingredient: List(Codeableconcept),
    property: List(ManufactureditemdefinitionProperty),
  )
}

pub fn manufactureditemdefinition_new(
  manufactured_dose_form manufactured_dose_form: Codeableconcept,
  status status: r4bvaluesets.Publicationstatus,
) -> Manufactureditemdefinition {
  Manufactureditemdefinition(
    property: [],
    ingredient: [],
    manufacturer: [],
    unit_of_presentation: None,
    manufactured_dose_form:,
    status:,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ManufacturedItemDefinition#resource
pub type ManufactureditemdefinitionProperty {
  ManufactureditemdefinitionProperty(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Codeableconcept,
    value: Option(ManufactureditemdefinitionPropertyValue),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ManufacturedItemDefinition#resource
pub type ManufactureditemdefinitionPropertyValue {
  ManufactureditemdefinitionPropertyValueCodeableconcept(value: Codeableconcept)
  ManufactureditemdefinitionPropertyValueQuantity(value: Quantity)
  ManufactureditemdefinitionPropertyValueDate(value: String)
  ManufactureditemdefinitionPropertyValueBoolean(value: Bool)
  ManufactureditemdefinitionPropertyValueAttachment(value: Attachment)
}

pub fn manufactureditemdefinition_property_value_to_json(
  elt: ManufactureditemdefinitionPropertyValue,
) -> Json {
  case elt {
    ManufactureditemdefinitionPropertyValueCodeableconcept(v) ->
      codeableconcept_to_json(v)
    ManufactureditemdefinitionPropertyValueQuantity(v) -> quantity_to_json(v)
    ManufactureditemdefinitionPropertyValueDate(v) -> json.string(v)
    ManufactureditemdefinitionPropertyValueBoolean(v) -> json.bool(v)
    ManufactureditemdefinitionPropertyValueAttachment(v) ->
      attachment_to_json(v)
  }
}

pub fn manufactureditemdefinition_property_value_decoder() -> Decoder(
  ManufactureditemdefinitionPropertyValue,
) {
  decode.one_of(
    decode.field(
      "valueCodeableConcept",
      codeableconcept_decoder(),
      decode.success,
    )
      |> decode.map(ManufactureditemdefinitionPropertyValueCodeableconcept),
    [
      decode.field("valueQuantity", quantity_decoder(), decode.success)
        |> decode.map(ManufactureditemdefinitionPropertyValueQuantity),
      decode.field("valueDate", decode.string, decode.success)
        |> decode.map(ManufactureditemdefinitionPropertyValueDate),
      decode.field("valueBoolean", decode.bool, decode.success)
        |> decode.map(ManufactureditemdefinitionPropertyValueBoolean),
      decode.field("valueAttachment", attachment_decoder(), decode.success)
        |> decode.map(ManufactureditemdefinitionPropertyValueAttachment),
    ],
  )
}

pub fn manufactureditemdefinition_property_new(
  type_ type_: Codeableconcept,
) -> ManufactureditemdefinitionProperty {
  ManufactureditemdefinitionProperty(
    value: None,
    type_:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn manufactureditemdefinition_property_to_json(
  manufactureditemdefinition_property: ManufactureditemdefinitionProperty,
) -> Json {
  let ManufactureditemdefinitionProperty(
    value:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = manufactureditemdefinition_property
  let fields = [
    #("type", codeableconcept_to_json(type_)),
  ]
  let fields = case value {
    Some(v) -> [
      #(
        "value"
          <> case v {
          ManufactureditemdefinitionPropertyValueCodeableconcept(_) ->
            "Codeableconcept"
          ManufactureditemdefinitionPropertyValueQuantity(_) -> "Quantity"
          ManufactureditemdefinitionPropertyValueDate(_) -> "Date"
          ManufactureditemdefinitionPropertyValueBoolean(_) -> "Boolean"
          ManufactureditemdefinitionPropertyValueAttachment(_) -> "Attachment"
        },
        manufactureditemdefinition_property_value_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn manufactureditemdefinition_property_decoder() -> Decoder(
  ManufactureditemdefinitionProperty,
) {
  use value <- decode.then(
    none_if_omitted(manufactureditemdefinition_property_value_decoder()),
  )
  use type_ <- decode.field("type", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ManufactureditemdefinitionProperty(
    value:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn manufactureditemdefinition_to_json(
  manufactureditemdefinition: Manufactureditemdefinition,
) -> Json {
  let Manufactureditemdefinition(
    property:,
    ingredient:,
    manufacturer:,
    unit_of_presentation:,
    manufactured_dose_form:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = manufactureditemdefinition
  let fields = [
    #("manufacturedDoseForm", codeableconcept_to_json(manufactured_dose_form)),
    #("status", r4bvaluesets.publicationstatus_to_json(status)),
  ]
  let fields = case property {
    [] -> fields
    _ -> [
      #(
        "property",
        json.array(property, manufactureditemdefinition_property_to_json),
      ),
      ..fields
    ]
  }
  let fields = case ingredient {
    [] -> fields
    _ -> [
      #("ingredient", json.array(ingredient, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case manufacturer {
    [] -> fields
    _ -> [
      #("manufacturer", json.array(manufacturer, reference_to_json)),
      ..fields
    ]
  }
  let fields = case unit_of_presentation {
    Some(v) -> [#("unitOfPresentation", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [
    #("resourceType", json.string("Manufactureditemdefinition")),
    ..fields
  ]
  json.object(fields)
}

pub fn manufactureditemdefinition_decoder() -> Decoder(
  Manufactureditemdefinition,
) {
  use property <- decode.optional_field(
    "property",
    [],
    decode.list(manufactureditemdefinition_property_decoder()),
  )
  use ingredient <- decode.optional_field(
    "ingredient",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use manufacturer <- decode.optional_field(
    "manufacturer",
    [],
    decode.list(reference_decoder()),
  )
  use unit_of_presentation <- decode.optional_field(
    "unitOfPresentation",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use manufactured_dose_form <- decode.field(
    "manufacturedDoseForm",
    codeableconcept_decoder(),
  )
  use status <- decode.field("status", r4bvaluesets.publicationstatus_decoder())
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Manufactureditemdefinition",
    decode.failure(
      manufactureditemdefinition_new(manufactured_dose_form:, status:),
      "resourceType",
    ),
  )
  decode.success(Manufactureditemdefinition(
    property:,
    ingredient:,
    manufacturer:,
    unit_of_presentation:,
    manufactured_dose_form:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/Measure#resource
pub type Measure {
  Measure(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    url: Option(String),
    identifier: List(Identifier),
    version: Option(String),
    name: Option(String),
    title: Option(String),
    subtitle: Option(String),
    status: r4bvaluesets.Publicationstatus,
    experimental: Option(Bool),
    subject: Option(MeasureSubject),
    date: Option(String),
    publisher: Option(String),
    contact: List(Contactdetail),
    description: Option(String),
    use_context: List(Usagecontext),
    jurisdiction: List(Codeableconcept),
    purpose: Option(String),
    usage: Option(String),
    copyright: Option(String),
    approval_date: Option(String),
    last_review_date: Option(String),
    effective_period: Option(Period),
    topic: List(Codeableconcept),
    author: List(Contactdetail),
    editor: List(Contactdetail),
    reviewer: List(Contactdetail),
    endorser: List(Contactdetail),
    related_artifact: List(Relatedartifact),
    library: List(String),
    disclaimer: Option(String),
    scoring: Option(Codeableconcept),
    composite_scoring: Option(Codeableconcept),
    type_: List(Codeableconcept),
    risk_adjustment: Option(String),
    rate_aggregation: Option(String),
    rationale: Option(String),
    clinical_recommendation_statement: Option(String),
    improvement_notation: Option(Codeableconcept),
    definition: List(String),
    guidance: Option(String),
    group: List(MeasureGroup),
    supplemental_data: List(MeasureSupplementaldata),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Measure#resource
pub type MeasureSubject {
  MeasureSubjectCodeableconcept(subject: Codeableconcept)
  MeasureSubjectReference(subject: Reference)
}

pub fn measure_subject_to_json(elt: MeasureSubject) -> Json {
  case elt {
    MeasureSubjectCodeableconcept(v) -> codeableconcept_to_json(v)
    MeasureSubjectReference(v) -> reference_to_json(v)
  }
}

pub fn measure_subject_decoder() -> Decoder(MeasureSubject) {
  decode.one_of(
    decode.field(
      "subjectCodeableConcept",
      codeableconcept_decoder(),
      decode.success,
    )
      |> decode.map(MeasureSubjectCodeableconcept),
    [
      decode.field("subjectReference", reference_decoder(), decode.success)
      |> decode.map(MeasureSubjectReference),
    ],
  )
}

pub fn measure_new(status status: r4bvaluesets.Publicationstatus) -> Measure {
  Measure(
    supplemental_data: [],
    group: [],
    guidance: None,
    definition: [],
    improvement_notation: None,
    clinical_recommendation_statement: None,
    rationale: None,
    rate_aggregation: None,
    risk_adjustment: None,
    type_: [],
    composite_scoring: None,
    scoring: None,
    disclaimer: None,
    library: [],
    related_artifact: [],
    endorser: [],
    reviewer: [],
    editor: [],
    author: [],
    topic: [],
    effective_period: None,
    last_review_date: None,
    approval_date: None,
    copyright: None,
    usage: None,
    purpose: None,
    jurisdiction: [],
    use_context: [],
    description: None,
    contact: [],
    publisher: None,
    date: None,
    subject: None,
    experimental: None,
    status:,
    subtitle: None,
    title: None,
    name: None,
    version: None,
    identifier: [],
    url: None,
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Measure#resource
pub type MeasureGroup {
  MeasureGroup(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    code: Option(Codeableconcept),
    description: Option(String),
    population: List(MeasureGroupPopulation),
    stratifier: List(MeasureGroupStratifier),
  )
}

pub fn measure_group_new() -> MeasureGroup {
  MeasureGroup(
    stratifier: [],
    population: [],
    description: None,
    code: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Measure#resource
pub type MeasureGroupPopulation {
  MeasureGroupPopulation(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    code: Option(Codeableconcept),
    description: Option(String),
    criteria: Expression,
  )
}

pub fn measure_group_population_new(
  criteria criteria: Expression,
) -> MeasureGroupPopulation {
  MeasureGroupPopulation(
    criteria:,
    description: None,
    code: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Measure#resource
pub type MeasureGroupStratifier {
  MeasureGroupStratifier(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    code: Option(Codeableconcept),
    description: Option(String),
    criteria: Option(Expression),
    component: List(MeasureGroupStratifierComponent),
  )
}

pub fn measure_group_stratifier_new() -> MeasureGroupStratifier {
  MeasureGroupStratifier(
    component: [],
    criteria: None,
    description: None,
    code: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Measure#resource
pub type MeasureGroupStratifierComponent {
  MeasureGroupStratifierComponent(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    code: Option(Codeableconcept),
    description: Option(String),
    criteria: Expression,
  )
}

pub fn measure_group_stratifier_component_new(
  criteria criteria: Expression,
) -> MeasureGroupStratifierComponent {
  MeasureGroupStratifierComponent(
    criteria:,
    description: None,
    code: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Measure#resource
pub type MeasureSupplementaldata {
  MeasureSupplementaldata(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    code: Option(Codeableconcept),
    usage: List(Codeableconcept),
    description: Option(String),
    criteria: Expression,
  )
}

pub fn measure_supplementaldata_new(
  criteria criteria: Expression,
) -> MeasureSupplementaldata {
  MeasureSupplementaldata(
    criteria:,
    description: None,
    usage: [],
    code: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn measure_supplementaldata_to_json(
  measure_supplementaldata: MeasureSupplementaldata,
) -> Json {
  let MeasureSupplementaldata(
    criteria:,
    description:,
    usage:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ) = measure_supplementaldata
  let fields = [
    #("criteria", expression_to_json(criteria)),
  ]
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case usage {
    [] -> fields
    _ -> [#("usage", json.array(usage, codeableconcept_to_json)), ..fields]
  }
  let fields = case code {
    Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn measure_supplementaldata_decoder() -> Decoder(MeasureSupplementaldata) {
  use criteria <- decode.field("criteria", expression_decoder())
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use usage <- decode.optional_field(
    "usage",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MeasureSupplementaldata(
    criteria:,
    description:,
    usage:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn measure_group_stratifier_component_to_json(
  measure_group_stratifier_component: MeasureGroupStratifierComponent,
) -> Json {
  let MeasureGroupStratifierComponent(
    criteria:,
    description:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ) = measure_group_stratifier_component
  let fields = [
    #("criteria", expression_to_json(criteria)),
  ]
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case code {
    Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn measure_group_stratifier_component_decoder() -> Decoder(
  MeasureGroupStratifierComponent,
) {
  use criteria <- decode.field("criteria", expression_decoder())
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MeasureGroupStratifierComponent(
    criteria:,
    description:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn measure_group_stratifier_to_json(
  measure_group_stratifier: MeasureGroupStratifier,
) -> Json {
  let MeasureGroupStratifier(
    component:,
    criteria:,
    description:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ) = measure_group_stratifier
  let fields = []
  let fields = case component {
    [] -> fields
    _ -> [
      #(
        "component",
        json.array(component, measure_group_stratifier_component_to_json),
      ),
      ..fields
    ]
  }
  let fields = case criteria {
    Some(v) -> [#("criteria", expression_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case code {
    Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn measure_group_stratifier_decoder() -> Decoder(MeasureGroupStratifier) {
  use component <- decode.optional_field(
    "component",
    [],
    decode.list(measure_group_stratifier_component_decoder()),
  )
  use criteria <- decode.optional_field(
    "criteria",
    None,
    decode.optional(expression_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MeasureGroupStratifier(
    component:,
    criteria:,
    description:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn measure_group_population_to_json(
  measure_group_population: MeasureGroupPopulation,
) -> Json {
  let MeasureGroupPopulation(
    criteria:,
    description:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ) = measure_group_population
  let fields = [
    #("criteria", expression_to_json(criteria)),
  ]
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case code {
    Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn measure_group_population_decoder() -> Decoder(MeasureGroupPopulation) {
  use criteria <- decode.field("criteria", expression_decoder())
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MeasureGroupPopulation(
    criteria:,
    description:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn measure_group_to_json(measure_group: MeasureGroup) -> Json {
  let MeasureGroup(
    stratifier:,
    population:,
    description:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ) = measure_group
  let fields = []
  let fields = case stratifier {
    [] -> fields
    _ -> [
      #("stratifier", json.array(stratifier, measure_group_stratifier_to_json)),
      ..fields
    ]
  }
  let fields = case population {
    [] -> fields
    _ -> [
      #("population", json.array(population, measure_group_population_to_json)),
      ..fields
    ]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case code {
    Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn measure_group_decoder() -> Decoder(MeasureGroup) {
  use stratifier <- decode.optional_field(
    "stratifier",
    [],
    decode.list(measure_group_stratifier_decoder()),
  )
  use population <- decode.optional_field(
    "population",
    [],
    decode.list(measure_group_population_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MeasureGroup(
    stratifier:,
    population:,
    description:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn measure_to_json(measure: Measure) -> Json {
  let Measure(
    supplemental_data:,
    group:,
    guidance:,
    definition:,
    improvement_notation:,
    clinical_recommendation_statement:,
    rationale:,
    rate_aggregation:,
    risk_adjustment:,
    type_:,
    composite_scoring:,
    scoring:,
    disclaimer:,
    library:,
    related_artifact:,
    endorser:,
    reviewer:,
    editor:,
    author:,
    topic:,
    effective_period:,
    last_review_date:,
    approval_date:,
    copyright:,
    usage:,
    purpose:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    subject:,
    experimental:,
    status:,
    subtitle:,
    title:,
    name:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = measure
  let fields = [
    #("status", r4bvaluesets.publicationstatus_to_json(status)),
  ]
  let fields = case supplemental_data {
    [] -> fields
    _ -> [
      #(
        "supplementalData",
        json.array(supplemental_data, measure_supplementaldata_to_json),
      ),
      ..fields
    ]
  }
  let fields = case group {
    [] -> fields
    _ -> [#("group", json.array(group, measure_group_to_json)), ..fields]
  }
  let fields = case guidance {
    Some(v) -> [#("guidance", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case definition {
    [] -> fields
    _ -> [#("definition", json.array(definition, json.string)), ..fields]
  }
  let fields = case improvement_notation {
    Some(v) -> [#("improvementNotation", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case clinical_recommendation_statement {
    Some(v) -> [#("clinicalRecommendationStatement", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case rationale {
    Some(v) -> [#("rationale", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case rate_aggregation {
    Some(v) -> [#("rateAggregation", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case risk_adjustment {
    Some(v) -> [#("riskAdjustment", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    [] -> fields
    _ -> [#("type", json.array(type_, codeableconcept_to_json)), ..fields]
  }
  let fields = case composite_scoring {
    Some(v) -> [#("compositeScoring", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case scoring {
    Some(v) -> [#("scoring", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case disclaimer {
    Some(v) -> [#("disclaimer", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case library {
    [] -> fields
    _ -> [#("library", json.array(library, json.string)), ..fields]
  }
  let fields = case related_artifact {
    [] -> fields
    _ -> [
      #(
        "relatedArtifact",
        json.array(related_artifact, relatedartifact_to_json),
      ),
      ..fields
    ]
  }
  let fields = case endorser {
    [] -> fields
    _ -> [#("endorser", json.array(endorser, contactdetail_to_json)), ..fields]
  }
  let fields = case reviewer {
    [] -> fields
    _ -> [#("reviewer", json.array(reviewer, contactdetail_to_json)), ..fields]
  }
  let fields = case editor {
    [] -> fields
    _ -> [#("editor", json.array(editor, contactdetail_to_json)), ..fields]
  }
  let fields = case author {
    [] -> fields
    _ -> [#("author", json.array(author, contactdetail_to_json)), ..fields]
  }
  let fields = case topic {
    [] -> fields
    _ -> [#("topic", json.array(topic, codeableconcept_to_json)), ..fields]
  }
  let fields = case effective_period {
    Some(v) -> [#("effectivePeriod", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case last_review_date {
    Some(v) -> [#("lastReviewDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case approval_date {
    Some(v) -> [#("approvalDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case copyright {
    Some(v) -> [#("copyright", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case usage {
    Some(v) -> [#("usage", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case purpose {
    Some(v) -> [#("purpose", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case jurisdiction {
    [] -> fields
    _ -> [
      #("jurisdiction", json.array(jurisdiction, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case use_context {
    [] -> fields
    _ -> [
      #("useContext", json.array(use_context, usagecontext_to_json)),
      ..fields
    ]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case contact {
    [] -> fields
    _ -> [#("contact", json.array(contact, contactdetail_to_json)), ..fields]
  }
  let fields = case publisher {
    Some(v) -> [#("publisher", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case date {
    Some(v) -> [#("date", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case subject {
    Some(v) -> [
      #(
        "subject"
          <> case v {
          MeasureSubjectCodeableconcept(_) -> "Codeableconcept"
          MeasureSubjectReference(_) -> "Reference"
        },
        measure_subject_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case experimental {
    Some(v) -> [#("experimental", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case subtitle {
    Some(v) -> [#("subtitle", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case title {
    Some(v) -> [#("title", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case version {
    Some(v) -> [#("version", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case url {
    Some(v) -> [#("url", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Measure")), ..fields]
  json.object(fields)
}

pub fn measure_decoder() -> Decoder(Measure) {
  use supplemental_data <- decode.optional_field(
    "supplementalData",
    [],
    decode.list(measure_supplementaldata_decoder()),
  )
  use group <- decode.optional_field(
    "group",
    [],
    decode.list(measure_group_decoder()),
  )
  use guidance <- decode.optional_field(
    "guidance",
    None,
    decode.optional(decode.string),
  )
  use definition <- decode.optional_field(
    "definition",
    [],
    decode.list(decode.string),
  )
  use improvement_notation <- decode.optional_field(
    "improvementNotation",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use clinical_recommendation_statement <- decode.optional_field(
    "clinicalRecommendationStatement",
    None,
    decode.optional(decode.string),
  )
  use rationale <- decode.optional_field(
    "rationale",
    None,
    decode.optional(decode.string),
  )
  use rate_aggregation <- decode.optional_field(
    "rateAggregation",
    None,
    decode.optional(decode.string),
  )
  use risk_adjustment <- decode.optional_field(
    "riskAdjustment",
    None,
    decode.optional(decode.string),
  )
  use type_ <- decode.optional_field(
    "type",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use composite_scoring <- decode.optional_field(
    "compositeScoring",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use scoring <- decode.optional_field(
    "scoring",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use disclaimer <- decode.optional_field(
    "disclaimer",
    None,
    decode.optional(decode.string),
  )
  use library <- decode.optional_field(
    "library",
    [],
    decode.list(decode.string),
  )
  use related_artifact <- decode.optional_field(
    "relatedArtifact",
    [],
    decode.list(relatedartifact_decoder()),
  )
  use endorser <- decode.optional_field(
    "endorser",
    [],
    decode.list(contactdetail_decoder()),
  )
  use reviewer <- decode.optional_field(
    "reviewer",
    [],
    decode.list(contactdetail_decoder()),
  )
  use editor <- decode.optional_field(
    "editor",
    [],
    decode.list(contactdetail_decoder()),
  )
  use author <- decode.optional_field(
    "author",
    [],
    decode.list(contactdetail_decoder()),
  )
  use topic <- decode.optional_field(
    "topic",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use effective_period <- decode.optional_field(
    "effectivePeriod",
    None,
    decode.optional(period_decoder()),
  )
  use last_review_date <- decode.optional_field(
    "lastReviewDate",
    None,
    decode.optional(decode.string),
  )
  use approval_date <- decode.optional_field(
    "approvalDate",
    None,
    decode.optional(decode.string),
  )
  use copyright <- decode.optional_field(
    "copyright",
    None,
    decode.optional(decode.string),
  )
  use usage <- decode.optional_field(
    "usage",
    None,
    decode.optional(decode.string),
  )
  use purpose <- decode.optional_field(
    "purpose",
    None,
    decode.optional(decode.string),
  )
  use jurisdiction <- decode.optional_field(
    "jurisdiction",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use use_context <- decode.optional_field(
    "useContext",
    [],
    decode.list(usagecontext_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use contact <- decode.optional_field(
    "contact",
    [],
    decode.list(contactdetail_decoder()),
  )
  use publisher <- decode.optional_field(
    "publisher",
    None,
    decode.optional(decode.string),
  )
  use date <- decode.optional_field(
    "date",
    None,
    decode.optional(decode.string),
  )
  use subject <- decode.then(none_if_omitted(measure_subject_decoder()))
  use experimental <- decode.optional_field(
    "experimental",
    None,
    decode.optional(decode.bool),
  )
  use status <- decode.field("status", r4bvaluesets.publicationstatus_decoder())
  use subtitle <- decode.optional_field(
    "subtitle",
    None,
    decode.optional(decode.string),
  )
  use title <- decode.optional_field(
    "title",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use version <- decode.optional_field(
    "version",
    None,
    decode.optional(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use url <- decode.optional_field("url", None, decode.optional(decode.string))
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Measure",
    decode.failure(measure_new(status:), "resourceType"),
  )
  decode.success(Measure(
    supplemental_data:,
    group:,
    guidance:,
    definition:,
    improvement_notation:,
    clinical_recommendation_statement:,
    rationale:,
    rate_aggregation:,
    risk_adjustment:,
    type_:,
    composite_scoring:,
    scoring:,
    disclaimer:,
    library:,
    related_artifact:,
    endorser:,
    reviewer:,
    editor:,
    author:,
    topic:,
    effective_period:,
    last_review_date:,
    approval_date:,
    copyright:,
    usage:,
    purpose:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    subject:,
    experimental:,
    status:,
    subtitle:,
    title:,
    name:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/MeasureReport#resource
pub type Measurereport {
  Measurereport(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    status: r4bvaluesets.Measurereportstatus,
    type_: r4bvaluesets.Measurereporttype,
    measure: String,
    subject: Option(Reference),
    date: Option(String),
    reporter: Option(Reference),
    period: Period,
    improvement_notation: Option(Codeableconcept),
    group: List(MeasurereportGroup),
    evaluated_resource: List(Reference),
  )
}

pub fn measurereport_new(
  period period: Period,
  measure measure: String,
  type_ type_: r4bvaluesets.Measurereporttype,
  status status: r4bvaluesets.Measurereportstatus,
) -> Measurereport {
  Measurereport(
    evaluated_resource: [],
    group: [],
    improvement_notation: None,
    period:,
    reporter: None,
    date: None,
    subject: None,
    measure:,
    type_:,
    status:,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/MeasureReport#resource
pub type MeasurereportGroup {
  MeasurereportGroup(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    code: Option(Codeableconcept),
    population: List(MeasurereportGroupPopulation),
    measure_score: Option(Quantity),
    stratifier: List(MeasurereportGroupStratifier),
  )
}

pub fn measurereport_group_new() -> MeasurereportGroup {
  MeasurereportGroup(
    stratifier: [],
    measure_score: None,
    population: [],
    code: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/MeasureReport#resource
pub type MeasurereportGroupPopulation {
  MeasurereportGroupPopulation(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    code: Option(Codeableconcept),
    count: Option(Int),
    subject_results: Option(Reference),
  )
}

pub fn measurereport_group_population_new() -> MeasurereportGroupPopulation {
  MeasurereportGroupPopulation(
    subject_results: None,
    count: None,
    code: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/MeasureReport#resource
pub type MeasurereportGroupStratifier {
  MeasurereportGroupStratifier(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    code: List(Codeableconcept),
    stratum: List(MeasurereportGroupStratifierStratum),
  )
}

pub fn measurereport_group_stratifier_new() -> MeasurereportGroupStratifier {
  MeasurereportGroupStratifier(
    stratum: [],
    code: [],
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/MeasureReport#resource
pub type MeasurereportGroupStratifierStratum {
  MeasurereportGroupStratifierStratum(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    value: Option(Codeableconcept),
    component: List(MeasurereportGroupStratifierStratumComponent),
    population: List(MeasurereportGroupStratifierStratumPopulation),
    measure_score: Option(Quantity),
  )
}

pub fn measurereport_group_stratifier_stratum_new() -> MeasurereportGroupStratifierStratum {
  MeasurereportGroupStratifierStratum(
    measure_score: None,
    population: [],
    component: [],
    value: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/MeasureReport#resource
pub type MeasurereportGroupStratifierStratumComponent {
  MeasurereportGroupStratifierStratumComponent(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    code: Codeableconcept,
    value: Codeableconcept,
  )
}

pub fn measurereport_group_stratifier_stratum_component_new(
  value value: Codeableconcept,
  code code: Codeableconcept,
) -> MeasurereportGroupStratifierStratumComponent {
  MeasurereportGroupStratifierStratumComponent(
    value:,
    code:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/MeasureReport#resource
pub type MeasurereportGroupStratifierStratumPopulation {
  MeasurereportGroupStratifierStratumPopulation(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    code: Option(Codeableconcept),
    count: Option(Int),
    subject_results: Option(Reference),
  )
}

pub fn measurereport_group_stratifier_stratum_population_new() -> MeasurereportGroupStratifierStratumPopulation {
  MeasurereportGroupStratifierStratumPopulation(
    subject_results: None,
    count: None,
    code: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn measurereport_group_stratifier_stratum_population_to_json(
  measurereport_group_stratifier_stratum_population: MeasurereportGroupStratifierStratumPopulation,
) -> Json {
  let MeasurereportGroupStratifierStratumPopulation(
    subject_results:,
    count:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ) = measurereport_group_stratifier_stratum_population
  let fields = []
  let fields = case subject_results {
    Some(v) -> [#("subjectResults", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case count {
    Some(v) -> [#("count", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case code {
    Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn measurereport_group_stratifier_stratum_population_decoder() -> Decoder(
  MeasurereportGroupStratifierStratumPopulation,
) {
  use subject_results <- decode.optional_field(
    "subjectResults",
    None,
    decode.optional(reference_decoder()),
  )
  use count <- decode.optional_field("count", None, decode.optional(decode.int))
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MeasurereportGroupStratifierStratumPopulation(
    subject_results:,
    count:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn measurereport_group_stratifier_stratum_component_to_json(
  measurereport_group_stratifier_stratum_component: MeasurereportGroupStratifierStratumComponent,
) -> Json {
  let MeasurereportGroupStratifierStratumComponent(
    value:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ) = measurereport_group_stratifier_stratum_component
  let fields = [
    #("value", codeableconcept_to_json(value)),
    #("code", codeableconcept_to_json(code)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn measurereport_group_stratifier_stratum_component_decoder() -> Decoder(
  MeasurereportGroupStratifierStratumComponent,
) {
  use value <- decode.field("value", codeableconcept_decoder())
  use code <- decode.field("code", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MeasurereportGroupStratifierStratumComponent(
    value:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn measurereport_group_stratifier_stratum_to_json(
  measurereport_group_stratifier_stratum: MeasurereportGroupStratifierStratum,
) -> Json {
  let MeasurereportGroupStratifierStratum(
    measure_score:,
    population:,
    component:,
    value:,
    modifier_extension:,
    extension:,
    id:,
  ) = measurereport_group_stratifier_stratum
  let fields = []
  let fields = case measure_score {
    Some(v) -> [#("measureScore", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case population {
    [] -> fields
    _ -> [
      #(
        "population",
        json.array(
          population,
          measurereport_group_stratifier_stratum_population_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case component {
    [] -> fields
    _ -> [
      #(
        "component",
        json.array(
          component,
          measurereport_group_stratifier_stratum_component_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case value {
    Some(v) -> [#("value", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn measurereport_group_stratifier_stratum_decoder() -> Decoder(
  MeasurereportGroupStratifierStratum,
) {
  use measure_score <- decode.optional_field(
    "measureScore",
    None,
    decode.optional(quantity_decoder()),
  )
  use population <- decode.optional_field(
    "population",
    [],
    decode.list(measurereport_group_stratifier_stratum_population_decoder()),
  )
  use component <- decode.optional_field(
    "component",
    [],
    decode.list(measurereport_group_stratifier_stratum_component_decoder()),
  )
  use value <- decode.optional_field(
    "value",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MeasurereportGroupStratifierStratum(
    measure_score:,
    population:,
    component:,
    value:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn measurereport_group_stratifier_to_json(
  measurereport_group_stratifier: MeasurereportGroupStratifier,
) -> Json {
  let MeasurereportGroupStratifier(
    stratum:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ) = measurereport_group_stratifier
  let fields = []
  let fields = case stratum {
    [] -> fields
    _ -> [
      #(
        "stratum",
        json.array(stratum, measurereport_group_stratifier_stratum_to_json),
      ),
      ..fields
    ]
  }
  let fields = case code {
    [] -> fields
    _ -> [#("code", json.array(code, codeableconcept_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn measurereport_group_stratifier_decoder() -> Decoder(
  MeasurereportGroupStratifier,
) {
  use stratum <- decode.optional_field(
    "stratum",
    [],
    decode.list(measurereport_group_stratifier_stratum_decoder()),
  )
  use code <- decode.optional_field(
    "code",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MeasurereportGroupStratifier(
    stratum:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn measurereport_group_population_to_json(
  measurereport_group_population: MeasurereportGroupPopulation,
) -> Json {
  let MeasurereportGroupPopulation(
    subject_results:,
    count:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ) = measurereport_group_population
  let fields = []
  let fields = case subject_results {
    Some(v) -> [#("subjectResults", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case count {
    Some(v) -> [#("count", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case code {
    Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn measurereport_group_population_decoder() -> Decoder(
  MeasurereportGroupPopulation,
) {
  use subject_results <- decode.optional_field(
    "subjectResults",
    None,
    decode.optional(reference_decoder()),
  )
  use count <- decode.optional_field("count", None, decode.optional(decode.int))
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MeasurereportGroupPopulation(
    subject_results:,
    count:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn measurereport_group_to_json(
  measurereport_group: MeasurereportGroup,
) -> Json {
  let MeasurereportGroup(
    stratifier:,
    measure_score:,
    population:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ) = measurereport_group
  let fields = []
  let fields = case stratifier {
    [] -> fields
    _ -> [
      #(
        "stratifier",
        json.array(stratifier, measurereport_group_stratifier_to_json),
      ),
      ..fields
    ]
  }
  let fields = case measure_score {
    Some(v) -> [#("measureScore", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case population {
    [] -> fields
    _ -> [
      #(
        "population",
        json.array(population, measurereport_group_population_to_json),
      ),
      ..fields
    ]
  }
  let fields = case code {
    Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn measurereport_group_decoder() -> Decoder(MeasurereportGroup) {
  use stratifier <- decode.optional_field(
    "stratifier",
    [],
    decode.list(measurereport_group_stratifier_decoder()),
  )
  use measure_score <- decode.optional_field(
    "measureScore",
    None,
    decode.optional(quantity_decoder()),
  )
  use population <- decode.optional_field(
    "population",
    [],
    decode.list(measurereport_group_population_decoder()),
  )
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MeasurereportGroup(
    stratifier:,
    measure_score:,
    population:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn measurereport_to_json(measurereport: Measurereport) -> Json {
  let Measurereport(
    evaluated_resource:,
    group:,
    improvement_notation:,
    period:,
    reporter:,
    date:,
    subject:,
    measure:,
    type_:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = measurereport
  let fields = [
    #("period", period_to_json(period)),
    #("measure", json.string(measure)),
    #("type", r4bvaluesets.measurereporttype_to_json(type_)),
    #("status", r4bvaluesets.measurereportstatus_to_json(status)),
  ]
  let fields = case evaluated_resource {
    [] -> fields
    _ -> [
      #("evaluatedResource", json.array(evaluated_resource, reference_to_json)),
      ..fields
    ]
  }
  let fields = case group {
    [] -> fields
    _ -> [#("group", json.array(group, measurereport_group_to_json)), ..fields]
  }
  let fields = case improvement_notation {
    Some(v) -> [#("improvementNotation", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case reporter {
    Some(v) -> [#("reporter", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case date {
    Some(v) -> [#("date", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case subject {
    Some(v) -> [#("subject", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Measurereport")), ..fields]
  json.object(fields)
}

pub fn measurereport_decoder() -> Decoder(Measurereport) {
  use evaluated_resource <- decode.optional_field(
    "evaluatedResource",
    [],
    decode.list(reference_decoder()),
  )
  use group <- decode.optional_field(
    "group",
    [],
    decode.list(measurereport_group_decoder()),
  )
  use improvement_notation <- decode.optional_field(
    "improvementNotation",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use period <- decode.field("period", period_decoder())
  use reporter <- decode.optional_field(
    "reporter",
    None,
    decode.optional(reference_decoder()),
  )
  use date <- decode.optional_field(
    "date",
    None,
    decode.optional(decode.string),
  )
  use subject <- decode.optional_field(
    "subject",
    None,
    decode.optional(reference_decoder()),
  )
  use measure <- decode.field("measure", decode.string)
  use type_ <- decode.field("type", r4bvaluesets.measurereporttype_decoder())
  use status <- decode.field(
    "status",
    r4bvaluesets.measurereportstatus_decoder(),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Measurereport",
    decode.failure(
      measurereport_new(period:, measure:, type_:, status:),
      "resourceType",
    ),
  )
  decode.success(Measurereport(
    evaluated_resource:,
    group:,
    improvement_notation:,
    period:,
    reporter:,
    date:,
    subject:,
    measure:,
    type_:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/Media#resource
pub type Media {
  Media(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    based_on: List(Reference),
    part_of: List(Reference),
    status: r4bvaluesets.Eventstatus,
    type_: Option(Codeableconcept),
    modality: Option(Codeableconcept),
    view: Option(Codeableconcept),
    subject: Option(Reference),
    encounter: Option(Reference),
    created: Option(MediaCreated),
    issued: Option(String),
    operator: Option(Reference),
    reason_code: List(Codeableconcept),
    body_site: Option(Codeableconcept),
    device_name: Option(String),
    device: Option(Reference),
    height: Option(Int),
    width: Option(Int),
    frames: Option(Int),
    duration: Option(Float),
    content: Attachment,
    note: List(Annotation),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Media#resource
pub type MediaCreated {
  MediaCreatedDatetime(created: String)
  MediaCreatedPeriod(created: Period)
}

pub fn media_created_to_json(elt: MediaCreated) -> Json {
  case elt {
    MediaCreatedDatetime(v) -> json.string(v)
    MediaCreatedPeriod(v) -> period_to_json(v)
  }
}

pub fn media_created_decoder() -> Decoder(MediaCreated) {
  decode.one_of(
    decode.field("createdDateTime", decode.string, decode.success)
      |> decode.map(MediaCreatedDatetime),
    [
      decode.field("createdPeriod", period_decoder(), decode.success)
      |> decode.map(MediaCreatedPeriod),
    ],
  )
}

pub fn media_new(
  content content: Attachment,
  status status: r4bvaluesets.Eventstatus,
) -> Media {
  Media(
    note: [],
    content:,
    duration: None,
    frames: None,
    width: None,
    height: None,
    device: None,
    device_name: None,
    body_site: None,
    reason_code: [],
    operator: None,
    issued: None,
    created: None,
    encounter: None,
    subject: None,
    view: None,
    modality: None,
    type_: None,
    status:,
    part_of: [],
    based_on: [],
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

pub fn media_to_json(media: Media) -> Json {
  let Media(
    note:,
    content:,
    duration:,
    frames:,
    width:,
    height:,
    device:,
    device_name:,
    body_site:,
    reason_code:,
    operator:,
    issued:,
    created:,
    encounter:,
    subject:,
    view:,
    modality:,
    type_:,
    status:,
    part_of:,
    based_on:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = media
  let fields = [
    #("content", attachment_to_json(content)),
    #("status", r4bvaluesets.eventstatus_to_json(status)),
  ]
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case duration {
    Some(v) -> [#("duration", json.float(v)), ..fields]
    None -> fields
  }
  let fields = case frames {
    Some(v) -> [#("frames", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case width {
    Some(v) -> [#("width", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case height {
    Some(v) -> [#("height", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case device {
    Some(v) -> [#("device", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case device_name {
    Some(v) -> [#("deviceName", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case body_site {
    Some(v) -> [#("bodySite", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case reason_code {
    [] -> fields
    _ -> [
      #("reasonCode", json.array(reason_code, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case operator {
    Some(v) -> [#("operator", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case issued {
    Some(v) -> [#("issued", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case created {
    Some(v) -> [
      #(
        "created"
          <> case v {
          MediaCreatedDatetime(_) -> "Datetime"
          MediaCreatedPeriod(_) -> "Period"
        },
        media_created_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case encounter {
    Some(v) -> [#("encounter", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case subject {
    Some(v) -> [#("subject", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case view {
    Some(v) -> [#("view", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modality {
    Some(v) -> [#("modality", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case part_of {
    [] -> fields
    _ -> [#("partOf", json.array(part_of, reference_to_json)), ..fields]
  }
  let fields = case based_on {
    [] -> fields
    _ -> [#("basedOn", json.array(based_on, reference_to_json)), ..fields]
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Media")), ..fields]
  json.object(fields)
}

pub fn media_decoder() -> Decoder(Media) {
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use content <- decode.field("content", attachment_decoder())
  use duration <- decode.optional_field(
    "duration",
    None,
    decode.optional(decode.float),
  )
  use frames <- decode.optional_field(
    "frames",
    None,
    decode.optional(decode.int),
  )
  use width <- decode.optional_field("width", None, decode.optional(decode.int))
  use height <- decode.optional_field(
    "height",
    None,
    decode.optional(decode.int),
  )
  use device <- decode.optional_field(
    "device",
    None,
    decode.optional(reference_decoder()),
  )
  use device_name <- decode.optional_field(
    "deviceName",
    None,
    decode.optional(decode.string),
  )
  use body_site <- decode.optional_field(
    "bodySite",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use reason_code <- decode.optional_field(
    "reasonCode",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use operator <- decode.optional_field(
    "operator",
    None,
    decode.optional(reference_decoder()),
  )
  use issued <- decode.optional_field(
    "issued",
    None,
    decode.optional(decode.string),
  )
  use created <- decode.then(none_if_omitted(media_created_decoder()))
  use encounter <- decode.optional_field(
    "encounter",
    None,
    decode.optional(reference_decoder()),
  )
  use subject <- decode.optional_field(
    "subject",
    None,
    decode.optional(reference_decoder()),
  )
  use view <- decode.optional_field(
    "view",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modality <- decode.optional_field(
    "modality",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use status <- decode.field("status", r4bvaluesets.eventstatus_decoder())
  use part_of <- decode.optional_field(
    "partOf",
    [],
    decode.list(reference_decoder()),
  )
  use based_on <- decode.optional_field(
    "basedOn",
    [],
    decode.list(reference_decoder()),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Media",
    decode.failure(media_new(content:, status:), "resourceType"),
  )
  decode.success(Media(
    note:,
    content:,
    duration:,
    frames:,
    width:,
    height:,
    device:,
    device_name:,
    body_site:,
    reason_code:,
    operator:,
    issued:,
    created:,
    encounter:,
    subject:,
    view:,
    modality:,
    type_:,
    status:,
    part_of:,
    based_on:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/Medication#resource
pub type Medication {
  Medication(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    code: Option(Codeableconcept),
    status: Option(r4bvaluesets.Medicationstatus),
    manufacturer: Option(Reference),
    form: Option(Codeableconcept),
    amount: Option(Ratio),
    ingredient: List(MedicationIngredient),
    batch: Option(MedicationBatch),
  )
}

pub fn medication_new() -> Medication {
  Medication(
    batch: None,
    ingredient: [],
    amount: None,
    form: None,
    manufacturer: None,
    status: None,
    code: None,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Medication#resource
pub type MedicationIngredient {
  MedicationIngredient(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    item: MedicationIngredientItem,
    is_active: Option(Bool),
    strength: Option(Ratio),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Medication#resource
pub type MedicationIngredientItem {
  MedicationIngredientItemCodeableconcept(item: Codeableconcept)
  MedicationIngredientItemReference(item: Reference)
}

pub fn medication_ingredient_item_to_json(elt: MedicationIngredientItem) -> Json {
  case elt {
    MedicationIngredientItemCodeableconcept(v) -> codeableconcept_to_json(v)
    MedicationIngredientItemReference(v) -> reference_to_json(v)
  }
}

pub fn medication_ingredient_item_decoder() -> Decoder(MedicationIngredientItem) {
  decode.one_of(
    decode.field(
      "itemCodeableConcept",
      codeableconcept_decoder(),
      decode.success,
    )
      |> decode.map(MedicationIngredientItemCodeableconcept),
    [
      decode.field("itemReference", reference_decoder(), decode.success)
      |> decode.map(MedicationIngredientItemReference),
    ],
  )
}

pub fn medication_ingredient_new(
  item item: MedicationIngredientItem,
) -> MedicationIngredient {
  MedicationIngredient(
    strength: None,
    is_active: None,
    item:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Medication#resource
pub type MedicationBatch {
  MedicationBatch(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    lot_number: Option(String),
    expiration_date: Option(String),
  )
}

pub fn medication_batch_new() -> MedicationBatch {
  MedicationBatch(
    expiration_date: None,
    lot_number: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn medication_batch_to_json(medication_batch: MedicationBatch) -> Json {
  let MedicationBatch(
    expiration_date:,
    lot_number:,
    modifier_extension:,
    extension:,
    id:,
  ) = medication_batch
  let fields = []
  let fields = case expiration_date {
    Some(v) -> [#("expirationDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case lot_number {
    Some(v) -> [#("lotNumber", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn medication_batch_decoder() -> Decoder(MedicationBatch) {
  use expiration_date <- decode.optional_field(
    "expirationDate",
    None,
    decode.optional(decode.string),
  )
  use lot_number <- decode.optional_field(
    "lotNumber",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MedicationBatch(
    expiration_date:,
    lot_number:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn medication_ingredient_to_json(
  medication_ingredient: MedicationIngredient,
) -> Json {
  let MedicationIngredient(
    strength:,
    is_active:,
    item:,
    modifier_extension:,
    extension:,
    id:,
  ) = medication_ingredient
  let fields = [
    #("item", medication_ingredient_item_to_json(item)),
  ]
  let fields = case strength {
    Some(v) -> [#("strength", ratio_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case is_active {
    Some(v) -> [#("isActive", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn medication_ingredient_decoder() -> Decoder(MedicationIngredient) {
  use strength <- decode.optional_field(
    "strength",
    None,
    decode.optional(ratio_decoder()),
  )
  use is_active <- decode.optional_field(
    "isActive",
    None,
    decode.optional(decode.bool),
  )
  use item <- decode.then(medication_ingredient_item_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MedicationIngredient(
    strength:,
    is_active:,
    item:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn medication_to_json(medication: Medication) -> Json {
  let Medication(
    batch:,
    ingredient:,
    amount:,
    form:,
    manufacturer:,
    status:,
    code:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = medication
  let fields = []
  let fields = case batch {
    Some(v) -> [#("batch", medication_batch_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case ingredient {
    [] -> fields
    _ -> [
      #("ingredient", json.array(ingredient, medication_ingredient_to_json)),
      ..fields
    ]
  }
  let fields = case amount {
    Some(v) -> [#("amount", ratio_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case form {
    Some(v) -> [#("form", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case manufacturer {
    Some(v) -> [#("manufacturer", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case status {
    Some(v) -> [#("status", r4bvaluesets.medicationstatus_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case code {
    Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Medication")), ..fields]
  json.object(fields)
}

pub fn medication_decoder() -> Decoder(Medication) {
  use batch <- decode.optional_field(
    "batch",
    None,
    decode.optional(medication_batch_decoder()),
  )
  use ingredient <- decode.optional_field(
    "ingredient",
    [],
    decode.list(medication_ingredient_decoder()),
  )
  use amount <- decode.optional_field(
    "amount",
    None,
    decode.optional(ratio_decoder()),
  )
  use form <- decode.optional_field(
    "form",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use manufacturer <- decode.optional_field(
    "manufacturer",
    None,
    decode.optional(reference_decoder()),
  )
  use status <- decode.optional_field(
    "status",
    None,
    decode.optional(r4bvaluesets.medicationstatus_decoder()),
  )
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Medication",
    decode.failure(medication_new(), "resourceType"),
  )
  decode.success(Medication(
    batch:,
    ingredient:,
    amount:,
    form:,
    manufacturer:,
    status:,
    code:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/MedicationAdministration#resource
pub type Medicationadministration {
  Medicationadministration(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    instantiates: List(String),
    part_of: List(Reference),
    status: r4bvaluesets.Medicationadminstatus,
    status_reason: List(Codeableconcept),
    category: Option(Codeableconcept),
    medication: MedicationadministrationMedication,
    subject: Reference,
    context: Option(Reference),
    supporting_information: List(Reference),
    effective: MedicationadministrationEffective,
    performer: List(MedicationadministrationPerformer),
    reason_code: List(Codeableconcept),
    reason_reference: List(Reference),
    request: Option(Reference),
    device: List(Reference),
    note: List(Annotation),
    dosage: Option(MedicationadministrationDosage),
    event_history: List(Reference),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/MedicationAdministration#resource
pub type MedicationadministrationMedication {
  MedicationadministrationMedicationCodeableconcept(medication: Codeableconcept)
  MedicationadministrationMedicationReference(medication: Reference)
}

pub fn medicationadministration_medication_to_json(
  elt: MedicationadministrationMedication,
) -> Json {
  case elt {
    MedicationadministrationMedicationCodeableconcept(v) ->
      codeableconcept_to_json(v)
    MedicationadministrationMedicationReference(v) -> reference_to_json(v)
  }
}

pub fn medicationadministration_medication_decoder() -> Decoder(
  MedicationadministrationMedication,
) {
  decode.one_of(
    decode.field(
      "medicationCodeableConcept",
      codeableconcept_decoder(),
      decode.success,
    )
      |> decode.map(MedicationadministrationMedicationCodeableconcept),
    [
      decode.field("medicationReference", reference_decoder(), decode.success)
      |> decode.map(MedicationadministrationMedicationReference),
    ],
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/MedicationAdministration#resource
pub type MedicationadministrationEffective {
  MedicationadministrationEffectiveDatetime(effective: String)
  MedicationadministrationEffectivePeriod(effective: Period)
}

pub fn medicationadministration_effective_to_json(
  elt: MedicationadministrationEffective,
) -> Json {
  case elt {
    MedicationadministrationEffectiveDatetime(v) -> json.string(v)
    MedicationadministrationEffectivePeriod(v) -> period_to_json(v)
  }
}

pub fn medicationadministration_effective_decoder() -> Decoder(
  MedicationadministrationEffective,
) {
  decode.one_of(
    decode.field("effectiveDateTime", decode.string, decode.success)
      |> decode.map(MedicationadministrationEffectiveDatetime),
    [
      decode.field("effectivePeriod", period_decoder(), decode.success)
      |> decode.map(MedicationadministrationEffectivePeriod),
    ],
  )
}

pub fn medicationadministration_new(
  effective effective: MedicationadministrationEffective,
  subject subject: Reference,
  medication medication: MedicationadministrationMedication,
  status status: r4bvaluesets.Medicationadminstatus,
) -> Medicationadministration {
  Medicationadministration(
    event_history: [],
    dosage: None,
    note: [],
    device: [],
    request: None,
    reason_reference: [],
    reason_code: [],
    performer: [],
    effective:,
    supporting_information: [],
    context: None,
    subject:,
    medication:,
    category: None,
    status_reason: [],
    status:,
    part_of: [],
    instantiates: [],
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/MedicationAdministration#resource
pub type MedicationadministrationPerformer {
  MedicationadministrationPerformer(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    function: Option(Codeableconcept),
    actor: Reference,
  )
}

pub fn medicationadministration_performer_new(
  actor actor: Reference,
) -> MedicationadministrationPerformer {
  MedicationadministrationPerformer(
    actor:,
    function: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/MedicationAdministration#resource
pub type MedicationadministrationDosage {
  MedicationadministrationDosage(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    text: Option(String),
    site: Option(Codeableconcept),
    route: Option(Codeableconcept),
    method: Option(Codeableconcept),
    dose: Option(Quantity),
    rate: Option(MedicationadministrationDosageRate),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/MedicationAdministration#resource
pub type MedicationadministrationDosageRate {
  MedicationadministrationDosageRateRatio(rate: Ratio)
  MedicationadministrationDosageRateQuantity(rate: Quantity)
}

pub fn medicationadministration_dosage_rate_to_json(
  elt: MedicationadministrationDosageRate,
) -> Json {
  case elt {
    MedicationadministrationDosageRateRatio(v) -> ratio_to_json(v)
    MedicationadministrationDosageRateQuantity(v) -> quantity_to_json(v)
  }
}

pub fn medicationadministration_dosage_rate_decoder() -> Decoder(
  MedicationadministrationDosageRate,
) {
  decode.one_of(
    decode.field("rateRatio", ratio_decoder(), decode.success)
      |> decode.map(MedicationadministrationDosageRateRatio),
    [
      decode.field("rateQuantity", quantity_decoder(), decode.success)
      |> decode.map(MedicationadministrationDosageRateQuantity),
    ],
  )
}

pub fn medicationadministration_dosage_new() -> MedicationadministrationDosage {
  MedicationadministrationDosage(
    rate: None,
    dose: None,
    method: None,
    route: None,
    site: None,
    text: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn medicationadministration_dosage_to_json(
  medicationadministration_dosage: MedicationadministrationDosage,
) -> Json {
  let MedicationadministrationDosage(
    rate:,
    dose:,
    method:,
    route:,
    site:,
    text:,
    modifier_extension:,
    extension:,
    id:,
  ) = medicationadministration_dosage
  let fields = []
  let fields = case rate {
    Some(v) -> [
      #(
        "rate"
          <> case v {
          MedicationadministrationDosageRateRatio(_) -> "Ratio"
          MedicationadministrationDosageRateQuantity(_) -> "Quantity"
        },
        medicationadministration_dosage_rate_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case dose {
    Some(v) -> [#("dose", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case method {
    Some(v) -> [#("method", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case route {
    Some(v) -> [#("route", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case site {
    Some(v) -> [#("site", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case text {
    Some(v) -> [#("text", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn medicationadministration_dosage_decoder() -> Decoder(
  MedicationadministrationDosage,
) {
  use rate <- decode.then(
    none_if_omitted(medicationadministration_dosage_rate_decoder()),
  )
  use dose <- decode.optional_field(
    "dose",
    None,
    decode.optional(quantity_decoder()),
  )
  use method <- decode.optional_field(
    "method",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use route <- decode.optional_field(
    "route",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use site <- decode.optional_field(
    "site",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MedicationadministrationDosage(
    rate:,
    dose:,
    method:,
    route:,
    site:,
    text:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn medicationadministration_performer_to_json(
  medicationadministration_performer: MedicationadministrationPerformer,
) -> Json {
  let MedicationadministrationPerformer(
    actor:,
    function:,
    modifier_extension:,
    extension:,
    id:,
  ) = medicationadministration_performer
  let fields = [
    #("actor", reference_to_json(actor)),
  ]
  let fields = case function {
    Some(v) -> [#("function", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn medicationadministration_performer_decoder() -> Decoder(
  MedicationadministrationPerformer,
) {
  use actor <- decode.field("actor", reference_decoder())
  use function <- decode.optional_field(
    "function",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MedicationadministrationPerformer(
    actor:,
    function:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn medicationadministration_to_json(
  medicationadministration: Medicationadministration,
) -> Json {
  let Medicationadministration(
    event_history:,
    dosage:,
    note:,
    device:,
    request:,
    reason_reference:,
    reason_code:,
    performer:,
    effective:,
    supporting_information:,
    context:,
    subject:,
    medication:,
    category:,
    status_reason:,
    status:,
    part_of:,
    instantiates:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = medicationadministration
  let fields = [
    #("effective", medicationadministration_effective_to_json(effective)),
    #("subject", reference_to_json(subject)),
    #("medication", medicationadministration_medication_to_json(medication)),
    #("status", r4bvaluesets.medicationadminstatus_to_json(status)),
  ]
  let fields = case event_history {
    [] -> fields
    _ -> [
      #("eventHistory", json.array(event_history, reference_to_json)),
      ..fields
    ]
  }
  let fields = case dosage {
    Some(v) -> [
      #("dosage", medicationadministration_dosage_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case device {
    [] -> fields
    _ -> [#("device", json.array(device, reference_to_json)), ..fields]
  }
  let fields = case request {
    Some(v) -> [#("request", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case reason_reference {
    [] -> fields
    _ -> [
      #("reasonReference", json.array(reason_reference, reference_to_json)),
      ..fields
    ]
  }
  let fields = case reason_code {
    [] -> fields
    _ -> [
      #("reasonCode", json.array(reason_code, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case performer {
    [] -> fields
    _ -> [
      #(
        "performer",
        json.array(performer, medicationadministration_performer_to_json),
      ),
      ..fields
    ]
  }
  let fields = case supporting_information {
    [] -> fields
    _ -> [
      #(
        "supportingInformation",
        json.array(supporting_information, reference_to_json),
      ),
      ..fields
    ]
  }
  let fields = case context {
    Some(v) -> [#("context", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case category {
    Some(v) -> [#("category", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case status_reason {
    [] -> fields
    _ -> [
      #("statusReason", json.array(status_reason, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case part_of {
    [] -> fields
    _ -> [#("partOf", json.array(part_of, reference_to_json)), ..fields]
  }
  let fields = case instantiates {
    [] -> fields
    _ -> [#("instantiates", json.array(instantiates, json.string)), ..fields]
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [
    #("resourceType", json.string("Medicationadministration")),
    ..fields
  ]
  json.object(fields)
}

pub fn medicationadministration_decoder() -> Decoder(Medicationadministration) {
  use event_history <- decode.optional_field(
    "eventHistory",
    [],
    decode.list(reference_decoder()),
  )
  use dosage <- decode.optional_field(
    "dosage",
    None,
    decode.optional(medicationadministration_dosage_decoder()),
  )
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use device <- decode.optional_field(
    "device",
    [],
    decode.list(reference_decoder()),
  )
  use request <- decode.optional_field(
    "request",
    None,
    decode.optional(reference_decoder()),
  )
  use reason_reference <- decode.optional_field(
    "reasonReference",
    [],
    decode.list(reference_decoder()),
  )
  use reason_code <- decode.optional_field(
    "reasonCode",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use performer <- decode.optional_field(
    "performer",
    [],
    decode.list(medicationadministration_performer_decoder()),
  )
  use effective <- decode.then(medicationadministration_effective_decoder())
  use supporting_information <- decode.optional_field(
    "supportingInformation",
    [],
    decode.list(reference_decoder()),
  )
  use context <- decode.optional_field(
    "context",
    None,
    decode.optional(reference_decoder()),
  )
  use subject <- decode.field("subject", reference_decoder())
  use medication <- decode.then(medicationadministration_medication_decoder())
  use category <- decode.optional_field(
    "category",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use status_reason <- decode.optional_field(
    "statusReason",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use status <- decode.field(
    "status",
    r4bvaluesets.medicationadminstatus_decoder(),
  )
  use part_of <- decode.optional_field(
    "partOf",
    [],
    decode.list(reference_decoder()),
  )
  use instantiates <- decode.optional_field(
    "instantiates",
    [],
    decode.list(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Medicationadministration",
    decode.failure(
      medicationadministration_new(effective:, subject:, medication:, status:),
      "resourceType",
    ),
  )
  decode.success(Medicationadministration(
    event_history:,
    dosage:,
    note:,
    device:,
    request:,
    reason_reference:,
    reason_code:,
    performer:,
    effective:,
    supporting_information:,
    context:,
    subject:,
    medication:,
    category:,
    status_reason:,
    status:,
    part_of:,
    instantiates:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/MedicationDispense#resource
pub type Medicationdispense {
  Medicationdispense(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    part_of: List(Reference),
    status: r4bvaluesets.Medicationdispensestatus,
    status_reason: Option(MedicationdispenseStatusreason),
    category: Option(Codeableconcept),
    medication: MedicationdispenseMedication,
    subject: Option(Reference),
    context: Option(Reference),
    supporting_information: List(Reference),
    performer: List(MedicationdispensePerformer),
    location: Option(Reference),
    authorizing_prescription: List(Reference),
    type_: Option(Codeableconcept),
    quantity: Option(Quantity),
    days_supply: Option(Quantity),
    when_prepared: Option(String),
    when_handed_over: Option(String),
    destination: Option(Reference),
    receiver: List(Reference),
    note: List(Annotation),
    dosage_instruction: List(Dosage),
    substitution: Option(MedicationdispenseSubstitution),
    detected_issue: List(Reference),
    event_history: List(Reference),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/MedicationDispense#resource
pub type MedicationdispenseStatusreason {
  MedicationdispenseStatusreasonCodeableconcept(status_reason: Codeableconcept)
  MedicationdispenseStatusreasonReference(status_reason: Reference)
}

pub fn medicationdispense_statusreason_to_json(
  elt: MedicationdispenseStatusreason,
) -> Json {
  case elt {
    MedicationdispenseStatusreasonCodeableconcept(v) ->
      codeableconcept_to_json(v)
    MedicationdispenseStatusreasonReference(v) -> reference_to_json(v)
  }
}

pub fn medicationdispense_statusreason_decoder() -> Decoder(
  MedicationdispenseStatusreason,
) {
  decode.one_of(
    decode.field(
      "statusReasonCodeableConcept",
      codeableconcept_decoder(),
      decode.success,
    )
      |> decode.map(MedicationdispenseStatusreasonCodeableconcept),
    [
      decode.field("statusReasonReference", reference_decoder(), decode.success)
      |> decode.map(MedicationdispenseStatusreasonReference),
    ],
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/MedicationDispense#resource
pub type MedicationdispenseMedication {
  MedicationdispenseMedicationCodeableconcept(medication: Codeableconcept)
  MedicationdispenseMedicationReference(medication: Reference)
}

pub fn medicationdispense_medication_to_json(
  elt: MedicationdispenseMedication,
) -> Json {
  case elt {
    MedicationdispenseMedicationCodeableconcept(v) -> codeableconcept_to_json(v)
    MedicationdispenseMedicationReference(v) -> reference_to_json(v)
  }
}

pub fn medicationdispense_medication_decoder() -> Decoder(
  MedicationdispenseMedication,
) {
  decode.one_of(
    decode.field(
      "medicationCodeableConcept",
      codeableconcept_decoder(),
      decode.success,
    )
      |> decode.map(MedicationdispenseMedicationCodeableconcept),
    [
      decode.field("medicationReference", reference_decoder(), decode.success)
      |> decode.map(MedicationdispenseMedicationReference),
    ],
  )
}

pub fn medicationdispense_new(
  medication medication: MedicationdispenseMedication,
  status status: r4bvaluesets.Medicationdispensestatus,
) -> Medicationdispense {
  Medicationdispense(
    event_history: [],
    detected_issue: [],
    substitution: None,
    dosage_instruction: [],
    note: [],
    receiver: [],
    destination: None,
    when_handed_over: None,
    when_prepared: None,
    days_supply: None,
    quantity: None,
    type_: None,
    authorizing_prescription: [],
    location: None,
    performer: [],
    supporting_information: [],
    context: None,
    subject: None,
    medication:,
    category: None,
    status_reason: None,
    status:,
    part_of: [],
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/MedicationDispense#resource
pub type MedicationdispensePerformer {
  MedicationdispensePerformer(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    function: Option(Codeableconcept),
    actor: Reference,
  )
}

pub fn medicationdispense_performer_new(
  actor actor: Reference,
) -> MedicationdispensePerformer {
  MedicationdispensePerformer(
    actor:,
    function: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/MedicationDispense#resource
pub type MedicationdispenseSubstitution {
  MedicationdispenseSubstitution(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    was_substituted: Bool,
    type_: Option(Codeableconcept),
    reason: List(Codeableconcept),
    responsible_party: List(Reference),
  )
}

pub fn medicationdispense_substitution_new(
  was_substituted was_substituted: Bool,
) -> MedicationdispenseSubstitution {
  MedicationdispenseSubstitution(
    responsible_party: [],
    reason: [],
    type_: None,
    was_substituted:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn medicationdispense_substitution_to_json(
  medicationdispense_substitution: MedicationdispenseSubstitution,
) -> Json {
  let MedicationdispenseSubstitution(
    responsible_party:,
    reason:,
    type_:,
    was_substituted:,
    modifier_extension:,
    extension:,
    id:,
  ) = medicationdispense_substitution
  let fields = [
    #("wasSubstituted", json.bool(was_substituted)),
  ]
  let fields = case responsible_party {
    [] -> fields
    _ -> [
      #("responsibleParty", json.array(responsible_party, reference_to_json)),
      ..fields
    ]
  }
  let fields = case reason {
    [] -> fields
    _ -> [#("reason", json.array(reason, codeableconcept_to_json)), ..fields]
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn medicationdispense_substitution_decoder() -> Decoder(
  MedicationdispenseSubstitution,
) {
  use responsible_party <- decode.optional_field(
    "responsibleParty",
    [],
    decode.list(reference_decoder()),
  )
  use reason <- decode.optional_field(
    "reason",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use was_substituted <- decode.field("wasSubstituted", decode.bool)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MedicationdispenseSubstitution(
    responsible_party:,
    reason:,
    type_:,
    was_substituted:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn medicationdispense_performer_to_json(
  medicationdispense_performer: MedicationdispensePerformer,
) -> Json {
  let MedicationdispensePerformer(
    actor:,
    function:,
    modifier_extension:,
    extension:,
    id:,
  ) = medicationdispense_performer
  let fields = [
    #("actor", reference_to_json(actor)),
  ]
  let fields = case function {
    Some(v) -> [#("function", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn medicationdispense_performer_decoder() -> Decoder(
  MedicationdispensePerformer,
) {
  use actor <- decode.field("actor", reference_decoder())
  use function <- decode.optional_field(
    "function",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MedicationdispensePerformer(
    actor:,
    function:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn medicationdispense_to_json(
  medicationdispense: Medicationdispense,
) -> Json {
  let Medicationdispense(
    event_history:,
    detected_issue:,
    substitution:,
    dosage_instruction:,
    note:,
    receiver:,
    destination:,
    when_handed_over:,
    when_prepared:,
    days_supply:,
    quantity:,
    type_:,
    authorizing_prescription:,
    location:,
    performer:,
    supporting_information:,
    context:,
    subject:,
    medication:,
    category:,
    status_reason:,
    status:,
    part_of:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = medicationdispense
  let fields = [
    #("medication", medicationdispense_medication_to_json(medication)),
    #("status", r4bvaluesets.medicationdispensestatus_to_json(status)),
  ]
  let fields = case event_history {
    [] -> fields
    _ -> [
      #("eventHistory", json.array(event_history, reference_to_json)),
      ..fields
    ]
  }
  let fields = case detected_issue {
    [] -> fields
    _ -> [
      #("detectedIssue", json.array(detected_issue, reference_to_json)),
      ..fields
    ]
  }
  let fields = case substitution {
    Some(v) -> [
      #("substitution", medicationdispense_substitution_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case dosage_instruction {
    [] -> fields
    _ -> [
      #("dosageInstruction", json.array(dosage_instruction, dosage_to_json)),
      ..fields
    ]
  }
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case receiver {
    [] -> fields
    _ -> [#("receiver", json.array(receiver, reference_to_json)), ..fields]
  }
  let fields = case destination {
    Some(v) -> [#("destination", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case when_handed_over {
    Some(v) -> [#("whenHandedOver", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case when_prepared {
    Some(v) -> [#("whenPrepared", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case days_supply {
    Some(v) -> [#("daysSupply", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case quantity {
    Some(v) -> [#("quantity", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case authorizing_prescription {
    [] -> fields
    _ -> [
      #(
        "authorizingPrescription",
        json.array(authorizing_prescription, reference_to_json),
      ),
      ..fields
    ]
  }
  let fields = case location {
    Some(v) -> [#("location", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case performer {
    [] -> fields
    _ -> [
      #(
        "performer",
        json.array(performer, medicationdispense_performer_to_json),
      ),
      ..fields
    ]
  }
  let fields = case supporting_information {
    [] -> fields
    _ -> [
      #(
        "supportingInformation",
        json.array(supporting_information, reference_to_json),
      ),
      ..fields
    ]
  }
  let fields = case context {
    Some(v) -> [#("context", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case subject {
    Some(v) -> [#("subject", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case category {
    Some(v) -> [#("category", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case status_reason {
    Some(v) -> [
      #(
        "statusReason"
          <> case v {
          MedicationdispenseStatusreasonCodeableconcept(_) -> "Codeableconcept"
          MedicationdispenseStatusreasonReference(_) -> "Reference"
        },
        medicationdispense_statusreason_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case part_of {
    [] -> fields
    _ -> [#("partOf", json.array(part_of, reference_to_json)), ..fields]
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Medicationdispense")), ..fields]
  json.object(fields)
}

pub fn medicationdispense_decoder() -> Decoder(Medicationdispense) {
  use event_history <- decode.optional_field(
    "eventHistory",
    [],
    decode.list(reference_decoder()),
  )
  use detected_issue <- decode.optional_field(
    "detectedIssue",
    [],
    decode.list(reference_decoder()),
  )
  use substitution <- decode.optional_field(
    "substitution",
    None,
    decode.optional(medicationdispense_substitution_decoder()),
  )
  use dosage_instruction <- decode.optional_field(
    "dosageInstruction",
    [],
    decode.list(dosage_decoder()),
  )
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use receiver <- decode.optional_field(
    "receiver",
    [],
    decode.list(reference_decoder()),
  )
  use destination <- decode.optional_field(
    "destination",
    None,
    decode.optional(reference_decoder()),
  )
  use when_handed_over <- decode.optional_field(
    "whenHandedOver",
    None,
    decode.optional(decode.string),
  )
  use when_prepared <- decode.optional_field(
    "whenPrepared",
    None,
    decode.optional(decode.string),
  )
  use days_supply <- decode.optional_field(
    "daysSupply",
    None,
    decode.optional(quantity_decoder()),
  )
  use quantity <- decode.optional_field(
    "quantity",
    None,
    decode.optional(quantity_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use authorizing_prescription <- decode.optional_field(
    "authorizingPrescription",
    [],
    decode.list(reference_decoder()),
  )
  use location <- decode.optional_field(
    "location",
    None,
    decode.optional(reference_decoder()),
  )
  use performer <- decode.optional_field(
    "performer",
    [],
    decode.list(medicationdispense_performer_decoder()),
  )
  use supporting_information <- decode.optional_field(
    "supportingInformation",
    [],
    decode.list(reference_decoder()),
  )
  use context <- decode.optional_field(
    "context",
    None,
    decode.optional(reference_decoder()),
  )
  use subject <- decode.optional_field(
    "subject",
    None,
    decode.optional(reference_decoder()),
  )
  use medication <- decode.then(medicationdispense_medication_decoder())
  use category <- decode.optional_field(
    "category",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use status_reason <- decode.then(
    none_if_omitted(medicationdispense_statusreason_decoder()),
  )
  use status <- decode.field(
    "status",
    r4bvaluesets.medicationdispensestatus_decoder(),
  )
  use part_of <- decode.optional_field(
    "partOf",
    [],
    decode.list(reference_decoder()),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Medicationdispense",
    decode.failure(medicationdispense_new(medication:, status:), "resourceType"),
  )
  decode.success(Medicationdispense(
    event_history:,
    detected_issue:,
    substitution:,
    dosage_instruction:,
    note:,
    receiver:,
    destination:,
    when_handed_over:,
    when_prepared:,
    days_supply:,
    quantity:,
    type_:,
    authorizing_prescription:,
    location:,
    performer:,
    supporting_information:,
    context:,
    subject:,
    medication:,
    category:,
    status_reason:,
    status:,
    part_of:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/MedicationKnowledge#resource
pub type Medicationknowledge {
  Medicationknowledge(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    code: Option(Codeableconcept),
    status: Option(r4bvaluesets.Medicationknowledgestatus),
    manufacturer: Option(Reference),
    dose_form: Option(Codeableconcept),
    amount: Option(Quantity),
    synonym: List(String),
    related_medication_knowledge: List(
      MedicationknowledgeRelatedmedicationknowledge,
    ),
    associated_medication: List(Reference),
    product_type: List(Codeableconcept),
    monograph: List(MedicationknowledgeMonograph),
    ingredient: List(MedicationknowledgeIngredient),
    preparation_instruction: Option(String),
    intended_route: List(Codeableconcept),
    cost: List(MedicationknowledgeCost),
    monitoring_program: List(MedicationknowledgeMonitoringprogram),
    administration_guidelines: List(MedicationknowledgeAdministrationguidelines),
    medicine_classification: List(MedicationknowledgeMedicineclassification),
    packaging: Option(MedicationknowledgePackaging),
    drug_characteristic: List(MedicationknowledgeDrugcharacteristic),
    contraindication: List(Reference),
    regulatory: List(MedicationknowledgeRegulatory),
    kinetics: List(MedicationknowledgeKinetics),
  )
}

pub fn medicationknowledge_new() -> Medicationknowledge {
  Medicationknowledge(
    kinetics: [],
    regulatory: [],
    contraindication: [],
    drug_characteristic: [],
    packaging: None,
    medicine_classification: [],
    administration_guidelines: [],
    monitoring_program: [],
    cost: [],
    intended_route: [],
    preparation_instruction: None,
    ingredient: [],
    monograph: [],
    product_type: [],
    associated_medication: [],
    related_medication_knowledge: [],
    synonym: [],
    amount: None,
    dose_form: None,
    manufacturer: None,
    status: None,
    code: None,
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/MedicationKnowledge#resource
pub type MedicationknowledgeRelatedmedicationknowledge {
  MedicationknowledgeRelatedmedicationknowledge(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Codeableconcept,
    reference: List(Reference),
  )
}

pub fn medicationknowledge_relatedmedicationknowledge_new(
  type_ type_: Codeableconcept,
) -> MedicationknowledgeRelatedmedicationknowledge {
  MedicationknowledgeRelatedmedicationknowledge(
    reference: [],
    type_:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/MedicationKnowledge#resource
pub type MedicationknowledgeMonograph {
  MedicationknowledgeMonograph(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Option(Codeableconcept),
    source: Option(Reference),
  )
}

pub fn medicationknowledge_monograph_new() -> MedicationknowledgeMonograph {
  MedicationknowledgeMonograph(
    source: None,
    type_: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/MedicationKnowledge#resource
pub type MedicationknowledgeIngredient {
  MedicationknowledgeIngredient(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    item: MedicationknowledgeIngredientItem,
    is_active: Option(Bool),
    strength: Option(Ratio),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/MedicationKnowledge#resource
pub type MedicationknowledgeIngredientItem {
  MedicationknowledgeIngredientItemCodeableconcept(item: Codeableconcept)
  MedicationknowledgeIngredientItemReference(item: Reference)
}

pub fn medicationknowledge_ingredient_item_to_json(
  elt: MedicationknowledgeIngredientItem,
) -> Json {
  case elt {
    MedicationknowledgeIngredientItemCodeableconcept(v) ->
      codeableconcept_to_json(v)
    MedicationknowledgeIngredientItemReference(v) -> reference_to_json(v)
  }
}

pub fn medicationknowledge_ingredient_item_decoder() -> Decoder(
  MedicationknowledgeIngredientItem,
) {
  decode.one_of(
    decode.field(
      "itemCodeableConcept",
      codeableconcept_decoder(),
      decode.success,
    )
      |> decode.map(MedicationknowledgeIngredientItemCodeableconcept),
    [
      decode.field("itemReference", reference_decoder(), decode.success)
      |> decode.map(MedicationknowledgeIngredientItemReference),
    ],
  )
}

pub fn medicationknowledge_ingredient_new(
  item item: MedicationknowledgeIngredientItem,
) -> MedicationknowledgeIngredient {
  MedicationknowledgeIngredient(
    strength: None,
    is_active: None,
    item:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/MedicationKnowledge#resource
pub type MedicationknowledgeCost {
  MedicationknowledgeCost(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Codeableconcept,
    source: Option(String),
    cost: Money,
  )
}

pub fn medicationknowledge_cost_new(
  cost cost: Money,
  type_ type_: Codeableconcept,
) -> MedicationknowledgeCost {
  MedicationknowledgeCost(
    cost:,
    source: None,
    type_:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/MedicationKnowledge#resource
pub type MedicationknowledgeMonitoringprogram {
  MedicationknowledgeMonitoringprogram(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Option(Codeableconcept),
    name: Option(String),
  )
}

pub fn medicationknowledge_monitoringprogram_new() -> MedicationknowledgeMonitoringprogram {
  MedicationknowledgeMonitoringprogram(
    name: None,
    type_: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/MedicationKnowledge#resource
pub type MedicationknowledgeAdministrationguidelines {
  MedicationknowledgeAdministrationguidelines(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    dosage: List(MedicationknowledgeAdministrationguidelinesDosage),
    indication: Option(MedicationknowledgeAdministrationguidelinesIndication),
    patient_characteristics: List(
      MedicationknowledgeAdministrationguidelinesPatientcharacteristics,
    ),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/MedicationKnowledge#resource
pub type MedicationknowledgeAdministrationguidelinesIndication {
  MedicationknowledgeAdministrationguidelinesIndicationCodeableconcept(
    indication: Codeableconcept,
  )
  MedicationknowledgeAdministrationguidelinesIndicationReference(
    indication: Reference,
  )
}

pub fn medicationknowledge_administrationguidelines_indication_to_json(
  elt: MedicationknowledgeAdministrationguidelinesIndication,
) -> Json {
  case elt {
    MedicationknowledgeAdministrationguidelinesIndicationCodeableconcept(v) ->
      codeableconcept_to_json(v)
    MedicationknowledgeAdministrationguidelinesIndicationReference(v) ->
      reference_to_json(v)
  }
}

pub fn medicationknowledge_administrationguidelines_indication_decoder() -> Decoder(
  MedicationknowledgeAdministrationguidelinesIndication,
) {
  decode.one_of(
    decode.field(
      "indicationCodeableConcept",
      codeableconcept_decoder(),
      decode.success,
    )
      |> decode.map(
        MedicationknowledgeAdministrationguidelinesIndicationCodeableconcept,
      ),
    [
      decode.field("indicationReference", reference_decoder(), decode.success)
      |> decode.map(
        MedicationknowledgeAdministrationguidelinesIndicationReference,
      ),
    ],
  )
}

pub fn medicationknowledge_administrationguidelines_new() -> MedicationknowledgeAdministrationguidelines {
  MedicationknowledgeAdministrationguidelines(
    patient_characteristics: [],
    indication: None,
    dosage: [],
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/MedicationKnowledge#resource
pub type MedicationknowledgeAdministrationguidelinesDosage {
  MedicationknowledgeAdministrationguidelinesDosage(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Codeableconcept,
    dosage: List(Dosage),
  )
}

pub fn medicationknowledge_administrationguidelines_dosage_new(
  type_ type_: Codeableconcept,
) -> MedicationknowledgeAdministrationguidelinesDosage {
  MedicationknowledgeAdministrationguidelinesDosage(
    dosage: [],
    type_:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/MedicationKnowledge#resource
pub type MedicationknowledgeAdministrationguidelinesPatientcharacteristics {
  MedicationknowledgeAdministrationguidelinesPatientcharacteristics(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    characteristic: MedicationknowledgeAdministrationguidelinesPatientcharacteristicsCharacteristic,
    value: List(String),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/MedicationKnowledge#resource
pub type MedicationknowledgeAdministrationguidelinesPatientcharacteristicsCharacteristic {
  MedicationknowledgeAdministrationguidelinesPatientcharacteristicsCharacteristicCodeableconcept(
    characteristic: Codeableconcept,
  )
  MedicationknowledgeAdministrationguidelinesPatientcharacteristicsCharacteristicQuantity(
    characteristic: Quantity,
  )
}

pub fn medicationknowledge_administrationguidelines_patientcharacteristics_characteristic_to_json(
  elt: MedicationknowledgeAdministrationguidelinesPatientcharacteristicsCharacteristic,
) -> Json {
  case elt {
    MedicationknowledgeAdministrationguidelinesPatientcharacteristicsCharacteristicCodeableconcept(
      v,
    ) -> codeableconcept_to_json(v)
    MedicationknowledgeAdministrationguidelinesPatientcharacteristicsCharacteristicQuantity(
      v,
    ) -> quantity_to_json(v)
  }
}

pub fn medicationknowledge_administrationguidelines_patientcharacteristics_characteristic_decoder() -> Decoder(
  MedicationknowledgeAdministrationguidelinesPatientcharacteristicsCharacteristic,
) {
  decode.one_of(
    decode.field(
      "characteristicCodeableConcept",
      codeableconcept_decoder(),
      decode.success,
    )
      |> decode.map(
        MedicationknowledgeAdministrationguidelinesPatientcharacteristicsCharacteristicCodeableconcept,
      ),
    [
      decode.field("characteristicQuantity", quantity_decoder(), decode.success)
      |> decode.map(
        MedicationknowledgeAdministrationguidelinesPatientcharacteristicsCharacteristicQuantity,
      ),
    ],
  )
}

pub fn medicationknowledge_administrationguidelines_patientcharacteristics_new(
  characteristic characteristic: MedicationknowledgeAdministrationguidelinesPatientcharacteristicsCharacteristic,
) -> MedicationknowledgeAdministrationguidelinesPatientcharacteristics {
  MedicationknowledgeAdministrationguidelinesPatientcharacteristics(
    value: [],
    characteristic:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/MedicationKnowledge#resource
pub type MedicationknowledgeMedicineclassification {
  MedicationknowledgeMedicineclassification(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Codeableconcept,
    classification: List(Codeableconcept),
  )
}

pub fn medicationknowledge_medicineclassification_new(
  type_ type_: Codeableconcept,
) -> MedicationknowledgeMedicineclassification {
  MedicationknowledgeMedicineclassification(
    classification: [],
    type_:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/MedicationKnowledge#resource
pub type MedicationknowledgePackaging {
  MedicationknowledgePackaging(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Option(Codeableconcept),
    quantity: Option(Quantity),
  )
}

pub fn medicationknowledge_packaging_new() -> MedicationknowledgePackaging {
  MedicationknowledgePackaging(
    quantity: None,
    type_: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/MedicationKnowledge#resource
pub type MedicationknowledgeDrugcharacteristic {
  MedicationknowledgeDrugcharacteristic(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Option(Codeableconcept),
    value: Option(MedicationknowledgeDrugcharacteristicValue),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/MedicationKnowledge#resource
pub type MedicationknowledgeDrugcharacteristicValue {
  MedicationknowledgeDrugcharacteristicValueCodeableconcept(
    value: Codeableconcept,
  )
  MedicationknowledgeDrugcharacteristicValueString(value: String)
  MedicationknowledgeDrugcharacteristicValueQuantity(value: Quantity)
  MedicationknowledgeDrugcharacteristicValueBase64binary(value: String)
}

pub fn medicationknowledge_drugcharacteristic_value_to_json(
  elt: MedicationknowledgeDrugcharacteristicValue,
) -> Json {
  case elt {
    MedicationknowledgeDrugcharacteristicValueCodeableconcept(v) ->
      codeableconcept_to_json(v)
    MedicationknowledgeDrugcharacteristicValueString(v) -> json.string(v)
    MedicationknowledgeDrugcharacteristicValueQuantity(v) -> quantity_to_json(v)
    MedicationknowledgeDrugcharacteristicValueBase64binary(v) -> json.string(v)
  }
}

pub fn medicationknowledge_drugcharacteristic_value_decoder() -> Decoder(
  MedicationknowledgeDrugcharacteristicValue,
) {
  decode.one_of(
    decode.field(
      "valueCodeableConcept",
      codeableconcept_decoder(),
      decode.success,
    )
      |> decode.map(MedicationknowledgeDrugcharacteristicValueCodeableconcept),
    [
      decode.field("valueString", decode.string, decode.success)
        |> decode.map(MedicationknowledgeDrugcharacteristicValueString),
      decode.field("valueQuantity", quantity_decoder(), decode.success)
        |> decode.map(MedicationknowledgeDrugcharacteristicValueQuantity),
      decode.field("valueBase64Binary", decode.string, decode.success)
        |> decode.map(MedicationknowledgeDrugcharacteristicValueBase64binary),
    ],
  )
}

pub fn medicationknowledge_drugcharacteristic_new() -> MedicationknowledgeDrugcharacteristic {
  MedicationknowledgeDrugcharacteristic(
    value: None,
    type_: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/MedicationKnowledge#resource
pub type MedicationknowledgeRegulatory {
  MedicationknowledgeRegulatory(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    regulatory_authority: Reference,
    substitution: List(MedicationknowledgeRegulatorySubstitution),
    schedule: List(MedicationknowledgeRegulatorySchedule),
    max_dispense: Option(MedicationknowledgeRegulatoryMaxdispense),
  )
}

pub fn medicationknowledge_regulatory_new(
  regulatory_authority regulatory_authority: Reference,
) -> MedicationknowledgeRegulatory {
  MedicationknowledgeRegulatory(
    max_dispense: None,
    schedule: [],
    substitution: [],
    regulatory_authority:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/MedicationKnowledge#resource
pub type MedicationknowledgeRegulatorySubstitution {
  MedicationknowledgeRegulatorySubstitution(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Codeableconcept,
    allowed: Bool,
  )
}

pub fn medicationknowledge_regulatory_substitution_new(
  allowed allowed: Bool,
  type_ type_: Codeableconcept,
) -> MedicationknowledgeRegulatorySubstitution {
  MedicationknowledgeRegulatorySubstitution(
    allowed:,
    type_:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/MedicationKnowledge#resource
pub type MedicationknowledgeRegulatorySchedule {
  MedicationknowledgeRegulatorySchedule(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    schedule: Codeableconcept,
  )
}

pub fn medicationknowledge_regulatory_schedule_new(
  schedule schedule: Codeableconcept,
) -> MedicationknowledgeRegulatorySchedule {
  MedicationknowledgeRegulatorySchedule(
    schedule:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/MedicationKnowledge#resource
pub type MedicationknowledgeRegulatoryMaxdispense {
  MedicationknowledgeRegulatoryMaxdispense(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    quantity: Quantity,
    period: Option(Duration),
  )
}

pub fn medicationknowledge_regulatory_maxdispense_new(
  quantity quantity: Quantity,
) -> MedicationknowledgeRegulatoryMaxdispense {
  MedicationknowledgeRegulatoryMaxdispense(
    period: None,
    quantity:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/MedicationKnowledge#resource
pub type MedicationknowledgeKinetics {
  MedicationknowledgeKinetics(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    area_under_curve: List(Quantity),
    lethal_dose50: List(Quantity),
    half_life_period: Option(Duration),
  )
}

pub fn medicationknowledge_kinetics_new() -> MedicationknowledgeKinetics {
  MedicationknowledgeKinetics(
    half_life_period: None,
    lethal_dose50: [],
    area_under_curve: [],
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn medicationknowledge_kinetics_to_json(
  medicationknowledge_kinetics: MedicationknowledgeKinetics,
) -> Json {
  let MedicationknowledgeKinetics(
    half_life_period:,
    lethal_dose50:,
    area_under_curve:,
    modifier_extension:,
    extension:,
    id:,
  ) = medicationknowledge_kinetics
  let fields = []
  let fields = case half_life_period {
    Some(v) -> [#("halfLifePeriod", duration_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case lethal_dose50 {
    [] -> fields
    _ -> [
      #("lethalDose50", json.array(lethal_dose50, quantity_to_json)),
      ..fields
    ]
  }
  let fields = case area_under_curve {
    [] -> fields
    _ -> [
      #("areaUnderCurve", json.array(area_under_curve, quantity_to_json)),
      ..fields
    ]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn medicationknowledge_kinetics_decoder() -> Decoder(
  MedicationknowledgeKinetics,
) {
  use half_life_period <- decode.optional_field(
    "halfLifePeriod",
    None,
    decode.optional(duration_decoder()),
  )
  use lethal_dose50 <- decode.optional_field(
    "lethalDose50",
    [],
    decode.list(quantity_decoder()),
  )
  use area_under_curve <- decode.optional_field(
    "areaUnderCurve",
    [],
    decode.list(quantity_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MedicationknowledgeKinetics(
    half_life_period:,
    lethal_dose50:,
    area_under_curve:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn medicationknowledge_regulatory_maxdispense_to_json(
  medicationknowledge_regulatory_maxdispense: MedicationknowledgeRegulatoryMaxdispense,
) -> Json {
  let MedicationknowledgeRegulatoryMaxdispense(
    period:,
    quantity:,
    modifier_extension:,
    extension:,
    id:,
  ) = medicationknowledge_regulatory_maxdispense
  let fields = [
    #("quantity", quantity_to_json(quantity)),
  ]
  let fields = case period {
    Some(v) -> [#("period", duration_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn medicationknowledge_regulatory_maxdispense_decoder() -> Decoder(
  MedicationknowledgeRegulatoryMaxdispense,
) {
  use period <- decode.optional_field(
    "period",
    None,
    decode.optional(duration_decoder()),
  )
  use quantity <- decode.field("quantity", quantity_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MedicationknowledgeRegulatoryMaxdispense(
    period:,
    quantity:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn medicationknowledge_regulatory_schedule_to_json(
  medicationknowledge_regulatory_schedule: MedicationknowledgeRegulatorySchedule,
) -> Json {
  let MedicationknowledgeRegulatorySchedule(
    schedule:,
    modifier_extension:,
    extension:,
    id:,
  ) = medicationknowledge_regulatory_schedule
  let fields = [
    #("schedule", codeableconcept_to_json(schedule)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn medicationknowledge_regulatory_schedule_decoder() -> Decoder(
  MedicationknowledgeRegulatorySchedule,
) {
  use schedule <- decode.field("schedule", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MedicationknowledgeRegulatorySchedule(
    schedule:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn medicationknowledge_regulatory_substitution_to_json(
  medicationknowledge_regulatory_substitution: MedicationknowledgeRegulatorySubstitution,
) -> Json {
  let MedicationknowledgeRegulatorySubstitution(
    allowed:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = medicationknowledge_regulatory_substitution
  let fields = [
    #("allowed", json.bool(allowed)),
    #("type", codeableconcept_to_json(type_)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn medicationknowledge_regulatory_substitution_decoder() -> Decoder(
  MedicationknowledgeRegulatorySubstitution,
) {
  use allowed <- decode.field("allowed", decode.bool)
  use type_ <- decode.field("type", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MedicationknowledgeRegulatorySubstitution(
    allowed:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn medicationknowledge_regulatory_to_json(
  medicationknowledge_regulatory: MedicationknowledgeRegulatory,
) -> Json {
  let MedicationknowledgeRegulatory(
    max_dispense:,
    schedule:,
    substitution:,
    regulatory_authority:,
    modifier_extension:,
    extension:,
    id:,
  ) = medicationknowledge_regulatory
  let fields = [
    #("regulatoryAuthority", reference_to_json(regulatory_authority)),
  ]
  let fields = case max_dispense {
    Some(v) -> [
      #("maxDispense", medicationknowledge_regulatory_maxdispense_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case schedule {
    [] -> fields
    _ -> [
      #(
        "schedule",
        json.array(schedule, medicationknowledge_regulatory_schedule_to_json),
      ),
      ..fields
    ]
  }
  let fields = case substitution {
    [] -> fields
    _ -> [
      #(
        "substitution",
        json.array(
          substitution,
          medicationknowledge_regulatory_substitution_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn medicationknowledge_regulatory_decoder() -> Decoder(
  MedicationknowledgeRegulatory,
) {
  use max_dispense <- decode.optional_field(
    "maxDispense",
    None,
    decode.optional(medicationknowledge_regulatory_maxdispense_decoder()),
  )
  use schedule <- decode.optional_field(
    "schedule",
    [],
    decode.list(medicationknowledge_regulatory_schedule_decoder()),
  )
  use substitution <- decode.optional_field(
    "substitution",
    [],
    decode.list(medicationknowledge_regulatory_substitution_decoder()),
  )
  use regulatory_authority <- decode.field(
    "regulatoryAuthority",
    reference_decoder(),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MedicationknowledgeRegulatory(
    max_dispense:,
    schedule:,
    substitution:,
    regulatory_authority:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn medicationknowledge_drugcharacteristic_to_json(
  medicationknowledge_drugcharacteristic: MedicationknowledgeDrugcharacteristic,
) -> Json {
  let MedicationknowledgeDrugcharacteristic(
    value:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = medicationknowledge_drugcharacteristic
  let fields = []
  let fields = case value {
    Some(v) -> [
      #(
        "value"
          <> case v {
          MedicationknowledgeDrugcharacteristicValueCodeableconcept(_) ->
            "Codeableconcept"
          MedicationknowledgeDrugcharacteristicValueString(_) -> "String"
          MedicationknowledgeDrugcharacteristicValueQuantity(_) -> "Quantity"
          MedicationknowledgeDrugcharacteristicValueBase64binary(_) ->
            "Base64binary"
        },
        medicationknowledge_drugcharacteristic_value_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn medicationknowledge_drugcharacteristic_decoder() -> Decoder(
  MedicationknowledgeDrugcharacteristic,
) {
  use value <- decode.then(
    none_if_omitted(medicationknowledge_drugcharacteristic_value_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MedicationknowledgeDrugcharacteristic(
    value:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn medicationknowledge_packaging_to_json(
  medicationknowledge_packaging: MedicationknowledgePackaging,
) -> Json {
  let MedicationknowledgePackaging(
    quantity:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = medicationknowledge_packaging
  let fields = []
  let fields = case quantity {
    Some(v) -> [#("quantity", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn medicationknowledge_packaging_decoder() -> Decoder(
  MedicationknowledgePackaging,
) {
  use quantity <- decode.optional_field(
    "quantity",
    None,
    decode.optional(quantity_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MedicationknowledgePackaging(
    quantity:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn medicationknowledge_medicineclassification_to_json(
  medicationknowledge_medicineclassification: MedicationknowledgeMedicineclassification,
) -> Json {
  let MedicationknowledgeMedicineclassification(
    classification:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = medicationknowledge_medicineclassification
  let fields = [
    #("type", codeableconcept_to_json(type_)),
  ]
  let fields = case classification {
    [] -> fields
    _ -> [
      #("classification", json.array(classification, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn medicationknowledge_medicineclassification_decoder() -> Decoder(
  MedicationknowledgeMedicineclassification,
) {
  use classification <- decode.optional_field(
    "classification",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use type_ <- decode.field("type", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MedicationknowledgeMedicineclassification(
    classification:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn medicationknowledge_administrationguidelines_patientcharacteristics_to_json(
  medicationknowledge_administrationguidelines_patientcharacteristics: MedicationknowledgeAdministrationguidelinesPatientcharacteristics,
) -> Json {
  let MedicationknowledgeAdministrationguidelinesPatientcharacteristics(
    value:,
    characteristic:,
    modifier_extension:,
    extension:,
    id:,
  ) = medicationknowledge_administrationguidelines_patientcharacteristics
  let fields = [
    #(
      "characteristic",
      medicationknowledge_administrationguidelines_patientcharacteristics_characteristic_to_json(
        characteristic,
      ),
    ),
  ]
  let fields = case value {
    [] -> fields
    _ -> [#("value", json.array(value, json.string)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn medicationknowledge_administrationguidelines_patientcharacteristics_decoder() -> Decoder(
  MedicationknowledgeAdministrationguidelinesPatientcharacteristics,
) {
  use value <- decode.optional_field("value", [], decode.list(decode.string))
  use characteristic <- decode.then(
    medicationknowledge_administrationguidelines_patientcharacteristics_characteristic_decoder(),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(
    MedicationknowledgeAdministrationguidelinesPatientcharacteristics(
      value:,
      characteristic:,
      modifier_extension:,
      extension:,
      id:,
    ),
  )
}

pub fn medicationknowledge_administrationguidelines_dosage_to_json(
  medicationknowledge_administrationguidelines_dosage: MedicationknowledgeAdministrationguidelinesDosage,
) -> Json {
  let MedicationknowledgeAdministrationguidelinesDosage(
    dosage:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = medicationknowledge_administrationguidelines_dosage
  let fields = [
    #("type", codeableconcept_to_json(type_)),
  ]
  let fields = case dosage {
    [] -> fields
    _ -> [#("dosage", json.array(dosage, dosage_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn medicationknowledge_administrationguidelines_dosage_decoder() -> Decoder(
  MedicationknowledgeAdministrationguidelinesDosage,
) {
  use dosage <- decode.optional_field(
    "dosage",
    [],
    decode.list(dosage_decoder()),
  )
  use type_ <- decode.field("type", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MedicationknowledgeAdministrationguidelinesDosage(
    dosage:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn medicationknowledge_administrationguidelines_to_json(
  medicationknowledge_administrationguidelines: MedicationknowledgeAdministrationguidelines,
) -> Json {
  let MedicationknowledgeAdministrationguidelines(
    patient_characteristics:,
    indication:,
    dosage:,
    modifier_extension:,
    extension:,
    id:,
  ) = medicationknowledge_administrationguidelines
  let fields = []
  let fields = case patient_characteristics {
    [] -> fields
    _ -> [
      #(
        "patientCharacteristics",
        json.array(
          patient_characteristics,
          medicationknowledge_administrationguidelines_patientcharacteristics_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case indication {
    Some(v) -> [
      #(
        "indication"
          <> case v {
          MedicationknowledgeAdministrationguidelinesIndicationCodeableconcept(
            _,
          ) -> "Codeableconcept"
          MedicationknowledgeAdministrationguidelinesIndicationReference(_) ->
            "Reference"
        },
        medicationknowledge_administrationguidelines_indication_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case dosage {
    [] -> fields
    _ -> [
      #(
        "dosage",
        json.array(
          dosage,
          medicationknowledge_administrationguidelines_dosage_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn medicationknowledge_administrationguidelines_decoder() -> Decoder(
  MedicationknowledgeAdministrationguidelines,
) {
  use patient_characteristics <- decode.optional_field(
    "patientCharacteristics",
    [],
    decode.list(
      medicationknowledge_administrationguidelines_patientcharacteristics_decoder(),
    ),
  )
  use indication <- decode.then(
    none_if_omitted(
      medicationknowledge_administrationguidelines_indication_decoder(),
    ),
  )
  use dosage <- decode.optional_field(
    "dosage",
    [],
    decode.list(medicationknowledge_administrationguidelines_dosage_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MedicationknowledgeAdministrationguidelines(
    patient_characteristics:,
    indication:,
    dosage:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn medicationknowledge_monitoringprogram_to_json(
  medicationknowledge_monitoringprogram: MedicationknowledgeMonitoringprogram,
) -> Json {
  let MedicationknowledgeMonitoringprogram(
    name:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = medicationknowledge_monitoringprogram
  let fields = []
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn medicationknowledge_monitoringprogram_decoder() -> Decoder(
  MedicationknowledgeMonitoringprogram,
) {
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MedicationknowledgeMonitoringprogram(
    name:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn medicationknowledge_cost_to_json(
  medicationknowledge_cost: MedicationknowledgeCost,
) -> Json {
  let MedicationknowledgeCost(
    cost:,
    source:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = medicationknowledge_cost
  let fields = [
    #("cost", money_to_json(cost)),
    #("type", codeableconcept_to_json(type_)),
  ]
  let fields = case source {
    Some(v) -> [#("source", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn medicationknowledge_cost_decoder() -> Decoder(MedicationknowledgeCost) {
  use cost <- decode.field("cost", money_decoder())
  use source <- decode.optional_field(
    "source",
    None,
    decode.optional(decode.string),
  )
  use type_ <- decode.field("type", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MedicationknowledgeCost(
    cost:,
    source:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn medicationknowledge_ingredient_to_json(
  medicationknowledge_ingredient: MedicationknowledgeIngredient,
) -> Json {
  let MedicationknowledgeIngredient(
    strength:,
    is_active:,
    item:,
    modifier_extension:,
    extension:,
    id:,
  ) = medicationknowledge_ingredient
  let fields = [
    #("item", medicationknowledge_ingredient_item_to_json(item)),
  ]
  let fields = case strength {
    Some(v) -> [#("strength", ratio_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case is_active {
    Some(v) -> [#("isActive", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn medicationknowledge_ingredient_decoder() -> Decoder(
  MedicationknowledgeIngredient,
) {
  use strength <- decode.optional_field(
    "strength",
    None,
    decode.optional(ratio_decoder()),
  )
  use is_active <- decode.optional_field(
    "isActive",
    None,
    decode.optional(decode.bool),
  )
  use item <- decode.then(medicationknowledge_ingredient_item_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MedicationknowledgeIngredient(
    strength:,
    is_active:,
    item:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn medicationknowledge_monograph_to_json(
  medicationknowledge_monograph: MedicationknowledgeMonograph,
) -> Json {
  let MedicationknowledgeMonograph(
    source:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = medicationknowledge_monograph
  let fields = []
  let fields = case source {
    Some(v) -> [#("source", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn medicationknowledge_monograph_decoder() -> Decoder(
  MedicationknowledgeMonograph,
) {
  use source <- decode.optional_field(
    "source",
    None,
    decode.optional(reference_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MedicationknowledgeMonograph(
    source:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn medicationknowledge_relatedmedicationknowledge_to_json(
  medicationknowledge_relatedmedicationknowledge: MedicationknowledgeRelatedmedicationknowledge,
) -> Json {
  let MedicationknowledgeRelatedmedicationknowledge(
    reference:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = medicationknowledge_relatedmedicationknowledge
  let fields = [
    #("type", codeableconcept_to_json(type_)),
  ]
  let fields = case reference {
    [] -> fields
    _ -> [#("reference", json.array(reference, reference_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn medicationknowledge_relatedmedicationknowledge_decoder() -> Decoder(
  MedicationknowledgeRelatedmedicationknowledge,
) {
  use reference <- decode.optional_field(
    "reference",
    [],
    decode.list(reference_decoder()),
  )
  use type_ <- decode.field("type", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MedicationknowledgeRelatedmedicationknowledge(
    reference:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn medicationknowledge_to_json(
  medicationknowledge: Medicationknowledge,
) -> Json {
  let Medicationknowledge(
    kinetics:,
    regulatory:,
    contraindication:,
    drug_characteristic:,
    packaging:,
    medicine_classification:,
    administration_guidelines:,
    monitoring_program:,
    cost:,
    intended_route:,
    preparation_instruction:,
    ingredient:,
    monograph:,
    product_type:,
    associated_medication:,
    related_medication_knowledge:,
    synonym:,
    amount:,
    dose_form:,
    manufacturer:,
    status:,
    code:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = medicationknowledge
  let fields = []
  let fields = case kinetics {
    [] -> fields
    _ -> [
      #("kinetics", json.array(kinetics, medicationknowledge_kinetics_to_json)),
      ..fields
    ]
  }
  let fields = case regulatory {
    [] -> fields
    _ -> [
      #(
        "regulatory",
        json.array(regulatory, medicationknowledge_regulatory_to_json),
      ),
      ..fields
    ]
  }
  let fields = case contraindication {
    [] -> fields
    _ -> [
      #("contraindication", json.array(contraindication, reference_to_json)),
      ..fields
    ]
  }
  let fields = case drug_characteristic {
    [] -> fields
    _ -> [
      #(
        "drugCharacteristic",
        json.array(
          drug_characteristic,
          medicationknowledge_drugcharacteristic_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case packaging {
    Some(v) -> [
      #("packaging", medicationknowledge_packaging_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case medicine_classification {
    [] -> fields
    _ -> [
      #(
        "medicineClassification",
        json.array(
          medicine_classification,
          medicationknowledge_medicineclassification_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case administration_guidelines {
    [] -> fields
    _ -> [
      #(
        "administrationGuidelines",
        json.array(
          administration_guidelines,
          medicationknowledge_administrationguidelines_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case monitoring_program {
    [] -> fields
    _ -> [
      #(
        "monitoringProgram",
        json.array(
          monitoring_program,
          medicationknowledge_monitoringprogram_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case cost {
    [] -> fields
    _ -> [
      #("cost", json.array(cost, medicationknowledge_cost_to_json)),
      ..fields
    ]
  }
  let fields = case intended_route {
    [] -> fields
    _ -> [
      #("intendedRoute", json.array(intended_route, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case preparation_instruction {
    Some(v) -> [#("preparationInstruction", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case ingredient {
    [] -> fields
    _ -> [
      #(
        "ingredient",
        json.array(ingredient, medicationknowledge_ingredient_to_json),
      ),
      ..fields
    ]
  }
  let fields = case monograph {
    [] -> fields
    _ -> [
      #(
        "monograph",
        json.array(monograph, medicationknowledge_monograph_to_json),
      ),
      ..fields
    ]
  }
  let fields = case product_type {
    [] -> fields
    _ -> [
      #("productType", json.array(product_type, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case associated_medication {
    [] -> fields
    _ -> [
      #(
        "associatedMedication",
        json.array(associated_medication, reference_to_json),
      ),
      ..fields
    ]
  }
  let fields = case related_medication_knowledge {
    [] -> fields
    _ -> [
      #(
        "relatedMedicationKnowledge",
        json.array(
          related_medication_knowledge,
          medicationknowledge_relatedmedicationknowledge_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case synonym {
    [] -> fields
    _ -> [#("synonym", json.array(synonym, json.string)), ..fields]
  }
  let fields = case amount {
    Some(v) -> [#("amount", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case dose_form {
    Some(v) -> [#("doseForm", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case manufacturer {
    Some(v) -> [#("manufacturer", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case status {
    Some(v) -> [
      #("status", r4bvaluesets.medicationknowledgestatus_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case code {
    Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Medicationknowledge")), ..fields]
  json.object(fields)
}

pub fn medicationknowledge_decoder() -> Decoder(Medicationknowledge) {
  use kinetics <- decode.optional_field(
    "kinetics",
    [],
    decode.list(medicationknowledge_kinetics_decoder()),
  )
  use regulatory <- decode.optional_field(
    "regulatory",
    [],
    decode.list(medicationknowledge_regulatory_decoder()),
  )
  use contraindication <- decode.optional_field(
    "contraindication",
    [],
    decode.list(reference_decoder()),
  )
  use drug_characteristic <- decode.optional_field(
    "drugCharacteristic",
    [],
    decode.list(medicationknowledge_drugcharacteristic_decoder()),
  )
  use packaging <- decode.optional_field(
    "packaging",
    None,
    decode.optional(medicationknowledge_packaging_decoder()),
  )
  use medicine_classification <- decode.optional_field(
    "medicineClassification",
    [],
    decode.list(medicationknowledge_medicineclassification_decoder()),
  )
  use administration_guidelines <- decode.optional_field(
    "administrationGuidelines",
    [],
    decode.list(medicationknowledge_administrationguidelines_decoder()),
  )
  use monitoring_program <- decode.optional_field(
    "monitoringProgram",
    [],
    decode.list(medicationknowledge_monitoringprogram_decoder()),
  )
  use cost <- decode.optional_field(
    "cost",
    [],
    decode.list(medicationknowledge_cost_decoder()),
  )
  use intended_route <- decode.optional_field(
    "intendedRoute",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use preparation_instruction <- decode.optional_field(
    "preparationInstruction",
    None,
    decode.optional(decode.string),
  )
  use ingredient <- decode.optional_field(
    "ingredient",
    [],
    decode.list(medicationknowledge_ingredient_decoder()),
  )
  use monograph <- decode.optional_field(
    "monograph",
    [],
    decode.list(medicationknowledge_monograph_decoder()),
  )
  use product_type <- decode.optional_field(
    "productType",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use associated_medication <- decode.optional_field(
    "associatedMedication",
    [],
    decode.list(reference_decoder()),
  )
  use related_medication_knowledge <- decode.optional_field(
    "relatedMedicationKnowledge",
    [],
    decode.list(medicationknowledge_relatedmedicationknowledge_decoder()),
  )
  use synonym <- decode.optional_field(
    "synonym",
    [],
    decode.list(decode.string),
  )
  use amount <- decode.optional_field(
    "amount",
    None,
    decode.optional(quantity_decoder()),
  )
  use dose_form <- decode.optional_field(
    "doseForm",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use manufacturer <- decode.optional_field(
    "manufacturer",
    None,
    decode.optional(reference_decoder()),
  )
  use status <- decode.optional_field(
    "status",
    None,
    decode.optional(r4bvaluesets.medicationknowledgestatus_decoder()),
  )
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Medicationknowledge",
    decode.failure(medicationknowledge_new(), "resourceType"),
  )
  decode.success(Medicationknowledge(
    kinetics:,
    regulatory:,
    contraindication:,
    drug_characteristic:,
    packaging:,
    medicine_classification:,
    administration_guidelines:,
    monitoring_program:,
    cost:,
    intended_route:,
    preparation_instruction:,
    ingredient:,
    monograph:,
    product_type:,
    associated_medication:,
    related_medication_knowledge:,
    synonym:,
    amount:,
    dose_form:,
    manufacturer:,
    status:,
    code:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/MedicationRequest#resource
pub type Medicationrequest {
  Medicationrequest(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    status: r4bvaluesets.Medicationrequeststatus,
    status_reason: Option(Codeableconcept),
    intent: r4bvaluesets.Medicationrequestintent,
    category: List(Codeableconcept),
    priority: Option(r4bvaluesets.Requestpriority),
    do_not_perform: Option(Bool),
    reported: Option(MedicationrequestReported),
    medication: MedicationrequestMedication,
    subject: Reference,
    encounter: Option(Reference),
    supporting_information: List(Reference),
    authored_on: Option(String),
    requester: Option(Reference),
    performer: Option(Reference),
    performer_type: Option(Codeableconcept),
    recorder: Option(Reference),
    reason_code: List(Codeableconcept),
    reason_reference: List(Reference),
    instantiates_canonical: List(String),
    instantiates_uri: List(String),
    based_on: List(Reference),
    group_identifier: Option(Identifier),
    course_of_therapy_type: Option(Codeableconcept),
    insurance: List(Reference),
    note: List(Annotation),
    dosage_instruction: List(Dosage),
    dispense_request: Option(MedicationrequestDispenserequest),
    substitution: Option(MedicationrequestSubstitution),
    prior_prescription: Option(Reference),
    detected_issue: List(Reference),
    event_history: List(Reference),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/MedicationRequest#resource
pub type MedicationrequestReported {
  MedicationrequestReportedBoolean(reported: Bool)
  MedicationrequestReportedReference(reported: Reference)
}

pub fn medicationrequest_reported_to_json(
  elt: MedicationrequestReported,
) -> Json {
  case elt {
    MedicationrequestReportedBoolean(v) -> json.bool(v)
    MedicationrequestReportedReference(v) -> reference_to_json(v)
  }
}

pub fn medicationrequest_reported_decoder() -> Decoder(
  MedicationrequestReported,
) {
  decode.one_of(
    decode.field("reportedBoolean", decode.bool, decode.success)
      |> decode.map(MedicationrequestReportedBoolean),
    [
      decode.field("reportedReference", reference_decoder(), decode.success)
      |> decode.map(MedicationrequestReportedReference),
    ],
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/MedicationRequest#resource
pub type MedicationrequestMedication {
  MedicationrequestMedicationCodeableconcept(medication: Codeableconcept)
  MedicationrequestMedicationReference(medication: Reference)
}

pub fn medicationrequest_medication_to_json(
  elt: MedicationrequestMedication,
) -> Json {
  case elt {
    MedicationrequestMedicationCodeableconcept(v) -> codeableconcept_to_json(v)
    MedicationrequestMedicationReference(v) -> reference_to_json(v)
  }
}

pub fn medicationrequest_medication_decoder() -> Decoder(
  MedicationrequestMedication,
) {
  decode.one_of(
    decode.field(
      "medicationCodeableConcept",
      codeableconcept_decoder(),
      decode.success,
    )
      |> decode.map(MedicationrequestMedicationCodeableconcept),
    [
      decode.field("medicationReference", reference_decoder(), decode.success)
      |> decode.map(MedicationrequestMedicationReference),
    ],
  )
}

pub fn medicationrequest_new(
  subject subject: Reference,
  medication medication: MedicationrequestMedication,
  intent intent: r4bvaluesets.Medicationrequestintent,
  status status: r4bvaluesets.Medicationrequeststatus,
) -> Medicationrequest {
  Medicationrequest(
    event_history: [],
    detected_issue: [],
    prior_prescription: None,
    substitution: None,
    dispense_request: None,
    dosage_instruction: [],
    note: [],
    insurance: [],
    course_of_therapy_type: None,
    group_identifier: None,
    based_on: [],
    instantiates_uri: [],
    instantiates_canonical: [],
    reason_reference: [],
    reason_code: [],
    recorder: None,
    performer_type: None,
    performer: None,
    requester: None,
    authored_on: None,
    supporting_information: [],
    encounter: None,
    subject:,
    medication:,
    reported: None,
    do_not_perform: None,
    priority: None,
    category: [],
    intent:,
    status_reason: None,
    status:,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/MedicationRequest#resource
pub type MedicationrequestDispenserequest {
  MedicationrequestDispenserequest(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    initial_fill: Option(MedicationrequestDispenserequestInitialfill),
    dispense_interval: Option(Duration),
    validity_period: Option(Period),
    number_of_repeats_allowed: Option(Int),
    quantity: Option(Quantity),
    expected_supply_duration: Option(Duration),
    performer: Option(Reference),
  )
}

pub fn medicationrequest_dispenserequest_new() -> MedicationrequestDispenserequest {
  MedicationrequestDispenserequest(
    performer: None,
    expected_supply_duration: None,
    quantity: None,
    number_of_repeats_allowed: None,
    validity_period: None,
    dispense_interval: None,
    initial_fill: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/MedicationRequest#resource
pub type MedicationrequestDispenserequestInitialfill {
  MedicationrequestDispenserequestInitialfill(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    quantity: Option(Quantity),
    duration: Option(Duration),
  )
}

pub fn medicationrequest_dispenserequest_initialfill_new() -> MedicationrequestDispenserequestInitialfill {
  MedicationrequestDispenserequestInitialfill(
    duration: None,
    quantity: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/MedicationRequest#resource
pub type MedicationrequestSubstitution {
  MedicationrequestSubstitution(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    allowed: MedicationrequestSubstitutionAllowed,
    reason: Option(Codeableconcept),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/MedicationRequest#resource
pub type MedicationrequestSubstitutionAllowed {
  MedicationrequestSubstitutionAllowedBoolean(allowed: Bool)
  MedicationrequestSubstitutionAllowedCodeableconcept(allowed: Codeableconcept)
}

pub fn medicationrequest_substitution_allowed_to_json(
  elt: MedicationrequestSubstitutionAllowed,
) -> Json {
  case elt {
    MedicationrequestSubstitutionAllowedBoolean(v) -> json.bool(v)
    MedicationrequestSubstitutionAllowedCodeableconcept(v) ->
      codeableconcept_to_json(v)
  }
}

pub fn medicationrequest_substitution_allowed_decoder() -> Decoder(
  MedicationrequestSubstitutionAllowed,
) {
  decode.one_of(
    decode.field("allowedBoolean", decode.bool, decode.success)
      |> decode.map(MedicationrequestSubstitutionAllowedBoolean),
    [
      decode.field(
        "allowedCodeableConcept",
        codeableconcept_decoder(),
        decode.success,
      )
      |> decode.map(MedicationrequestSubstitutionAllowedCodeableconcept),
    ],
  )
}

pub fn medicationrequest_substitution_new(
  allowed allowed: MedicationrequestSubstitutionAllowed,
) -> MedicationrequestSubstitution {
  MedicationrequestSubstitution(
    reason: None,
    allowed:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn medicationrequest_substitution_to_json(
  medicationrequest_substitution: MedicationrequestSubstitution,
) -> Json {
  let MedicationrequestSubstitution(
    reason:,
    allowed:,
    modifier_extension:,
    extension:,
    id:,
  ) = medicationrequest_substitution
  let fields = [
    #("allowed", medicationrequest_substitution_allowed_to_json(allowed)),
  ]
  let fields = case reason {
    Some(v) -> [#("reason", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn medicationrequest_substitution_decoder() -> Decoder(
  MedicationrequestSubstitution,
) {
  use reason <- decode.optional_field(
    "reason",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use allowed <- decode.then(medicationrequest_substitution_allowed_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MedicationrequestSubstitution(
    reason:,
    allowed:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn medicationrequest_dispenserequest_initialfill_to_json(
  medicationrequest_dispenserequest_initialfill: MedicationrequestDispenserequestInitialfill,
) -> Json {
  let MedicationrequestDispenserequestInitialfill(
    duration:,
    quantity:,
    modifier_extension:,
    extension:,
    id:,
  ) = medicationrequest_dispenserequest_initialfill
  let fields = []
  let fields = case duration {
    Some(v) -> [#("duration", duration_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case quantity {
    Some(v) -> [#("quantity", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn medicationrequest_dispenserequest_initialfill_decoder() -> Decoder(
  MedicationrequestDispenserequestInitialfill,
) {
  use duration <- decode.optional_field(
    "duration",
    None,
    decode.optional(duration_decoder()),
  )
  use quantity <- decode.optional_field(
    "quantity",
    None,
    decode.optional(quantity_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MedicationrequestDispenserequestInitialfill(
    duration:,
    quantity:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn medicationrequest_dispenserequest_to_json(
  medicationrequest_dispenserequest: MedicationrequestDispenserequest,
) -> Json {
  let MedicationrequestDispenserequest(
    performer:,
    expected_supply_duration:,
    quantity:,
    number_of_repeats_allowed:,
    validity_period:,
    dispense_interval:,
    initial_fill:,
    modifier_extension:,
    extension:,
    id:,
  ) = medicationrequest_dispenserequest
  let fields = []
  let fields = case performer {
    Some(v) -> [#("performer", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case expected_supply_duration {
    Some(v) -> [#("expectedSupplyDuration", duration_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case quantity {
    Some(v) -> [#("quantity", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case number_of_repeats_allowed {
    Some(v) -> [#("numberOfRepeatsAllowed", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case validity_period {
    Some(v) -> [#("validityPeriod", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case dispense_interval {
    Some(v) -> [#("dispenseInterval", duration_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case initial_fill {
    Some(v) -> [
      #("initialFill", medicationrequest_dispenserequest_initialfill_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn medicationrequest_dispenserequest_decoder() -> Decoder(
  MedicationrequestDispenserequest,
) {
  use performer <- decode.optional_field(
    "performer",
    None,
    decode.optional(reference_decoder()),
  )
  use expected_supply_duration <- decode.optional_field(
    "expectedSupplyDuration",
    None,
    decode.optional(duration_decoder()),
  )
  use quantity <- decode.optional_field(
    "quantity",
    None,
    decode.optional(quantity_decoder()),
  )
  use number_of_repeats_allowed <- decode.optional_field(
    "numberOfRepeatsAllowed",
    None,
    decode.optional(decode.int),
  )
  use validity_period <- decode.optional_field(
    "validityPeriod",
    None,
    decode.optional(period_decoder()),
  )
  use dispense_interval <- decode.optional_field(
    "dispenseInterval",
    None,
    decode.optional(duration_decoder()),
  )
  use initial_fill <- decode.optional_field(
    "initialFill",
    None,
    decode.optional(medicationrequest_dispenserequest_initialfill_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MedicationrequestDispenserequest(
    performer:,
    expected_supply_duration:,
    quantity:,
    number_of_repeats_allowed:,
    validity_period:,
    dispense_interval:,
    initial_fill:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn medicationrequest_to_json(medicationrequest: Medicationrequest) -> Json {
  let Medicationrequest(
    event_history:,
    detected_issue:,
    prior_prescription:,
    substitution:,
    dispense_request:,
    dosage_instruction:,
    note:,
    insurance:,
    course_of_therapy_type:,
    group_identifier:,
    based_on:,
    instantiates_uri:,
    instantiates_canonical:,
    reason_reference:,
    reason_code:,
    recorder:,
    performer_type:,
    performer:,
    requester:,
    authored_on:,
    supporting_information:,
    encounter:,
    subject:,
    medication:,
    reported:,
    do_not_perform:,
    priority:,
    category:,
    intent:,
    status_reason:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = medicationrequest
  let fields = [
    #("subject", reference_to_json(subject)),
    #("medication", medicationrequest_medication_to_json(medication)),
    #("intent", r4bvaluesets.medicationrequestintent_to_json(intent)),
    #("status", r4bvaluesets.medicationrequeststatus_to_json(status)),
  ]
  let fields = case event_history {
    [] -> fields
    _ -> [
      #("eventHistory", json.array(event_history, reference_to_json)),
      ..fields
    ]
  }
  let fields = case detected_issue {
    [] -> fields
    _ -> [
      #("detectedIssue", json.array(detected_issue, reference_to_json)),
      ..fields
    ]
  }
  let fields = case prior_prescription {
    Some(v) -> [#("priorPrescription", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case substitution {
    Some(v) -> [
      #("substitution", medicationrequest_substitution_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case dispense_request {
    Some(v) -> [
      #("dispenseRequest", medicationrequest_dispenserequest_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case dosage_instruction {
    [] -> fields
    _ -> [
      #("dosageInstruction", json.array(dosage_instruction, dosage_to_json)),
      ..fields
    ]
  }
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case insurance {
    [] -> fields
    _ -> [#("insurance", json.array(insurance, reference_to_json)), ..fields]
  }
  let fields = case course_of_therapy_type {
    Some(v) -> [#("courseOfTherapyType", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case group_identifier {
    Some(v) -> [#("groupIdentifier", identifier_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case based_on {
    [] -> fields
    _ -> [#("basedOn", json.array(based_on, reference_to_json)), ..fields]
  }
  let fields = case instantiates_uri {
    [] -> fields
    _ -> [
      #("instantiatesUri", json.array(instantiates_uri, json.string)),
      ..fields
    ]
  }
  let fields = case instantiates_canonical {
    [] -> fields
    _ -> [
      #(
        "instantiatesCanonical",
        json.array(instantiates_canonical, json.string),
      ),
      ..fields
    ]
  }
  let fields = case reason_reference {
    [] -> fields
    _ -> [
      #("reasonReference", json.array(reason_reference, reference_to_json)),
      ..fields
    ]
  }
  let fields = case reason_code {
    [] -> fields
    _ -> [
      #("reasonCode", json.array(reason_code, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case recorder {
    Some(v) -> [#("recorder", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case performer_type {
    Some(v) -> [#("performerType", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case performer {
    Some(v) -> [#("performer", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case requester {
    Some(v) -> [#("requester", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case authored_on {
    Some(v) -> [#("authoredOn", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case supporting_information {
    [] -> fields
    _ -> [
      #(
        "supportingInformation",
        json.array(supporting_information, reference_to_json),
      ),
      ..fields
    ]
  }
  let fields = case encounter {
    Some(v) -> [#("encounter", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case reported {
    Some(v) -> [
      #(
        "reported"
          <> case v {
          MedicationrequestReportedBoolean(_) -> "Boolean"
          MedicationrequestReportedReference(_) -> "Reference"
        },
        medicationrequest_reported_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case do_not_perform {
    Some(v) -> [#("doNotPerform", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case priority {
    Some(v) -> [
      #("priority", r4bvaluesets.requestpriority_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case category {
    [] -> fields
    _ -> [
      #("category", json.array(category, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case status_reason {
    Some(v) -> [#("statusReason", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Medicationrequest")), ..fields]
  json.object(fields)
}

pub fn medicationrequest_decoder() -> Decoder(Medicationrequest) {
  use event_history <- decode.optional_field(
    "eventHistory",
    [],
    decode.list(reference_decoder()),
  )
  use detected_issue <- decode.optional_field(
    "detectedIssue",
    [],
    decode.list(reference_decoder()),
  )
  use prior_prescription <- decode.optional_field(
    "priorPrescription",
    None,
    decode.optional(reference_decoder()),
  )
  use substitution <- decode.optional_field(
    "substitution",
    None,
    decode.optional(medicationrequest_substitution_decoder()),
  )
  use dispense_request <- decode.optional_field(
    "dispenseRequest",
    None,
    decode.optional(medicationrequest_dispenserequest_decoder()),
  )
  use dosage_instruction <- decode.optional_field(
    "dosageInstruction",
    [],
    decode.list(dosage_decoder()),
  )
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use insurance <- decode.optional_field(
    "insurance",
    [],
    decode.list(reference_decoder()),
  )
  use course_of_therapy_type <- decode.optional_field(
    "courseOfTherapyType",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use group_identifier <- decode.optional_field(
    "groupIdentifier",
    None,
    decode.optional(identifier_decoder()),
  )
  use based_on <- decode.optional_field(
    "basedOn",
    [],
    decode.list(reference_decoder()),
  )
  use instantiates_uri <- decode.optional_field(
    "instantiatesUri",
    [],
    decode.list(decode.string),
  )
  use instantiates_canonical <- decode.optional_field(
    "instantiatesCanonical",
    [],
    decode.list(decode.string),
  )
  use reason_reference <- decode.optional_field(
    "reasonReference",
    [],
    decode.list(reference_decoder()),
  )
  use reason_code <- decode.optional_field(
    "reasonCode",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use recorder <- decode.optional_field(
    "recorder",
    None,
    decode.optional(reference_decoder()),
  )
  use performer_type <- decode.optional_field(
    "performerType",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use performer <- decode.optional_field(
    "performer",
    None,
    decode.optional(reference_decoder()),
  )
  use requester <- decode.optional_field(
    "requester",
    None,
    decode.optional(reference_decoder()),
  )
  use authored_on <- decode.optional_field(
    "authoredOn",
    None,
    decode.optional(decode.string),
  )
  use supporting_information <- decode.optional_field(
    "supportingInformation",
    [],
    decode.list(reference_decoder()),
  )
  use encounter <- decode.optional_field(
    "encounter",
    None,
    decode.optional(reference_decoder()),
  )
  use subject <- decode.field("subject", reference_decoder())
  use medication <- decode.then(medicationrequest_medication_decoder())
  use reported <- decode.then(
    none_if_omitted(medicationrequest_reported_decoder()),
  )
  use do_not_perform <- decode.optional_field(
    "doNotPerform",
    None,
    decode.optional(decode.bool),
  )
  use priority <- decode.optional_field(
    "priority",
    None,
    decode.optional(r4bvaluesets.requestpriority_decoder()),
  )
  use category <- decode.optional_field(
    "category",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use intent <- decode.field(
    "intent",
    r4bvaluesets.medicationrequestintent_decoder(),
  )
  use status_reason <- decode.optional_field(
    "statusReason",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use status <- decode.field(
    "status",
    r4bvaluesets.medicationrequeststatus_decoder(),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Medicationrequest",
    decode.failure(
      medicationrequest_new(subject:, medication:, intent:, status:),
      "resourceType",
    ),
  )
  decode.success(Medicationrequest(
    event_history:,
    detected_issue:,
    prior_prescription:,
    substitution:,
    dispense_request:,
    dosage_instruction:,
    note:,
    insurance:,
    course_of_therapy_type:,
    group_identifier:,
    based_on:,
    instantiates_uri:,
    instantiates_canonical:,
    reason_reference:,
    reason_code:,
    recorder:,
    performer_type:,
    performer:,
    requester:,
    authored_on:,
    supporting_information:,
    encounter:,
    subject:,
    medication:,
    reported:,
    do_not_perform:,
    priority:,
    category:,
    intent:,
    status_reason:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/MedicationStatement#resource
pub type Medicationstatement {
  Medicationstatement(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    based_on: List(Reference),
    part_of: List(Reference),
    status: r4bvaluesets.Medicationstatementstatus,
    status_reason: List(Codeableconcept),
    category: Option(Codeableconcept),
    medication: MedicationstatementMedication,
    subject: Reference,
    context: Option(Reference),
    effective: Option(MedicationstatementEffective),
    date_asserted: Option(String),
    information_source: Option(Reference),
    derived_from: List(Reference),
    reason_code: List(Codeableconcept),
    reason_reference: List(Reference),
    note: List(Annotation),
    dosage: List(Dosage),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/MedicationStatement#resource
pub type MedicationstatementMedication {
  MedicationstatementMedicationCodeableconcept(medication: Codeableconcept)
  MedicationstatementMedicationReference(medication: Reference)
}

pub fn medicationstatement_medication_to_json(
  elt: MedicationstatementMedication,
) -> Json {
  case elt {
    MedicationstatementMedicationCodeableconcept(v) ->
      codeableconcept_to_json(v)
    MedicationstatementMedicationReference(v) -> reference_to_json(v)
  }
}

pub fn medicationstatement_medication_decoder() -> Decoder(
  MedicationstatementMedication,
) {
  decode.one_of(
    decode.field(
      "medicationCodeableConcept",
      codeableconcept_decoder(),
      decode.success,
    )
      |> decode.map(MedicationstatementMedicationCodeableconcept),
    [
      decode.field("medicationReference", reference_decoder(), decode.success)
      |> decode.map(MedicationstatementMedicationReference),
    ],
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/MedicationStatement#resource
pub type MedicationstatementEffective {
  MedicationstatementEffectiveDatetime(effective: String)
  MedicationstatementEffectivePeriod(effective: Period)
}

pub fn medicationstatement_effective_to_json(
  elt: MedicationstatementEffective,
) -> Json {
  case elt {
    MedicationstatementEffectiveDatetime(v) -> json.string(v)
    MedicationstatementEffectivePeriod(v) -> period_to_json(v)
  }
}

pub fn medicationstatement_effective_decoder() -> Decoder(
  MedicationstatementEffective,
) {
  decode.one_of(
    decode.field("effectiveDateTime", decode.string, decode.success)
      |> decode.map(MedicationstatementEffectiveDatetime),
    [
      decode.field("effectivePeriod", period_decoder(), decode.success)
      |> decode.map(MedicationstatementEffectivePeriod),
    ],
  )
}

pub fn medicationstatement_new(
  subject subject: Reference,
  medication medication: MedicationstatementMedication,
  status status: r4bvaluesets.Medicationstatementstatus,
) -> Medicationstatement {
  Medicationstatement(
    dosage: [],
    note: [],
    reason_reference: [],
    reason_code: [],
    derived_from: [],
    information_source: None,
    date_asserted: None,
    effective: None,
    context: None,
    subject:,
    medication:,
    category: None,
    status_reason: [],
    status:,
    part_of: [],
    based_on: [],
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

pub fn medicationstatement_to_json(
  medicationstatement: Medicationstatement,
) -> Json {
  let Medicationstatement(
    dosage:,
    note:,
    reason_reference:,
    reason_code:,
    derived_from:,
    information_source:,
    date_asserted:,
    effective:,
    context:,
    subject:,
    medication:,
    category:,
    status_reason:,
    status:,
    part_of:,
    based_on:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = medicationstatement
  let fields = [
    #("subject", reference_to_json(subject)),
    #("medication", medicationstatement_medication_to_json(medication)),
    #("status", r4bvaluesets.medicationstatementstatus_to_json(status)),
  ]
  let fields = case dosage {
    [] -> fields
    _ -> [#("dosage", json.array(dosage, dosage_to_json)), ..fields]
  }
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case reason_reference {
    [] -> fields
    _ -> [
      #("reasonReference", json.array(reason_reference, reference_to_json)),
      ..fields
    ]
  }
  let fields = case reason_code {
    [] -> fields
    _ -> [
      #("reasonCode", json.array(reason_code, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case derived_from {
    [] -> fields
    _ -> [
      #("derivedFrom", json.array(derived_from, reference_to_json)),
      ..fields
    ]
  }
  let fields = case information_source {
    Some(v) -> [#("informationSource", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case date_asserted {
    Some(v) -> [#("dateAsserted", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case effective {
    Some(v) -> [
      #(
        "effective"
          <> case v {
          MedicationstatementEffectiveDatetime(_) -> "Datetime"
          MedicationstatementEffectivePeriod(_) -> "Period"
        },
        medicationstatement_effective_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case context {
    Some(v) -> [#("context", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case category {
    Some(v) -> [#("category", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case status_reason {
    [] -> fields
    _ -> [
      #("statusReason", json.array(status_reason, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case part_of {
    [] -> fields
    _ -> [#("partOf", json.array(part_of, reference_to_json)), ..fields]
  }
  let fields = case based_on {
    [] -> fields
    _ -> [#("basedOn", json.array(based_on, reference_to_json)), ..fields]
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Medicationstatement")), ..fields]
  json.object(fields)
}

pub fn medicationstatement_decoder() -> Decoder(Medicationstatement) {
  use dosage <- decode.optional_field(
    "dosage",
    [],
    decode.list(dosage_decoder()),
  )
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use reason_reference <- decode.optional_field(
    "reasonReference",
    [],
    decode.list(reference_decoder()),
  )
  use reason_code <- decode.optional_field(
    "reasonCode",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use derived_from <- decode.optional_field(
    "derivedFrom",
    [],
    decode.list(reference_decoder()),
  )
  use information_source <- decode.optional_field(
    "informationSource",
    None,
    decode.optional(reference_decoder()),
  )
  use date_asserted <- decode.optional_field(
    "dateAsserted",
    None,
    decode.optional(decode.string),
  )
  use effective <- decode.then(
    none_if_omitted(medicationstatement_effective_decoder()),
  )
  use context <- decode.optional_field(
    "context",
    None,
    decode.optional(reference_decoder()),
  )
  use subject <- decode.field("subject", reference_decoder())
  use medication <- decode.then(medicationstatement_medication_decoder())
  use category <- decode.optional_field(
    "category",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use status_reason <- decode.optional_field(
    "statusReason",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use status <- decode.field(
    "status",
    r4bvaluesets.medicationstatementstatus_decoder(),
  )
  use part_of <- decode.optional_field(
    "partOf",
    [],
    decode.list(reference_decoder()),
  )
  use based_on <- decode.optional_field(
    "basedOn",
    [],
    decode.list(reference_decoder()),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Medicationstatement",
    decode.failure(
      medicationstatement_new(subject:, medication:, status:),
      "resourceType",
    ),
  )
  decode.success(Medicationstatement(
    dosage:,
    note:,
    reason_reference:,
    reason_code:,
    derived_from:,
    information_source:,
    date_asserted:,
    effective:,
    context:,
    subject:,
    medication:,
    category:,
    status_reason:,
    status:,
    part_of:,
    based_on:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/MedicinalProductDefinition#resource
pub type Medicinalproductdefinition {
  Medicinalproductdefinition(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    type_: Option(Codeableconcept),
    domain: Option(Codeableconcept),
    version: Option(String),
    status: Option(Codeableconcept),
    status_date: Option(String),
    description: Option(String),
    combined_pharmaceutical_dose_form: Option(Codeableconcept),
    route: List(Codeableconcept),
    indication: Option(String),
    legal_status_of_supply: Option(Codeableconcept),
    additional_monitoring_indicator: Option(Codeableconcept),
    special_measures: List(Codeableconcept),
    pediatric_use_indicator: Option(Codeableconcept),
    classification: List(Codeableconcept),
    marketing_status: List(Marketingstatus),
    packaged_medicinal_product: List(Codeableconcept),
    ingredient: List(Codeableconcept),
    impurity: List(Codeablereference),
    attached_document: List(Reference),
    master_file: List(Reference),
    contact: List(MedicinalproductdefinitionContact),
    clinical_trial: List(Reference),
    code: List(Coding),
    name: List(MedicinalproductdefinitionName),
    cross_reference: List(MedicinalproductdefinitionCrossreference),
    operation: List(MedicinalproductdefinitionOperation),
    characteristic: List(MedicinalproductdefinitionCharacteristic),
  )
}

pub fn medicinalproductdefinition_new() -> Medicinalproductdefinition {
  Medicinalproductdefinition(
    characteristic: [],
    operation: [],
    cross_reference: [],
    name: [],
    code: [],
    clinical_trial: [],
    contact: [],
    master_file: [],
    attached_document: [],
    impurity: [],
    ingredient: [],
    packaged_medicinal_product: [],
    marketing_status: [],
    classification: [],
    pediatric_use_indicator: None,
    special_measures: [],
    additional_monitoring_indicator: None,
    legal_status_of_supply: None,
    indication: None,
    route: [],
    combined_pharmaceutical_dose_form: None,
    description: None,
    status_date: None,
    status: None,
    version: None,
    domain: None,
    type_: None,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/MedicinalProductDefinition#resource
pub type MedicinalproductdefinitionContact {
  MedicinalproductdefinitionContact(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Option(Codeableconcept),
    contact: Reference,
  )
}

pub fn medicinalproductdefinition_contact_new(
  contact contact: Reference,
) -> MedicinalproductdefinitionContact {
  MedicinalproductdefinitionContact(
    contact:,
    type_: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/MedicinalProductDefinition#resource
pub type MedicinalproductdefinitionName {
  MedicinalproductdefinitionName(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    product_name: String,
    type_: Option(Codeableconcept),
    name_part: List(MedicinalproductdefinitionNameNamepart),
    country_language: List(MedicinalproductdefinitionNameCountrylanguage),
  )
}

pub fn medicinalproductdefinition_name_new(
  product_name product_name: String,
) -> MedicinalproductdefinitionName {
  MedicinalproductdefinitionName(
    country_language: [],
    name_part: [],
    type_: None,
    product_name:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/MedicinalProductDefinition#resource
pub type MedicinalproductdefinitionNameNamepart {
  MedicinalproductdefinitionNameNamepart(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    part: String,
    type_: Codeableconcept,
  )
}

pub fn medicinalproductdefinition_name_namepart_new(
  type_ type_: Codeableconcept,
  part part: String,
) -> MedicinalproductdefinitionNameNamepart {
  MedicinalproductdefinitionNameNamepart(
    type_:,
    part:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/MedicinalProductDefinition#resource
pub type MedicinalproductdefinitionNameCountrylanguage {
  MedicinalproductdefinitionNameCountrylanguage(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    country: Codeableconcept,
    jurisdiction: Option(Codeableconcept),
    language: Codeableconcept,
  )
}

pub fn medicinalproductdefinition_name_countrylanguage_new(
  language language: Codeableconcept,
  country country: Codeableconcept,
) -> MedicinalproductdefinitionNameCountrylanguage {
  MedicinalproductdefinitionNameCountrylanguage(
    language:,
    jurisdiction: None,
    country:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/MedicinalProductDefinition#resource
pub type MedicinalproductdefinitionCrossreference {
  MedicinalproductdefinitionCrossreference(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    product: Codeablereference,
    type_: Option(Codeableconcept),
  )
}

pub fn medicinalproductdefinition_crossreference_new(
  product product: Codeablereference,
) -> MedicinalproductdefinitionCrossreference {
  MedicinalproductdefinitionCrossreference(
    type_: None,
    product:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/MedicinalProductDefinition#resource
pub type MedicinalproductdefinitionOperation {
  MedicinalproductdefinitionOperation(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Option(Codeablereference),
    effective_date: Option(Period),
    organization: List(Reference),
    confidentiality_indicator: Option(Codeableconcept),
  )
}

pub fn medicinalproductdefinition_operation_new() -> MedicinalproductdefinitionOperation {
  MedicinalproductdefinitionOperation(
    confidentiality_indicator: None,
    organization: [],
    effective_date: None,
    type_: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/MedicinalProductDefinition#resource
pub type MedicinalproductdefinitionCharacteristic {
  MedicinalproductdefinitionCharacteristic(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Codeableconcept,
    value: Option(MedicinalproductdefinitionCharacteristicValue),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/MedicinalProductDefinition#resource
pub type MedicinalproductdefinitionCharacteristicValue {
  MedicinalproductdefinitionCharacteristicValueCodeableconcept(
    value: Codeableconcept,
  )
  MedicinalproductdefinitionCharacteristicValueQuantity(value: Quantity)
  MedicinalproductdefinitionCharacteristicValueDate(value: String)
  MedicinalproductdefinitionCharacteristicValueBoolean(value: Bool)
  MedicinalproductdefinitionCharacteristicValueAttachment(value: Attachment)
}

pub fn medicinalproductdefinition_characteristic_value_to_json(
  elt: MedicinalproductdefinitionCharacteristicValue,
) -> Json {
  case elt {
    MedicinalproductdefinitionCharacteristicValueCodeableconcept(v) ->
      codeableconcept_to_json(v)
    MedicinalproductdefinitionCharacteristicValueQuantity(v) ->
      quantity_to_json(v)
    MedicinalproductdefinitionCharacteristicValueDate(v) -> json.string(v)
    MedicinalproductdefinitionCharacteristicValueBoolean(v) -> json.bool(v)
    MedicinalproductdefinitionCharacteristicValueAttachment(v) ->
      attachment_to_json(v)
  }
}

pub fn medicinalproductdefinition_characteristic_value_decoder() -> Decoder(
  MedicinalproductdefinitionCharacteristicValue,
) {
  decode.one_of(
    decode.field(
      "valueCodeableConcept",
      codeableconcept_decoder(),
      decode.success,
    )
      |> decode.map(
        MedicinalproductdefinitionCharacteristicValueCodeableconcept,
      ),
    [
      decode.field("valueQuantity", quantity_decoder(), decode.success)
        |> decode.map(MedicinalproductdefinitionCharacteristicValueQuantity),
      decode.field("valueDate", decode.string, decode.success)
        |> decode.map(MedicinalproductdefinitionCharacteristicValueDate),
      decode.field("valueBoolean", decode.bool, decode.success)
        |> decode.map(MedicinalproductdefinitionCharacteristicValueBoolean),
      decode.field("valueAttachment", attachment_decoder(), decode.success)
        |> decode.map(MedicinalproductdefinitionCharacteristicValueAttachment),
    ],
  )
}

pub fn medicinalproductdefinition_characteristic_new(
  type_ type_: Codeableconcept,
) -> MedicinalproductdefinitionCharacteristic {
  MedicinalproductdefinitionCharacteristic(
    value: None,
    type_:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn medicinalproductdefinition_characteristic_to_json(
  medicinalproductdefinition_characteristic: MedicinalproductdefinitionCharacteristic,
) -> Json {
  let MedicinalproductdefinitionCharacteristic(
    value:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = medicinalproductdefinition_characteristic
  let fields = [
    #("type", codeableconcept_to_json(type_)),
  ]
  let fields = case value {
    Some(v) -> [
      #(
        "value"
          <> case v {
          MedicinalproductdefinitionCharacteristicValueCodeableconcept(_) ->
            "Codeableconcept"
          MedicinalproductdefinitionCharacteristicValueQuantity(_) -> "Quantity"
          MedicinalproductdefinitionCharacteristicValueDate(_) -> "Date"
          MedicinalproductdefinitionCharacteristicValueBoolean(_) -> "Boolean"
          MedicinalproductdefinitionCharacteristicValueAttachment(_) ->
            "Attachment"
        },
        medicinalproductdefinition_characteristic_value_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn medicinalproductdefinition_characteristic_decoder() -> Decoder(
  MedicinalproductdefinitionCharacteristic,
) {
  use value <- decode.then(
    none_if_omitted(medicinalproductdefinition_characteristic_value_decoder()),
  )
  use type_ <- decode.field("type", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MedicinalproductdefinitionCharacteristic(
    value:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn medicinalproductdefinition_operation_to_json(
  medicinalproductdefinition_operation: MedicinalproductdefinitionOperation,
) -> Json {
  let MedicinalproductdefinitionOperation(
    confidentiality_indicator:,
    organization:,
    effective_date:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = medicinalproductdefinition_operation
  let fields = []
  let fields = case confidentiality_indicator {
    Some(v) -> [
      #("confidentialityIndicator", codeableconcept_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case organization {
    [] -> fields
    _ -> [
      #("organization", json.array(organization, reference_to_json)),
      ..fields
    ]
  }
  let fields = case effective_date {
    Some(v) -> [#("effectiveDate", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeablereference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn medicinalproductdefinition_operation_decoder() -> Decoder(
  MedicinalproductdefinitionOperation,
) {
  use confidentiality_indicator <- decode.optional_field(
    "confidentialityIndicator",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use organization <- decode.optional_field(
    "organization",
    [],
    decode.list(reference_decoder()),
  )
  use effective_date <- decode.optional_field(
    "effectiveDate",
    None,
    decode.optional(period_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeablereference_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MedicinalproductdefinitionOperation(
    confidentiality_indicator:,
    organization:,
    effective_date:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn medicinalproductdefinition_crossreference_to_json(
  medicinalproductdefinition_crossreference: MedicinalproductdefinitionCrossreference,
) -> Json {
  let MedicinalproductdefinitionCrossreference(
    type_:,
    product:,
    modifier_extension:,
    extension:,
    id:,
  ) = medicinalproductdefinition_crossreference
  let fields = [
    #("product", codeablereference_to_json(product)),
  ]
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn medicinalproductdefinition_crossreference_decoder() -> Decoder(
  MedicinalproductdefinitionCrossreference,
) {
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use product <- decode.field("product", codeablereference_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MedicinalproductdefinitionCrossreference(
    type_:,
    product:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn medicinalproductdefinition_name_countrylanguage_to_json(
  medicinalproductdefinition_name_countrylanguage: MedicinalproductdefinitionNameCountrylanguage,
) -> Json {
  let MedicinalproductdefinitionNameCountrylanguage(
    language:,
    jurisdiction:,
    country:,
    modifier_extension:,
    extension:,
    id:,
  ) = medicinalproductdefinition_name_countrylanguage
  let fields = [
    #("language", codeableconcept_to_json(language)),
    #("country", codeableconcept_to_json(country)),
  ]
  let fields = case jurisdiction {
    Some(v) -> [#("jurisdiction", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn medicinalproductdefinition_name_countrylanguage_decoder() -> Decoder(
  MedicinalproductdefinitionNameCountrylanguage,
) {
  use language <- decode.field("language", codeableconcept_decoder())
  use jurisdiction <- decode.optional_field(
    "jurisdiction",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use country <- decode.field("country", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MedicinalproductdefinitionNameCountrylanguage(
    language:,
    jurisdiction:,
    country:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn medicinalproductdefinition_name_namepart_to_json(
  medicinalproductdefinition_name_namepart: MedicinalproductdefinitionNameNamepart,
) -> Json {
  let MedicinalproductdefinitionNameNamepart(
    type_:,
    part:,
    modifier_extension:,
    extension:,
    id:,
  ) = medicinalproductdefinition_name_namepart
  let fields = [
    #("type", codeableconcept_to_json(type_)),
    #("part", json.string(part)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn medicinalproductdefinition_name_namepart_decoder() -> Decoder(
  MedicinalproductdefinitionNameNamepart,
) {
  use type_ <- decode.field("type", codeableconcept_decoder())
  use part <- decode.field("part", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MedicinalproductdefinitionNameNamepart(
    type_:,
    part:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn medicinalproductdefinition_name_to_json(
  medicinalproductdefinition_name: MedicinalproductdefinitionName,
) -> Json {
  let MedicinalproductdefinitionName(
    country_language:,
    name_part:,
    type_:,
    product_name:,
    modifier_extension:,
    extension:,
    id:,
  ) = medicinalproductdefinition_name
  let fields = [
    #("productName", json.string(product_name)),
  ]
  let fields = case country_language {
    [] -> fields
    _ -> [
      #(
        "countryLanguage",
        json.array(
          country_language,
          medicinalproductdefinition_name_countrylanguage_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case name_part {
    [] -> fields
    _ -> [
      #(
        "namePart",
        json.array(name_part, medicinalproductdefinition_name_namepart_to_json),
      ),
      ..fields
    ]
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn medicinalproductdefinition_name_decoder() -> Decoder(
  MedicinalproductdefinitionName,
) {
  use country_language <- decode.optional_field(
    "countryLanguage",
    [],
    decode.list(medicinalproductdefinition_name_countrylanguage_decoder()),
  )
  use name_part <- decode.optional_field(
    "namePart",
    [],
    decode.list(medicinalproductdefinition_name_namepart_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use product_name <- decode.field("productName", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MedicinalproductdefinitionName(
    country_language:,
    name_part:,
    type_:,
    product_name:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn medicinalproductdefinition_contact_to_json(
  medicinalproductdefinition_contact: MedicinalproductdefinitionContact,
) -> Json {
  let MedicinalproductdefinitionContact(
    contact:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = medicinalproductdefinition_contact
  let fields = [
    #("contact", reference_to_json(contact)),
  ]
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn medicinalproductdefinition_contact_decoder() -> Decoder(
  MedicinalproductdefinitionContact,
) {
  use contact <- decode.field("contact", reference_decoder())
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MedicinalproductdefinitionContact(
    contact:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn medicinalproductdefinition_to_json(
  medicinalproductdefinition: Medicinalproductdefinition,
) -> Json {
  let Medicinalproductdefinition(
    characteristic:,
    operation:,
    cross_reference:,
    name:,
    code:,
    clinical_trial:,
    contact:,
    master_file:,
    attached_document:,
    impurity:,
    ingredient:,
    packaged_medicinal_product:,
    marketing_status:,
    classification:,
    pediatric_use_indicator:,
    special_measures:,
    additional_monitoring_indicator:,
    legal_status_of_supply:,
    indication:,
    route:,
    combined_pharmaceutical_dose_form:,
    description:,
    status_date:,
    status:,
    version:,
    domain:,
    type_:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = medicinalproductdefinition
  let fields = []
  let fields = case characteristic {
    [] -> fields
    _ -> [
      #(
        "characteristic",
        json.array(
          characteristic,
          medicinalproductdefinition_characteristic_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case operation {
    [] -> fields
    _ -> [
      #(
        "operation",
        json.array(operation, medicinalproductdefinition_operation_to_json),
      ),
      ..fields
    ]
  }
  let fields = case cross_reference {
    [] -> fields
    _ -> [
      #(
        "crossReference",
        json.array(
          cross_reference,
          medicinalproductdefinition_crossreference_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case name {
    [] -> fields
    _ -> [
      #("name", json.array(name, medicinalproductdefinition_name_to_json)),
      ..fields
    ]
  }
  let fields = case code {
    [] -> fields
    _ -> [#("code", json.array(code, coding_to_json)), ..fields]
  }
  let fields = case clinical_trial {
    [] -> fields
    _ -> [
      #("clinicalTrial", json.array(clinical_trial, reference_to_json)),
      ..fields
    ]
  }
  let fields = case contact {
    [] -> fields
    _ -> [
      #(
        "contact",
        json.array(contact, medicinalproductdefinition_contact_to_json),
      ),
      ..fields
    ]
  }
  let fields = case master_file {
    [] -> fields
    _ -> [#("masterFile", json.array(master_file, reference_to_json)), ..fields]
  }
  let fields = case attached_document {
    [] -> fields
    _ -> [
      #("attachedDocument", json.array(attached_document, reference_to_json)),
      ..fields
    ]
  }
  let fields = case impurity {
    [] -> fields
    _ -> [
      #("impurity", json.array(impurity, codeablereference_to_json)),
      ..fields
    ]
  }
  let fields = case ingredient {
    [] -> fields
    _ -> [
      #("ingredient", json.array(ingredient, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case packaged_medicinal_product {
    [] -> fields
    _ -> [
      #(
        "packagedMedicinalProduct",
        json.array(packaged_medicinal_product, codeableconcept_to_json),
      ),
      ..fields
    ]
  }
  let fields = case marketing_status {
    [] -> fields
    _ -> [
      #(
        "marketingStatus",
        json.array(marketing_status, marketingstatus_to_json),
      ),
      ..fields
    ]
  }
  let fields = case classification {
    [] -> fields
    _ -> [
      #("classification", json.array(classification, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case pediatric_use_indicator {
    Some(v) -> [
      #("pediatricUseIndicator", codeableconcept_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case special_measures {
    [] -> fields
    _ -> [
      #(
        "specialMeasures",
        json.array(special_measures, codeableconcept_to_json),
      ),
      ..fields
    ]
  }
  let fields = case additional_monitoring_indicator {
    Some(v) -> [
      #("additionalMonitoringIndicator", codeableconcept_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case legal_status_of_supply {
    Some(v) -> [#("legalStatusOfSupply", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case indication {
    Some(v) -> [#("indication", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case route {
    [] -> fields
    _ -> [#("route", json.array(route, codeableconcept_to_json)), ..fields]
  }
  let fields = case combined_pharmaceutical_dose_form {
    Some(v) -> [
      #("combinedPharmaceuticalDoseForm", codeableconcept_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case status_date {
    Some(v) -> [#("statusDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case status {
    Some(v) -> [#("status", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case version {
    Some(v) -> [#("version", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case domain {
    Some(v) -> [#("domain", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [
    #("resourceType", json.string("Medicinalproductdefinition")),
    ..fields
  ]
  json.object(fields)
}

pub fn medicinalproductdefinition_decoder() -> Decoder(
  Medicinalproductdefinition,
) {
  use characteristic <- decode.optional_field(
    "characteristic",
    [],
    decode.list(medicinalproductdefinition_characteristic_decoder()),
  )
  use operation <- decode.optional_field(
    "operation",
    [],
    decode.list(medicinalproductdefinition_operation_decoder()),
  )
  use cross_reference <- decode.optional_field(
    "crossReference",
    [],
    decode.list(medicinalproductdefinition_crossreference_decoder()),
  )
  use name <- decode.optional_field(
    "name",
    [],
    decode.list(medicinalproductdefinition_name_decoder()),
  )
  use code <- decode.optional_field("code", [], decode.list(coding_decoder()))
  use clinical_trial <- decode.optional_field(
    "clinicalTrial",
    [],
    decode.list(reference_decoder()),
  )
  use contact <- decode.optional_field(
    "contact",
    [],
    decode.list(medicinalproductdefinition_contact_decoder()),
  )
  use master_file <- decode.optional_field(
    "masterFile",
    [],
    decode.list(reference_decoder()),
  )
  use attached_document <- decode.optional_field(
    "attachedDocument",
    [],
    decode.list(reference_decoder()),
  )
  use impurity <- decode.optional_field(
    "impurity",
    [],
    decode.list(codeablereference_decoder()),
  )
  use ingredient <- decode.optional_field(
    "ingredient",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use packaged_medicinal_product <- decode.optional_field(
    "packagedMedicinalProduct",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use marketing_status <- decode.optional_field(
    "marketingStatus",
    [],
    decode.list(marketingstatus_decoder()),
  )
  use classification <- decode.optional_field(
    "classification",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use pediatric_use_indicator <- decode.optional_field(
    "pediatricUseIndicator",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use special_measures <- decode.optional_field(
    "specialMeasures",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use additional_monitoring_indicator <- decode.optional_field(
    "additionalMonitoringIndicator",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use legal_status_of_supply <- decode.optional_field(
    "legalStatusOfSupply",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use indication <- decode.optional_field(
    "indication",
    None,
    decode.optional(decode.string),
  )
  use route <- decode.optional_field(
    "route",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use combined_pharmaceutical_dose_form <- decode.optional_field(
    "combinedPharmaceuticalDoseForm",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use status_date <- decode.optional_field(
    "statusDate",
    None,
    decode.optional(decode.string),
  )
  use status <- decode.optional_field(
    "status",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use version <- decode.optional_field(
    "version",
    None,
    decode.optional(decode.string),
  )
  use domain <- decode.optional_field(
    "domain",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Medicinalproductdefinition",
    decode.failure(medicinalproductdefinition_new(), "resourceType"),
  )
  decode.success(Medicinalproductdefinition(
    characteristic:,
    operation:,
    cross_reference:,
    name:,
    code:,
    clinical_trial:,
    contact:,
    master_file:,
    attached_document:,
    impurity:,
    ingredient:,
    packaged_medicinal_product:,
    marketing_status:,
    classification:,
    pediatric_use_indicator:,
    special_measures:,
    additional_monitoring_indicator:,
    legal_status_of_supply:,
    indication:,
    route:,
    combined_pharmaceutical_dose_form:,
    description:,
    status_date:,
    status:,
    version:,
    domain:,
    type_:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/MessageDefinition#resource
pub type Messagedefinition {
  Messagedefinition(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    url: Option(String),
    identifier: List(Identifier),
    version: Option(String),
    name: Option(String),
    title: Option(String),
    replaces: List(String),
    status: r4bvaluesets.Publicationstatus,
    experimental: Option(Bool),
    date: String,
    publisher: Option(String),
    contact: List(Contactdetail),
    description: Option(String),
    use_context: List(Usagecontext),
    jurisdiction: List(Codeableconcept),
    purpose: Option(String),
    copyright: Option(String),
    base: Option(String),
    parent: List(String),
    event: MessagedefinitionEvent,
    category: Option(r4bvaluesets.Messagesignificancecategory),
    focus: List(MessagedefinitionFocus),
    response_required: Option(r4bvaluesets.Messageheaderresponserequest),
    allowed_response: List(MessagedefinitionAllowedresponse),
    graph: List(String),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/MessageDefinition#resource
pub type MessagedefinitionEvent {
  MessagedefinitionEventCoding(event: Coding)
  MessagedefinitionEventUri(event: String)
}

pub fn messagedefinition_event_to_json(elt: MessagedefinitionEvent) -> Json {
  case elt {
    MessagedefinitionEventCoding(v) -> coding_to_json(v)
    MessagedefinitionEventUri(v) -> json.string(v)
  }
}

pub fn messagedefinition_event_decoder() -> Decoder(MessagedefinitionEvent) {
  decode.one_of(
    decode.field("eventCoding", coding_decoder(), decode.success)
      |> decode.map(MessagedefinitionEventCoding),
    [
      decode.field("eventUri", decode.string, decode.success)
      |> decode.map(MessagedefinitionEventUri),
    ],
  )
}

pub fn messagedefinition_new(
  event event: MessagedefinitionEvent,
  date date: String,
  status status: r4bvaluesets.Publicationstatus,
) -> Messagedefinition {
  Messagedefinition(
    graph: [],
    allowed_response: [],
    response_required: None,
    focus: [],
    category: None,
    event:,
    parent: [],
    base: None,
    copyright: None,
    purpose: None,
    jurisdiction: [],
    use_context: [],
    description: None,
    contact: [],
    publisher: None,
    date:,
    experimental: None,
    status:,
    replaces: [],
    title: None,
    name: None,
    version: None,
    identifier: [],
    url: None,
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/MessageDefinition#resource
pub type MessagedefinitionFocus {
  MessagedefinitionFocus(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    code: r4bvaluesets.Resourcetypes,
    profile: Option(String),
    min: Int,
    max: Option(String),
  )
}

pub fn messagedefinition_focus_new(
  min min: Int,
  code code: r4bvaluesets.Resourcetypes,
) -> MessagedefinitionFocus {
  MessagedefinitionFocus(
    max: None,
    min:,
    profile: None,
    code:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/MessageDefinition#resource
pub type MessagedefinitionAllowedresponse {
  MessagedefinitionAllowedresponse(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    message: String,
    situation: Option(String),
  )
}

pub fn messagedefinition_allowedresponse_new(
  message message: String,
) -> MessagedefinitionAllowedresponse {
  MessagedefinitionAllowedresponse(
    situation: None,
    message:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn messagedefinition_allowedresponse_to_json(
  messagedefinition_allowedresponse: MessagedefinitionAllowedresponse,
) -> Json {
  let MessagedefinitionAllowedresponse(
    situation:,
    message:,
    modifier_extension:,
    extension:,
    id:,
  ) = messagedefinition_allowedresponse
  let fields = [
    #("message", json.string(message)),
  ]
  let fields = case situation {
    Some(v) -> [#("situation", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn messagedefinition_allowedresponse_decoder() -> Decoder(
  MessagedefinitionAllowedresponse,
) {
  use situation <- decode.optional_field(
    "situation",
    None,
    decode.optional(decode.string),
  )
  use message <- decode.field("message", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MessagedefinitionAllowedresponse(
    situation:,
    message:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn messagedefinition_focus_to_json(
  messagedefinition_focus: MessagedefinitionFocus,
) -> Json {
  let MessagedefinitionFocus(
    max:,
    min:,
    profile:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ) = messagedefinition_focus
  let fields = [
    #("min", json.int(min)),
    #("code", r4bvaluesets.resourcetypes_to_json(code)),
  ]
  let fields = case max {
    Some(v) -> [#("max", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case profile {
    Some(v) -> [#("profile", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn messagedefinition_focus_decoder() -> Decoder(MessagedefinitionFocus) {
  use max <- decode.optional_field("max", None, decode.optional(decode.string))
  use min <- decode.field("min", decode.int)
  use profile <- decode.optional_field(
    "profile",
    None,
    decode.optional(decode.string),
  )
  use code <- decode.field("code", r4bvaluesets.resourcetypes_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MessagedefinitionFocus(
    max:,
    min:,
    profile:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn messagedefinition_to_json(messagedefinition: Messagedefinition) -> Json {
  let Messagedefinition(
    graph:,
    allowed_response:,
    response_required:,
    focus:,
    category:,
    event:,
    parent:,
    base:,
    copyright:,
    purpose:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    experimental:,
    status:,
    replaces:,
    title:,
    name:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = messagedefinition
  let fields = [
    #("event", messagedefinition_event_to_json(event)),
    #("date", json.string(date)),
    #("status", r4bvaluesets.publicationstatus_to_json(status)),
  ]
  let fields = case graph {
    [] -> fields
    _ -> [#("graph", json.array(graph, json.string)), ..fields]
  }
  let fields = case allowed_response {
    [] -> fields
    _ -> [
      #(
        "allowedResponse",
        json.array(allowed_response, messagedefinition_allowedresponse_to_json),
      ),
      ..fields
    ]
  }
  let fields = case response_required {
    Some(v) -> [
      #(
        "responseRequired",
        r4bvaluesets.messageheaderresponserequest_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case focus {
    [] -> fields
    _ -> [
      #("focus", json.array(focus, messagedefinition_focus_to_json)),
      ..fields
    ]
  }
  let fields = case category {
    Some(v) -> [
      #("category", r4bvaluesets.messagesignificancecategory_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case parent {
    [] -> fields
    _ -> [#("parent", json.array(parent, json.string)), ..fields]
  }
  let fields = case base {
    Some(v) -> [#("base", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case copyright {
    Some(v) -> [#("copyright", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case purpose {
    Some(v) -> [#("purpose", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case jurisdiction {
    [] -> fields
    _ -> [
      #("jurisdiction", json.array(jurisdiction, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case use_context {
    [] -> fields
    _ -> [
      #("useContext", json.array(use_context, usagecontext_to_json)),
      ..fields
    ]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case contact {
    [] -> fields
    _ -> [#("contact", json.array(contact, contactdetail_to_json)), ..fields]
  }
  let fields = case publisher {
    Some(v) -> [#("publisher", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case experimental {
    Some(v) -> [#("experimental", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case replaces {
    [] -> fields
    _ -> [#("replaces", json.array(replaces, json.string)), ..fields]
  }
  let fields = case title {
    Some(v) -> [#("title", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case version {
    Some(v) -> [#("version", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case url {
    Some(v) -> [#("url", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Messagedefinition")), ..fields]
  json.object(fields)
}

pub fn messagedefinition_decoder() -> Decoder(Messagedefinition) {
  use graph <- decode.optional_field("graph", [], decode.list(decode.string))
  use allowed_response <- decode.optional_field(
    "allowedResponse",
    [],
    decode.list(messagedefinition_allowedresponse_decoder()),
  )
  use response_required <- decode.optional_field(
    "responseRequired",
    None,
    decode.optional(r4bvaluesets.messageheaderresponserequest_decoder()),
  )
  use focus <- decode.optional_field(
    "focus",
    [],
    decode.list(messagedefinition_focus_decoder()),
  )
  use category <- decode.optional_field(
    "category",
    None,
    decode.optional(r4bvaluesets.messagesignificancecategory_decoder()),
  )
  use event <- decode.then(messagedefinition_event_decoder())
  use parent <- decode.optional_field("parent", [], decode.list(decode.string))
  use base <- decode.optional_field(
    "base",
    None,
    decode.optional(decode.string),
  )
  use copyright <- decode.optional_field(
    "copyright",
    None,
    decode.optional(decode.string),
  )
  use purpose <- decode.optional_field(
    "purpose",
    None,
    decode.optional(decode.string),
  )
  use jurisdiction <- decode.optional_field(
    "jurisdiction",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use use_context <- decode.optional_field(
    "useContext",
    [],
    decode.list(usagecontext_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use contact <- decode.optional_field(
    "contact",
    [],
    decode.list(contactdetail_decoder()),
  )
  use publisher <- decode.optional_field(
    "publisher",
    None,
    decode.optional(decode.string),
  )
  use date <- decode.field("date", decode.string)
  use experimental <- decode.optional_field(
    "experimental",
    None,
    decode.optional(decode.bool),
  )
  use status <- decode.field("status", r4bvaluesets.publicationstatus_decoder())
  use replaces <- decode.optional_field(
    "replaces",
    [],
    decode.list(decode.string),
  )
  use title <- decode.optional_field(
    "title",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use version <- decode.optional_field(
    "version",
    None,
    decode.optional(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use url <- decode.optional_field("url", None, decode.optional(decode.string))
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Messagedefinition",
    decode.failure(
      messagedefinition_new(event:, date:, status:),
      "resourceType",
    ),
  )
  decode.success(Messagedefinition(
    graph:,
    allowed_response:,
    response_required:,
    focus:,
    category:,
    event:,
    parent:,
    base:,
    copyright:,
    purpose:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    experimental:,
    status:,
    replaces:,
    title:,
    name:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/MessageHeader#resource
pub type Messageheader {
  Messageheader(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    event: MessageheaderEvent,
    destination: List(MessageheaderDestination),
    sender: Option(Reference),
    enterer: Option(Reference),
    author: Option(Reference),
    source: MessageheaderSource,
    responsible: Option(Reference),
    reason: Option(Codeableconcept),
    response: Option(MessageheaderResponse),
    focus: List(Reference),
    definition: Option(String),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/MessageHeader#resource
pub type MessageheaderEvent {
  MessageheaderEventCoding(event: Coding)
  MessageheaderEventUri(event: String)
}

pub fn messageheader_event_to_json(elt: MessageheaderEvent) -> Json {
  case elt {
    MessageheaderEventCoding(v) -> coding_to_json(v)
    MessageheaderEventUri(v) -> json.string(v)
  }
}

pub fn messageheader_event_decoder() -> Decoder(MessageheaderEvent) {
  decode.one_of(
    decode.field("eventCoding", coding_decoder(), decode.success)
      |> decode.map(MessageheaderEventCoding),
    [
      decode.field("eventUri", decode.string, decode.success)
      |> decode.map(MessageheaderEventUri),
    ],
  )
}

pub fn messageheader_new(
  source source: MessageheaderSource,
  event event: MessageheaderEvent,
) -> Messageheader {
  Messageheader(
    definition: None,
    focus: [],
    response: None,
    reason: None,
    responsible: None,
    source:,
    author: None,
    enterer: None,
    sender: None,
    destination: [],
    event:,
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/MessageHeader#resource
pub type MessageheaderDestination {
  MessageheaderDestination(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    name: Option(String),
    target: Option(Reference),
    endpoint: String,
    receiver: Option(Reference),
  )
}

pub fn messageheader_destination_new(
  endpoint endpoint: String,
) -> MessageheaderDestination {
  MessageheaderDestination(
    receiver: None,
    endpoint:,
    target: None,
    name: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/MessageHeader#resource
pub type MessageheaderSource {
  MessageheaderSource(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    name: Option(String),
    software: Option(String),
    version: Option(String),
    contact: Option(Contactpoint),
    endpoint: String,
  )
}

pub fn messageheader_source_new(
  endpoint endpoint: String,
) -> MessageheaderSource {
  MessageheaderSource(
    endpoint:,
    contact: None,
    version: None,
    software: None,
    name: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/MessageHeader#resource
pub type MessageheaderResponse {
  MessageheaderResponse(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: String,
    code: r4bvaluesets.Responsecode,
    details: Option(Reference),
  )
}

pub fn messageheader_response_new(
  code code: r4bvaluesets.Responsecode,
  identifier identifier: String,
) -> MessageheaderResponse {
  MessageheaderResponse(
    details: None,
    code:,
    identifier:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn messageheader_response_to_json(
  messageheader_response: MessageheaderResponse,
) -> Json {
  let MessageheaderResponse(
    details:,
    code:,
    identifier:,
    modifier_extension:,
    extension:,
    id:,
  ) = messageheader_response
  let fields = [
    #("code", r4bvaluesets.responsecode_to_json(code)),
    #("identifier", json.string(identifier)),
  ]
  let fields = case details {
    Some(v) -> [#("details", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn messageheader_response_decoder() -> Decoder(MessageheaderResponse) {
  use details <- decode.optional_field(
    "details",
    None,
    decode.optional(reference_decoder()),
  )
  use code <- decode.field("code", r4bvaluesets.responsecode_decoder())
  use identifier <- decode.field("identifier", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MessageheaderResponse(
    details:,
    code:,
    identifier:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn messageheader_source_to_json(
  messageheader_source: MessageheaderSource,
) -> Json {
  let MessageheaderSource(
    endpoint:,
    contact:,
    version:,
    software:,
    name:,
    modifier_extension:,
    extension:,
    id:,
  ) = messageheader_source
  let fields = [
    #("endpoint", json.string(endpoint)),
  ]
  let fields = case contact {
    Some(v) -> [#("contact", contactpoint_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case version {
    Some(v) -> [#("version", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case software {
    Some(v) -> [#("software", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn messageheader_source_decoder() -> Decoder(MessageheaderSource) {
  use endpoint <- decode.field("endpoint", decode.string)
  use contact <- decode.optional_field(
    "contact",
    None,
    decode.optional(contactpoint_decoder()),
  )
  use version <- decode.optional_field(
    "version",
    None,
    decode.optional(decode.string),
  )
  use software <- decode.optional_field(
    "software",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MessageheaderSource(
    endpoint:,
    contact:,
    version:,
    software:,
    name:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn messageheader_destination_to_json(
  messageheader_destination: MessageheaderDestination,
) -> Json {
  let MessageheaderDestination(
    receiver:,
    endpoint:,
    target:,
    name:,
    modifier_extension:,
    extension:,
    id:,
  ) = messageheader_destination
  let fields = [
    #("endpoint", json.string(endpoint)),
  ]
  let fields = case receiver {
    Some(v) -> [#("receiver", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case target {
    Some(v) -> [#("target", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn messageheader_destination_decoder() -> Decoder(MessageheaderDestination) {
  use receiver <- decode.optional_field(
    "receiver",
    None,
    decode.optional(reference_decoder()),
  )
  use endpoint <- decode.field("endpoint", decode.string)
  use target <- decode.optional_field(
    "target",
    None,
    decode.optional(reference_decoder()),
  )
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MessageheaderDestination(
    receiver:,
    endpoint:,
    target:,
    name:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn messageheader_to_json(messageheader: Messageheader) -> Json {
  let Messageheader(
    definition:,
    focus:,
    response:,
    reason:,
    responsible:,
    source:,
    author:,
    enterer:,
    sender:,
    destination:,
    event:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = messageheader
  let fields = [
    #("source", messageheader_source_to_json(source)),
    #("event", messageheader_event_to_json(event)),
  ]
  let fields = case definition {
    Some(v) -> [#("definition", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case focus {
    [] -> fields
    _ -> [#("focus", json.array(focus, reference_to_json)), ..fields]
  }
  let fields = case response {
    Some(v) -> [#("response", messageheader_response_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case reason {
    Some(v) -> [#("reason", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case responsible {
    Some(v) -> [#("responsible", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case author {
    Some(v) -> [#("author", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case enterer {
    Some(v) -> [#("enterer", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case sender {
    Some(v) -> [#("sender", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case destination {
    [] -> fields
    _ -> [
      #(
        "destination",
        json.array(destination, messageheader_destination_to_json),
      ),
      ..fields
    ]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Messageheader")), ..fields]
  json.object(fields)
}

pub fn messageheader_decoder() -> Decoder(Messageheader) {
  use definition <- decode.optional_field(
    "definition",
    None,
    decode.optional(decode.string),
  )
  use focus <- decode.optional_field(
    "focus",
    [],
    decode.list(reference_decoder()),
  )
  use response <- decode.optional_field(
    "response",
    None,
    decode.optional(messageheader_response_decoder()),
  )
  use reason <- decode.optional_field(
    "reason",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use responsible <- decode.optional_field(
    "responsible",
    None,
    decode.optional(reference_decoder()),
  )
  use source <- decode.field("source", messageheader_source_decoder())
  use author <- decode.optional_field(
    "author",
    None,
    decode.optional(reference_decoder()),
  )
  use enterer <- decode.optional_field(
    "enterer",
    None,
    decode.optional(reference_decoder()),
  )
  use sender <- decode.optional_field(
    "sender",
    None,
    decode.optional(reference_decoder()),
  )
  use destination <- decode.optional_field(
    "destination",
    [],
    decode.list(messageheader_destination_decoder()),
  )
  use event <- decode.then(messageheader_event_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Messageheader",
    decode.failure(messageheader_new(source:, event:), "resourceType"),
  )
  decode.success(Messageheader(
    definition:,
    focus:,
    response:,
    reason:,
    responsible:,
    source:,
    author:,
    enterer:,
    sender:,
    destination:,
    event:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/MolecularSequence#resource
pub type Molecularsequence {
  Molecularsequence(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    type_: Option(r4bvaluesets.Sequencetype),
    coordinate_system: Int,
    patient: Option(Reference),
    specimen: Option(Reference),
    device: Option(Reference),
    performer: Option(Reference),
    quantity: Option(Quantity),
    reference_seq: Option(MolecularsequenceReferenceseq),
    variant: List(MolecularsequenceVariant),
    observed_seq: Option(String),
    quality: List(MolecularsequenceQuality),
    read_coverage: Option(Int),
    repository: List(MolecularsequenceRepository),
    pointer: List(Reference),
    structure_variant: List(MolecularsequenceStructurevariant),
  )
}

pub fn molecularsequence_new(
  coordinate_system coordinate_system: Int,
) -> Molecularsequence {
  Molecularsequence(
    structure_variant: [],
    pointer: [],
    repository: [],
    read_coverage: None,
    quality: [],
    observed_seq: None,
    variant: [],
    reference_seq: None,
    quantity: None,
    performer: None,
    device: None,
    specimen: None,
    patient: None,
    coordinate_system:,
    type_: None,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/MolecularSequence#resource
pub type MolecularsequenceReferenceseq {
  MolecularsequenceReferenceseq(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    chromosome: Option(Codeableconcept),
    genome_build: Option(String),
    orientation: Option(r4bvaluesets.Orientationtype),
    reference_seq_id: Option(Codeableconcept),
    reference_seq_pointer: Option(Reference),
    reference_seq_string: Option(String),
    strand: Option(r4bvaluesets.Strandtype),
    window_start: Option(Int),
    window_end: Option(Int),
  )
}

pub fn molecularsequence_referenceseq_new() -> MolecularsequenceReferenceseq {
  MolecularsequenceReferenceseq(
    window_end: None,
    window_start: None,
    strand: None,
    reference_seq_string: None,
    reference_seq_pointer: None,
    reference_seq_id: None,
    orientation: None,
    genome_build: None,
    chromosome: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/MolecularSequence#resource
pub type MolecularsequenceVariant {
  MolecularsequenceVariant(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    start: Option(Int),
    end: Option(Int),
    observed_allele: Option(String),
    reference_allele: Option(String),
    cigar: Option(String),
    variant_pointer: Option(Reference),
  )
}

pub fn molecularsequence_variant_new() -> MolecularsequenceVariant {
  MolecularsequenceVariant(
    variant_pointer: None,
    cigar: None,
    reference_allele: None,
    observed_allele: None,
    end: None,
    start: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/MolecularSequence#resource
pub type MolecularsequenceQuality {
  MolecularsequenceQuality(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: r4bvaluesets.Qualitytype,
    standard_sequence: Option(Codeableconcept),
    start: Option(Int),
    end: Option(Int),
    score: Option(Quantity),
    method: Option(Codeableconcept),
    truth_tp: Option(Float),
    query_tp: Option(Float),
    truth_fn: Option(Float),
    query_fp: Option(Float),
    gt_fp: Option(Float),
    precision: Option(Float),
    recall: Option(Float),
    f_score: Option(Float),
    roc: Option(MolecularsequenceQualityRoc),
  )
}

pub fn molecularsequence_quality_new(
  type_ type_: r4bvaluesets.Qualitytype,
) -> MolecularsequenceQuality {
  MolecularsequenceQuality(
    roc: None,
    f_score: None,
    recall: None,
    precision: None,
    gt_fp: None,
    query_fp: None,
    truth_fn: None,
    query_tp: None,
    truth_tp: None,
    method: None,
    score: None,
    end: None,
    start: None,
    standard_sequence: None,
    type_:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/MolecularSequence#resource
pub type MolecularsequenceQualityRoc {
  MolecularsequenceQualityRoc(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    score: List(Int),
    num_tp: List(Int),
    num_fp: List(Int),
    num_fn: List(Int),
    precision: List(Float),
    sensitivity: List(Float),
    f_measure: List(Float),
  )
}

pub fn molecularsequence_quality_roc_new() -> MolecularsequenceQualityRoc {
  MolecularsequenceQualityRoc(
    f_measure: [],
    sensitivity: [],
    precision: [],
    num_fn: [],
    num_fp: [],
    num_tp: [],
    score: [],
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/MolecularSequence#resource
pub type MolecularsequenceRepository {
  MolecularsequenceRepository(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: r4bvaluesets.Repositorytype,
    url: Option(String),
    name: Option(String),
    dataset_id: Option(String),
    variantset_id: Option(String),
    readset_id: Option(String),
  )
}

pub fn molecularsequence_repository_new(
  type_ type_: r4bvaluesets.Repositorytype,
) -> MolecularsequenceRepository {
  MolecularsequenceRepository(
    readset_id: None,
    variantset_id: None,
    dataset_id: None,
    name: None,
    url: None,
    type_:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/MolecularSequence#resource
pub type MolecularsequenceStructurevariant {
  MolecularsequenceStructurevariant(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    variant_type: Option(Codeableconcept),
    exact: Option(Bool),
    length: Option(Int),
    outer: Option(MolecularsequenceStructurevariantOuter),
    inner: Option(MolecularsequenceStructurevariantInner),
  )
}

pub fn molecularsequence_structurevariant_new() -> MolecularsequenceStructurevariant {
  MolecularsequenceStructurevariant(
    inner: None,
    outer: None,
    length: None,
    exact: None,
    variant_type: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/MolecularSequence#resource
pub type MolecularsequenceStructurevariantOuter {
  MolecularsequenceStructurevariantOuter(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    start: Option(Int),
    end: Option(Int),
  )
}

pub fn molecularsequence_structurevariant_outer_new() -> MolecularsequenceStructurevariantOuter {
  MolecularsequenceStructurevariantOuter(
    end: None,
    start: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/MolecularSequence#resource
pub type MolecularsequenceStructurevariantInner {
  MolecularsequenceStructurevariantInner(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    start: Option(Int),
    end: Option(Int),
  )
}

pub fn molecularsequence_structurevariant_inner_new() -> MolecularsequenceStructurevariantInner {
  MolecularsequenceStructurevariantInner(
    end: None,
    start: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn molecularsequence_structurevariant_inner_to_json(
  molecularsequence_structurevariant_inner: MolecularsequenceStructurevariantInner,
) -> Json {
  let MolecularsequenceStructurevariantInner(
    end:,
    start:,
    modifier_extension:,
    extension:,
    id:,
  ) = molecularsequence_structurevariant_inner
  let fields = []
  let fields = case end {
    Some(v) -> [#("end", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case start {
    Some(v) -> [#("start", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn molecularsequence_structurevariant_inner_decoder() -> Decoder(
  MolecularsequenceStructurevariantInner,
) {
  use end <- decode.optional_field("end", None, decode.optional(decode.int))
  use start <- decode.optional_field("start", None, decode.optional(decode.int))
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MolecularsequenceStructurevariantInner(
    end:,
    start:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn molecularsequence_structurevariant_outer_to_json(
  molecularsequence_structurevariant_outer: MolecularsequenceStructurevariantOuter,
) -> Json {
  let MolecularsequenceStructurevariantOuter(
    end:,
    start:,
    modifier_extension:,
    extension:,
    id:,
  ) = molecularsequence_structurevariant_outer
  let fields = []
  let fields = case end {
    Some(v) -> [#("end", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case start {
    Some(v) -> [#("start", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn molecularsequence_structurevariant_outer_decoder() -> Decoder(
  MolecularsequenceStructurevariantOuter,
) {
  use end <- decode.optional_field("end", None, decode.optional(decode.int))
  use start <- decode.optional_field("start", None, decode.optional(decode.int))
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MolecularsequenceStructurevariantOuter(
    end:,
    start:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn molecularsequence_structurevariant_to_json(
  molecularsequence_structurevariant: MolecularsequenceStructurevariant,
) -> Json {
  let MolecularsequenceStructurevariant(
    inner:,
    outer:,
    length:,
    exact:,
    variant_type:,
    modifier_extension:,
    extension:,
    id:,
  ) = molecularsequence_structurevariant
  let fields = []
  let fields = case inner {
    Some(v) -> [
      #("inner", molecularsequence_structurevariant_inner_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case outer {
    Some(v) -> [
      #("outer", molecularsequence_structurevariant_outer_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case length {
    Some(v) -> [#("length", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case exact {
    Some(v) -> [#("exact", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case variant_type {
    Some(v) -> [#("variantType", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn molecularsequence_structurevariant_decoder() -> Decoder(
  MolecularsequenceStructurevariant,
) {
  use inner <- decode.optional_field(
    "inner",
    None,
    decode.optional(molecularsequence_structurevariant_inner_decoder()),
  )
  use outer <- decode.optional_field(
    "outer",
    None,
    decode.optional(molecularsequence_structurevariant_outer_decoder()),
  )
  use length <- decode.optional_field(
    "length",
    None,
    decode.optional(decode.int),
  )
  use exact <- decode.optional_field(
    "exact",
    None,
    decode.optional(decode.bool),
  )
  use variant_type <- decode.optional_field(
    "variantType",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MolecularsequenceStructurevariant(
    inner:,
    outer:,
    length:,
    exact:,
    variant_type:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn molecularsequence_repository_to_json(
  molecularsequence_repository: MolecularsequenceRepository,
) -> Json {
  let MolecularsequenceRepository(
    readset_id:,
    variantset_id:,
    dataset_id:,
    name:,
    url:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = molecularsequence_repository
  let fields = [
    #("type", r4bvaluesets.repositorytype_to_json(type_)),
  ]
  let fields = case readset_id {
    Some(v) -> [#("readsetId", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case variantset_id {
    Some(v) -> [#("variantsetId", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case dataset_id {
    Some(v) -> [#("datasetId", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case url {
    Some(v) -> [#("url", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn molecularsequence_repository_decoder() -> Decoder(
  MolecularsequenceRepository,
) {
  use readset_id <- decode.optional_field(
    "readsetId",
    None,
    decode.optional(decode.string),
  )
  use variantset_id <- decode.optional_field(
    "variantsetId",
    None,
    decode.optional(decode.string),
  )
  use dataset_id <- decode.optional_field(
    "datasetId",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use url <- decode.optional_field("url", None, decode.optional(decode.string))
  use type_ <- decode.field("type", r4bvaluesets.repositorytype_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MolecularsequenceRepository(
    readset_id:,
    variantset_id:,
    dataset_id:,
    name:,
    url:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn molecularsequence_quality_roc_to_json(
  molecularsequence_quality_roc: MolecularsequenceQualityRoc,
) -> Json {
  let MolecularsequenceQualityRoc(
    f_measure:,
    sensitivity:,
    precision:,
    num_fn:,
    num_fp:,
    num_tp:,
    score:,
    modifier_extension:,
    extension:,
    id:,
  ) = molecularsequence_quality_roc
  let fields = []
  let fields = case f_measure {
    [] -> fields
    _ -> [#("fMeasure", json.array(f_measure, json.float)), ..fields]
  }
  let fields = case sensitivity {
    [] -> fields
    _ -> [#("sensitivity", json.array(sensitivity, json.float)), ..fields]
  }
  let fields = case precision {
    [] -> fields
    _ -> [#("precision", json.array(precision, json.float)), ..fields]
  }
  let fields = case num_fn {
    [] -> fields
    _ -> [#("numFN", json.array(num_fn, json.int)), ..fields]
  }
  let fields = case num_fp {
    [] -> fields
    _ -> [#("numFP", json.array(num_fp, json.int)), ..fields]
  }
  let fields = case num_tp {
    [] -> fields
    _ -> [#("numTP", json.array(num_tp, json.int)), ..fields]
  }
  let fields = case score {
    [] -> fields
    _ -> [#("score", json.array(score, json.int)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn molecularsequence_quality_roc_decoder() -> Decoder(
  MolecularsequenceQualityRoc,
) {
  use f_measure <- decode.optional_field(
    "fMeasure",
    [],
    decode.list(decode.float),
  )
  use sensitivity <- decode.optional_field(
    "sensitivity",
    [],
    decode.list(decode.float),
  )
  use precision <- decode.optional_field(
    "precision",
    [],
    decode.list(decode.float),
  )
  use num_fn <- decode.optional_field("numFN", [], decode.list(decode.int))
  use num_fp <- decode.optional_field("numFP", [], decode.list(decode.int))
  use num_tp <- decode.optional_field("numTP", [], decode.list(decode.int))
  use score <- decode.optional_field("score", [], decode.list(decode.int))
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MolecularsequenceQualityRoc(
    f_measure:,
    sensitivity:,
    precision:,
    num_fn:,
    num_fp:,
    num_tp:,
    score:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn molecularsequence_quality_to_json(
  molecularsequence_quality: MolecularsequenceQuality,
) -> Json {
  let MolecularsequenceQuality(
    roc:,
    f_score:,
    recall:,
    precision:,
    gt_fp:,
    query_fp:,
    truth_fn:,
    query_tp:,
    truth_tp:,
    method:,
    score:,
    end:,
    start:,
    standard_sequence:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = molecularsequence_quality
  let fields = [
    #("type", r4bvaluesets.qualitytype_to_json(type_)),
  ]
  let fields = case roc {
    Some(v) -> [#("roc", molecularsequence_quality_roc_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case f_score {
    Some(v) -> [#("fScore", json.float(v)), ..fields]
    None -> fields
  }
  let fields = case recall {
    Some(v) -> [#("recall", json.float(v)), ..fields]
    None -> fields
  }
  let fields = case precision {
    Some(v) -> [#("precision", json.float(v)), ..fields]
    None -> fields
  }
  let fields = case gt_fp {
    Some(v) -> [#("gtFP", json.float(v)), ..fields]
    None -> fields
  }
  let fields = case query_fp {
    Some(v) -> [#("queryFP", json.float(v)), ..fields]
    None -> fields
  }
  let fields = case truth_fn {
    Some(v) -> [#("truthFN", json.float(v)), ..fields]
    None -> fields
  }
  let fields = case query_tp {
    Some(v) -> [#("queryTP", json.float(v)), ..fields]
    None -> fields
  }
  let fields = case truth_tp {
    Some(v) -> [#("truthTP", json.float(v)), ..fields]
    None -> fields
  }
  let fields = case method {
    Some(v) -> [#("method", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case score {
    Some(v) -> [#("score", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case end {
    Some(v) -> [#("end", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case start {
    Some(v) -> [#("start", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case standard_sequence {
    Some(v) -> [#("standardSequence", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn molecularsequence_quality_decoder() -> Decoder(MolecularsequenceQuality) {
  use roc <- decode.optional_field(
    "roc",
    None,
    decode.optional(molecularsequence_quality_roc_decoder()),
  )
  use f_score <- decode.optional_field(
    "fScore",
    None,
    decode.optional(decode.float),
  )
  use recall <- decode.optional_field(
    "recall",
    None,
    decode.optional(decode.float),
  )
  use precision <- decode.optional_field(
    "precision",
    None,
    decode.optional(decode.float),
  )
  use gt_fp <- decode.optional_field(
    "gtFP",
    None,
    decode.optional(decode.float),
  )
  use query_fp <- decode.optional_field(
    "queryFP",
    None,
    decode.optional(decode.float),
  )
  use truth_fn <- decode.optional_field(
    "truthFN",
    None,
    decode.optional(decode.float),
  )
  use query_tp <- decode.optional_field(
    "queryTP",
    None,
    decode.optional(decode.float),
  )
  use truth_tp <- decode.optional_field(
    "truthTP",
    None,
    decode.optional(decode.float),
  )
  use method <- decode.optional_field(
    "method",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use score <- decode.optional_field(
    "score",
    None,
    decode.optional(quantity_decoder()),
  )
  use end <- decode.optional_field("end", None, decode.optional(decode.int))
  use start <- decode.optional_field("start", None, decode.optional(decode.int))
  use standard_sequence <- decode.optional_field(
    "standardSequence",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use type_ <- decode.field("type", r4bvaluesets.qualitytype_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MolecularsequenceQuality(
    roc:,
    f_score:,
    recall:,
    precision:,
    gt_fp:,
    query_fp:,
    truth_fn:,
    query_tp:,
    truth_tp:,
    method:,
    score:,
    end:,
    start:,
    standard_sequence:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn molecularsequence_variant_to_json(
  molecularsequence_variant: MolecularsequenceVariant,
) -> Json {
  let MolecularsequenceVariant(
    variant_pointer:,
    cigar:,
    reference_allele:,
    observed_allele:,
    end:,
    start:,
    modifier_extension:,
    extension:,
    id:,
  ) = molecularsequence_variant
  let fields = []
  let fields = case variant_pointer {
    Some(v) -> [#("variantPointer", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case cigar {
    Some(v) -> [#("cigar", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case reference_allele {
    Some(v) -> [#("referenceAllele", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case observed_allele {
    Some(v) -> [#("observedAllele", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case end {
    Some(v) -> [#("end", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case start {
    Some(v) -> [#("start", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn molecularsequence_variant_decoder() -> Decoder(MolecularsequenceVariant) {
  use variant_pointer <- decode.optional_field(
    "variantPointer",
    None,
    decode.optional(reference_decoder()),
  )
  use cigar <- decode.optional_field(
    "cigar",
    None,
    decode.optional(decode.string),
  )
  use reference_allele <- decode.optional_field(
    "referenceAllele",
    None,
    decode.optional(decode.string),
  )
  use observed_allele <- decode.optional_field(
    "observedAllele",
    None,
    decode.optional(decode.string),
  )
  use end <- decode.optional_field("end", None, decode.optional(decode.int))
  use start <- decode.optional_field("start", None, decode.optional(decode.int))
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MolecularsequenceVariant(
    variant_pointer:,
    cigar:,
    reference_allele:,
    observed_allele:,
    end:,
    start:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn molecularsequence_referenceseq_to_json(
  molecularsequence_referenceseq: MolecularsequenceReferenceseq,
) -> Json {
  let MolecularsequenceReferenceseq(
    window_end:,
    window_start:,
    strand:,
    reference_seq_string:,
    reference_seq_pointer:,
    reference_seq_id:,
    orientation:,
    genome_build:,
    chromosome:,
    modifier_extension:,
    extension:,
    id:,
  ) = molecularsequence_referenceseq
  let fields = []
  let fields = case window_end {
    Some(v) -> [#("windowEnd", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case window_start {
    Some(v) -> [#("windowStart", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case strand {
    Some(v) -> [#("strand", r4bvaluesets.strandtype_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case reference_seq_string {
    Some(v) -> [#("referenceSeqString", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case reference_seq_pointer {
    Some(v) -> [#("referenceSeqPointer", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case reference_seq_id {
    Some(v) -> [#("referenceSeqId", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case orientation {
    Some(v) -> [
      #("orientation", r4bvaluesets.orientationtype_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case genome_build {
    Some(v) -> [#("genomeBuild", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case chromosome {
    Some(v) -> [#("chromosome", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn molecularsequence_referenceseq_decoder() -> Decoder(
  MolecularsequenceReferenceseq,
) {
  use window_end <- decode.optional_field(
    "windowEnd",
    None,
    decode.optional(decode.int),
  )
  use window_start <- decode.optional_field(
    "windowStart",
    None,
    decode.optional(decode.int),
  )
  use strand <- decode.optional_field(
    "strand",
    None,
    decode.optional(r4bvaluesets.strandtype_decoder()),
  )
  use reference_seq_string <- decode.optional_field(
    "referenceSeqString",
    None,
    decode.optional(decode.string),
  )
  use reference_seq_pointer <- decode.optional_field(
    "referenceSeqPointer",
    None,
    decode.optional(reference_decoder()),
  )
  use reference_seq_id <- decode.optional_field(
    "referenceSeqId",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use orientation <- decode.optional_field(
    "orientation",
    None,
    decode.optional(r4bvaluesets.orientationtype_decoder()),
  )
  use genome_build <- decode.optional_field(
    "genomeBuild",
    None,
    decode.optional(decode.string),
  )
  use chromosome <- decode.optional_field(
    "chromosome",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MolecularsequenceReferenceseq(
    window_end:,
    window_start:,
    strand:,
    reference_seq_string:,
    reference_seq_pointer:,
    reference_seq_id:,
    orientation:,
    genome_build:,
    chromosome:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn molecularsequence_to_json(molecularsequence: Molecularsequence) -> Json {
  let Molecularsequence(
    structure_variant:,
    pointer:,
    repository:,
    read_coverage:,
    quality:,
    observed_seq:,
    variant:,
    reference_seq:,
    quantity:,
    performer:,
    device:,
    specimen:,
    patient:,
    coordinate_system:,
    type_:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = molecularsequence
  let fields = [
    #("coordinateSystem", json.int(coordinate_system)),
  ]
  let fields = case structure_variant {
    [] -> fields
    _ -> [
      #(
        "structureVariant",
        json.array(
          structure_variant,
          molecularsequence_structurevariant_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case pointer {
    [] -> fields
    _ -> [#("pointer", json.array(pointer, reference_to_json)), ..fields]
  }
  let fields = case repository {
    [] -> fields
    _ -> [
      #(
        "repository",
        json.array(repository, molecularsequence_repository_to_json),
      ),
      ..fields
    ]
  }
  let fields = case read_coverage {
    Some(v) -> [#("readCoverage", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case quality {
    [] -> fields
    _ -> [
      #("quality", json.array(quality, molecularsequence_quality_to_json)),
      ..fields
    ]
  }
  let fields = case observed_seq {
    Some(v) -> [#("observedSeq", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case variant {
    [] -> fields
    _ -> [
      #("variant", json.array(variant, molecularsequence_variant_to_json)),
      ..fields
    ]
  }
  let fields = case reference_seq {
    Some(v) -> [
      #("referenceSeq", molecularsequence_referenceseq_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case quantity {
    Some(v) -> [#("quantity", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case performer {
    Some(v) -> [#("performer", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case device {
    Some(v) -> [#("device", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case specimen {
    Some(v) -> [#("specimen", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case patient {
    Some(v) -> [#("patient", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", r4bvaluesets.sequencetype_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Molecularsequence")), ..fields]
  json.object(fields)
}

pub fn molecularsequence_decoder() -> Decoder(Molecularsequence) {
  use structure_variant <- decode.optional_field(
    "structureVariant",
    [],
    decode.list(molecularsequence_structurevariant_decoder()),
  )
  use pointer <- decode.optional_field(
    "pointer",
    [],
    decode.list(reference_decoder()),
  )
  use repository <- decode.optional_field(
    "repository",
    [],
    decode.list(molecularsequence_repository_decoder()),
  )
  use read_coverage <- decode.optional_field(
    "readCoverage",
    None,
    decode.optional(decode.int),
  )
  use quality <- decode.optional_field(
    "quality",
    [],
    decode.list(molecularsequence_quality_decoder()),
  )
  use observed_seq <- decode.optional_field(
    "observedSeq",
    None,
    decode.optional(decode.string),
  )
  use variant <- decode.optional_field(
    "variant",
    [],
    decode.list(molecularsequence_variant_decoder()),
  )
  use reference_seq <- decode.optional_field(
    "referenceSeq",
    None,
    decode.optional(molecularsequence_referenceseq_decoder()),
  )
  use quantity <- decode.optional_field(
    "quantity",
    None,
    decode.optional(quantity_decoder()),
  )
  use performer <- decode.optional_field(
    "performer",
    None,
    decode.optional(reference_decoder()),
  )
  use device <- decode.optional_field(
    "device",
    None,
    decode.optional(reference_decoder()),
  )
  use specimen <- decode.optional_field(
    "specimen",
    None,
    decode.optional(reference_decoder()),
  )
  use patient <- decode.optional_field(
    "patient",
    None,
    decode.optional(reference_decoder()),
  )
  use coordinate_system <- decode.field("coordinateSystem", decode.int)
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(r4bvaluesets.sequencetype_decoder()),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Molecularsequence",
    decode.failure(molecularsequence_new(coordinate_system:), "resourceType"),
  )
  decode.success(Molecularsequence(
    structure_variant:,
    pointer:,
    repository:,
    read_coverage:,
    quality:,
    observed_seq:,
    variant:,
    reference_seq:,
    quantity:,
    performer:,
    device:,
    specimen:,
    patient:,
    coordinate_system:,
    type_:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/NamingSystem#resource
pub type Namingsystem {
  Namingsystem(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    name: String,
    status: r4bvaluesets.Publicationstatus,
    kind: r4bvaluesets.Namingsystemtype,
    date: String,
    publisher: Option(String),
    contact: List(Contactdetail),
    responsible: Option(String),
    type_: Option(Codeableconcept),
    description: Option(String),
    use_context: List(Usagecontext),
    jurisdiction: List(Codeableconcept),
    usage: Option(String),
    unique_id: List(NamingsystemUniqueid),
  )
}

pub fn namingsystem_new(
  date date: String,
  kind kind: r4bvaluesets.Namingsystemtype,
  status status: r4bvaluesets.Publicationstatus,
  name name: String,
) -> Namingsystem {
  Namingsystem(
    unique_id: [],
    usage: None,
    jurisdiction: [],
    use_context: [],
    description: None,
    type_: None,
    responsible: None,
    contact: [],
    publisher: None,
    date:,
    kind:,
    status:,
    name:,
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/NamingSystem#resource
pub type NamingsystemUniqueid {
  NamingsystemUniqueid(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: r4bvaluesets.Namingsystemidentifiertype,
    value: String,
    preferred: Option(Bool),
    comment: Option(String),
    period: Option(Period),
  )
}

pub fn namingsystem_uniqueid_new(
  value value: String,
  type_ type_: r4bvaluesets.Namingsystemidentifiertype,
) -> NamingsystemUniqueid {
  NamingsystemUniqueid(
    period: None,
    comment: None,
    preferred: None,
    value:,
    type_:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn namingsystem_uniqueid_to_json(
  namingsystem_uniqueid: NamingsystemUniqueid,
) -> Json {
  let NamingsystemUniqueid(
    period:,
    comment:,
    preferred:,
    value:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = namingsystem_uniqueid
  let fields = [
    #("value", json.string(value)),
    #("type", r4bvaluesets.namingsystemidentifiertype_to_json(type_)),
  ]
  let fields = case period {
    Some(v) -> [#("period", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case comment {
    Some(v) -> [#("comment", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case preferred {
    Some(v) -> [#("preferred", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn namingsystem_uniqueid_decoder() -> Decoder(NamingsystemUniqueid) {
  use period <- decode.optional_field(
    "period",
    None,
    decode.optional(period_decoder()),
  )
  use comment <- decode.optional_field(
    "comment",
    None,
    decode.optional(decode.string),
  )
  use preferred <- decode.optional_field(
    "preferred",
    None,
    decode.optional(decode.bool),
  )
  use value <- decode.field("value", decode.string)
  use type_ <- decode.field(
    "type",
    r4bvaluesets.namingsystemidentifiertype_decoder(),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(NamingsystemUniqueid(
    period:,
    comment:,
    preferred:,
    value:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn namingsystem_to_json(namingsystem: Namingsystem) -> Json {
  let Namingsystem(
    unique_id:,
    usage:,
    jurisdiction:,
    use_context:,
    description:,
    type_:,
    responsible:,
    contact:,
    publisher:,
    date:,
    kind:,
    status:,
    name:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = namingsystem
  let fields = [
    #("date", json.string(date)),
    #("kind", r4bvaluesets.namingsystemtype_to_json(kind)),
    #("status", r4bvaluesets.publicationstatus_to_json(status)),
    #("name", json.string(name)),
  ]
  let fields = case unique_id {
    [] -> fields
    _ -> [
      #("uniqueId", json.array(unique_id, namingsystem_uniqueid_to_json)),
      ..fields
    ]
  }
  let fields = case usage {
    Some(v) -> [#("usage", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case jurisdiction {
    [] -> fields
    _ -> [
      #("jurisdiction", json.array(jurisdiction, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case use_context {
    [] -> fields
    _ -> [
      #("useContext", json.array(use_context, usagecontext_to_json)),
      ..fields
    ]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case responsible {
    Some(v) -> [#("responsible", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case contact {
    [] -> fields
    _ -> [#("contact", json.array(contact, contactdetail_to_json)), ..fields]
  }
  let fields = case publisher {
    Some(v) -> [#("publisher", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Namingsystem")), ..fields]
  json.object(fields)
}

pub fn namingsystem_decoder() -> Decoder(Namingsystem) {
  use unique_id <- decode.optional_field(
    "uniqueId",
    [],
    decode.list(namingsystem_uniqueid_decoder()),
  )
  use usage <- decode.optional_field(
    "usage",
    None,
    decode.optional(decode.string),
  )
  use jurisdiction <- decode.optional_field(
    "jurisdiction",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use use_context <- decode.optional_field(
    "useContext",
    [],
    decode.list(usagecontext_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use responsible <- decode.optional_field(
    "responsible",
    None,
    decode.optional(decode.string),
  )
  use contact <- decode.optional_field(
    "contact",
    [],
    decode.list(contactdetail_decoder()),
  )
  use publisher <- decode.optional_field(
    "publisher",
    None,
    decode.optional(decode.string),
  )
  use date <- decode.field("date", decode.string)
  use kind <- decode.field("kind", r4bvaluesets.namingsystemtype_decoder())
  use status <- decode.field("status", r4bvaluesets.publicationstatus_decoder())
  use name <- decode.field("name", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Namingsystem",
    decode.failure(
      namingsystem_new(date:, kind:, status:, name:),
      "resourceType",
    ),
  )
  decode.success(Namingsystem(
    unique_id:,
    usage:,
    jurisdiction:,
    use_context:,
    description:,
    type_:,
    responsible:,
    contact:,
    publisher:,
    date:,
    kind:,
    status:,
    name:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/NutritionOrder#resource
pub type Nutritionorder {
  Nutritionorder(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    instantiates_canonical: List(String),
    instantiates_uri: List(String),
    instantiates: List(String),
    status: r4bvaluesets.Requeststatus,
    intent: r4bvaluesets.Requestintent,
    patient: Reference,
    encounter: Option(Reference),
    date_time: String,
    orderer: Option(Reference),
    allergy_intolerance: List(Reference),
    food_preference_modifier: List(Codeableconcept),
    exclude_food_modifier: List(Codeableconcept),
    oral_diet: Option(NutritionorderOraldiet),
    supplement: List(NutritionorderSupplement),
    enteral_formula: Option(NutritionorderEnteralformula),
    note: List(Annotation),
  )
}

pub fn nutritionorder_new(
  date_time date_time: String,
  patient patient: Reference,
  intent intent: r4bvaluesets.Requestintent,
  status status: r4bvaluesets.Requeststatus,
) -> Nutritionorder {
  Nutritionorder(
    note: [],
    enteral_formula: None,
    supplement: [],
    oral_diet: None,
    exclude_food_modifier: [],
    food_preference_modifier: [],
    allergy_intolerance: [],
    orderer: None,
    date_time:,
    encounter: None,
    patient:,
    intent:,
    status:,
    instantiates: [],
    instantiates_uri: [],
    instantiates_canonical: [],
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/NutritionOrder#resource
pub type NutritionorderOraldiet {
  NutritionorderOraldiet(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: List(Codeableconcept),
    schedule: List(Timing),
    nutrient: List(NutritionorderOraldietNutrient),
    texture: List(NutritionorderOraldietTexture),
    fluid_consistency_type: List(Codeableconcept),
    instruction: Option(String),
  )
}

pub fn nutritionorder_oraldiet_new() -> NutritionorderOraldiet {
  NutritionorderOraldiet(
    instruction: None,
    fluid_consistency_type: [],
    texture: [],
    nutrient: [],
    schedule: [],
    type_: [],
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/NutritionOrder#resource
pub type NutritionorderOraldietNutrient {
  NutritionorderOraldietNutrient(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    modifier: Option(Codeableconcept),
    amount: Option(Quantity),
  )
}

pub fn nutritionorder_oraldiet_nutrient_new() -> NutritionorderOraldietNutrient {
  NutritionorderOraldietNutrient(
    amount: None,
    modifier: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/NutritionOrder#resource
pub type NutritionorderOraldietTexture {
  NutritionorderOraldietTexture(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    modifier: Option(Codeableconcept),
    food_type: Option(Codeableconcept),
  )
}

pub fn nutritionorder_oraldiet_texture_new() -> NutritionorderOraldietTexture {
  NutritionorderOraldietTexture(
    food_type: None,
    modifier: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/NutritionOrder#resource
pub type NutritionorderSupplement {
  NutritionorderSupplement(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Option(Codeableconcept),
    product_name: Option(String),
    schedule: List(Timing),
    quantity: Option(Quantity),
    instruction: Option(String),
  )
}

pub fn nutritionorder_supplement_new() -> NutritionorderSupplement {
  NutritionorderSupplement(
    instruction: None,
    quantity: None,
    schedule: [],
    product_name: None,
    type_: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/NutritionOrder#resource
pub type NutritionorderEnteralformula {
  NutritionorderEnteralformula(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    base_formula_type: Option(Codeableconcept),
    base_formula_product_name: Option(String),
    additive_type: Option(Codeableconcept),
    additive_product_name: Option(String),
    caloric_density: Option(Quantity),
    routeof_administration: Option(Codeableconcept),
    administration: List(NutritionorderEnteralformulaAdministration),
    max_volume_to_deliver: Option(Quantity),
    administration_instruction: Option(String),
  )
}

pub fn nutritionorder_enteralformula_new() -> NutritionorderEnteralformula {
  NutritionorderEnteralformula(
    administration_instruction: None,
    max_volume_to_deliver: None,
    administration: [],
    routeof_administration: None,
    caloric_density: None,
    additive_product_name: None,
    additive_type: None,
    base_formula_product_name: None,
    base_formula_type: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/NutritionOrder#resource
pub type NutritionorderEnteralformulaAdministration {
  NutritionorderEnteralformulaAdministration(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    schedule: Option(Timing),
    quantity: Option(Quantity),
    rate: Option(NutritionorderEnteralformulaAdministrationRate),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/NutritionOrder#resource
pub type NutritionorderEnteralformulaAdministrationRate {
  NutritionorderEnteralformulaAdministrationRateQuantity(rate: Quantity)
  NutritionorderEnteralformulaAdministrationRateRatio(rate: Ratio)
}

pub fn nutritionorder_enteralformula_administration_rate_to_json(
  elt: NutritionorderEnteralformulaAdministrationRate,
) -> Json {
  case elt {
    NutritionorderEnteralformulaAdministrationRateQuantity(v) ->
      quantity_to_json(v)
    NutritionorderEnteralformulaAdministrationRateRatio(v) -> ratio_to_json(v)
  }
}

pub fn nutritionorder_enteralformula_administration_rate_decoder() -> Decoder(
  NutritionorderEnteralformulaAdministrationRate,
) {
  decode.one_of(
    decode.field("rateQuantity", quantity_decoder(), decode.success)
      |> decode.map(NutritionorderEnteralformulaAdministrationRateQuantity),
    [
      decode.field("rateRatio", ratio_decoder(), decode.success)
      |> decode.map(NutritionorderEnteralformulaAdministrationRateRatio),
    ],
  )
}

pub fn nutritionorder_enteralformula_administration_new() -> NutritionorderEnteralformulaAdministration {
  NutritionorderEnteralformulaAdministration(
    rate: None,
    quantity: None,
    schedule: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn nutritionorder_enteralformula_administration_to_json(
  nutritionorder_enteralformula_administration: NutritionorderEnteralformulaAdministration,
) -> Json {
  let NutritionorderEnteralformulaAdministration(
    rate:,
    quantity:,
    schedule:,
    modifier_extension:,
    extension:,
    id:,
  ) = nutritionorder_enteralformula_administration
  let fields = []
  let fields = case rate {
    Some(v) -> [
      #(
        "rate"
          <> case v {
          NutritionorderEnteralformulaAdministrationRateQuantity(_) ->
            "Quantity"
          NutritionorderEnteralformulaAdministrationRateRatio(_) -> "Ratio"
        },
        nutritionorder_enteralformula_administration_rate_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case quantity {
    Some(v) -> [#("quantity", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case schedule {
    Some(v) -> [#("schedule", timing_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn nutritionorder_enteralformula_administration_decoder() -> Decoder(
  NutritionorderEnteralformulaAdministration,
) {
  use rate <- decode.then(
    none_if_omitted(nutritionorder_enteralformula_administration_rate_decoder()),
  )
  use quantity <- decode.optional_field(
    "quantity",
    None,
    decode.optional(quantity_decoder()),
  )
  use schedule <- decode.optional_field(
    "schedule",
    None,
    decode.optional(timing_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(NutritionorderEnteralformulaAdministration(
    rate:,
    quantity:,
    schedule:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn nutritionorder_enteralformula_to_json(
  nutritionorder_enteralformula: NutritionorderEnteralformula,
) -> Json {
  let NutritionorderEnteralformula(
    administration_instruction:,
    max_volume_to_deliver:,
    administration:,
    routeof_administration:,
    caloric_density:,
    additive_product_name:,
    additive_type:,
    base_formula_product_name:,
    base_formula_type:,
    modifier_extension:,
    extension:,
    id:,
  ) = nutritionorder_enteralformula
  let fields = []
  let fields = case administration_instruction {
    Some(v) -> [#("administrationInstruction", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case max_volume_to_deliver {
    Some(v) -> [#("maxVolumeToDeliver", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case administration {
    [] -> fields
    _ -> [
      #(
        "administration",
        json.array(
          administration,
          nutritionorder_enteralformula_administration_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case routeof_administration {
    Some(v) -> [
      #("routeofAdministration", codeableconcept_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case caloric_density {
    Some(v) -> [#("caloricDensity", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case additive_product_name {
    Some(v) -> [#("additiveProductName", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case additive_type {
    Some(v) -> [#("additiveType", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case base_formula_product_name {
    Some(v) -> [#("baseFormulaProductName", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case base_formula_type {
    Some(v) -> [#("baseFormulaType", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn nutritionorder_enteralformula_decoder() -> Decoder(
  NutritionorderEnteralformula,
) {
  use administration_instruction <- decode.optional_field(
    "administrationInstruction",
    None,
    decode.optional(decode.string),
  )
  use max_volume_to_deliver <- decode.optional_field(
    "maxVolumeToDeliver",
    None,
    decode.optional(quantity_decoder()),
  )
  use administration <- decode.optional_field(
    "administration",
    [],
    decode.list(nutritionorder_enteralformula_administration_decoder()),
  )
  use routeof_administration <- decode.optional_field(
    "routeofAdministration",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use caloric_density <- decode.optional_field(
    "caloricDensity",
    None,
    decode.optional(quantity_decoder()),
  )
  use additive_product_name <- decode.optional_field(
    "additiveProductName",
    None,
    decode.optional(decode.string),
  )
  use additive_type <- decode.optional_field(
    "additiveType",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use base_formula_product_name <- decode.optional_field(
    "baseFormulaProductName",
    None,
    decode.optional(decode.string),
  )
  use base_formula_type <- decode.optional_field(
    "baseFormulaType",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(NutritionorderEnteralformula(
    administration_instruction:,
    max_volume_to_deliver:,
    administration:,
    routeof_administration:,
    caloric_density:,
    additive_product_name:,
    additive_type:,
    base_formula_product_name:,
    base_formula_type:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn nutritionorder_supplement_to_json(
  nutritionorder_supplement: NutritionorderSupplement,
) -> Json {
  let NutritionorderSupplement(
    instruction:,
    quantity:,
    schedule:,
    product_name:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = nutritionorder_supplement
  let fields = []
  let fields = case instruction {
    Some(v) -> [#("instruction", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case quantity {
    Some(v) -> [#("quantity", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case schedule {
    [] -> fields
    _ -> [#("schedule", json.array(schedule, timing_to_json)), ..fields]
  }
  let fields = case product_name {
    Some(v) -> [#("productName", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn nutritionorder_supplement_decoder() -> Decoder(NutritionorderSupplement) {
  use instruction <- decode.optional_field(
    "instruction",
    None,
    decode.optional(decode.string),
  )
  use quantity <- decode.optional_field(
    "quantity",
    None,
    decode.optional(quantity_decoder()),
  )
  use schedule <- decode.optional_field(
    "schedule",
    [],
    decode.list(timing_decoder()),
  )
  use product_name <- decode.optional_field(
    "productName",
    None,
    decode.optional(decode.string),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(NutritionorderSupplement(
    instruction:,
    quantity:,
    schedule:,
    product_name:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn nutritionorder_oraldiet_texture_to_json(
  nutritionorder_oraldiet_texture: NutritionorderOraldietTexture,
) -> Json {
  let NutritionorderOraldietTexture(
    food_type:,
    modifier:,
    modifier_extension:,
    extension:,
    id:,
  ) = nutritionorder_oraldiet_texture
  let fields = []
  let fields = case food_type {
    Some(v) -> [#("foodType", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier {
    Some(v) -> [#("modifier", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn nutritionorder_oraldiet_texture_decoder() -> Decoder(
  NutritionorderOraldietTexture,
) {
  use food_type <- decode.optional_field(
    "foodType",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier <- decode.optional_field(
    "modifier",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(NutritionorderOraldietTexture(
    food_type:,
    modifier:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn nutritionorder_oraldiet_nutrient_to_json(
  nutritionorder_oraldiet_nutrient: NutritionorderOraldietNutrient,
) -> Json {
  let NutritionorderOraldietNutrient(
    amount:,
    modifier:,
    modifier_extension:,
    extension:,
    id:,
  ) = nutritionorder_oraldiet_nutrient
  let fields = []
  let fields = case amount {
    Some(v) -> [#("amount", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier {
    Some(v) -> [#("modifier", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn nutritionorder_oraldiet_nutrient_decoder() -> Decoder(
  NutritionorderOraldietNutrient,
) {
  use amount <- decode.optional_field(
    "amount",
    None,
    decode.optional(quantity_decoder()),
  )
  use modifier <- decode.optional_field(
    "modifier",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(NutritionorderOraldietNutrient(
    amount:,
    modifier:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn nutritionorder_oraldiet_to_json(
  nutritionorder_oraldiet: NutritionorderOraldiet,
) -> Json {
  let NutritionorderOraldiet(
    instruction:,
    fluid_consistency_type:,
    texture:,
    nutrient:,
    schedule:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = nutritionorder_oraldiet
  let fields = []
  let fields = case instruction {
    Some(v) -> [#("instruction", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case fluid_consistency_type {
    [] -> fields
    _ -> [
      #(
        "fluidConsistencyType",
        json.array(fluid_consistency_type, codeableconcept_to_json),
      ),
      ..fields
    ]
  }
  let fields = case texture {
    [] -> fields
    _ -> [
      #("texture", json.array(texture, nutritionorder_oraldiet_texture_to_json)),
      ..fields
    ]
  }
  let fields = case nutrient {
    [] -> fields
    _ -> [
      #(
        "nutrient",
        json.array(nutrient, nutritionorder_oraldiet_nutrient_to_json),
      ),
      ..fields
    ]
  }
  let fields = case schedule {
    [] -> fields
    _ -> [#("schedule", json.array(schedule, timing_to_json)), ..fields]
  }
  let fields = case type_ {
    [] -> fields
    _ -> [#("type", json.array(type_, codeableconcept_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn nutritionorder_oraldiet_decoder() -> Decoder(NutritionorderOraldiet) {
  use instruction <- decode.optional_field(
    "instruction",
    None,
    decode.optional(decode.string),
  )
  use fluid_consistency_type <- decode.optional_field(
    "fluidConsistencyType",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use texture <- decode.optional_field(
    "texture",
    [],
    decode.list(nutritionorder_oraldiet_texture_decoder()),
  )
  use nutrient <- decode.optional_field(
    "nutrient",
    [],
    decode.list(nutritionorder_oraldiet_nutrient_decoder()),
  )
  use schedule <- decode.optional_field(
    "schedule",
    [],
    decode.list(timing_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(NutritionorderOraldiet(
    instruction:,
    fluid_consistency_type:,
    texture:,
    nutrient:,
    schedule:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn nutritionorder_to_json(nutritionorder: Nutritionorder) -> Json {
  let Nutritionorder(
    note:,
    enteral_formula:,
    supplement:,
    oral_diet:,
    exclude_food_modifier:,
    food_preference_modifier:,
    allergy_intolerance:,
    orderer:,
    date_time:,
    encounter:,
    patient:,
    intent:,
    status:,
    instantiates:,
    instantiates_uri:,
    instantiates_canonical:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = nutritionorder
  let fields = [
    #("dateTime", json.string(date_time)),
    #("patient", reference_to_json(patient)),
    #("intent", r4bvaluesets.requestintent_to_json(intent)),
    #("status", r4bvaluesets.requeststatus_to_json(status)),
  ]
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case enteral_formula {
    Some(v) -> [
      #("enteralFormula", nutritionorder_enteralformula_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case supplement {
    [] -> fields
    _ -> [
      #("supplement", json.array(supplement, nutritionorder_supplement_to_json)),
      ..fields
    ]
  }
  let fields = case oral_diet {
    Some(v) -> [#("oralDiet", nutritionorder_oraldiet_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case exclude_food_modifier {
    [] -> fields
    _ -> [
      #(
        "excludeFoodModifier",
        json.array(exclude_food_modifier, codeableconcept_to_json),
      ),
      ..fields
    ]
  }
  let fields = case food_preference_modifier {
    [] -> fields
    _ -> [
      #(
        "foodPreferenceModifier",
        json.array(food_preference_modifier, codeableconcept_to_json),
      ),
      ..fields
    ]
  }
  let fields = case allergy_intolerance {
    [] -> fields
    _ -> [
      #(
        "allergyIntolerance",
        json.array(allergy_intolerance, reference_to_json),
      ),
      ..fields
    ]
  }
  let fields = case orderer {
    Some(v) -> [#("orderer", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case encounter {
    Some(v) -> [#("encounter", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case instantiates {
    [] -> fields
    _ -> [#("instantiates", json.array(instantiates, json.string)), ..fields]
  }
  let fields = case instantiates_uri {
    [] -> fields
    _ -> [
      #("instantiatesUri", json.array(instantiates_uri, json.string)),
      ..fields
    ]
  }
  let fields = case instantiates_canonical {
    [] -> fields
    _ -> [
      #(
        "instantiatesCanonical",
        json.array(instantiates_canonical, json.string),
      ),
      ..fields
    ]
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Nutritionorder")), ..fields]
  json.object(fields)
}

pub fn nutritionorder_decoder() -> Decoder(Nutritionorder) {
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use enteral_formula <- decode.optional_field(
    "enteralFormula",
    None,
    decode.optional(nutritionorder_enteralformula_decoder()),
  )
  use supplement <- decode.optional_field(
    "supplement",
    [],
    decode.list(nutritionorder_supplement_decoder()),
  )
  use oral_diet <- decode.optional_field(
    "oralDiet",
    None,
    decode.optional(nutritionorder_oraldiet_decoder()),
  )
  use exclude_food_modifier <- decode.optional_field(
    "excludeFoodModifier",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use food_preference_modifier <- decode.optional_field(
    "foodPreferenceModifier",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use allergy_intolerance <- decode.optional_field(
    "allergyIntolerance",
    [],
    decode.list(reference_decoder()),
  )
  use orderer <- decode.optional_field(
    "orderer",
    None,
    decode.optional(reference_decoder()),
  )
  use date_time <- decode.field("dateTime", decode.string)
  use encounter <- decode.optional_field(
    "encounter",
    None,
    decode.optional(reference_decoder()),
  )
  use patient <- decode.field("patient", reference_decoder())
  use intent <- decode.field("intent", r4bvaluesets.requestintent_decoder())
  use status <- decode.field("status", r4bvaluesets.requeststatus_decoder())
  use instantiates <- decode.optional_field(
    "instantiates",
    [],
    decode.list(decode.string),
  )
  use instantiates_uri <- decode.optional_field(
    "instantiatesUri",
    [],
    decode.list(decode.string),
  )
  use instantiates_canonical <- decode.optional_field(
    "instantiatesCanonical",
    [],
    decode.list(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Nutritionorder",
    decode.failure(
      nutritionorder_new(date_time:, patient:, intent:, status:),
      "resourceType",
    ),
  )
  decode.success(Nutritionorder(
    note:,
    enteral_formula:,
    supplement:,
    oral_diet:,
    exclude_food_modifier:,
    food_preference_modifier:,
    allergy_intolerance:,
    orderer:,
    date_time:,
    encounter:,
    patient:,
    intent:,
    status:,
    instantiates:,
    instantiates_uri:,
    instantiates_canonical:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/NutritionProduct#resource
pub type Nutritionproduct {
  Nutritionproduct(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    status: r4bvaluesets.Nutritionproductstatus,
    category: List(Codeableconcept),
    code: Option(Codeableconcept),
    manufacturer: List(Reference),
    nutrient: List(NutritionproductNutrient),
    ingredient: List(NutritionproductIngredient),
    known_allergen: List(Codeablereference),
    product_characteristic: List(NutritionproductProductcharacteristic),
    instance: Option(NutritionproductInstance),
    note: List(Annotation),
  )
}

pub fn nutritionproduct_new(
  status status: r4bvaluesets.Nutritionproductstatus,
) -> Nutritionproduct {
  Nutritionproduct(
    note: [],
    instance: None,
    product_characteristic: [],
    known_allergen: [],
    ingredient: [],
    nutrient: [],
    manufacturer: [],
    code: None,
    category: [],
    status:,
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/NutritionProduct#resource
pub type NutritionproductNutrient {
  NutritionproductNutrient(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    item: Option(Codeablereference),
    amount: List(Ratio),
  )
}

pub fn nutritionproduct_nutrient_new() -> NutritionproductNutrient {
  NutritionproductNutrient(
    amount: [],
    item: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/NutritionProduct#resource
pub type NutritionproductIngredient {
  NutritionproductIngredient(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    item: Codeablereference,
    amount: List(Ratio),
  )
}

pub fn nutritionproduct_ingredient_new(
  item item: Codeablereference,
) -> NutritionproductIngredient {
  NutritionproductIngredient(
    amount: [],
    item:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/NutritionProduct#resource
pub type NutritionproductProductcharacteristic {
  NutritionproductProductcharacteristic(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Codeableconcept,
    value: NutritionproductProductcharacteristicValue,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/NutritionProduct#resource
pub type NutritionproductProductcharacteristicValue {
  NutritionproductProductcharacteristicValueCodeableconcept(
    value: Codeableconcept,
  )
  NutritionproductProductcharacteristicValueString(value: String)
  NutritionproductProductcharacteristicValueQuantity(value: Quantity)
  NutritionproductProductcharacteristicValueBase64binary(value: String)
  NutritionproductProductcharacteristicValueAttachment(value: Attachment)
  NutritionproductProductcharacteristicValueBoolean(value: Bool)
}

pub fn nutritionproduct_productcharacteristic_value_to_json(
  elt: NutritionproductProductcharacteristicValue,
) -> Json {
  case elt {
    NutritionproductProductcharacteristicValueCodeableconcept(v) ->
      codeableconcept_to_json(v)
    NutritionproductProductcharacteristicValueString(v) -> json.string(v)
    NutritionproductProductcharacteristicValueQuantity(v) -> quantity_to_json(v)
    NutritionproductProductcharacteristicValueBase64binary(v) -> json.string(v)
    NutritionproductProductcharacteristicValueAttachment(v) ->
      attachment_to_json(v)
    NutritionproductProductcharacteristicValueBoolean(v) -> json.bool(v)
  }
}

pub fn nutritionproduct_productcharacteristic_value_decoder() -> Decoder(
  NutritionproductProductcharacteristicValue,
) {
  decode.one_of(
    decode.field(
      "valueCodeableConcept",
      codeableconcept_decoder(),
      decode.success,
    )
      |> decode.map(NutritionproductProductcharacteristicValueCodeableconcept),
    [
      decode.field("valueString", decode.string, decode.success)
        |> decode.map(NutritionproductProductcharacteristicValueString),
      decode.field("valueQuantity", quantity_decoder(), decode.success)
        |> decode.map(NutritionproductProductcharacteristicValueQuantity),
      decode.field("valueBase64Binary", decode.string, decode.success)
        |> decode.map(NutritionproductProductcharacteristicValueBase64binary),
      decode.field("valueAttachment", attachment_decoder(), decode.success)
        |> decode.map(NutritionproductProductcharacteristicValueAttachment),
      decode.field("valueBoolean", decode.bool, decode.success)
        |> decode.map(NutritionproductProductcharacteristicValueBoolean),
    ],
  )
}

pub fn nutritionproduct_productcharacteristic_new(
  value value: NutritionproductProductcharacteristicValue,
  type_ type_: Codeableconcept,
) -> NutritionproductProductcharacteristic {
  NutritionproductProductcharacteristic(
    value:,
    type_:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/NutritionProduct#resource
pub type NutritionproductInstance {
  NutritionproductInstance(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    quantity: Option(Quantity),
    identifier: List(Identifier),
    lot_number: Option(String),
    expiry: Option(String),
    use_by: Option(String),
  )
}

pub fn nutritionproduct_instance_new() -> NutritionproductInstance {
  NutritionproductInstance(
    use_by: None,
    expiry: None,
    lot_number: None,
    identifier: [],
    quantity: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn nutritionproduct_instance_to_json(
  nutritionproduct_instance: NutritionproductInstance,
) -> Json {
  let NutritionproductInstance(
    use_by:,
    expiry:,
    lot_number:,
    identifier:,
    quantity:,
    modifier_extension:,
    extension:,
    id:,
  ) = nutritionproduct_instance
  let fields = []
  let fields = case use_by {
    Some(v) -> [#("useBy", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case expiry {
    Some(v) -> [#("expiry", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case lot_number {
    Some(v) -> [#("lotNumber", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case quantity {
    Some(v) -> [#("quantity", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn nutritionproduct_instance_decoder() -> Decoder(NutritionproductInstance) {
  use use_by <- decode.optional_field(
    "useBy",
    None,
    decode.optional(decode.string),
  )
  use expiry <- decode.optional_field(
    "expiry",
    None,
    decode.optional(decode.string),
  )
  use lot_number <- decode.optional_field(
    "lotNumber",
    None,
    decode.optional(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use quantity <- decode.optional_field(
    "quantity",
    None,
    decode.optional(quantity_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(NutritionproductInstance(
    use_by:,
    expiry:,
    lot_number:,
    identifier:,
    quantity:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn nutritionproduct_productcharacteristic_to_json(
  nutritionproduct_productcharacteristic: NutritionproductProductcharacteristic,
) -> Json {
  let NutritionproductProductcharacteristic(
    value:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = nutritionproduct_productcharacteristic
  let fields = [
    #("value", nutritionproduct_productcharacteristic_value_to_json(value)),
    #("type", codeableconcept_to_json(type_)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn nutritionproduct_productcharacteristic_decoder() -> Decoder(
  NutritionproductProductcharacteristic,
) {
  use value <- decode.then(
    nutritionproduct_productcharacteristic_value_decoder(),
  )
  use type_ <- decode.field("type", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(NutritionproductProductcharacteristic(
    value:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn nutritionproduct_ingredient_to_json(
  nutritionproduct_ingredient: NutritionproductIngredient,
) -> Json {
  let NutritionproductIngredient(
    amount:,
    item:,
    modifier_extension:,
    extension:,
    id:,
  ) = nutritionproduct_ingredient
  let fields = [
    #("item", codeablereference_to_json(item)),
  ]
  let fields = case amount {
    [] -> fields
    _ -> [#("amount", json.array(amount, ratio_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn nutritionproduct_ingredient_decoder() -> Decoder(
  NutritionproductIngredient,
) {
  use amount <- decode.optional_field(
    "amount",
    [],
    decode.list(ratio_decoder()),
  )
  use item <- decode.field("item", codeablereference_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(NutritionproductIngredient(
    amount:,
    item:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn nutritionproduct_nutrient_to_json(
  nutritionproduct_nutrient: NutritionproductNutrient,
) -> Json {
  let NutritionproductNutrient(
    amount:,
    item:,
    modifier_extension:,
    extension:,
    id:,
  ) = nutritionproduct_nutrient
  let fields = []
  let fields = case amount {
    [] -> fields
    _ -> [#("amount", json.array(amount, ratio_to_json)), ..fields]
  }
  let fields = case item {
    Some(v) -> [#("item", codeablereference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn nutritionproduct_nutrient_decoder() -> Decoder(NutritionproductNutrient) {
  use amount <- decode.optional_field(
    "amount",
    [],
    decode.list(ratio_decoder()),
  )
  use item <- decode.optional_field(
    "item",
    None,
    decode.optional(codeablereference_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(NutritionproductNutrient(
    amount:,
    item:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn nutritionproduct_to_json(nutritionproduct: Nutritionproduct) -> Json {
  let Nutritionproduct(
    note:,
    instance:,
    product_characteristic:,
    known_allergen:,
    ingredient:,
    nutrient:,
    manufacturer:,
    code:,
    category:,
    status:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = nutritionproduct
  let fields = [
    #("status", r4bvaluesets.nutritionproductstatus_to_json(status)),
  ]
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case instance {
    Some(v) -> [#("instance", nutritionproduct_instance_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case product_characteristic {
    [] -> fields
    _ -> [
      #(
        "productCharacteristic",
        json.array(
          product_characteristic,
          nutritionproduct_productcharacteristic_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case known_allergen {
    [] -> fields
    _ -> [
      #("knownAllergen", json.array(known_allergen, codeablereference_to_json)),
      ..fields
    ]
  }
  let fields = case ingredient {
    [] -> fields
    _ -> [
      #(
        "ingredient",
        json.array(ingredient, nutritionproduct_ingredient_to_json),
      ),
      ..fields
    ]
  }
  let fields = case nutrient {
    [] -> fields
    _ -> [
      #("nutrient", json.array(nutrient, nutritionproduct_nutrient_to_json)),
      ..fields
    ]
  }
  let fields = case manufacturer {
    [] -> fields
    _ -> [
      #("manufacturer", json.array(manufacturer, reference_to_json)),
      ..fields
    ]
  }
  let fields = case code {
    Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case category {
    [] -> fields
    _ -> [
      #("category", json.array(category, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Nutritionproduct")), ..fields]
  json.object(fields)
}

pub fn nutritionproduct_decoder() -> Decoder(Nutritionproduct) {
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use instance <- decode.optional_field(
    "instance",
    None,
    decode.optional(nutritionproduct_instance_decoder()),
  )
  use product_characteristic <- decode.optional_field(
    "productCharacteristic",
    [],
    decode.list(nutritionproduct_productcharacteristic_decoder()),
  )
  use known_allergen <- decode.optional_field(
    "knownAllergen",
    [],
    decode.list(codeablereference_decoder()),
  )
  use ingredient <- decode.optional_field(
    "ingredient",
    [],
    decode.list(nutritionproduct_ingredient_decoder()),
  )
  use nutrient <- decode.optional_field(
    "nutrient",
    [],
    decode.list(nutritionproduct_nutrient_decoder()),
  )
  use manufacturer <- decode.optional_field(
    "manufacturer",
    [],
    decode.list(reference_decoder()),
  )
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use category <- decode.optional_field(
    "category",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use status <- decode.field(
    "status",
    r4bvaluesets.nutritionproductstatus_decoder(),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Nutritionproduct",
    decode.failure(nutritionproduct_new(status:), "resourceType"),
  )
  decode.success(Nutritionproduct(
    note:,
    instance:,
    product_characteristic:,
    known_allergen:,
    ingredient:,
    nutrient:,
    manufacturer:,
    code:,
    category:,
    status:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/Observation#resource
pub type Observation {
  Observation(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    based_on: List(Reference),
    part_of: List(Reference),
    status: r4bvaluesets.Observationstatus,
    category: List(Codeableconcept),
    code: Codeableconcept,
    subject: Option(Reference),
    focus: List(Reference),
    encounter: Option(Reference),
    effective: Option(ObservationEffective),
    issued: Option(String),
    performer: List(Reference),
    value: Option(ObservationValue),
    data_absent_reason: Option(Codeableconcept),
    interpretation: List(Codeableconcept),
    note: List(Annotation),
    body_site: Option(Codeableconcept),
    method: Option(Codeableconcept),
    specimen: Option(Reference),
    device: Option(Reference),
    reference_range: List(ObservationReferencerange),
    has_member: List(Reference),
    derived_from: List(Reference),
    component: List(ObservationComponent),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Observation#resource
pub type ObservationEffective {
  ObservationEffectiveDatetime(effective: String)
  ObservationEffectivePeriod(effective: Period)
  ObservationEffectiveTiming(effective: Timing)
  ObservationEffectiveInstant(effective: String)
}

pub fn observation_effective_to_json(elt: ObservationEffective) -> Json {
  case elt {
    ObservationEffectiveDatetime(v) -> json.string(v)
    ObservationEffectivePeriod(v) -> period_to_json(v)
    ObservationEffectiveTiming(v) -> timing_to_json(v)
    ObservationEffectiveInstant(v) -> json.string(v)
  }
}

pub fn observation_effective_decoder() -> Decoder(ObservationEffective) {
  decode.one_of(
    decode.field("effectiveDateTime", decode.string, decode.success)
      |> decode.map(ObservationEffectiveDatetime),
    [
      decode.field("effectivePeriod", period_decoder(), decode.success)
        |> decode.map(ObservationEffectivePeriod),
      decode.field("effectiveTiming", timing_decoder(), decode.success)
        |> decode.map(ObservationEffectiveTiming),
      decode.field("effectiveInstant", decode.string, decode.success)
        |> decode.map(ObservationEffectiveInstant),
    ],
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Observation#resource
pub type ObservationValue {
  ObservationValueQuantity(value: Quantity)
  ObservationValueCodeableconcept(value: Codeableconcept)
  ObservationValueString(value: String)
  ObservationValueBoolean(value: Bool)
  ObservationValueInteger(value: Int)
  ObservationValueRange(value: Range)
  ObservationValueRatio(value: Ratio)
  ObservationValueSampleddata(value: Sampleddata)
  ObservationValueTime(value: String)
  ObservationValueDatetime(value: String)
  ObservationValuePeriod(value: Period)
}

pub fn observation_value_to_json(elt: ObservationValue) -> Json {
  case elt {
    ObservationValueQuantity(v) -> quantity_to_json(v)
    ObservationValueCodeableconcept(v) -> codeableconcept_to_json(v)
    ObservationValueString(v) -> json.string(v)
    ObservationValueBoolean(v) -> json.bool(v)
    ObservationValueInteger(v) -> json.int(v)
    ObservationValueRange(v) -> range_to_json(v)
    ObservationValueRatio(v) -> ratio_to_json(v)
    ObservationValueSampleddata(v) -> sampleddata_to_json(v)
    ObservationValueTime(v) -> json.string(v)
    ObservationValueDatetime(v) -> json.string(v)
    ObservationValuePeriod(v) -> period_to_json(v)
  }
}

pub fn observation_value_decoder() -> Decoder(ObservationValue) {
  decode.one_of(
    decode.field("valueQuantity", quantity_decoder(), decode.success)
      |> decode.map(ObservationValueQuantity),
    [
      decode.field(
        "valueCodeableConcept",
        codeableconcept_decoder(),
        decode.success,
      )
        |> decode.map(ObservationValueCodeableconcept),
      decode.field("valueString", decode.string, decode.success)
        |> decode.map(ObservationValueString),
      decode.field("valueBoolean", decode.bool, decode.success)
        |> decode.map(ObservationValueBoolean),
      decode.field("valueInteger", decode.int, decode.success)
        |> decode.map(ObservationValueInteger),
      decode.field("valueRange", range_decoder(), decode.success)
        |> decode.map(ObservationValueRange),
      decode.field("valueRatio", ratio_decoder(), decode.success)
        |> decode.map(ObservationValueRatio),
      decode.field("valueSampledData", sampleddata_decoder(), decode.success)
        |> decode.map(ObservationValueSampleddata),
      decode.field("valueTime", decode.string, decode.success)
        |> decode.map(ObservationValueTime),
      decode.field("valueDateTime", decode.string, decode.success)
        |> decode.map(ObservationValueDatetime),
      decode.field("valuePeriod", period_decoder(), decode.success)
        |> decode.map(ObservationValuePeriod),
    ],
  )
}

pub fn observation_new(
  code code: Codeableconcept,
  status status: r4bvaluesets.Observationstatus,
) -> Observation {
  Observation(
    component: [],
    derived_from: [],
    has_member: [],
    reference_range: [],
    device: None,
    specimen: None,
    method: None,
    body_site: None,
    note: [],
    interpretation: [],
    data_absent_reason: None,
    value: None,
    performer: [],
    issued: None,
    effective: None,
    encounter: None,
    focus: [],
    subject: None,
    code:,
    category: [],
    status:,
    part_of: [],
    based_on: [],
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Observation#resource
pub type ObservationReferencerange {
  ObservationReferencerange(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    low: Option(Quantity),
    high: Option(Quantity),
    type_: Option(Codeableconcept),
    applies_to: List(Codeableconcept),
    age: Option(Range),
    text: Option(String),
  )
}

pub fn observation_referencerange_new() -> ObservationReferencerange {
  ObservationReferencerange(
    text: None,
    age: None,
    applies_to: [],
    type_: None,
    high: None,
    low: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Observation#resource
pub type ObservationComponent {
  ObservationComponent(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    code: Codeableconcept,
    value: Option(ObservationComponentValue),
    data_absent_reason: Option(Codeableconcept),
    interpretation: List(Codeableconcept),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Observation#resource
pub type ObservationComponentValue {
  ObservationComponentValueQuantity(value: Quantity)
  ObservationComponentValueCodeableconcept(value: Codeableconcept)
  ObservationComponentValueString(value: String)
  ObservationComponentValueBoolean(value: Bool)
  ObservationComponentValueInteger(value: Int)
  ObservationComponentValueRange(value: Range)
  ObservationComponentValueRatio(value: Ratio)
  ObservationComponentValueSampleddata(value: Sampleddata)
  ObservationComponentValueTime(value: String)
  ObservationComponentValueDatetime(value: String)
  ObservationComponentValuePeriod(value: Period)
}

pub fn observation_component_value_to_json(
  elt: ObservationComponentValue,
) -> Json {
  case elt {
    ObservationComponentValueQuantity(v) -> quantity_to_json(v)
    ObservationComponentValueCodeableconcept(v) -> codeableconcept_to_json(v)
    ObservationComponentValueString(v) -> json.string(v)
    ObservationComponentValueBoolean(v) -> json.bool(v)
    ObservationComponentValueInteger(v) -> json.int(v)
    ObservationComponentValueRange(v) -> range_to_json(v)
    ObservationComponentValueRatio(v) -> ratio_to_json(v)
    ObservationComponentValueSampleddata(v) -> sampleddata_to_json(v)
    ObservationComponentValueTime(v) -> json.string(v)
    ObservationComponentValueDatetime(v) -> json.string(v)
    ObservationComponentValuePeriod(v) -> period_to_json(v)
  }
}

pub fn observation_component_value_decoder() -> Decoder(
  ObservationComponentValue,
) {
  decode.one_of(
    decode.field("valueQuantity", quantity_decoder(), decode.success)
      |> decode.map(ObservationComponentValueQuantity),
    [
      decode.field(
        "valueCodeableConcept",
        codeableconcept_decoder(),
        decode.success,
      )
        |> decode.map(ObservationComponentValueCodeableconcept),
      decode.field("valueString", decode.string, decode.success)
        |> decode.map(ObservationComponentValueString),
      decode.field("valueBoolean", decode.bool, decode.success)
        |> decode.map(ObservationComponentValueBoolean),
      decode.field("valueInteger", decode.int, decode.success)
        |> decode.map(ObservationComponentValueInteger),
      decode.field("valueRange", range_decoder(), decode.success)
        |> decode.map(ObservationComponentValueRange),
      decode.field("valueRatio", ratio_decoder(), decode.success)
        |> decode.map(ObservationComponentValueRatio),
      decode.field("valueSampledData", sampleddata_decoder(), decode.success)
        |> decode.map(ObservationComponentValueSampleddata),
      decode.field("valueTime", decode.string, decode.success)
        |> decode.map(ObservationComponentValueTime),
      decode.field("valueDateTime", decode.string, decode.success)
        |> decode.map(ObservationComponentValueDatetime),
      decode.field("valuePeriod", period_decoder(), decode.success)
        |> decode.map(ObservationComponentValuePeriod),
    ],
  )
}

pub fn observation_component_new(
  code code: Codeableconcept,
) -> ObservationComponent {
  ObservationComponent(
    interpretation: [],
    data_absent_reason: None,
    value: None,
    code:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn observation_component_to_json(
  observation_component: ObservationComponent,
) -> Json {
  let ObservationComponent(
    interpretation:,
    data_absent_reason:,
    value:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ) = observation_component
  let fields = [
    #("code", codeableconcept_to_json(code)),
  ]
  let fields = case interpretation {
    [] -> fields
    _ -> [
      #("interpretation", json.array(interpretation, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case data_absent_reason {
    Some(v) -> [#("dataAbsentReason", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case value {
    Some(v) -> [
      #(
        "value"
          <> case v {
          ObservationComponentValueQuantity(_) -> "Quantity"
          ObservationComponentValueCodeableconcept(_) -> "Codeableconcept"
          ObservationComponentValueString(_) -> "String"
          ObservationComponentValueBoolean(_) -> "Boolean"
          ObservationComponentValueInteger(_) -> "Integer"
          ObservationComponentValueRange(_) -> "Range"
          ObservationComponentValueRatio(_) -> "Ratio"
          ObservationComponentValueSampleddata(_) -> "Sampleddata"
          ObservationComponentValueTime(_) -> "Time"
          ObservationComponentValueDatetime(_) -> "Datetime"
          ObservationComponentValuePeriod(_) -> "Period"
        },
        observation_component_value_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn observation_component_decoder() -> Decoder(ObservationComponent) {
  use interpretation <- decode.optional_field(
    "interpretation",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use data_absent_reason <- decode.optional_field(
    "dataAbsentReason",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use value <- decode.then(
    none_if_omitted(observation_component_value_decoder()),
  )
  use code <- decode.field("code", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ObservationComponent(
    interpretation:,
    data_absent_reason:,
    value:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn observation_referencerange_to_json(
  observation_referencerange: ObservationReferencerange,
) -> Json {
  let ObservationReferencerange(
    text:,
    age:,
    applies_to:,
    type_:,
    high:,
    low:,
    modifier_extension:,
    extension:,
    id:,
  ) = observation_referencerange
  let fields = []
  let fields = case text {
    Some(v) -> [#("text", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case age {
    Some(v) -> [#("age", range_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case applies_to {
    [] -> fields
    _ -> [
      #("appliesTo", json.array(applies_to, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case high {
    Some(v) -> [#("high", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case low {
    Some(v) -> [#("low", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn observation_referencerange_decoder() -> Decoder(
  ObservationReferencerange,
) {
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(decode.string),
  )
  use age <- decode.optional_field(
    "age",
    None,
    decode.optional(range_decoder()),
  )
  use applies_to <- decode.optional_field(
    "appliesTo",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use high <- decode.optional_field(
    "high",
    None,
    decode.optional(quantity_decoder()),
  )
  use low <- decode.optional_field(
    "low",
    None,
    decode.optional(quantity_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ObservationReferencerange(
    text:,
    age:,
    applies_to:,
    type_:,
    high:,
    low:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn observation_to_json(observation: Observation) -> Json {
  let Observation(
    component:,
    derived_from:,
    has_member:,
    reference_range:,
    device:,
    specimen:,
    method:,
    body_site:,
    note:,
    interpretation:,
    data_absent_reason:,
    value:,
    performer:,
    issued:,
    effective:,
    encounter:,
    focus:,
    subject:,
    code:,
    category:,
    status:,
    part_of:,
    based_on:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = observation
  let fields = [
    #("code", codeableconcept_to_json(code)),
    #("status", r4bvaluesets.observationstatus_to_json(status)),
  ]
  let fields = case component {
    [] -> fields
    _ -> [
      #("component", json.array(component, observation_component_to_json)),
      ..fields
    ]
  }
  let fields = case derived_from {
    [] -> fields
    _ -> [
      #("derivedFrom", json.array(derived_from, reference_to_json)),
      ..fields
    ]
  }
  let fields = case has_member {
    [] -> fields
    _ -> [#("hasMember", json.array(has_member, reference_to_json)), ..fields]
  }
  let fields = case reference_range {
    [] -> fields
    _ -> [
      #(
        "referenceRange",
        json.array(reference_range, observation_referencerange_to_json),
      ),
      ..fields
    ]
  }
  let fields = case device {
    Some(v) -> [#("device", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case specimen {
    Some(v) -> [#("specimen", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case method {
    Some(v) -> [#("method", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case body_site {
    Some(v) -> [#("bodySite", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case interpretation {
    [] -> fields
    _ -> [
      #("interpretation", json.array(interpretation, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case data_absent_reason {
    Some(v) -> [#("dataAbsentReason", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case value {
    Some(v) -> [
      #(
        "value"
          <> case v {
          ObservationValueQuantity(_) -> "Quantity"
          ObservationValueCodeableconcept(_) -> "Codeableconcept"
          ObservationValueString(_) -> "String"
          ObservationValueBoolean(_) -> "Boolean"
          ObservationValueInteger(_) -> "Integer"
          ObservationValueRange(_) -> "Range"
          ObservationValueRatio(_) -> "Ratio"
          ObservationValueSampleddata(_) -> "Sampleddata"
          ObservationValueTime(_) -> "Time"
          ObservationValueDatetime(_) -> "Datetime"
          ObservationValuePeriod(_) -> "Period"
        },
        observation_value_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case performer {
    [] -> fields
    _ -> [#("performer", json.array(performer, reference_to_json)), ..fields]
  }
  let fields = case issued {
    Some(v) -> [#("issued", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case effective {
    Some(v) -> [
      #(
        "effective"
          <> case v {
          ObservationEffectiveDatetime(_) -> "Datetime"
          ObservationEffectivePeriod(_) -> "Period"
          ObservationEffectiveTiming(_) -> "Timing"
          ObservationEffectiveInstant(_) -> "Instant"
        },
        observation_effective_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case encounter {
    Some(v) -> [#("encounter", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case focus {
    [] -> fields
    _ -> [#("focus", json.array(focus, reference_to_json)), ..fields]
  }
  let fields = case subject {
    Some(v) -> [#("subject", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case category {
    [] -> fields
    _ -> [
      #("category", json.array(category, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case part_of {
    [] -> fields
    _ -> [#("partOf", json.array(part_of, reference_to_json)), ..fields]
  }
  let fields = case based_on {
    [] -> fields
    _ -> [#("basedOn", json.array(based_on, reference_to_json)), ..fields]
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Observation")), ..fields]
  json.object(fields)
}

pub fn observation_decoder() -> Decoder(Observation) {
  use component <- decode.optional_field(
    "component",
    [],
    decode.list(observation_component_decoder()),
  )
  use derived_from <- decode.optional_field(
    "derivedFrom",
    [],
    decode.list(reference_decoder()),
  )
  use has_member <- decode.optional_field(
    "hasMember",
    [],
    decode.list(reference_decoder()),
  )
  use reference_range <- decode.optional_field(
    "referenceRange",
    [],
    decode.list(observation_referencerange_decoder()),
  )
  use device <- decode.optional_field(
    "device",
    None,
    decode.optional(reference_decoder()),
  )
  use specimen <- decode.optional_field(
    "specimen",
    None,
    decode.optional(reference_decoder()),
  )
  use method <- decode.optional_field(
    "method",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use body_site <- decode.optional_field(
    "bodySite",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use interpretation <- decode.optional_field(
    "interpretation",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use data_absent_reason <- decode.optional_field(
    "dataAbsentReason",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use value <- decode.then(none_if_omitted(observation_value_decoder()))
  use performer <- decode.optional_field(
    "performer",
    [],
    decode.list(reference_decoder()),
  )
  use issued <- decode.optional_field(
    "issued",
    None,
    decode.optional(decode.string),
  )
  use effective <- decode.then(none_if_omitted(observation_effective_decoder()))
  use encounter <- decode.optional_field(
    "encounter",
    None,
    decode.optional(reference_decoder()),
  )
  use focus <- decode.optional_field(
    "focus",
    [],
    decode.list(reference_decoder()),
  )
  use subject <- decode.optional_field(
    "subject",
    None,
    decode.optional(reference_decoder()),
  )
  use code <- decode.field("code", codeableconcept_decoder())
  use category <- decode.optional_field(
    "category",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use status <- decode.field("status", r4bvaluesets.observationstatus_decoder())
  use part_of <- decode.optional_field(
    "partOf",
    [],
    decode.list(reference_decoder()),
  )
  use based_on <- decode.optional_field(
    "basedOn",
    [],
    decode.list(reference_decoder()),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Observation",
    decode.failure(observation_new(code:, status:), "resourceType"),
  )
  decode.success(Observation(
    component:,
    derived_from:,
    has_member:,
    reference_range:,
    device:,
    specimen:,
    method:,
    body_site:,
    note:,
    interpretation:,
    data_absent_reason:,
    value:,
    performer:,
    issued:,
    effective:,
    encounter:,
    focus:,
    subject:,
    code:,
    category:,
    status:,
    part_of:,
    based_on:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/ObservationDefinition#resource
pub type Observationdefinition {
  Observationdefinition(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    category: List(Codeableconcept),
    code: Codeableconcept,
    identifier: List(Identifier),
    permitted_data_type: List(r4bvaluesets.Permitteddatatype),
    multiple_results_allowed: Option(Bool),
    method: Option(Codeableconcept),
    preferred_report_name: Option(String),
    quantitative_details: Option(ObservationdefinitionQuantitativedetails),
    qualified_interval: List(ObservationdefinitionQualifiedinterval),
    valid_coded_value_set: Option(Reference),
    normal_coded_value_set: Option(Reference),
    abnormal_coded_value_set: Option(Reference),
    critical_coded_value_set: Option(Reference),
  )
}

pub fn observationdefinition_new(
  code code: Codeableconcept,
) -> Observationdefinition {
  Observationdefinition(
    critical_coded_value_set: None,
    abnormal_coded_value_set: None,
    normal_coded_value_set: None,
    valid_coded_value_set: None,
    qualified_interval: [],
    quantitative_details: None,
    preferred_report_name: None,
    method: None,
    multiple_results_allowed: None,
    permitted_data_type: [],
    identifier: [],
    code:,
    category: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ObservationDefinition#resource
pub type ObservationdefinitionQuantitativedetails {
  ObservationdefinitionQuantitativedetails(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    customary_unit: Option(Codeableconcept),
    unit: Option(Codeableconcept),
    conversion_factor: Option(Float),
    decimal_precision: Option(Int),
  )
}

pub fn observationdefinition_quantitativedetails_new() -> ObservationdefinitionQuantitativedetails {
  ObservationdefinitionQuantitativedetails(
    decimal_precision: None,
    conversion_factor: None,
    unit: None,
    customary_unit: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ObservationDefinition#resource
pub type ObservationdefinitionQualifiedinterval {
  ObservationdefinitionQualifiedinterval(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    category: Option(r4bvaluesets.Observationrangecategory),
    range: Option(Range),
    context: Option(Codeableconcept),
    applies_to: List(Codeableconcept),
    gender: Option(r4bvaluesets.Administrativegender),
    age: Option(Range),
    gestational_age: Option(Range),
    condition: Option(String),
  )
}

pub fn observationdefinition_qualifiedinterval_new() -> ObservationdefinitionQualifiedinterval {
  ObservationdefinitionQualifiedinterval(
    condition: None,
    gestational_age: None,
    age: None,
    gender: None,
    applies_to: [],
    context: None,
    range: None,
    category: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn observationdefinition_qualifiedinterval_to_json(
  observationdefinition_qualifiedinterval: ObservationdefinitionQualifiedinterval,
) -> Json {
  let ObservationdefinitionQualifiedinterval(
    condition:,
    gestational_age:,
    age:,
    gender:,
    applies_to:,
    context:,
    range:,
    category:,
    modifier_extension:,
    extension:,
    id:,
  ) = observationdefinition_qualifiedinterval
  let fields = []
  let fields = case condition {
    Some(v) -> [#("condition", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case gestational_age {
    Some(v) -> [#("gestationalAge", range_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case age {
    Some(v) -> [#("age", range_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case gender {
    Some(v) -> [
      #("gender", r4bvaluesets.administrativegender_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case applies_to {
    [] -> fields
    _ -> [
      #("appliesTo", json.array(applies_to, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case context {
    Some(v) -> [#("context", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case range {
    Some(v) -> [#("range", range_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case category {
    Some(v) -> [
      #("category", r4bvaluesets.observationrangecategory_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn observationdefinition_qualifiedinterval_decoder() -> Decoder(
  ObservationdefinitionQualifiedinterval,
) {
  use condition <- decode.optional_field(
    "condition",
    None,
    decode.optional(decode.string),
  )
  use gestational_age <- decode.optional_field(
    "gestationalAge",
    None,
    decode.optional(range_decoder()),
  )
  use age <- decode.optional_field(
    "age",
    None,
    decode.optional(range_decoder()),
  )
  use gender <- decode.optional_field(
    "gender",
    None,
    decode.optional(r4bvaluesets.administrativegender_decoder()),
  )
  use applies_to <- decode.optional_field(
    "appliesTo",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use context <- decode.optional_field(
    "context",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use range <- decode.optional_field(
    "range",
    None,
    decode.optional(range_decoder()),
  )
  use category <- decode.optional_field(
    "category",
    None,
    decode.optional(r4bvaluesets.observationrangecategory_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ObservationdefinitionQualifiedinterval(
    condition:,
    gestational_age:,
    age:,
    gender:,
    applies_to:,
    context:,
    range:,
    category:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn observationdefinition_quantitativedetails_to_json(
  observationdefinition_quantitativedetails: ObservationdefinitionQuantitativedetails,
) -> Json {
  let ObservationdefinitionQuantitativedetails(
    decimal_precision:,
    conversion_factor:,
    unit:,
    customary_unit:,
    modifier_extension:,
    extension:,
    id:,
  ) = observationdefinition_quantitativedetails
  let fields = []
  let fields = case decimal_precision {
    Some(v) -> [#("decimalPrecision", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case conversion_factor {
    Some(v) -> [#("conversionFactor", json.float(v)), ..fields]
    None -> fields
  }
  let fields = case unit {
    Some(v) -> [#("unit", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case customary_unit {
    Some(v) -> [#("customaryUnit", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn observationdefinition_quantitativedetails_decoder() -> Decoder(
  ObservationdefinitionQuantitativedetails,
) {
  use decimal_precision <- decode.optional_field(
    "decimalPrecision",
    None,
    decode.optional(decode.int),
  )
  use conversion_factor <- decode.optional_field(
    "conversionFactor",
    None,
    decode.optional(decode.float),
  )
  use unit <- decode.optional_field(
    "unit",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use customary_unit <- decode.optional_field(
    "customaryUnit",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ObservationdefinitionQuantitativedetails(
    decimal_precision:,
    conversion_factor:,
    unit:,
    customary_unit:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn observationdefinition_to_json(
  observationdefinition: Observationdefinition,
) -> Json {
  let Observationdefinition(
    critical_coded_value_set:,
    abnormal_coded_value_set:,
    normal_coded_value_set:,
    valid_coded_value_set:,
    qualified_interval:,
    quantitative_details:,
    preferred_report_name:,
    method:,
    multiple_results_allowed:,
    permitted_data_type:,
    identifier:,
    code:,
    category:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = observationdefinition
  let fields = [
    #("code", codeableconcept_to_json(code)),
  ]
  let fields = case critical_coded_value_set {
    Some(v) -> [#("criticalCodedValueSet", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case abnormal_coded_value_set {
    Some(v) -> [#("abnormalCodedValueSet", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case normal_coded_value_set {
    Some(v) -> [#("normalCodedValueSet", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case valid_coded_value_set {
    Some(v) -> [#("validCodedValueSet", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case qualified_interval {
    [] -> fields
    _ -> [
      #(
        "qualifiedInterval",
        json.array(
          qualified_interval,
          observationdefinition_qualifiedinterval_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case quantitative_details {
    Some(v) -> [
      #(
        "quantitativeDetails",
        observationdefinition_quantitativedetails_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case preferred_report_name {
    Some(v) -> [#("preferredReportName", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case method {
    Some(v) -> [#("method", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case multiple_results_allowed {
    Some(v) -> [#("multipleResultsAllowed", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case permitted_data_type {
    [] -> fields
    _ -> [
      #(
        "permittedDataType",
        json.array(permitted_data_type, r4bvaluesets.permitteddatatype_to_json),
      ),
      ..fields
    ]
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case category {
    [] -> fields
    _ -> [
      #("category", json.array(category, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [
    #("resourceType", json.string("Observationdefinition")),
    ..fields
  ]
  json.object(fields)
}

pub fn observationdefinition_decoder() -> Decoder(Observationdefinition) {
  use critical_coded_value_set <- decode.optional_field(
    "criticalCodedValueSet",
    None,
    decode.optional(reference_decoder()),
  )
  use abnormal_coded_value_set <- decode.optional_field(
    "abnormalCodedValueSet",
    None,
    decode.optional(reference_decoder()),
  )
  use normal_coded_value_set <- decode.optional_field(
    "normalCodedValueSet",
    None,
    decode.optional(reference_decoder()),
  )
  use valid_coded_value_set <- decode.optional_field(
    "validCodedValueSet",
    None,
    decode.optional(reference_decoder()),
  )
  use qualified_interval <- decode.optional_field(
    "qualifiedInterval",
    [],
    decode.list(observationdefinition_qualifiedinterval_decoder()),
  )
  use quantitative_details <- decode.optional_field(
    "quantitativeDetails",
    None,
    decode.optional(observationdefinition_quantitativedetails_decoder()),
  )
  use preferred_report_name <- decode.optional_field(
    "preferredReportName",
    None,
    decode.optional(decode.string),
  )
  use method <- decode.optional_field(
    "method",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use multiple_results_allowed <- decode.optional_field(
    "multipleResultsAllowed",
    None,
    decode.optional(decode.bool),
  )
  use permitted_data_type <- decode.optional_field(
    "permittedDataType",
    [],
    decode.list(r4bvaluesets.permitteddatatype_decoder()),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use code <- decode.field("code", codeableconcept_decoder())
  use category <- decode.optional_field(
    "category",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Observationdefinition",
    decode.failure(observationdefinition_new(code:), "resourceType"),
  )
  decode.success(Observationdefinition(
    critical_coded_value_set:,
    abnormal_coded_value_set:,
    normal_coded_value_set:,
    valid_coded_value_set:,
    qualified_interval:,
    quantitative_details:,
    preferred_report_name:,
    method:,
    multiple_results_allowed:,
    permitted_data_type:,
    identifier:,
    code:,
    category:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/OperationDefinition#resource
pub type Operationdefinition {
  Operationdefinition(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    url: Option(String),
    version: Option(String),
    name: String,
    title: Option(String),
    status: r4bvaluesets.Publicationstatus,
    kind: r4bvaluesets.Operationkind,
    experimental: Option(Bool),
    date: Option(String),
    publisher: Option(String),
    contact: List(Contactdetail),
    description: Option(String),
    use_context: List(Usagecontext),
    jurisdiction: List(Codeableconcept),
    purpose: Option(String),
    affects_state: Option(Bool),
    code: String,
    comment: Option(String),
    base: Option(String),
    resource: List(r4bvaluesets.Resourcetypes),
    system: Bool,
    type_: Bool,
    instance: Bool,
    input_profile: Option(String),
    output_profile: Option(String),
    parameter: List(OperationdefinitionParameter),
    overload: List(OperationdefinitionOverload),
  )
}

pub fn operationdefinition_new(
  instance instance: Bool,
  type_ type_: Bool,
  system system: Bool,
  code code: String,
  kind kind: r4bvaluesets.Operationkind,
  status status: r4bvaluesets.Publicationstatus,
  name name: String,
) -> Operationdefinition {
  Operationdefinition(
    overload: [],
    parameter: [],
    output_profile: None,
    input_profile: None,
    instance:,
    type_:,
    system:,
    resource: [],
    base: None,
    comment: None,
    code:,
    affects_state: None,
    purpose: None,
    jurisdiction: [],
    use_context: [],
    description: None,
    contact: [],
    publisher: None,
    date: None,
    experimental: None,
    kind:,
    status:,
    title: None,
    name:,
    version: None,
    url: None,
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/OperationDefinition#resource
pub type OperationdefinitionParameter {
  OperationdefinitionParameter(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    name: String,
    use_: r4bvaluesets.Operationparameteruse,
    min: Int,
    max: String,
    documentation: Option(String),
    type_: Option(r4bvaluesets.Alltypes),
    target_profile: List(String),
    search_type: Option(r4bvaluesets.Searchparamtype),
    binding: Option(OperationdefinitionParameterBinding),
    referenced_from: List(OperationdefinitionParameterReferencedfrom),
  )
}

pub fn operationdefinition_parameter_new(
  max max: String,
  min min: Int,
  use_ use_: r4bvaluesets.Operationparameteruse,
  name name: String,
) -> OperationdefinitionParameter {
  OperationdefinitionParameter(
    referenced_from: [],
    binding: None,
    search_type: None,
    target_profile: [],
    type_: None,
    documentation: None,
    max:,
    min:,
    use_:,
    name:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/OperationDefinition#resource
pub type OperationdefinitionParameterBinding {
  OperationdefinitionParameterBinding(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    strength: r4bvaluesets.Bindingstrength,
    value_set: String,
  )
}

pub fn operationdefinition_parameter_binding_new(
  value_set value_set: String,
  strength strength: r4bvaluesets.Bindingstrength,
) -> OperationdefinitionParameterBinding {
  OperationdefinitionParameterBinding(
    value_set:,
    strength:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/OperationDefinition#resource
pub type OperationdefinitionParameterReferencedfrom {
  OperationdefinitionParameterReferencedfrom(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    source: String,
    source_id: Option(String),
  )
}

pub fn operationdefinition_parameter_referencedfrom_new(
  source source: String,
) -> OperationdefinitionParameterReferencedfrom {
  OperationdefinitionParameterReferencedfrom(
    source_id: None,
    source:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/OperationDefinition#resource
pub type OperationdefinitionOverload {
  OperationdefinitionOverload(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    parameter_name: List(String),
    comment: Option(String),
  )
}

pub fn operationdefinition_overload_new() -> OperationdefinitionOverload {
  OperationdefinitionOverload(
    comment: None,
    parameter_name: [],
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn operationdefinition_overload_to_json(
  operationdefinition_overload: OperationdefinitionOverload,
) -> Json {
  let OperationdefinitionOverload(
    comment:,
    parameter_name:,
    modifier_extension:,
    extension:,
    id:,
  ) = operationdefinition_overload
  let fields = []
  let fields = case comment {
    Some(v) -> [#("comment", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case parameter_name {
    [] -> fields
    _ -> [#("parameterName", json.array(parameter_name, json.string)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn operationdefinition_overload_decoder() -> Decoder(
  OperationdefinitionOverload,
) {
  use comment <- decode.optional_field(
    "comment",
    None,
    decode.optional(decode.string),
  )
  use parameter_name <- decode.optional_field(
    "parameterName",
    [],
    decode.list(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(OperationdefinitionOverload(
    comment:,
    parameter_name:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn operationdefinition_parameter_referencedfrom_to_json(
  operationdefinition_parameter_referencedfrom: OperationdefinitionParameterReferencedfrom,
) -> Json {
  let OperationdefinitionParameterReferencedfrom(
    source_id:,
    source:,
    modifier_extension:,
    extension:,
    id:,
  ) = operationdefinition_parameter_referencedfrom
  let fields = [
    #("source", json.string(source)),
  ]
  let fields = case source_id {
    Some(v) -> [#("sourceId", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn operationdefinition_parameter_referencedfrom_decoder() -> Decoder(
  OperationdefinitionParameterReferencedfrom,
) {
  use source_id <- decode.optional_field(
    "sourceId",
    None,
    decode.optional(decode.string),
  )
  use source <- decode.field("source", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(OperationdefinitionParameterReferencedfrom(
    source_id:,
    source:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn operationdefinition_parameter_binding_to_json(
  operationdefinition_parameter_binding: OperationdefinitionParameterBinding,
) -> Json {
  let OperationdefinitionParameterBinding(
    value_set:,
    strength:,
    modifier_extension:,
    extension:,
    id:,
  ) = operationdefinition_parameter_binding
  let fields = [
    #("valueSet", json.string(value_set)),
    #("strength", r4bvaluesets.bindingstrength_to_json(strength)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn operationdefinition_parameter_binding_decoder() -> Decoder(
  OperationdefinitionParameterBinding,
) {
  use value_set <- decode.field("valueSet", decode.string)
  use strength <- decode.field(
    "strength",
    r4bvaluesets.bindingstrength_decoder(),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(OperationdefinitionParameterBinding(
    value_set:,
    strength:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn operationdefinition_parameter_to_json(
  operationdefinition_parameter: OperationdefinitionParameter,
) -> Json {
  let OperationdefinitionParameter(
    referenced_from:,
    binding:,
    search_type:,
    target_profile:,
    type_:,
    documentation:,
    max:,
    min:,
    use_:,
    name:,
    modifier_extension:,
    extension:,
    id:,
  ) = operationdefinition_parameter
  let fields = [
    #("max", json.string(max)),
    #("min", json.int(min)),
    #("use", r4bvaluesets.operationparameteruse_to_json(use_)),
    #("name", json.string(name)),
  ]
  let fields = case referenced_from {
    [] -> fields
    _ -> [
      #(
        "referencedFrom",
        json.array(
          referenced_from,
          operationdefinition_parameter_referencedfrom_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case binding {
    Some(v) -> [
      #("binding", operationdefinition_parameter_binding_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case search_type {
    Some(v) -> [
      #("searchType", r4bvaluesets.searchparamtype_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case target_profile {
    [] -> fields
    _ -> [#("targetProfile", json.array(target_profile, json.string)), ..fields]
  }
  let fields = case type_ {
    Some(v) -> [#("type", r4bvaluesets.alltypes_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case documentation {
    Some(v) -> [#("documentation", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn operationdefinition_parameter_decoder() -> Decoder(
  OperationdefinitionParameter,
) {
  use referenced_from <- decode.optional_field(
    "referencedFrom",
    [],
    decode.list(operationdefinition_parameter_referencedfrom_decoder()),
  )
  use binding <- decode.optional_field(
    "binding",
    None,
    decode.optional(operationdefinition_parameter_binding_decoder()),
  )
  use search_type <- decode.optional_field(
    "searchType",
    None,
    decode.optional(r4bvaluesets.searchparamtype_decoder()),
  )
  use target_profile <- decode.optional_field(
    "targetProfile",
    [],
    decode.list(decode.string),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(r4bvaluesets.alltypes_decoder()),
  )
  use documentation <- decode.optional_field(
    "documentation",
    None,
    decode.optional(decode.string),
  )
  use max <- decode.field("max", decode.string)
  use min <- decode.field("min", decode.int)
  use use_ <- decode.field("use", r4bvaluesets.operationparameteruse_decoder())
  use name <- decode.field("name", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(OperationdefinitionParameter(
    referenced_from:,
    binding:,
    search_type:,
    target_profile:,
    type_:,
    documentation:,
    max:,
    min:,
    use_:,
    name:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn operationdefinition_to_json(
  operationdefinition: Operationdefinition,
) -> Json {
  let Operationdefinition(
    overload:,
    parameter:,
    output_profile:,
    input_profile:,
    instance:,
    type_:,
    system:,
    resource:,
    base:,
    comment:,
    code:,
    affects_state:,
    purpose:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    experimental:,
    kind:,
    status:,
    title:,
    name:,
    version:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = operationdefinition
  let fields = [
    #("instance", json.bool(instance)),
    #("type", json.bool(type_)),
    #("system", json.bool(system)),
    #("code", json.string(code)),
    #("kind", r4bvaluesets.operationkind_to_json(kind)),
    #("status", r4bvaluesets.publicationstatus_to_json(status)),
    #("name", json.string(name)),
  ]
  let fields = case overload {
    [] -> fields
    _ -> [
      #("overload", json.array(overload, operationdefinition_overload_to_json)),
      ..fields
    ]
  }
  let fields = case parameter {
    [] -> fields
    _ -> [
      #(
        "parameter",
        json.array(parameter, operationdefinition_parameter_to_json),
      ),
      ..fields
    ]
  }
  let fields = case output_profile {
    Some(v) -> [#("outputProfile", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case input_profile {
    Some(v) -> [#("inputProfile", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case resource {
    [] -> fields
    _ -> [
      #("resource", json.array(resource, r4bvaluesets.resourcetypes_to_json)),
      ..fields
    ]
  }
  let fields = case base {
    Some(v) -> [#("base", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case comment {
    Some(v) -> [#("comment", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case affects_state {
    Some(v) -> [#("affectsState", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case purpose {
    Some(v) -> [#("purpose", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case jurisdiction {
    [] -> fields
    _ -> [
      #("jurisdiction", json.array(jurisdiction, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case use_context {
    [] -> fields
    _ -> [
      #("useContext", json.array(use_context, usagecontext_to_json)),
      ..fields
    ]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case contact {
    [] -> fields
    _ -> [#("contact", json.array(contact, contactdetail_to_json)), ..fields]
  }
  let fields = case publisher {
    Some(v) -> [#("publisher", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case date {
    Some(v) -> [#("date", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case experimental {
    Some(v) -> [#("experimental", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case title {
    Some(v) -> [#("title", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case version {
    Some(v) -> [#("version", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case url {
    Some(v) -> [#("url", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Operationdefinition")), ..fields]
  json.object(fields)
}

pub fn operationdefinition_decoder() -> Decoder(Operationdefinition) {
  use overload <- decode.optional_field(
    "overload",
    [],
    decode.list(operationdefinition_overload_decoder()),
  )
  use parameter <- decode.optional_field(
    "parameter",
    [],
    decode.list(operationdefinition_parameter_decoder()),
  )
  use output_profile <- decode.optional_field(
    "outputProfile",
    None,
    decode.optional(decode.string),
  )
  use input_profile <- decode.optional_field(
    "inputProfile",
    None,
    decode.optional(decode.string),
  )
  use instance <- decode.field("instance", decode.bool)
  use type_ <- decode.field("type", decode.bool)
  use system <- decode.field("system", decode.bool)
  use resource <- decode.optional_field(
    "resource",
    [],
    decode.list(r4bvaluesets.resourcetypes_decoder()),
  )
  use base <- decode.optional_field(
    "base",
    None,
    decode.optional(decode.string),
  )
  use comment <- decode.optional_field(
    "comment",
    None,
    decode.optional(decode.string),
  )
  use code <- decode.field("code", decode.string)
  use affects_state <- decode.optional_field(
    "affectsState",
    None,
    decode.optional(decode.bool),
  )
  use purpose <- decode.optional_field(
    "purpose",
    None,
    decode.optional(decode.string),
  )
  use jurisdiction <- decode.optional_field(
    "jurisdiction",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use use_context <- decode.optional_field(
    "useContext",
    [],
    decode.list(usagecontext_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use contact <- decode.optional_field(
    "contact",
    [],
    decode.list(contactdetail_decoder()),
  )
  use publisher <- decode.optional_field(
    "publisher",
    None,
    decode.optional(decode.string),
  )
  use date <- decode.optional_field(
    "date",
    None,
    decode.optional(decode.string),
  )
  use experimental <- decode.optional_field(
    "experimental",
    None,
    decode.optional(decode.bool),
  )
  use kind <- decode.field("kind", r4bvaluesets.operationkind_decoder())
  use status <- decode.field("status", r4bvaluesets.publicationstatus_decoder())
  use title <- decode.optional_field(
    "title",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.field("name", decode.string)
  use version <- decode.optional_field(
    "version",
    None,
    decode.optional(decode.string),
  )
  use url <- decode.optional_field("url", None, decode.optional(decode.string))
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Operationdefinition",
    decode.failure(
      operationdefinition_new(
        instance:,
        type_:,
        system:,
        code:,
        kind:,
        status:,
        name:,
      ),
      "resourceType",
    ),
  )
  decode.success(Operationdefinition(
    overload:,
    parameter:,
    output_profile:,
    input_profile:,
    instance:,
    type_:,
    system:,
    resource:,
    base:,
    comment:,
    code:,
    affects_state:,
    purpose:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    experimental:,
    kind:,
    status:,
    title:,
    name:,
    version:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/OperationOutcome#resource
pub type Operationoutcome {
  Operationoutcome(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    issue: List(OperationoutcomeIssue),
  )
}

pub fn operationoutcome_new() -> Operationoutcome {
  Operationoutcome(
    issue: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/OperationOutcome#resource
pub type OperationoutcomeIssue {
  OperationoutcomeIssue(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    severity: r4bvaluesets.Issueseverity,
    code: r4bvaluesets.Issuetype,
    details: Option(Codeableconcept),
    diagnostics: Option(String),
    location: List(String),
    expression: List(String),
  )
}

pub fn operationoutcome_issue_new(
  code code: r4bvaluesets.Issuetype,
  severity severity: r4bvaluesets.Issueseverity,
) -> OperationoutcomeIssue {
  OperationoutcomeIssue(
    expression: [],
    location: [],
    diagnostics: None,
    details: None,
    code:,
    severity:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn operationoutcome_issue_to_json(
  operationoutcome_issue: OperationoutcomeIssue,
) -> Json {
  let OperationoutcomeIssue(
    expression:,
    location:,
    diagnostics:,
    details:,
    code:,
    severity:,
    modifier_extension:,
    extension:,
    id:,
  ) = operationoutcome_issue
  let fields = [
    #("code", r4bvaluesets.issuetype_to_json(code)),
    #("severity", r4bvaluesets.issueseverity_to_json(severity)),
  ]
  let fields = case expression {
    [] -> fields
    _ -> [#("expression", json.array(expression, json.string)), ..fields]
  }
  let fields = case location {
    [] -> fields
    _ -> [#("location", json.array(location, json.string)), ..fields]
  }
  let fields = case diagnostics {
    Some(v) -> [#("diagnostics", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case details {
    Some(v) -> [#("details", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn operationoutcome_issue_decoder() -> Decoder(OperationoutcomeIssue) {
  use expression <- decode.optional_field(
    "expression",
    [],
    decode.list(decode.string),
  )
  use location <- decode.optional_field(
    "location",
    [],
    decode.list(decode.string),
  )
  use diagnostics <- decode.optional_field(
    "diagnostics",
    None,
    decode.optional(decode.string),
  )
  use details <- decode.optional_field(
    "details",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use code <- decode.field("code", r4bvaluesets.issuetype_decoder())
  use severity <- decode.field("severity", r4bvaluesets.issueseverity_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(OperationoutcomeIssue(
    expression:,
    location:,
    diagnostics:,
    details:,
    code:,
    severity:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn operationoutcome_to_json(operationoutcome: Operationoutcome) -> Json {
  let Operationoutcome(
    issue:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = operationoutcome
  let fields = []
  let fields = case issue {
    [] -> fields
    _ -> [
      #("issue", json.array(issue, operationoutcome_issue_to_json)),
      ..fields
    ]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Operationoutcome")), ..fields]
  json.object(fields)
}

pub fn operationoutcome_decoder() -> Decoder(Operationoutcome) {
  use issue <- decode.optional_field(
    "issue",
    [],
    decode.list(operationoutcome_issue_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Operationoutcome",
    decode.failure(operationoutcome_new(), "resourceType"),
  )
  decode.success(Operationoutcome(
    issue:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/Organization#resource
pub type Organization {
  Organization(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    active: Option(Bool),
    type_: List(Codeableconcept),
    name: Option(String),
    alias: List(String),
    telecom: List(Contactpoint),
    address: List(Address),
    part_of: Option(Reference),
    contact: List(OrganizationContact),
    endpoint: List(Reference),
  )
}

pub fn organization_new() -> Organization {
  Organization(
    endpoint: [],
    contact: [],
    part_of: None,
    address: [],
    telecom: [],
    alias: [],
    name: None,
    type_: [],
    active: None,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Organization#resource
pub type OrganizationContact {
  OrganizationContact(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    purpose: Option(Codeableconcept),
    name: Option(Humanname),
    telecom: List(Contactpoint),
    address: Option(Address),
  )
}

pub fn organization_contact_new() -> OrganizationContact {
  OrganizationContact(
    address: None,
    telecom: [],
    name: None,
    purpose: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn organization_contact_to_json(
  organization_contact: OrganizationContact,
) -> Json {
  let OrganizationContact(
    address:,
    telecom:,
    name:,
    purpose:,
    modifier_extension:,
    extension:,
    id:,
  ) = organization_contact
  let fields = []
  let fields = case address {
    Some(v) -> [#("address", address_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case telecom {
    [] -> fields
    _ -> [#("telecom", json.array(telecom, contactpoint_to_json)), ..fields]
  }
  let fields = case name {
    Some(v) -> [#("name", humanname_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case purpose {
    Some(v) -> [#("purpose", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn organization_contact_decoder() -> Decoder(OrganizationContact) {
  use address <- decode.optional_field(
    "address",
    None,
    decode.optional(address_decoder()),
  )
  use telecom <- decode.optional_field(
    "telecom",
    [],
    decode.list(contactpoint_decoder()),
  )
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(humanname_decoder()),
  )
  use purpose <- decode.optional_field(
    "purpose",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(OrganizationContact(
    address:,
    telecom:,
    name:,
    purpose:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn organization_to_json(organization: Organization) -> Json {
  let Organization(
    endpoint:,
    contact:,
    part_of:,
    address:,
    telecom:,
    alias:,
    name:,
    type_:,
    active:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = organization
  let fields = []
  let fields = case endpoint {
    [] -> fields
    _ -> [#("endpoint", json.array(endpoint, reference_to_json)), ..fields]
  }
  let fields = case contact {
    [] -> fields
    _ -> [
      #("contact", json.array(contact, organization_contact_to_json)),
      ..fields
    ]
  }
  let fields = case part_of {
    Some(v) -> [#("partOf", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case address {
    [] -> fields
    _ -> [#("address", json.array(address, address_to_json)), ..fields]
  }
  let fields = case telecom {
    [] -> fields
    _ -> [#("telecom", json.array(telecom, contactpoint_to_json)), ..fields]
  }
  let fields = case alias {
    [] -> fields
    _ -> [#("alias", json.array(alias, json.string)), ..fields]
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    [] -> fields
    _ -> [#("type", json.array(type_, codeableconcept_to_json)), ..fields]
  }
  let fields = case active {
    Some(v) -> [#("active", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Organization")), ..fields]
  json.object(fields)
}

pub fn organization_decoder() -> Decoder(Organization) {
  use endpoint <- decode.optional_field(
    "endpoint",
    [],
    decode.list(reference_decoder()),
  )
  use contact <- decode.optional_field(
    "contact",
    [],
    decode.list(organization_contact_decoder()),
  )
  use part_of <- decode.optional_field(
    "partOf",
    None,
    decode.optional(reference_decoder()),
  )
  use address <- decode.optional_field(
    "address",
    [],
    decode.list(address_decoder()),
  )
  use telecom <- decode.optional_field(
    "telecom",
    [],
    decode.list(contactpoint_decoder()),
  )
  use alias <- decode.optional_field("alias", [], decode.list(decode.string))
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use type_ <- decode.optional_field(
    "type",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use active <- decode.optional_field(
    "active",
    None,
    decode.optional(decode.bool),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Organization",
    decode.failure(organization_new(), "resourceType"),
  )
  decode.success(Organization(
    endpoint:,
    contact:,
    part_of:,
    address:,
    telecom:,
    alias:,
    name:,
    type_:,
    active:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/OrganizationAffiliation#resource
pub type Organizationaffiliation {
  Organizationaffiliation(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    active: Option(Bool),
    period: Option(Period),
    organization: Option(Reference),
    participating_organization: Option(Reference),
    network: List(Reference),
    code: List(Codeableconcept),
    specialty: List(Codeableconcept),
    location: List(Reference),
    healthcare_service: List(Reference),
    telecom: List(Contactpoint),
    endpoint: List(Reference),
  )
}

pub fn organizationaffiliation_new() -> Organizationaffiliation {
  Organizationaffiliation(
    endpoint: [],
    telecom: [],
    healthcare_service: [],
    location: [],
    specialty: [],
    code: [],
    network: [],
    participating_organization: None,
    organization: None,
    period: None,
    active: None,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

pub fn organizationaffiliation_to_json(
  organizationaffiliation: Organizationaffiliation,
) -> Json {
  let Organizationaffiliation(
    endpoint:,
    telecom:,
    healthcare_service:,
    location:,
    specialty:,
    code:,
    network:,
    participating_organization:,
    organization:,
    period:,
    active:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = organizationaffiliation
  let fields = []
  let fields = case endpoint {
    [] -> fields
    _ -> [#("endpoint", json.array(endpoint, reference_to_json)), ..fields]
  }
  let fields = case telecom {
    [] -> fields
    _ -> [#("telecom", json.array(telecom, contactpoint_to_json)), ..fields]
  }
  let fields = case healthcare_service {
    [] -> fields
    _ -> [
      #("healthcareService", json.array(healthcare_service, reference_to_json)),
      ..fields
    ]
  }
  let fields = case location {
    [] -> fields
    _ -> [#("location", json.array(location, reference_to_json)), ..fields]
  }
  let fields = case specialty {
    [] -> fields
    _ -> [
      #("specialty", json.array(specialty, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case code {
    [] -> fields
    _ -> [#("code", json.array(code, codeableconcept_to_json)), ..fields]
  }
  let fields = case network {
    [] -> fields
    _ -> [#("network", json.array(network, reference_to_json)), ..fields]
  }
  let fields = case participating_organization {
    Some(v) -> [#("participatingOrganization", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case organization {
    Some(v) -> [#("organization", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case period {
    Some(v) -> [#("period", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case active {
    Some(v) -> [#("active", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [
    #("resourceType", json.string("Organizationaffiliation")),
    ..fields
  ]
  json.object(fields)
}

pub fn organizationaffiliation_decoder() -> Decoder(Organizationaffiliation) {
  use endpoint <- decode.optional_field(
    "endpoint",
    [],
    decode.list(reference_decoder()),
  )
  use telecom <- decode.optional_field(
    "telecom",
    [],
    decode.list(contactpoint_decoder()),
  )
  use healthcare_service <- decode.optional_field(
    "healthcareService",
    [],
    decode.list(reference_decoder()),
  )
  use location <- decode.optional_field(
    "location",
    [],
    decode.list(reference_decoder()),
  )
  use specialty <- decode.optional_field(
    "specialty",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use code <- decode.optional_field(
    "code",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use network <- decode.optional_field(
    "network",
    [],
    decode.list(reference_decoder()),
  )
  use participating_organization <- decode.optional_field(
    "participatingOrganization",
    None,
    decode.optional(reference_decoder()),
  )
  use organization <- decode.optional_field(
    "organization",
    None,
    decode.optional(reference_decoder()),
  )
  use period <- decode.optional_field(
    "period",
    None,
    decode.optional(period_decoder()),
  )
  use active <- decode.optional_field(
    "active",
    None,
    decode.optional(decode.bool),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Organizationaffiliation",
    decode.failure(organizationaffiliation_new(), "resourceType"),
  )
  decode.success(Organizationaffiliation(
    endpoint:,
    telecom:,
    healthcare_service:,
    location:,
    specialty:,
    code:,
    network:,
    participating_organization:,
    organization:,
    period:,
    active:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/PackagedProductDefinition#resource
pub type Packagedproductdefinition {
  Packagedproductdefinition(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    name: Option(String),
    type_: Option(Codeableconcept),
    package_for: List(Reference),
    status: Option(Codeableconcept),
    status_date: Option(String),
    contained_item_quantity: List(Quantity),
    description: Option(String),
    legal_status_of_supply: List(PackagedproductdefinitionLegalstatusofsupply),
    marketing_status: List(Marketingstatus),
    characteristic: List(Codeableconcept),
    copackaged_indicator: Option(Bool),
    manufacturer: List(Reference),
    package: Option(PackagedproductdefinitionPackage),
  )
}

pub fn packagedproductdefinition_new() -> Packagedproductdefinition {
  Packagedproductdefinition(
    package: None,
    manufacturer: [],
    copackaged_indicator: None,
    characteristic: [],
    marketing_status: [],
    legal_status_of_supply: [],
    description: None,
    contained_item_quantity: [],
    status_date: None,
    status: None,
    package_for: [],
    type_: None,
    name: None,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/PackagedProductDefinition#resource
pub type PackagedproductdefinitionLegalstatusofsupply {
  PackagedproductdefinitionLegalstatusofsupply(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    code: Option(Codeableconcept),
    jurisdiction: Option(Codeableconcept),
  )
}

pub fn packagedproductdefinition_legalstatusofsupply_new() -> PackagedproductdefinitionLegalstatusofsupply {
  PackagedproductdefinitionLegalstatusofsupply(
    jurisdiction: None,
    code: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/PackagedProductDefinition#resource
pub type PackagedproductdefinitionPackage {
  PackagedproductdefinitionPackage(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    type_: Option(Codeableconcept),
    quantity: Option(Int),
    material: List(Codeableconcept),
    alternate_material: List(Codeableconcept),
    shelf_life_storage: List(PackagedproductdefinitionPackageShelflifestorage),
    manufacturer: List(Reference),
    property: List(PackagedproductdefinitionPackageProperty),
    contained_item: List(PackagedproductdefinitionPackageContaineditem),
  )
}

pub fn packagedproductdefinition_package_new() -> PackagedproductdefinitionPackage {
  PackagedproductdefinitionPackage(
    contained_item: [],
    property: [],
    manufacturer: [],
    shelf_life_storage: [],
    alternate_material: [],
    material: [],
    quantity: None,
    type_: None,
    identifier: [],
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/PackagedProductDefinition#resource
pub type PackagedproductdefinitionPackageShelflifestorage {
  PackagedproductdefinitionPackageShelflifestorage(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Option(Codeableconcept),
    period: Option(PackagedproductdefinitionPackageShelflifestoragePeriod),
    special_precautions_for_storage: List(Codeableconcept),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/PackagedProductDefinition#resource
pub type PackagedproductdefinitionPackageShelflifestoragePeriod {
  PackagedproductdefinitionPackageShelflifestoragePeriodDuration(
    period: Duration,
  )
  PackagedproductdefinitionPackageShelflifestoragePeriodString(period: String)
}

pub fn packagedproductdefinition_package_shelflifestorage_period_to_json(
  elt: PackagedproductdefinitionPackageShelflifestoragePeriod,
) -> Json {
  case elt {
    PackagedproductdefinitionPackageShelflifestoragePeriodDuration(v) ->
      duration_to_json(v)
    PackagedproductdefinitionPackageShelflifestoragePeriodString(v) ->
      json.string(v)
  }
}

pub fn packagedproductdefinition_package_shelflifestorage_period_decoder() -> Decoder(
  PackagedproductdefinitionPackageShelflifestoragePeriod,
) {
  decode.one_of(
    decode.field("periodDuration", duration_decoder(), decode.success)
      |> decode.map(
        PackagedproductdefinitionPackageShelflifestoragePeriodDuration,
      ),
    [
      decode.field("periodString", decode.string, decode.success)
      |> decode.map(
        PackagedproductdefinitionPackageShelflifestoragePeriodString,
      ),
    ],
  )
}

pub fn packagedproductdefinition_package_shelflifestorage_new() -> PackagedproductdefinitionPackageShelflifestorage {
  PackagedproductdefinitionPackageShelflifestorage(
    special_precautions_for_storage: [],
    period: None,
    type_: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/PackagedProductDefinition#resource
pub type PackagedproductdefinitionPackageProperty {
  PackagedproductdefinitionPackageProperty(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Codeableconcept,
    value: Option(PackagedproductdefinitionPackagePropertyValue),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/PackagedProductDefinition#resource
pub type PackagedproductdefinitionPackagePropertyValue {
  PackagedproductdefinitionPackagePropertyValueCodeableconcept(
    value: Codeableconcept,
  )
  PackagedproductdefinitionPackagePropertyValueQuantity(value: Quantity)
  PackagedproductdefinitionPackagePropertyValueDate(value: String)
  PackagedproductdefinitionPackagePropertyValueBoolean(value: Bool)
  PackagedproductdefinitionPackagePropertyValueAttachment(value: Attachment)
}

pub fn packagedproductdefinition_package_property_value_to_json(
  elt: PackagedproductdefinitionPackagePropertyValue,
) -> Json {
  case elt {
    PackagedproductdefinitionPackagePropertyValueCodeableconcept(v) ->
      codeableconcept_to_json(v)
    PackagedproductdefinitionPackagePropertyValueQuantity(v) ->
      quantity_to_json(v)
    PackagedproductdefinitionPackagePropertyValueDate(v) -> json.string(v)
    PackagedproductdefinitionPackagePropertyValueBoolean(v) -> json.bool(v)
    PackagedproductdefinitionPackagePropertyValueAttachment(v) ->
      attachment_to_json(v)
  }
}

pub fn packagedproductdefinition_package_property_value_decoder() -> Decoder(
  PackagedproductdefinitionPackagePropertyValue,
) {
  decode.one_of(
    decode.field(
      "valueCodeableConcept",
      codeableconcept_decoder(),
      decode.success,
    )
      |> decode.map(
        PackagedproductdefinitionPackagePropertyValueCodeableconcept,
      ),
    [
      decode.field("valueQuantity", quantity_decoder(), decode.success)
        |> decode.map(PackagedproductdefinitionPackagePropertyValueQuantity),
      decode.field("valueDate", decode.string, decode.success)
        |> decode.map(PackagedproductdefinitionPackagePropertyValueDate),
      decode.field("valueBoolean", decode.bool, decode.success)
        |> decode.map(PackagedproductdefinitionPackagePropertyValueBoolean),
      decode.field("valueAttachment", attachment_decoder(), decode.success)
        |> decode.map(PackagedproductdefinitionPackagePropertyValueAttachment),
    ],
  )
}

pub fn packagedproductdefinition_package_property_new(
  type_ type_: Codeableconcept,
) -> PackagedproductdefinitionPackageProperty {
  PackagedproductdefinitionPackageProperty(
    value: None,
    type_:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/PackagedProductDefinition#resource
pub type PackagedproductdefinitionPackageContaineditem {
  PackagedproductdefinitionPackageContaineditem(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    item: Codeablereference,
    amount: Option(Quantity),
  )
}

pub fn packagedproductdefinition_package_containeditem_new(
  item item: Codeablereference,
) -> PackagedproductdefinitionPackageContaineditem {
  PackagedproductdefinitionPackageContaineditem(
    amount: None,
    item:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn packagedproductdefinition_package_containeditem_to_json(
  packagedproductdefinition_package_containeditem: PackagedproductdefinitionPackageContaineditem,
) -> Json {
  let PackagedproductdefinitionPackageContaineditem(
    amount:,
    item:,
    modifier_extension:,
    extension:,
    id:,
  ) = packagedproductdefinition_package_containeditem
  let fields = [
    #("item", codeablereference_to_json(item)),
  ]
  let fields = case amount {
    Some(v) -> [#("amount", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn packagedproductdefinition_package_containeditem_decoder() -> Decoder(
  PackagedproductdefinitionPackageContaineditem,
) {
  use amount <- decode.optional_field(
    "amount",
    None,
    decode.optional(quantity_decoder()),
  )
  use item <- decode.field("item", codeablereference_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(PackagedproductdefinitionPackageContaineditem(
    amount:,
    item:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn packagedproductdefinition_package_property_to_json(
  packagedproductdefinition_package_property: PackagedproductdefinitionPackageProperty,
) -> Json {
  let PackagedproductdefinitionPackageProperty(
    value:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = packagedproductdefinition_package_property
  let fields = [
    #("type", codeableconcept_to_json(type_)),
  ]
  let fields = case value {
    Some(v) -> [
      #(
        "value"
          <> case v {
          PackagedproductdefinitionPackagePropertyValueCodeableconcept(_) ->
            "Codeableconcept"
          PackagedproductdefinitionPackagePropertyValueQuantity(_) -> "Quantity"
          PackagedproductdefinitionPackagePropertyValueDate(_) -> "Date"
          PackagedproductdefinitionPackagePropertyValueBoolean(_) -> "Boolean"
          PackagedproductdefinitionPackagePropertyValueAttachment(_) ->
            "Attachment"
        },
        packagedproductdefinition_package_property_value_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn packagedproductdefinition_package_property_decoder() -> Decoder(
  PackagedproductdefinitionPackageProperty,
) {
  use value <- decode.then(
    none_if_omitted(packagedproductdefinition_package_property_value_decoder()),
  )
  use type_ <- decode.field("type", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(PackagedproductdefinitionPackageProperty(
    value:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn packagedproductdefinition_package_shelflifestorage_to_json(
  packagedproductdefinition_package_shelflifestorage: PackagedproductdefinitionPackageShelflifestorage,
) -> Json {
  let PackagedproductdefinitionPackageShelflifestorage(
    special_precautions_for_storage:,
    period:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = packagedproductdefinition_package_shelflifestorage
  let fields = []
  let fields = case special_precautions_for_storage {
    [] -> fields
    _ -> [
      #(
        "specialPrecautionsForStorage",
        json.array(special_precautions_for_storage, codeableconcept_to_json),
      ),
      ..fields
    ]
  }
  let fields = case period {
    Some(v) -> [
      #(
        "period"
          <> case v {
          PackagedproductdefinitionPackageShelflifestoragePeriodDuration(_) ->
            "Duration"
          PackagedproductdefinitionPackageShelflifestoragePeriodString(_) ->
            "String"
        },
        packagedproductdefinition_package_shelflifestorage_period_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn packagedproductdefinition_package_shelflifestorage_decoder() -> Decoder(
  PackagedproductdefinitionPackageShelflifestorage,
) {
  use special_precautions_for_storage <- decode.optional_field(
    "specialPrecautionsForStorage",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use period <- decode.then(
    none_if_omitted(
      packagedproductdefinition_package_shelflifestorage_period_decoder(),
    ),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(PackagedproductdefinitionPackageShelflifestorage(
    special_precautions_for_storage:,
    period:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn packagedproductdefinition_package_to_json(
  packagedproductdefinition_package: PackagedproductdefinitionPackage,
) -> Json {
  let PackagedproductdefinitionPackage(
    contained_item:,
    property:,
    manufacturer:,
    shelf_life_storage:,
    alternate_material:,
    material:,
    quantity:,
    type_:,
    identifier:,
    modifier_extension:,
    extension:,
    id:,
  ) = packagedproductdefinition_package
  let fields = []
  let fields = case contained_item {
    [] -> fields
    _ -> [
      #(
        "containedItem",
        json.array(
          contained_item,
          packagedproductdefinition_package_containeditem_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case property {
    [] -> fields
    _ -> [
      #(
        "property",
        json.array(property, packagedproductdefinition_package_property_to_json),
      ),
      ..fields
    ]
  }
  let fields = case manufacturer {
    [] -> fields
    _ -> [
      #("manufacturer", json.array(manufacturer, reference_to_json)),
      ..fields
    ]
  }
  let fields = case shelf_life_storage {
    [] -> fields
    _ -> [
      #(
        "shelfLifeStorage",
        json.array(
          shelf_life_storage,
          packagedproductdefinition_package_shelflifestorage_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case alternate_material {
    [] -> fields
    _ -> [
      #(
        "alternateMaterial",
        json.array(alternate_material, codeableconcept_to_json),
      ),
      ..fields
    ]
  }
  let fields = case material {
    [] -> fields
    _ -> [
      #("material", json.array(material, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case quantity {
    Some(v) -> [#("quantity", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn packagedproductdefinition_package_decoder() -> Decoder(
  PackagedproductdefinitionPackage,
) {
  use contained_item <- decode.optional_field(
    "containedItem",
    [],
    decode.list(packagedproductdefinition_package_containeditem_decoder()),
  )
  use property <- decode.optional_field(
    "property",
    [],
    decode.list(packagedproductdefinition_package_property_decoder()),
  )
  use manufacturer <- decode.optional_field(
    "manufacturer",
    [],
    decode.list(reference_decoder()),
  )
  use shelf_life_storage <- decode.optional_field(
    "shelfLifeStorage",
    [],
    decode.list(packagedproductdefinition_package_shelflifestorage_decoder()),
  )
  use alternate_material <- decode.optional_field(
    "alternateMaterial",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use material <- decode.optional_field(
    "material",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use quantity <- decode.optional_field(
    "quantity",
    None,
    decode.optional(decode.int),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(PackagedproductdefinitionPackage(
    contained_item:,
    property:,
    manufacturer:,
    shelf_life_storage:,
    alternate_material:,
    material:,
    quantity:,
    type_:,
    identifier:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn packagedproductdefinition_legalstatusofsupply_to_json(
  packagedproductdefinition_legalstatusofsupply: PackagedproductdefinitionLegalstatusofsupply,
) -> Json {
  let PackagedproductdefinitionLegalstatusofsupply(
    jurisdiction:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ) = packagedproductdefinition_legalstatusofsupply
  let fields = []
  let fields = case jurisdiction {
    Some(v) -> [#("jurisdiction", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case code {
    Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn packagedproductdefinition_legalstatusofsupply_decoder() -> Decoder(
  PackagedproductdefinitionLegalstatusofsupply,
) {
  use jurisdiction <- decode.optional_field(
    "jurisdiction",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(PackagedproductdefinitionLegalstatusofsupply(
    jurisdiction:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn packagedproductdefinition_to_json(
  packagedproductdefinition: Packagedproductdefinition,
) -> Json {
  let Packagedproductdefinition(
    package:,
    manufacturer:,
    copackaged_indicator:,
    characteristic:,
    marketing_status:,
    legal_status_of_supply:,
    description:,
    contained_item_quantity:,
    status_date:,
    status:,
    package_for:,
    type_:,
    name:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = packagedproductdefinition
  let fields = []
  let fields = case package {
    Some(v) -> [
      #("package", packagedproductdefinition_package_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case manufacturer {
    [] -> fields
    _ -> [
      #("manufacturer", json.array(manufacturer, reference_to_json)),
      ..fields
    ]
  }
  let fields = case copackaged_indicator {
    Some(v) -> [#("copackagedIndicator", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case characteristic {
    [] -> fields
    _ -> [
      #("characteristic", json.array(characteristic, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case marketing_status {
    [] -> fields
    _ -> [
      #(
        "marketingStatus",
        json.array(marketing_status, marketingstatus_to_json),
      ),
      ..fields
    ]
  }
  let fields = case legal_status_of_supply {
    [] -> fields
    _ -> [
      #(
        "legalStatusOfSupply",
        json.array(
          legal_status_of_supply,
          packagedproductdefinition_legalstatusofsupply_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case contained_item_quantity {
    [] -> fields
    _ -> [
      #(
        "containedItemQuantity",
        json.array(contained_item_quantity, quantity_to_json),
      ),
      ..fields
    ]
  }
  let fields = case status_date {
    Some(v) -> [#("statusDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case status {
    Some(v) -> [#("status", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case package_for {
    [] -> fields
    _ -> [#("packageFor", json.array(package_for, reference_to_json)), ..fields]
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [
    #("resourceType", json.string("Packagedproductdefinition")),
    ..fields
  ]
  json.object(fields)
}

pub fn packagedproductdefinition_decoder() -> Decoder(Packagedproductdefinition) {
  use package <- decode.optional_field(
    "package",
    None,
    decode.optional(packagedproductdefinition_package_decoder()),
  )
  use manufacturer <- decode.optional_field(
    "manufacturer",
    [],
    decode.list(reference_decoder()),
  )
  use copackaged_indicator <- decode.optional_field(
    "copackagedIndicator",
    None,
    decode.optional(decode.bool),
  )
  use characteristic <- decode.optional_field(
    "characteristic",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use marketing_status <- decode.optional_field(
    "marketingStatus",
    [],
    decode.list(marketingstatus_decoder()),
  )
  use legal_status_of_supply <- decode.optional_field(
    "legalStatusOfSupply",
    [],
    decode.list(packagedproductdefinition_legalstatusofsupply_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use contained_item_quantity <- decode.optional_field(
    "containedItemQuantity",
    [],
    decode.list(quantity_decoder()),
  )
  use status_date <- decode.optional_field(
    "statusDate",
    None,
    decode.optional(decode.string),
  )
  use status <- decode.optional_field(
    "status",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use package_for <- decode.optional_field(
    "packageFor",
    [],
    decode.list(reference_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Packagedproductdefinition",
    decode.failure(packagedproductdefinition_new(), "resourceType"),
  )
  decode.success(Packagedproductdefinition(
    package:,
    manufacturer:,
    copackaged_indicator:,
    characteristic:,
    marketing_status:,
    legal_status_of_supply:,
    description:,
    contained_item_quantity:,
    status_date:,
    status:,
    package_for:,
    type_:,
    name:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/Parameters#resource
pub type Parameters {
  Parameters(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    parameter: List(ParametersParameter),
  )
}

pub fn parameters_new() -> Parameters {
  Parameters(
    parameter: [],
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Parameters#resource
pub type ParametersParameter {
  ParametersParameter(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    name: String,
    value: Option(ParametersParameterValue),
    resource: Option(Resource),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Parameters#resource
pub type ParametersParameterValue {
  ParametersParameterValueBase64binary(value: String)
  ParametersParameterValueBoolean(value: Bool)
  ParametersParameterValueCanonical(value: String)
  ParametersParameterValueCode(value: String)
  ParametersParameterValueDate(value: String)
  ParametersParameterValueDatetime(value: String)
  ParametersParameterValueDecimal(value: Float)
  ParametersParameterValueId(value: String)
  ParametersParameterValueInstant(value: String)
  ParametersParameterValueInteger(value: Int)
  ParametersParameterValueMarkdown(value: String)
  ParametersParameterValueOid(value: String)
  ParametersParameterValuePositiveint(value: Int)
  ParametersParameterValueString(value: String)
  ParametersParameterValueTime(value: String)
  ParametersParameterValueUnsignedint(value: Int)
  ParametersParameterValueUri(value: String)
  ParametersParameterValueUrl(value: String)
  ParametersParameterValueUuid(value: String)
  ParametersParameterValueAddress(value: Address)
  ParametersParameterValueAge(value: Age)
  ParametersParameterValueAnnotation(value: Annotation)
  ParametersParameterValueAttachment(value: Attachment)
  ParametersParameterValueCodeableconcept(value: Codeableconcept)
  ParametersParameterValueCoding(value: Coding)
  ParametersParameterValueContactpoint(value: Contactpoint)
  ParametersParameterValueCount(value: Count)
  ParametersParameterValueDistance(value: Distance)
  ParametersParameterValueDuration(value: Duration)
  ParametersParameterValueHumanname(value: Humanname)
  ParametersParameterValueIdentifier(value: Identifier)
  ParametersParameterValueMoney(value: Money)
  ParametersParameterValuePeriod(value: Period)
  ParametersParameterValueQuantity(value: Quantity)
  ParametersParameterValueRange(value: Range)
  ParametersParameterValueRatio(value: Ratio)
  ParametersParameterValueReference(value: Reference)
  ParametersParameterValueSampleddata(value: Sampleddata)
  ParametersParameterValueSignature(value: Signature)
  ParametersParameterValueTiming(value: Timing)
  ParametersParameterValueContactdetail(value: Contactdetail)
  ParametersParameterValueContributor(value: Contributor)
  ParametersParameterValueDatarequirement(value: Datarequirement)
  ParametersParameterValueExpression(value: Expression)
  ParametersParameterValueParameterdefinition(value: Parameterdefinition)
  ParametersParameterValueRelatedartifact(value: Relatedartifact)
  ParametersParameterValueTriggerdefinition(value: Triggerdefinition)
  ParametersParameterValueUsagecontext(value: Usagecontext)
  ParametersParameterValueDosage(value: Dosage)
  ParametersParameterValueMeta(value: Meta)
}

pub fn parameters_parameter_value_to_json(elt: ParametersParameterValue) -> Json {
  case elt {
    ParametersParameterValueBase64binary(v) -> json.string(v)
    ParametersParameterValueBoolean(v) -> json.bool(v)
    ParametersParameterValueCanonical(v) -> json.string(v)
    ParametersParameterValueCode(v) -> json.string(v)
    ParametersParameterValueDate(v) -> json.string(v)
    ParametersParameterValueDatetime(v) -> json.string(v)
    ParametersParameterValueDecimal(v) -> json.float(v)
    ParametersParameterValueId(v) -> json.string(v)
    ParametersParameterValueInstant(v) -> json.string(v)
    ParametersParameterValueInteger(v) -> json.int(v)
    ParametersParameterValueMarkdown(v) -> json.string(v)
    ParametersParameterValueOid(v) -> json.string(v)
    ParametersParameterValuePositiveint(v) -> json.int(v)
    ParametersParameterValueString(v) -> json.string(v)
    ParametersParameterValueTime(v) -> json.string(v)
    ParametersParameterValueUnsignedint(v) -> json.int(v)
    ParametersParameterValueUri(v) -> json.string(v)
    ParametersParameterValueUrl(v) -> json.string(v)
    ParametersParameterValueUuid(v) -> json.string(v)
    ParametersParameterValueAddress(v) -> address_to_json(v)
    ParametersParameterValueAge(v) -> age_to_json(v)
    ParametersParameterValueAnnotation(v) -> annotation_to_json(v)
    ParametersParameterValueAttachment(v) -> attachment_to_json(v)
    ParametersParameterValueCodeableconcept(v) -> codeableconcept_to_json(v)
    ParametersParameterValueCoding(v) -> coding_to_json(v)
    ParametersParameterValueContactpoint(v) -> contactpoint_to_json(v)
    ParametersParameterValueCount(v) -> count_to_json(v)
    ParametersParameterValueDistance(v) -> distance_to_json(v)
    ParametersParameterValueDuration(v) -> duration_to_json(v)
    ParametersParameterValueHumanname(v) -> humanname_to_json(v)
    ParametersParameterValueIdentifier(v) -> identifier_to_json(v)
    ParametersParameterValueMoney(v) -> money_to_json(v)
    ParametersParameterValuePeriod(v) -> period_to_json(v)
    ParametersParameterValueQuantity(v) -> quantity_to_json(v)
    ParametersParameterValueRange(v) -> range_to_json(v)
    ParametersParameterValueRatio(v) -> ratio_to_json(v)
    ParametersParameterValueReference(v) -> reference_to_json(v)
    ParametersParameterValueSampleddata(v) -> sampleddata_to_json(v)
    ParametersParameterValueSignature(v) -> signature_to_json(v)
    ParametersParameterValueTiming(v) -> timing_to_json(v)
    ParametersParameterValueContactdetail(v) -> contactdetail_to_json(v)
    ParametersParameterValueContributor(v) -> contributor_to_json(v)
    ParametersParameterValueDatarequirement(v) -> datarequirement_to_json(v)
    ParametersParameterValueExpression(v) -> expression_to_json(v)
    ParametersParameterValueParameterdefinition(v) ->
      parameterdefinition_to_json(v)
    ParametersParameterValueRelatedartifact(v) -> relatedartifact_to_json(v)
    ParametersParameterValueTriggerdefinition(v) -> triggerdefinition_to_json(v)
    ParametersParameterValueUsagecontext(v) -> usagecontext_to_json(v)
    ParametersParameterValueDosage(v) -> dosage_to_json(v)
    ParametersParameterValueMeta(v) -> meta_to_json(v)
  }
}

pub fn parameters_parameter_value_decoder() -> Decoder(ParametersParameterValue) {
  decode.one_of(
    decode.field("valueBase64Binary", decode.string, decode.success)
      |> decode.map(ParametersParameterValueBase64binary),
    [
      decode.field("valueBoolean", decode.bool, decode.success)
        |> decode.map(ParametersParameterValueBoolean),
      decode.field("valueCanonical", decode.string, decode.success)
        |> decode.map(ParametersParameterValueCanonical),
      decode.field("valueCode", decode.string, decode.success)
        |> decode.map(ParametersParameterValueCode),
      decode.field("valueDate", decode.string, decode.success)
        |> decode.map(ParametersParameterValueDate),
      decode.field("valueDateTime", decode.string, decode.success)
        |> decode.map(ParametersParameterValueDatetime),
      decode.field("valueDecimal", decode.float, decode.success)
        |> decode.map(ParametersParameterValueDecimal),
      decode.field("valueId", decode.string, decode.success)
        |> decode.map(ParametersParameterValueId),
      decode.field("valueInstant", decode.string, decode.success)
        |> decode.map(ParametersParameterValueInstant),
      decode.field("valueInteger", decode.int, decode.success)
        |> decode.map(ParametersParameterValueInteger),
      decode.field("valueMarkdown", decode.string, decode.success)
        |> decode.map(ParametersParameterValueMarkdown),
      decode.field("valueOid", decode.string, decode.success)
        |> decode.map(ParametersParameterValueOid),
      decode.field("valuePositiveInt", decode.int, decode.success)
        |> decode.map(ParametersParameterValuePositiveint),
      decode.field("valueString", decode.string, decode.success)
        |> decode.map(ParametersParameterValueString),
      decode.field("valueTime", decode.string, decode.success)
        |> decode.map(ParametersParameterValueTime),
      decode.field("valueUnsignedInt", decode.int, decode.success)
        |> decode.map(ParametersParameterValueUnsignedint),
      decode.field("valueUri", decode.string, decode.success)
        |> decode.map(ParametersParameterValueUri),
      decode.field("valueUrl", decode.string, decode.success)
        |> decode.map(ParametersParameterValueUrl),
      decode.field("valueUuid", decode.string, decode.success)
        |> decode.map(ParametersParameterValueUuid),
      decode.field("valueAddress", address_decoder(), decode.success)
        |> decode.map(ParametersParameterValueAddress),
      decode.field("valueAge", age_decoder(), decode.success)
        |> decode.map(ParametersParameterValueAge),
      decode.field("valueAnnotation", annotation_decoder(), decode.success)
        |> decode.map(ParametersParameterValueAnnotation),
      decode.field("valueAttachment", attachment_decoder(), decode.success)
        |> decode.map(ParametersParameterValueAttachment),
      decode.field(
        "valueCodeableConcept",
        codeableconcept_decoder(),
        decode.success,
      )
        |> decode.map(ParametersParameterValueCodeableconcept),
      decode.field("valueCoding", coding_decoder(), decode.success)
        |> decode.map(ParametersParameterValueCoding),
      decode.field("valueContactPoint", contactpoint_decoder(), decode.success)
        |> decode.map(ParametersParameterValueContactpoint),
      decode.field("valueCount", count_decoder(), decode.success)
        |> decode.map(ParametersParameterValueCount),
      decode.field("valueDistance", distance_decoder(), decode.success)
        |> decode.map(ParametersParameterValueDistance),
      decode.field("valueDuration", duration_decoder(), decode.success)
        |> decode.map(ParametersParameterValueDuration),
      decode.field("valueHumanName", humanname_decoder(), decode.success)
        |> decode.map(ParametersParameterValueHumanname),
      decode.field("valueIdentifier", identifier_decoder(), decode.success)
        |> decode.map(ParametersParameterValueIdentifier),
      decode.field("valueMoney", money_decoder(), decode.success)
        |> decode.map(ParametersParameterValueMoney),
      decode.field("valuePeriod", period_decoder(), decode.success)
        |> decode.map(ParametersParameterValuePeriod),
      decode.field("valueQuantity", quantity_decoder(), decode.success)
        |> decode.map(ParametersParameterValueQuantity),
      decode.field("valueRange", range_decoder(), decode.success)
        |> decode.map(ParametersParameterValueRange),
      decode.field("valueRatio", ratio_decoder(), decode.success)
        |> decode.map(ParametersParameterValueRatio),
      decode.field("valueReference", reference_decoder(), decode.success)
        |> decode.map(ParametersParameterValueReference),
      decode.field("valueSampledData", sampleddata_decoder(), decode.success)
        |> decode.map(ParametersParameterValueSampleddata),
      decode.field("valueSignature", signature_decoder(), decode.success)
        |> decode.map(ParametersParameterValueSignature),
      decode.field("valueTiming", timing_decoder(), decode.success)
        |> decode.map(ParametersParameterValueTiming),
      decode.field(
        "valueContactDetail",
        contactdetail_decoder(),
        decode.success,
      )
        |> decode.map(ParametersParameterValueContactdetail),
      decode.field("valueContributor", contributor_decoder(), decode.success)
        |> decode.map(ParametersParameterValueContributor),
      decode.field(
        "valueDataRequirement",
        datarequirement_decoder(),
        decode.success,
      )
        |> decode.map(ParametersParameterValueDatarequirement),
      decode.field("valueExpression", expression_decoder(), decode.success)
        |> decode.map(ParametersParameterValueExpression),
      decode.field(
        "valueParameterDefinition",
        parameterdefinition_decoder(),
        decode.success,
      )
        |> decode.map(ParametersParameterValueParameterdefinition),
      decode.field(
        "valueRelatedArtifact",
        relatedartifact_decoder(),
        decode.success,
      )
        |> decode.map(ParametersParameterValueRelatedartifact),
      decode.field(
        "valueTriggerDefinition",
        triggerdefinition_decoder(),
        decode.success,
      )
        |> decode.map(ParametersParameterValueTriggerdefinition),
      decode.field("valueUsageContext", usagecontext_decoder(), decode.success)
        |> decode.map(ParametersParameterValueUsagecontext),
      decode.field("valueDosage", dosage_decoder(), decode.success)
        |> decode.map(ParametersParameterValueDosage),
      decode.field("valueMeta", meta_decoder(), decode.success)
        |> decode.map(ParametersParameterValueMeta),
    ],
  )
}

pub fn parameters_parameter_new(name name: String) -> ParametersParameter {
  ParametersParameter(
    resource: None,
    value: None,
    name:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn parameters_parameter_to_json(
  parameters_parameter: ParametersParameter,
) -> Json {
  let ParametersParameter(
    resource:,
    value:,
    name:,
    modifier_extension:,
    extension:,
    id:,
  ) = parameters_parameter
  let fields = [
    #("name", json.string(name)),
  ]
  let fields = case resource {
    Some(v) -> [#("resource", resource_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case value {
    Some(v) -> [
      #(
        "value"
          <> case v {
          ParametersParameterValueBase64binary(_) -> "Base64binary"
          ParametersParameterValueBoolean(_) -> "Boolean"
          ParametersParameterValueCanonical(_) -> "Canonical"
          ParametersParameterValueCode(_) -> "Code"
          ParametersParameterValueDate(_) -> "Date"
          ParametersParameterValueDatetime(_) -> "Datetime"
          ParametersParameterValueDecimal(_) -> "Decimal"
          ParametersParameterValueId(_) -> "Id"
          ParametersParameterValueInstant(_) -> "Instant"
          ParametersParameterValueInteger(_) -> "Integer"
          ParametersParameterValueMarkdown(_) -> "Markdown"
          ParametersParameterValueOid(_) -> "Oid"
          ParametersParameterValuePositiveint(_) -> "Positiveint"
          ParametersParameterValueString(_) -> "String"
          ParametersParameterValueTime(_) -> "Time"
          ParametersParameterValueUnsignedint(_) -> "Unsignedint"
          ParametersParameterValueUri(_) -> "Uri"
          ParametersParameterValueUrl(_) -> "Url"
          ParametersParameterValueUuid(_) -> "Uuid"
          ParametersParameterValueAddress(_) -> "Address"
          ParametersParameterValueAge(_) -> "Age"
          ParametersParameterValueAnnotation(_) -> "Annotation"
          ParametersParameterValueAttachment(_) -> "Attachment"
          ParametersParameterValueCodeableconcept(_) -> "Codeableconcept"
          ParametersParameterValueCoding(_) -> "Coding"
          ParametersParameterValueContactpoint(_) -> "Contactpoint"
          ParametersParameterValueCount(_) -> "Count"
          ParametersParameterValueDistance(_) -> "Distance"
          ParametersParameterValueDuration(_) -> "Duration"
          ParametersParameterValueHumanname(_) -> "Humanname"
          ParametersParameterValueIdentifier(_) -> "Identifier"
          ParametersParameterValueMoney(_) -> "Money"
          ParametersParameterValuePeriod(_) -> "Period"
          ParametersParameterValueQuantity(_) -> "Quantity"
          ParametersParameterValueRange(_) -> "Range"
          ParametersParameterValueRatio(_) -> "Ratio"
          ParametersParameterValueReference(_) -> "Reference"
          ParametersParameterValueSampleddata(_) -> "Sampleddata"
          ParametersParameterValueSignature(_) -> "Signature"
          ParametersParameterValueTiming(_) -> "Timing"
          ParametersParameterValueContactdetail(_) -> "Contactdetail"
          ParametersParameterValueContributor(_) -> "Contributor"
          ParametersParameterValueDatarequirement(_) -> "Datarequirement"
          ParametersParameterValueExpression(_) -> "Expression"
          ParametersParameterValueParameterdefinition(_) ->
            "Parameterdefinition"
          ParametersParameterValueRelatedartifact(_) -> "Relatedartifact"
          ParametersParameterValueTriggerdefinition(_) -> "Triggerdefinition"
          ParametersParameterValueUsagecontext(_) -> "Usagecontext"
          ParametersParameterValueDosage(_) -> "Dosage"
          ParametersParameterValueMeta(_) -> "Meta"
        },
        parameters_parameter_value_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn parameters_parameter_decoder() -> Decoder(ParametersParameter) {
  use resource <- decode.optional_field(
    "resource",
    None,
    decode.optional(resource_decoder()),
  )
  use value <- decode.then(
    none_if_omitted(parameters_parameter_value_decoder()),
  )
  use name <- decode.field("name", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ParametersParameter(
    resource:,
    value:,
    name:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn parameters_to_json(parameters: Parameters) -> Json {
  let Parameters(parameter:, language:, implicit_rules:, meta:, id:) =
    parameters
  let fields = []
  let fields = case parameter {
    [] -> fields
    _ -> [
      #("parameter", json.array(parameter, parameters_parameter_to_json)),
      ..fields
    ]
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Parameters")), ..fields]
  json.object(fields)
}

pub fn parameters_decoder() -> Decoder(Parameters) {
  use parameter <- decode.optional_field(
    "parameter",
    [],
    decode.list(parameters_parameter_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Parameters",
    decode.failure(parameters_new(), "resourceType"),
  )
  decode.success(Parameters(parameter:, language:, implicit_rules:, meta:, id:))
}

///http://hl7.org/fhir/r4b/StructureDefinition/Patient#resource
pub type Patient {
  Patient(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    active: Option(Bool),
    name: List(Humanname),
    telecom: List(Contactpoint),
    gender: Option(r4bvaluesets.Administrativegender),
    birth_date: Option(String),
    deceased: Option(PatientDeceased),
    address: List(Address),
    marital_status: Option(Codeableconcept),
    multiple_birth: Option(PatientMultiplebirth),
    photo: List(Attachment),
    contact: List(PatientContact),
    communication: List(PatientCommunication),
    general_practitioner: List(Reference),
    managing_organization: Option(Reference),
    link: List(PatientLink),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Patient#resource
pub type PatientDeceased {
  PatientDeceasedBoolean(deceased: Bool)
  PatientDeceasedDatetime(deceased: String)
}

pub fn patient_deceased_to_json(elt: PatientDeceased) -> Json {
  case elt {
    PatientDeceasedBoolean(v) -> json.bool(v)
    PatientDeceasedDatetime(v) -> json.string(v)
  }
}

pub fn patient_deceased_decoder() -> Decoder(PatientDeceased) {
  decode.one_of(
    decode.field("deceasedBoolean", decode.bool, decode.success)
      |> decode.map(PatientDeceasedBoolean),
    [
      decode.field("deceasedDateTime", decode.string, decode.success)
      |> decode.map(PatientDeceasedDatetime),
    ],
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Patient#resource
pub type PatientMultiplebirth {
  PatientMultiplebirthBoolean(multiple_birth: Bool)
  PatientMultiplebirthInteger(multiple_birth: Int)
}

pub fn patient_multiplebirth_to_json(elt: PatientMultiplebirth) -> Json {
  case elt {
    PatientMultiplebirthBoolean(v) -> json.bool(v)
    PatientMultiplebirthInteger(v) -> json.int(v)
  }
}

pub fn patient_multiplebirth_decoder() -> Decoder(PatientMultiplebirth) {
  decode.one_of(
    decode.field("multipleBirthBoolean", decode.bool, decode.success)
      |> decode.map(PatientMultiplebirthBoolean),
    [
      decode.field("multipleBirthInteger", decode.int, decode.success)
      |> decode.map(PatientMultiplebirthInteger),
    ],
  )
}

pub fn patient_new() -> Patient {
  Patient(
    link: [],
    managing_organization: None,
    general_practitioner: [],
    communication: [],
    contact: [],
    photo: [],
    multiple_birth: None,
    marital_status: None,
    address: [],
    deceased: None,
    birth_date: None,
    gender: None,
    telecom: [],
    name: [],
    active: None,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Patient#resource
pub type PatientContact {
  PatientContact(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    relationship: List(Codeableconcept),
    name: Option(Humanname),
    telecom: List(Contactpoint),
    address: Option(Address),
    gender: Option(r4bvaluesets.Administrativegender),
    organization: Option(Reference),
    period: Option(Period),
  )
}

pub fn patient_contact_new() -> PatientContact {
  PatientContact(
    period: None,
    organization: None,
    gender: None,
    address: None,
    telecom: [],
    name: None,
    relationship: [],
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Patient#resource
pub type PatientCommunication {
  PatientCommunication(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    language: Codeableconcept,
    preferred: Option(Bool),
  )
}

pub fn patient_communication_new(
  language language: Codeableconcept,
) -> PatientCommunication {
  PatientCommunication(
    preferred: None,
    language:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Patient#resource
pub type PatientLink {
  PatientLink(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    other: Reference,
    type_: r4bvaluesets.Linktype,
  )
}

pub fn patient_link_new(
  type_ type_: r4bvaluesets.Linktype,
  other other: Reference,
) -> PatientLink {
  PatientLink(type_:, other:, modifier_extension: [], extension: [], id: None)
}

pub fn patient_link_to_json(patient_link: PatientLink) -> Json {
  let PatientLink(type_:, other:, modifier_extension:, extension:, id:) =
    patient_link
  let fields = [
    #("type", r4bvaluesets.linktype_to_json(type_)),
    #("other", reference_to_json(other)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn patient_link_decoder() -> Decoder(PatientLink) {
  use type_ <- decode.field("type", r4bvaluesets.linktype_decoder())
  use other <- decode.field("other", reference_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(PatientLink(
    type_:,
    other:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn patient_communication_to_json(
  patient_communication: PatientCommunication,
) -> Json {
  let PatientCommunication(
    preferred:,
    language:,
    modifier_extension:,
    extension:,
    id:,
  ) = patient_communication
  let fields = [
    #("language", codeableconcept_to_json(language)),
  ]
  let fields = case preferred {
    Some(v) -> [#("preferred", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn patient_communication_decoder() -> Decoder(PatientCommunication) {
  use preferred <- decode.optional_field(
    "preferred",
    None,
    decode.optional(decode.bool),
  )
  use language <- decode.field("language", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(PatientCommunication(
    preferred:,
    language:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn patient_contact_to_json(patient_contact: PatientContact) -> Json {
  let PatientContact(
    period:,
    organization:,
    gender:,
    address:,
    telecom:,
    name:,
    relationship:,
    modifier_extension:,
    extension:,
    id:,
  ) = patient_contact
  let fields = []
  let fields = case period {
    Some(v) -> [#("period", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case organization {
    Some(v) -> [#("organization", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case gender {
    Some(v) -> [
      #("gender", r4bvaluesets.administrativegender_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case address {
    Some(v) -> [#("address", address_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case telecom {
    [] -> fields
    _ -> [#("telecom", json.array(telecom, contactpoint_to_json)), ..fields]
  }
  let fields = case name {
    Some(v) -> [#("name", humanname_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case relationship {
    [] -> fields
    _ -> [
      #("relationship", json.array(relationship, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn patient_contact_decoder() -> Decoder(PatientContact) {
  use period <- decode.optional_field(
    "period",
    None,
    decode.optional(period_decoder()),
  )
  use organization <- decode.optional_field(
    "organization",
    None,
    decode.optional(reference_decoder()),
  )
  use gender <- decode.optional_field(
    "gender",
    None,
    decode.optional(r4bvaluesets.administrativegender_decoder()),
  )
  use address <- decode.optional_field(
    "address",
    None,
    decode.optional(address_decoder()),
  )
  use telecom <- decode.optional_field(
    "telecom",
    [],
    decode.list(contactpoint_decoder()),
  )
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(humanname_decoder()),
  )
  use relationship <- decode.optional_field(
    "relationship",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(PatientContact(
    period:,
    organization:,
    gender:,
    address:,
    telecom:,
    name:,
    relationship:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn patient_to_json(patient: Patient) -> Json {
  let Patient(
    link:,
    managing_organization:,
    general_practitioner:,
    communication:,
    contact:,
    photo:,
    multiple_birth:,
    marital_status:,
    address:,
    deceased:,
    birth_date:,
    gender:,
    telecom:,
    name:,
    active:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = patient
  let fields = []
  let fields = case link {
    [] -> fields
    _ -> [#("link", json.array(link, patient_link_to_json)), ..fields]
  }
  let fields = case managing_organization {
    Some(v) -> [#("managingOrganization", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case general_practitioner {
    [] -> fields
    _ -> [
      #(
        "generalPractitioner",
        json.array(general_practitioner, reference_to_json),
      ),
      ..fields
    ]
  }
  let fields = case communication {
    [] -> fields
    _ -> [
      #(
        "communication",
        json.array(communication, patient_communication_to_json),
      ),
      ..fields
    ]
  }
  let fields = case contact {
    [] -> fields
    _ -> [#("contact", json.array(contact, patient_contact_to_json)), ..fields]
  }
  let fields = case photo {
    [] -> fields
    _ -> [#("photo", json.array(photo, attachment_to_json)), ..fields]
  }
  let fields = case multiple_birth {
    Some(v) -> [
      #(
        "multipleBirth"
          <> case v {
          PatientMultiplebirthBoolean(_) -> "Boolean"
          PatientMultiplebirthInteger(_) -> "Integer"
        },
        patient_multiplebirth_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case marital_status {
    Some(v) -> [#("maritalStatus", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case address {
    [] -> fields
    _ -> [#("address", json.array(address, address_to_json)), ..fields]
  }
  let fields = case deceased {
    Some(v) -> [
      #(
        "deceased"
          <> case v {
          PatientDeceasedBoolean(_) -> "Boolean"
          PatientDeceasedDatetime(_) -> "Datetime"
        },
        patient_deceased_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case birth_date {
    Some(v) -> [#("birthDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case gender {
    Some(v) -> [
      #("gender", r4bvaluesets.administrativegender_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case telecom {
    [] -> fields
    _ -> [#("telecom", json.array(telecom, contactpoint_to_json)), ..fields]
  }
  let fields = case name {
    [] -> fields
    _ -> [#("name", json.array(name, humanname_to_json)), ..fields]
  }
  let fields = case active {
    Some(v) -> [#("active", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Patient")), ..fields]
  json.object(fields)
}

pub fn patient_decoder() -> Decoder(Patient) {
  use link <- decode.optional_field(
    "link",
    [],
    decode.list(patient_link_decoder()),
  )
  use managing_organization <- decode.optional_field(
    "managingOrganization",
    None,
    decode.optional(reference_decoder()),
  )
  use general_practitioner <- decode.optional_field(
    "generalPractitioner",
    [],
    decode.list(reference_decoder()),
  )
  use communication <- decode.optional_field(
    "communication",
    [],
    decode.list(patient_communication_decoder()),
  )
  use contact <- decode.optional_field(
    "contact",
    [],
    decode.list(patient_contact_decoder()),
  )
  use photo <- decode.optional_field(
    "photo",
    [],
    decode.list(attachment_decoder()),
  )
  use multiple_birth <- decode.then(
    none_if_omitted(patient_multiplebirth_decoder()),
  )
  use marital_status <- decode.optional_field(
    "maritalStatus",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use address <- decode.optional_field(
    "address",
    [],
    decode.list(address_decoder()),
  )
  use deceased <- decode.then(none_if_omitted(patient_deceased_decoder()))
  use birth_date <- decode.optional_field(
    "birthDate",
    None,
    decode.optional(decode.string),
  )
  use gender <- decode.optional_field(
    "gender",
    None,
    decode.optional(r4bvaluesets.administrativegender_decoder()),
  )
  use telecom <- decode.optional_field(
    "telecom",
    [],
    decode.list(contactpoint_decoder()),
  )
  use name <- decode.optional_field(
    "name",
    [],
    decode.list(humanname_decoder()),
  )
  use active <- decode.optional_field(
    "active",
    None,
    decode.optional(decode.bool),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Patient",
    decode.failure(patient_new(), "resourceType"),
  )
  decode.success(Patient(
    link:,
    managing_organization:,
    general_practitioner:,
    communication:,
    contact:,
    photo:,
    multiple_birth:,
    marital_status:,
    address:,
    deceased:,
    birth_date:,
    gender:,
    telecom:,
    name:,
    active:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/PaymentNotice#resource
pub type Paymentnotice {
  Paymentnotice(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    status: r4bvaluesets.Fmstatus,
    request: Option(Reference),
    response: Option(Reference),
    created: String,
    provider: Option(Reference),
    payment: Reference,
    payment_date: Option(String),
    payee: Option(Reference),
    recipient: Reference,
    amount: Money,
    payment_status: Option(Codeableconcept),
  )
}

pub fn paymentnotice_new(
  amount amount: Money,
  recipient recipient: Reference,
  payment payment: Reference,
  created created: String,
  status status: r4bvaluesets.Fmstatus,
) -> Paymentnotice {
  Paymentnotice(
    payment_status: None,
    amount:,
    recipient:,
    payee: None,
    payment_date: None,
    payment:,
    provider: None,
    created:,
    response: None,
    request: None,
    status:,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

pub fn paymentnotice_to_json(paymentnotice: Paymentnotice) -> Json {
  let Paymentnotice(
    payment_status:,
    amount:,
    recipient:,
    payee:,
    payment_date:,
    payment:,
    provider:,
    created:,
    response:,
    request:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = paymentnotice
  let fields = [
    #("amount", money_to_json(amount)),
    #("recipient", reference_to_json(recipient)),
    #("payment", reference_to_json(payment)),
    #("created", json.string(created)),
    #("status", r4bvaluesets.fmstatus_to_json(status)),
  ]
  let fields = case payment_status {
    Some(v) -> [#("paymentStatus", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case payee {
    Some(v) -> [#("payee", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case payment_date {
    Some(v) -> [#("paymentDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case provider {
    Some(v) -> [#("provider", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case response {
    Some(v) -> [#("response", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case request {
    Some(v) -> [#("request", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Paymentnotice")), ..fields]
  json.object(fields)
}

pub fn paymentnotice_decoder() -> Decoder(Paymentnotice) {
  use payment_status <- decode.optional_field(
    "paymentStatus",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use amount <- decode.field("amount", money_decoder())
  use recipient <- decode.field("recipient", reference_decoder())
  use payee <- decode.optional_field(
    "payee",
    None,
    decode.optional(reference_decoder()),
  )
  use payment_date <- decode.optional_field(
    "paymentDate",
    None,
    decode.optional(decode.string),
  )
  use payment <- decode.field("payment", reference_decoder())
  use provider <- decode.optional_field(
    "provider",
    None,
    decode.optional(reference_decoder()),
  )
  use created <- decode.field("created", decode.string)
  use response <- decode.optional_field(
    "response",
    None,
    decode.optional(reference_decoder()),
  )
  use request <- decode.optional_field(
    "request",
    None,
    decode.optional(reference_decoder()),
  )
  use status <- decode.field("status", r4bvaluesets.fmstatus_decoder())
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Paymentnotice",
    decode.failure(
      paymentnotice_new(amount:, recipient:, payment:, created:, status:),
      "resourceType",
    ),
  )
  decode.success(Paymentnotice(
    payment_status:,
    amount:,
    recipient:,
    payee:,
    payment_date:,
    payment:,
    provider:,
    created:,
    response:,
    request:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/PaymentReconciliation#resource
pub type Paymentreconciliation {
  Paymentreconciliation(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    status: r4bvaluesets.Fmstatus,
    period: Option(Period),
    created: String,
    payment_issuer: Option(Reference),
    request: Option(Reference),
    requestor: Option(Reference),
    outcome: Option(r4bvaluesets.Remittanceoutcome),
    disposition: Option(String),
    payment_date: String,
    payment_amount: Money,
    payment_identifier: Option(Identifier),
    detail: List(PaymentreconciliationDetail),
    form_code: Option(Codeableconcept),
    process_note: List(PaymentreconciliationProcessnote),
  )
}

pub fn paymentreconciliation_new(
  payment_amount payment_amount: Money,
  payment_date payment_date: String,
  created created: String,
  status status: r4bvaluesets.Fmstatus,
) -> Paymentreconciliation {
  Paymentreconciliation(
    process_note: [],
    form_code: None,
    detail: [],
    payment_identifier: None,
    payment_amount:,
    payment_date:,
    disposition: None,
    outcome: None,
    requestor: None,
    request: None,
    payment_issuer: None,
    created:,
    period: None,
    status:,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/PaymentReconciliation#resource
pub type PaymentreconciliationDetail {
  PaymentreconciliationDetail(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: Option(Identifier),
    predecessor: Option(Identifier),
    type_: Codeableconcept,
    request: Option(Reference),
    submitter: Option(Reference),
    response: Option(Reference),
    date: Option(String),
    responsible: Option(Reference),
    payee: Option(Reference),
    amount: Option(Money),
  )
}

pub fn paymentreconciliation_detail_new(
  type_ type_: Codeableconcept,
) -> PaymentreconciliationDetail {
  PaymentreconciliationDetail(
    amount: None,
    payee: None,
    responsible: None,
    date: None,
    response: None,
    submitter: None,
    request: None,
    type_:,
    predecessor: None,
    identifier: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/PaymentReconciliation#resource
pub type PaymentreconciliationProcessnote {
  PaymentreconciliationProcessnote(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Option(r4bvaluesets.Notetype),
    text: Option(String),
  )
}

pub fn paymentreconciliation_processnote_new() -> PaymentreconciliationProcessnote {
  PaymentreconciliationProcessnote(
    text: None,
    type_: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn paymentreconciliation_processnote_to_json(
  paymentreconciliation_processnote: PaymentreconciliationProcessnote,
) -> Json {
  let PaymentreconciliationProcessnote(
    text:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = paymentreconciliation_processnote
  let fields = []
  let fields = case text {
    Some(v) -> [#("text", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", r4bvaluesets.notetype_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn paymentreconciliation_processnote_decoder() -> Decoder(
  PaymentreconciliationProcessnote,
) {
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(decode.string),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(r4bvaluesets.notetype_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(PaymentreconciliationProcessnote(
    text:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn paymentreconciliation_detail_to_json(
  paymentreconciliation_detail: PaymentreconciliationDetail,
) -> Json {
  let PaymentreconciliationDetail(
    amount:,
    payee:,
    responsible:,
    date:,
    response:,
    submitter:,
    request:,
    type_:,
    predecessor:,
    identifier:,
    modifier_extension:,
    extension:,
    id:,
  ) = paymentreconciliation_detail
  let fields = [
    #("type", codeableconcept_to_json(type_)),
  ]
  let fields = case amount {
    Some(v) -> [#("amount", money_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case payee {
    Some(v) -> [#("payee", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case responsible {
    Some(v) -> [#("responsible", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case date {
    Some(v) -> [#("date", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case response {
    Some(v) -> [#("response", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case submitter {
    Some(v) -> [#("submitter", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case request {
    Some(v) -> [#("request", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case predecessor {
    Some(v) -> [#("predecessor", identifier_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    Some(v) -> [#("identifier", identifier_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn paymentreconciliation_detail_decoder() -> Decoder(
  PaymentreconciliationDetail,
) {
  use amount <- decode.optional_field(
    "amount",
    None,
    decode.optional(money_decoder()),
  )
  use payee <- decode.optional_field(
    "payee",
    None,
    decode.optional(reference_decoder()),
  )
  use responsible <- decode.optional_field(
    "responsible",
    None,
    decode.optional(reference_decoder()),
  )
  use date <- decode.optional_field(
    "date",
    None,
    decode.optional(decode.string),
  )
  use response <- decode.optional_field(
    "response",
    None,
    decode.optional(reference_decoder()),
  )
  use submitter <- decode.optional_field(
    "submitter",
    None,
    decode.optional(reference_decoder()),
  )
  use request <- decode.optional_field(
    "request",
    None,
    decode.optional(reference_decoder()),
  )
  use type_ <- decode.field("type", codeableconcept_decoder())
  use predecessor <- decode.optional_field(
    "predecessor",
    None,
    decode.optional(identifier_decoder()),
  )
  use identifier <- decode.optional_field(
    "identifier",
    None,
    decode.optional(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(PaymentreconciliationDetail(
    amount:,
    payee:,
    responsible:,
    date:,
    response:,
    submitter:,
    request:,
    type_:,
    predecessor:,
    identifier:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn paymentreconciliation_to_json(
  paymentreconciliation: Paymentreconciliation,
) -> Json {
  let Paymentreconciliation(
    process_note:,
    form_code:,
    detail:,
    payment_identifier:,
    payment_amount:,
    payment_date:,
    disposition:,
    outcome:,
    requestor:,
    request:,
    payment_issuer:,
    created:,
    period:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = paymentreconciliation
  let fields = [
    #("paymentAmount", money_to_json(payment_amount)),
    #("paymentDate", json.string(payment_date)),
    #("created", json.string(created)),
    #("status", r4bvaluesets.fmstatus_to_json(status)),
  ]
  let fields = case process_note {
    [] -> fields
    _ -> [
      #(
        "processNote",
        json.array(process_note, paymentreconciliation_processnote_to_json),
      ),
      ..fields
    ]
  }
  let fields = case form_code {
    Some(v) -> [#("formCode", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case detail {
    [] -> fields
    _ -> [
      #("detail", json.array(detail, paymentreconciliation_detail_to_json)),
      ..fields
    ]
  }
  let fields = case payment_identifier {
    Some(v) -> [#("paymentIdentifier", identifier_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case disposition {
    Some(v) -> [#("disposition", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case outcome {
    Some(v) -> [
      #("outcome", r4bvaluesets.remittanceoutcome_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case requestor {
    Some(v) -> [#("requestor", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case request {
    Some(v) -> [#("request", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case payment_issuer {
    Some(v) -> [#("paymentIssuer", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case period {
    Some(v) -> [#("period", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [
    #("resourceType", json.string("Paymentreconciliation")),
    ..fields
  ]
  json.object(fields)
}

pub fn paymentreconciliation_decoder() -> Decoder(Paymentreconciliation) {
  use process_note <- decode.optional_field(
    "processNote",
    [],
    decode.list(paymentreconciliation_processnote_decoder()),
  )
  use form_code <- decode.optional_field(
    "formCode",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use detail <- decode.optional_field(
    "detail",
    [],
    decode.list(paymentreconciliation_detail_decoder()),
  )
  use payment_identifier <- decode.optional_field(
    "paymentIdentifier",
    None,
    decode.optional(identifier_decoder()),
  )
  use payment_amount <- decode.field("paymentAmount", money_decoder())
  use payment_date <- decode.field("paymentDate", decode.string)
  use disposition <- decode.optional_field(
    "disposition",
    None,
    decode.optional(decode.string),
  )
  use outcome <- decode.optional_field(
    "outcome",
    None,
    decode.optional(r4bvaluesets.remittanceoutcome_decoder()),
  )
  use requestor <- decode.optional_field(
    "requestor",
    None,
    decode.optional(reference_decoder()),
  )
  use request <- decode.optional_field(
    "request",
    None,
    decode.optional(reference_decoder()),
  )
  use payment_issuer <- decode.optional_field(
    "paymentIssuer",
    None,
    decode.optional(reference_decoder()),
  )
  use created <- decode.field("created", decode.string)
  use period <- decode.optional_field(
    "period",
    None,
    decode.optional(period_decoder()),
  )
  use status <- decode.field("status", r4bvaluesets.fmstatus_decoder())
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Paymentreconciliation",
    decode.failure(
      paymentreconciliation_new(
        payment_amount:,
        payment_date:,
        created:,
        status:,
      ),
      "resourceType",
    ),
  )
  decode.success(Paymentreconciliation(
    process_note:,
    form_code:,
    detail:,
    payment_identifier:,
    payment_amount:,
    payment_date:,
    disposition:,
    outcome:,
    requestor:,
    request:,
    payment_issuer:,
    created:,
    period:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/Person#resource
pub type Person {
  Person(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    name: List(Humanname),
    telecom: List(Contactpoint),
    gender: Option(r4bvaluesets.Administrativegender),
    birth_date: Option(String),
    address: List(Address),
    photo: Option(Attachment),
    managing_organization: Option(Reference),
    active: Option(Bool),
    link: List(PersonLink),
  )
}

pub fn person_new() -> Person {
  Person(
    link: [],
    active: None,
    managing_organization: None,
    photo: None,
    address: [],
    birth_date: None,
    gender: None,
    telecom: [],
    name: [],
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Person#resource
pub type PersonLink {
  PersonLink(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    target: Reference,
    assurance: Option(r4bvaluesets.Identityassurancelevel),
  )
}

pub fn person_link_new(target target: Reference) -> PersonLink {
  PersonLink(
    assurance: None,
    target:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn person_link_to_json(person_link: PersonLink) -> Json {
  let PersonLink(assurance:, target:, modifier_extension:, extension:, id:) =
    person_link
  let fields = [
    #("target", reference_to_json(target)),
  ]
  let fields = case assurance {
    Some(v) -> [
      #("assurance", r4bvaluesets.identityassurancelevel_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn person_link_decoder() -> Decoder(PersonLink) {
  use assurance <- decode.optional_field(
    "assurance",
    None,
    decode.optional(r4bvaluesets.identityassurancelevel_decoder()),
  )
  use target <- decode.field("target", reference_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(PersonLink(
    assurance:,
    target:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn person_to_json(person: Person) -> Json {
  let Person(
    link:,
    active:,
    managing_organization:,
    photo:,
    address:,
    birth_date:,
    gender:,
    telecom:,
    name:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = person
  let fields = []
  let fields = case link {
    [] -> fields
    _ -> [#("link", json.array(link, person_link_to_json)), ..fields]
  }
  let fields = case active {
    Some(v) -> [#("active", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case managing_organization {
    Some(v) -> [#("managingOrganization", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case photo {
    Some(v) -> [#("photo", attachment_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case address {
    [] -> fields
    _ -> [#("address", json.array(address, address_to_json)), ..fields]
  }
  let fields = case birth_date {
    Some(v) -> [#("birthDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case gender {
    Some(v) -> [
      #("gender", r4bvaluesets.administrativegender_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case telecom {
    [] -> fields
    _ -> [#("telecom", json.array(telecom, contactpoint_to_json)), ..fields]
  }
  let fields = case name {
    [] -> fields
    _ -> [#("name", json.array(name, humanname_to_json)), ..fields]
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Person")), ..fields]
  json.object(fields)
}

pub fn person_decoder() -> Decoder(Person) {
  use link <- decode.optional_field(
    "link",
    [],
    decode.list(person_link_decoder()),
  )
  use active <- decode.optional_field(
    "active",
    None,
    decode.optional(decode.bool),
  )
  use managing_organization <- decode.optional_field(
    "managingOrganization",
    None,
    decode.optional(reference_decoder()),
  )
  use photo <- decode.optional_field(
    "photo",
    None,
    decode.optional(attachment_decoder()),
  )
  use address <- decode.optional_field(
    "address",
    [],
    decode.list(address_decoder()),
  )
  use birth_date <- decode.optional_field(
    "birthDate",
    None,
    decode.optional(decode.string),
  )
  use gender <- decode.optional_field(
    "gender",
    None,
    decode.optional(r4bvaluesets.administrativegender_decoder()),
  )
  use telecom <- decode.optional_field(
    "telecom",
    [],
    decode.list(contactpoint_decoder()),
  )
  use name <- decode.optional_field(
    "name",
    [],
    decode.list(humanname_decoder()),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Person",
    decode.failure(person_new(), "resourceType"),
  )
  decode.success(Person(
    link:,
    active:,
    managing_organization:,
    photo:,
    address:,
    birth_date:,
    gender:,
    telecom:,
    name:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/PlanDefinition#resource
pub type Plandefinition {
  Plandefinition(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    url: Option(String),
    identifier: List(Identifier),
    version: Option(String),
    name: Option(String),
    title: Option(String),
    subtitle: Option(String),
    type_: Option(Codeableconcept),
    status: r4bvaluesets.Publicationstatus,
    experimental: Option(Bool),
    subject: Option(PlandefinitionSubject),
    date: Option(String),
    publisher: Option(String),
    contact: List(Contactdetail),
    description: Option(String),
    use_context: List(Usagecontext),
    jurisdiction: List(Codeableconcept),
    purpose: Option(String),
    usage: Option(String),
    copyright: Option(String),
    approval_date: Option(String),
    last_review_date: Option(String),
    effective_period: Option(Period),
    topic: List(Codeableconcept),
    author: List(Contactdetail),
    editor: List(Contactdetail),
    reviewer: List(Contactdetail),
    endorser: List(Contactdetail),
    related_artifact: List(Relatedartifact),
    library: List(String),
    goal: List(PlandefinitionGoal),
    action: List(PlandefinitionAction),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/PlanDefinition#resource
pub type PlandefinitionSubject {
  PlandefinitionSubjectCodeableconcept(subject: Codeableconcept)
  PlandefinitionSubjectReference(subject: Reference)
  PlandefinitionSubjectCanonical(subject: String)
}

pub fn plandefinition_subject_to_json(elt: PlandefinitionSubject) -> Json {
  case elt {
    PlandefinitionSubjectCodeableconcept(v) -> codeableconcept_to_json(v)
    PlandefinitionSubjectReference(v) -> reference_to_json(v)
    PlandefinitionSubjectCanonical(v) -> json.string(v)
  }
}

pub fn plandefinition_subject_decoder() -> Decoder(PlandefinitionSubject) {
  decode.one_of(
    decode.field(
      "subjectCodeableConcept",
      codeableconcept_decoder(),
      decode.success,
    )
      |> decode.map(PlandefinitionSubjectCodeableconcept),
    [
      decode.field("subjectReference", reference_decoder(), decode.success)
        |> decode.map(PlandefinitionSubjectReference),
      decode.field("subjectCanonical", decode.string, decode.success)
        |> decode.map(PlandefinitionSubjectCanonical),
    ],
  )
}

pub fn plandefinition_new(
  status status: r4bvaluesets.Publicationstatus,
) -> Plandefinition {
  Plandefinition(
    action: [],
    goal: [],
    library: [],
    related_artifact: [],
    endorser: [],
    reviewer: [],
    editor: [],
    author: [],
    topic: [],
    effective_period: None,
    last_review_date: None,
    approval_date: None,
    copyright: None,
    usage: None,
    purpose: None,
    jurisdiction: [],
    use_context: [],
    description: None,
    contact: [],
    publisher: None,
    date: None,
    subject: None,
    experimental: None,
    status:,
    type_: None,
    subtitle: None,
    title: None,
    name: None,
    version: None,
    identifier: [],
    url: None,
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/PlanDefinition#resource
pub type PlandefinitionGoal {
  PlandefinitionGoal(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    category: Option(Codeableconcept),
    description: Codeableconcept,
    priority: Option(Codeableconcept),
    start: Option(Codeableconcept),
    addresses: List(Codeableconcept),
    documentation: List(Relatedartifact),
    target: List(PlandefinitionGoalTarget),
  )
}

pub fn plandefinition_goal_new(
  description description: Codeableconcept,
) -> PlandefinitionGoal {
  PlandefinitionGoal(
    target: [],
    documentation: [],
    addresses: [],
    start: None,
    priority: None,
    description:,
    category: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/PlanDefinition#resource
pub type PlandefinitionGoalTarget {
  PlandefinitionGoalTarget(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    measure: Option(Codeableconcept),
    detail: Option(PlandefinitionGoalTargetDetail),
    due: Option(Duration),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/PlanDefinition#resource
pub type PlandefinitionGoalTargetDetail {
  PlandefinitionGoalTargetDetailQuantity(detail: Quantity)
  PlandefinitionGoalTargetDetailRange(detail: Range)
  PlandefinitionGoalTargetDetailCodeableconcept(detail: Codeableconcept)
}

pub fn plandefinition_goal_target_detail_to_json(
  elt: PlandefinitionGoalTargetDetail,
) -> Json {
  case elt {
    PlandefinitionGoalTargetDetailQuantity(v) -> quantity_to_json(v)
    PlandefinitionGoalTargetDetailRange(v) -> range_to_json(v)
    PlandefinitionGoalTargetDetailCodeableconcept(v) ->
      codeableconcept_to_json(v)
  }
}

pub fn plandefinition_goal_target_detail_decoder() -> Decoder(
  PlandefinitionGoalTargetDetail,
) {
  decode.one_of(
    decode.field("detailQuantity", quantity_decoder(), decode.success)
      |> decode.map(PlandefinitionGoalTargetDetailQuantity),
    [
      decode.field("detailRange", range_decoder(), decode.success)
        |> decode.map(PlandefinitionGoalTargetDetailRange),
      decode.field(
        "detailCodeableConcept",
        codeableconcept_decoder(),
        decode.success,
      )
        |> decode.map(PlandefinitionGoalTargetDetailCodeableconcept),
    ],
  )
}

pub fn plandefinition_goal_target_new() -> PlandefinitionGoalTarget {
  PlandefinitionGoalTarget(
    due: None,
    detail: None,
    measure: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/PlanDefinition#resource
pub type PlandefinitionAction {
  PlandefinitionAction(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    prefix: Option(String),
    title: Option(String),
    description: Option(String),
    text_equivalent: Option(String),
    priority: Option(r4bvaluesets.Requestpriority),
    code: List(Codeableconcept),
    reason: List(Codeableconcept),
    documentation: List(Relatedartifact),
    goal_id: List(String),
    subject: Option(PlandefinitionActionSubject),
    trigger: List(Triggerdefinition),
    condition: List(PlandefinitionActionCondition),
    input: List(Datarequirement),
    output: List(Datarequirement),
    related_action: List(PlandefinitionActionRelatedaction),
    timing: Option(PlandefinitionActionTiming),
    participant: List(PlandefinitionActionParticipant),
    type_: Option(Codeableconcept),
    grouping_behavior: Option(r4bvaluesets.Actiongroupingbehavior),
    selection_behavior: Option(r4bvaluesets.Actionselectionbehavior),
    required_behavior: Option(r4bvaluesets.Actionrequiredbehavior),
    precheck_behavior: Option(r4bvaluesets.Actionprecheckbehavior),
    cardinality_behavior: Option(r4bvaluesets.Actioncardinalitybehavior),
    definition: Option(PlandefinitionActionDefinition),
    transform: Option(String),
    dynamic_value: List(PlandefinitionActionDynamicvalue),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/PlanDefinition#resource
pub type PlandefinitionActionSubject {
  PlandefinitionActionSubjectCodeableconcept(subject: Codeableconcept)
  PlandefinitionActionSubjectReference(subject: Reference)
  PlandefinitionActionSubjectCanonical(subject: String)
}

pub fn plandefinition_action_subject_to_json(
  elt: PlandefinitionActionSubject,
) -> Json {
  case elt {
    PlandefinitionActionSubjectCodeableconcept(v) -> codeableconcept_to_json(v)
    PlandefinitionActionSubjectReference(v) -> reference_to_json(v)
    PlandefinitionActionSubjectCanonical(v) -> json.string(v)
  }
}

pub fn plandefinition_action_subject_decoder() -> Decoder(
  PlandefinitionActionSubject,
) {
  decode.one_of(
    decode.field(
      "subjectCodeableConcept",
      codeableconcept_decoder(),
      decode.success,
    )
      |> decode.map(PlandefinitionActionSubjectCodeableconcept),
    [
      decode.field("subjectReference", reference_decoder(), decode.success)
        |> decode.map(PlandefinitionActionSubjectReference),
      decode.field("subjectCanonical", decode.string, decode.success)
        |> decode.map(PlandefinitionActionSubjectCanonical),
    ],
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/PlanDefinition#resource
pub type PlandefinitionActionTiming {
  PlandefinitionActionTimingDatetime(timing: String)
  PlandefinitionActionTimingAge(timing: Age)
  PlandefinitionActionTimingPeriod(timing: Period)
  PlandefinitionActionTimingDuration(timing: Duration)
  PlandefinitionActionTimingRange(timing: Range)
  PlandefinitionActionTimingTiming(timing: Timing)
}

pub fn plandefinition_action_timing_to_json(
  elt: PlandefinitionActionTiming,
) -> Json {
  case elt {
    PlandefinitionActionTimingDatetime(v) -> json.string(v)
    PlandefinitionActionTimingAge(v) -> age_to_json(v)
    PlandefinitionActionTimingPeriod(v) -> period_to_json(v)
    PlandefinitionActionTimingDuration(v) -> duration_to_json(v)
    PlandefinitionActionTimingRange(v) -> range_to_json(v)
    PlandefinitionActionTimingTiming(v) -> timing_to_json(v)
  }
}

pub fn plandefinition_action_timing_decoder() -> Decoder(
  PlandefinitionActionTiming,
) {
  decode.one_of(
    decode.field("timingDateTime", decode.string, decode.success)
      |> decode.map(PlandefinitionActionTimingDatetime),
    [
      decode.field("timingAge", age_decoder(), decode.success)
        |> decode.map(PlandefinitionActionTimingAge),
      decode.field("timingPeriod", period_decoder(), decode.success)
        |> decode.map(PlandefinitionActionTimingPeriod),
      decode.field("timingDuration", duration_decoder(), decode.success)
        |> decode.map(PlandefinitionActionTimingDuration),
      decode.field("timingRange", range_decoder(), decode.success)
        |> decode.map(PlandefinitionActionTimingRange),
      decode.field("timingTiming", timing_decoder(), decode.success)
        |> decode.map(PlandefinitionActionTimingTiming),
    ],
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/PlanDefinition#resource
pub type PlandefinitionActionDefinition {
  PlandefinitionActionDefinitionCanonical(definition: String)
  PlandefinitionActionDefinitionUri(definition: String)
}

pub fn plandefinition_action_definition_to_json(
  elt: PlandefinitionActionDefinition,
) -> Json {
  case elt {
    PlandefinitionActionDefinitionCanonical(v) -> json.string(v)
    PlandefinitionActionDefinitionUri(v) -> json.string(v)
  }
}

pub fn plandefinition_action_definition_decoder() -> Decoder(
  PlandefinitionActionDefinition,
) {
  decode.one_of(
    decode.field("definitionCanonical", decode.string, decode.success)
      |> decode.map(PlandefinitionActionDefinitionCanonical),
    [
      decode.field("definitionUri", decode.string, decode.success)
      |> decode.map(PlandefinitionActionDefinitionUri),
    ],
  )
}

pub fn plandefinition_action_new() -> PlandefinitionAction {
  PlandefinitionAction(
    dynamic_value: [],
    transform: None,
    definition: None,
    cardinality_behavior: None,
    precheck_behavior: None,
    required_behavior: None,
    selection_behavior: None,
    grouping_behavior: None,
    type_: None,
    participant: [],
    timing: None,
    related_action: [],
    output: [],
    input: [],
    condition: [],
    trigger: [],
    subject: None,
    goal_id: [],
    documentation: [],
    reason: [],
    code: [],
    priority: None,
    text_equivalent: None,
    description: None,
    title: None,
    prefix: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/PlanDefinition#resource
pub type PlandefinitionActionCondition {
  PlandefinitionActionCondition(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    kind: r4bvaluesets.Actionconditionkind,
    expression: Option(Expression),
  )
}

pub fn plandefinition_action_condition_new(
  kind kind: r4bvaluesets.Actionconditionkind,
) -> PlandefinitionActionCondition {
  PlandefinitionActionCondition(
    expression: None,
    kind:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/PlanDefinition#resource
pub type PlandefinitionActionRelatedaction {
  PlandefinitionActionRelatedaction(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    action_id: String,
    relationship: r4bvaluesets.Actionrelationshiptype,
    offset: Option(PlandefinitionActionRelatedactionOffset),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/PlanDefinition#resource
pub type PlandefinitionActionRelatedactionOffset {
  PlandefinitionActionRelatedactionOffsetDuration(offset: Duration)
  PlandefinitionActionRelatedactionOffsetRange(offset: Range)
}

pub fn plandefinition_action_relatedaction_offset_to_json(
  elt: PlandefinitionActionRelatedactionOffset,
) -> Json {
  case elt {
    PlandefinitionActionRelatedactionOffsetDuration(v) -> duration_to_json(v)
    PlandefinitionActionRelatedactionOffsetRange(v) -> range_to_json(v)
  }
}

pub fn plandefinition_action_relatedaction_offset_decoder() -> Decoder(
  PlandefinitionActionRelatedactionOffset,
) {
  decode.one_of(
    decode.field("offsetDuration", duration_decoder(), decode.success)
      |> decode.map(PlandefinitionActionRelatedactionOffsetDuration),
    [
      decode.field("offsetRange", range_decoder(), decode.success)
      |> decode.map(PlandefinitionActionRelatedactionOffsetRange),
    ],
  )
}

pub fn plandefinition_action_relatedaction_new(
  relationship relationship: r4bvaluesets.Actionrelationshiptype,
  action_id action_id: String,
) -> PlandefinitionActionRelatedaction {
  PlandefinitionActionRelatedaction(
    offset: None,
    relationship:,
    action_id:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/PlanDefinition#resource
pub type PlandefinitionActionParticipant {
  PlandefinitionActionParticipant(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: r4bvaluesets.Actionparticipanttype,
    role: Option(Codeableconcept),
  )
}

pub fn plandefinition_action_participant_new(
  type_ type_: r4bvaluesets.Actionparticipanttype,
) -> PlandefinitionActionParticipant {
  PlandefinitionActionParticipant(
    role: None,
    type_:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/PlanDefinition#resource
pub type PlandefinitionActionDynamicvalue {
  PlandefinitionActionDynamicvalue(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    path: Option(String),
    expression: Option(Expression),
  )
}

pub fn plandefinition_action_dynamicvalue_new() -> PlandefinitionActionDynamicvalue {
  PlandefinitionActionDynamicvalue(
    expression: None,
    path: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn plandefinition_action_dynamicvalue_to_json(
  plandefinition_action_dynamicvalue: PlandefinitionActionDynamicvalue,
) -> Json {
  let PlandefinitionActionDynamicvalue(
    expression:,
    path:,
    modifier_extension:,
    extension:,
    id:,
  ) = plandefinition_action_dynamicvalue
  let fields = []
  let fields = case expression {
    Some(v) -> [#("expression", expression_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case path {
    Some(v) -> [#("path", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn plandefinition_action_dynamicvalue_decoder() -> Decoder(
  PlandefinitionActionDynamicvalue,
) {
  use expression <- decode.optional_field(
    "expression",
    None,
    decode.optional(expression_decoder()),
  )
  use path <- decode.optional_field(
    "path",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(PlandefinitionActionDynamicvalue(
    expression:,
    path:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn plandefinition_action_participant_to_json(
  plandefinition_action_participant: PlandefinitionActionParticipant,
) -> Json {
  let PlandefinitionActionParticipant(
    role:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = plandefinition_action_participant
  let fields = [
    #("type", r4bvaluesets.actionparticipanttype_to_json(type_)),
  ]
  let fields = case role {
    Some(v) -> [#("role", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn plandefinition_action_participant_decoder() -> Decoder(
  PlandefinitionActionParticipant,
) {
  use role <- decode.optional_field(
    "role",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use type_ <- decode.field(
    "type",
    r4bvaluesets.actionparticipanttype_decoder(),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(PlandefinitionActionParticipant(
    role:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn plandefinition_action_relatedaction_to_json(
  plandefinition_action_relatedaction: PlandefinitionActionRelatedaction,
) -> Json {
  let PlandefinitionActionRelatedaction(
    offset:,
    relationship:,
    action_id:,
    modifier_extension:,
    extension:,
    id:,
  ) = plandefinition_action_relatedaction
  let fields = [
    #("relationship", r4bvaluesets.actionrelationshiptype_to_json(relationship)),
    #("actionId", json.string(action_id)),
  ]
  let fields = case offset {
    Some(v) -> [
      #(
        "offset"
          <> case v {
          PlandefinitionActionRelatedactionOffsetDuration(_) -> "Duration"
          PlandefinitionActionRelatedactionOffsetRange(_) -> "Range"
        },
        plandefinition_action_relatedaction_offset_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn plandefinition_action_relatedaction_decoder() -> Decoder(
  PlandefinitionActionRelatedaction,
) {
  use offset <- decode.then(
    none_if_omitted(plandefinition_action_relatedaction_offset_decoder()),
  )
  use relationship <- decode.field(
    "relationship",
    r4bvaluesets.actionrelationshiptype_decoder(),
  )
  use action_id <- decode.field("actionId", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(PlandefinitionActionRelatedaction(
    offset:,
    relationship:,
    action_id:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn plandefinition_action_condition_to_json(
  plandefinition_action_condition: PlandefinitionActionCondition,
) -> Json {
  let PlandefinitionActionCondition(
    expression:,
    kind:,
    modifier_extension:,
    extension:,
    id:,
  ) = plandefinition_action_condition
  let fields = [
    #("kind", r4bvaluesets.actionconditionkind_to_json(kind)),
  ]
  let fields = case expression {
    Some(v) -> [#("expression", expression_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn plandefinition_action_condition_decoder() -> Decoder(
  PlandefinitionActionCondition,
) {
  use expression <- decode.optional_field(
    "expression",
    None,
    decode.optional(expression_decoder()),
  )
  use kind <- decode.field("kind", r4bvaluesets.actionconditionkind_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(PlandefinitionActionCondition(
    expression:,
    kind:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn plandefinition_action_to_json(
  plandefinition_action: PlandefinitionAction,
) -> Json {
  let PlandefinitionAction(
    dynamic_value:,
    transform:,
    definition:,
    cardinality_behavior:,
    precheck_behavior:,
    required_behavior:,
    selection_behavior:,
    grouping_behavior:,
    type_:,
    participant:,
    timing:,
    related_action:,
    output:,
    input:,
    condition:,
    trigger:,
    subject:,
    goal_id:,
    documentation:,
    reason:,
    code:,
    priority:,
    text_equivalent:,
    description:,
    title:,
    prefix:,
    modifier_extension:,
    extension:,
    id:,
  ) = plandefinition_action
  let fields = []
  let fields = case dynamic_value {
    [] -> fields
    _ -> [
      #(
        "dynamicValue",
        json.array(dynamic_value, plandefinition_action_dynamicvalue_to_json),
      ),
      ..fields
    ]
  }
  let fields = case transform {
    Some(v) -> [#("transform", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case definition {
    Some(v) -> [
      #(
        "definition"
          <> case v {
          PlandefinitionActionDefinitionCanonical(_) -> "Canonical"
          PlandefinitionActionDefinitionUri(_) -> "Uri"
        },
        plandefinition_action_definition_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case cardinality_behavior {
    Some(v) -> [
      #(
        "cardinalityBehavior",
        r4bvaluesets.actioncardinalitybehavior_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case precheck_behavior {
    Some(v) -> [
      #("precheckBehavior", r4bvaluesets.actionprecheckbehavior_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case required_behavior {
    Some(v) -> [
      #("requiredBehavior", r4bvaluesets.actionrequiredbehavior_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case selection_behavior {
    Some(v) -> [
      #("selectionBehavior", r4bvaluesets.actionselectionbehavior_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case grouping_behavior {
    Some(v) -> [
      #("groupingBehavior", r4bvaluesets.actiongroupingbehavior_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case participant {
    [] -> fields
    _ -> [
      #(
        "participant",
        json.array(participant, plandefinition_action_participant_to_json),
      ),
      ..fields
    ]
  }
  let fields = case timing {
    Some(v) -> [
      #(
        "timing"
          <> case v {
          PlandefinitionActionTimingDatetime(_) -> "Datetime"
          PlandefinitionActionTimingAge(_) -> "Age"
          PlandefinitionActionTimingPeriod(_) -> "Period"
          PlandefinitionActionTimingDuration(_) -> "Duration"
          PlandefinitionActionTimingRange(_) -> "Range"
          PlandefinitionActionTimingTiming(_) -> "Timing"
        },
        plandefinition_action_timing_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case related_action {
    [] -> fields
    _ -> [
      #(
        "relatedAction",
        json.array(related_action, plandefinition_action_relatedaction_to_json),
      ),
      ..fields
    ]
  }
  let fields = case output {
    [] -> fields
    _ -> [#("output", json.array(output, datarequirement_to_json)), ..fields]
  }
  let fields = case input {
    [] -> fields
    _ -> [#("input", json.array(input, datarequirement_to_json)), ..fields]
  }
  let fields = case condition {
    [] -> fields
    _ -> [
      #(
        "condition",
        json.array(condition, plandefinition_action_condition_to_json),
      ),
      ..fields
    ]
  }
  let fields = case trigger {
    [] -> fields
    _ -> [
      #("trigger", json.array(trigger, triggerdefinition_to_json)),
      ..fields
    ]
  }
  let fields = case subject {
    Some(v) -> [
      #(
        "subject"
          <> case v {
          PlandefinitionActionSubjectCodeableconcept(_) -> "Codeableconcept"
          PlandefinitionActionSubjectReference(_) -> "Reference"
          PlandefinitionActionSubjectCanonical(_) -> "Canonical"
        },
        plandefinition_action_subject_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case goal_id {
    [] -> fields
    _ -> [#("goalId", json.array(goal_id, json.string)), ..fields]
  }
  let fields = case documentation {
    [] -> fields
    _ -> [
      #("documentation", json.array(documentation, relatedartifact_to_json)),
      ..fields
    ]
  }
  let fields = case reason {
    [] -> fields
    _ -> [#("reason", json.array(reason, codeableconcept_to_json)), ..fields]
  }
  let fields = case code {
    [] -> fields
    _ -> [#("code", json.array(code, codeableconcept_to_json)), ..fields]
  }
  let fields = case priority {
    Some(v) -> [
      #("priority", r4bvaluesets.requestpriority_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case text_equivalent {
    Some(v) -> [#("textEquivalent", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case title {
    Some(v) -> [#("title", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case prefix {
    Some(v) -> [#("prefix", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn plandefinition_action_decoder() -> Decoder(PlandefinitionAction) {
  use dynamic_value <- decode.optional_field(
    "dynamicValue",
    [],
    decode.list(plandefinition_action_dynamicvalue_decoder()),
  )
  use transform <- decode.optional_field(
    "transform",
    None,
    decode.optional(decode.string),
  )
  use definition <- decode.then(
    none_if_omitted(plandefinition_action_definition_decoder()),
  )
  use cardinality_behavior <- decode.optional_field(
    "cardinalityBehavior",
    None,
    decode.optional(r4bvaluesets.actioncardinalitybehavior_decoder()),
  )
  use precheck_behavior <- decode.optional_field(
    "precheckBehavior",
    None,
    decode.optional(r4bvaluesets.actionprecheckbehavior_decoder()),
  )
  use required_behavior <- decode.optional_field(
    "requiredBehavior",
    None,
    decode.optional(r4bvaluesets.actionrequiredbehavior_decoder()),
  )
  use selection_behavior <- decode.optional_field(
    "selectionBehavior",
    None,
    decode.optional(r4bvaluesets.actionselectionbehavior_decoder()),
  )
  use grouping_behavior <- decode.optional_field(
    "groupingBehavior",
    None,
    decode.optional(r4bvaluesets.actiongroupingbehavior_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use participant <- decode.optional_field(
    "participant",
    [],
    decode.list(plandefinition_action_participant_decoder()),
  )
  use timing <- decode.then(
    none_if_omitted(plandefinition_action_timing_decoder()),
  )
  use related_action <- decode.optional_field(
    "relatedAction",
    [],
    decode.list(plandefinition_action_relatedaction_decoder()),
  )
  use output <- decode.optional_field(
    "output",
    [],
    decode.list(datarequirement_decoder()),
  )
  use input <- decode.optional_field(
    "input",
    [],
    decode.list(datarequirement_decoder()),
  )
  use condition <- decode.optional_field(
    "condition",
    [],
    decode.list(plandefinition_action_condition_decoder()),
  )
  use trigger <- decode.optional_field(
    "trigger",
    [],
    decode.list(triggerdefinition_decoder()),
  )
  use subject <- decode.then(
    none_if_omitted(plandefinition_action_subject_decoder()),
  )
  use goal_id <- decode.optional_field("goalId", [], decode.list(decode.string))
  use documentation <- decode.optional_field(
    "documentation",
    [],
    decode.list(relatedartifact_decoder()),
  )
  use reason <- decode.optional_field(
    "reason",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use code <- decode.optional_field(
    "code",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use priority <- decode.optional_field(
    "priority",
    None,
    decode.optional(r4bvaluesets.requestpriority_decoder()),
  )
  use text_equivalent <- decode.optional_field(
    "textEquivalent",
    None,
    decode.optional(decode.string),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use title <- decode.optional_field(
    "title",
    None,
    decode.optional(decode.string),
  )
  use prefix <- decode.optional_field(
    "prefix",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(PlandefinitionAction(
    dynamic_value:,
    transform:,
    definition:,
    cardinality_behavior:,
    precheck_behavior:,
    required_behavior:,
    selection_behavior:,
    grouping_behavior:,
    type_:,
    participant:,
    timing:,
    related_action:,
    output:,
    input:,
    condition:,
    trigger:,
    subject:,
    goal_id:,
    documentation:,
    reason:,
    code:,
    priority:,
    text_equivalent:,
    description:,
    title:,
    prefix:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn plandefinition_goal_target_to_json(
  plandefinition_goal_target: PlandefinitionGoalTarget,
) -> Json {
  let PlandefinitionGoalTarget(
    due:,
    detail:,
    measure:,
    modifier_extension:,
    extension:,
    id:,
  ) = plandefinition_goal_target
  let fields = []
  let fields = case due {
    Some(v) -> [#("due", duration_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case detail {
    Some(v) -> [
      #(
        "detail"
          <> case v {
          PlandefinitionGoalTargetDetailQuantity(_) -> "Quantity"
          PlandefinitionGoalTargetDetailRange(_) -> "Range"
          PlandefinitionGoalTargetDetailCodeableconcept(_) -> "Codeableconcept"
        },
        plandefinition_goal_target_detail_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case measure {
    Some(v) -> [#("measure", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn plandefinition_goal_target_decoder() -> Decoder(PlandefinitionGoalTarget) {
  use due <- decode.optional_field(
    "due",
    None,
    decode.optional(duration_decoder()),
  )
  use detail <- decode.then(
    none_if_omitted(plandefinition_goal_target_detail_decoder()),
  )
  use measure <- decode.optional_field(
    "measure",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(PlandefinitionGoalTarget(
    due:,
    detail:,
    measure:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn plandefinition_goal_to_json(
  plandefinition_goal: PlandefinitionGoal,
) -> Json {
  let PlandefinitionGoal(
    target:,
    documentation:,
    addresses:,
    start:,
    priority:,
    description:,
    category:,
    modifier_extension:,
    extension:,
    id:,
  ) = plandefinition_goal
  let fields = [
    #("description", codeableconcept_to_json(description)),
  ]
  let fields = case target {
    [] -> fields
    _ -> [
      #("target", json.array(target, plandefinition_goal_target_to_json)),
      ..fields
    ]
  }
  let fields = case documentation {
    [] -> fields
    _ -> [
      #("documentation", json.array(documentation, relatedartifact_to_json)),
      ..fields
    ]
  }
  let fields = case addresses {
    [] -> fields
    _ -> [
      #("addresses", json.array(addresses, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case start {
    Some(v) -> [#("start", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case priority {
    Some(v) -> [#("priority", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case category {
    Some(v) -> [#("category", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn plandefinition_goal_decoder() -> Decoder(PlandefinitionGoal) {
  use target <- decode.optional_field(
    "target",
    [],
    decode.list(plandefinition_goal_target_decoder()),
  )
  use documentation <- decode.optional_field(
    "documentation",
    [],
    decode.list(relatedartifact_decoder()),
  )
  use addresses <- decode.optional_field(
    "addresses",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use start <- decode.optional_field(
    "start",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use priority <- decode.optional_field(
    "priority",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use description <- decode.field("description", codeableconcept_decoder())
  use category <- decode.optional_field(
    "category",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(PlandefinitionGoal(
    target:,
    documentation:,
    addresses:,
    start:,
    priority:,
    description:,
    category:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn plandefinition_to_json(plandefinition: Plandefinition) -> Json {
  let Plandefinition(
    action:,
    goal:,
    library:,
    related_artifact:,
    endorser:,
    reviewer:,
    editor:,
    author:,
    topic:,
    effective_period:,
    last_review_date:,
    approval_date:,
    copyright:,
    usage:,
    purpose:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    subject:,
    experimental:,
    status:,
    type_:,
    subtitle:,
    title:,
    name:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = plandefinition
  let fields = [
    #("status", r4bvaluesets.publicationstatus_to_json(status)),
  ]
  let fields = case action {
    [] -> fields
    _ -> [
      #("action", json.array(action, plandefinition_action_to_json)),
      ..fields
    ]
  }
  let fields = case goal {
    [] -> fields
    _ -> [#("goal", json.array(goal, plandefinition_goal_to_json)), ..fields]
  }
  let fields = case library {
    [] -> fields
    _ -> [#("library", json.array(library, json.string)), ..fields]
  }
  let fields = case related_artifact {
    [] -> fields
    _ -> [
      #(
        "relatedArtifact",
        json.array(related_artifact, relatedartifact_to_json),
      ),
      ..fields
    ]
  }
  let fields = case endorser {
    [] -> fields
    _ -> [#("endorser", json.array(endorser, contactdetail_to_json)), ..fields]
  }
  let fields = case reviewer {
    [] -> fields
    _ -> [#("reviewer", json.array(reviewer, contactdetail_to_json)), ..fields]
  }
  let fields = case editor {
    [] -> fields
    _ -> [#("editor", json.array(editor, contactdetail_to_json)), ..fields]
  }
  let fields = case author {
    [] -> fields
    _ -> [#("author", json.array(author, contactdetail_to_json)), ..fields]
  }
  let fields = case topic {
    [] -> fields
    _ -> [#("topic", json.array(topic, codeableconcept_to_json)), ..fields]
  }
  let fields = case effective_period {
    Some(v) -> [#("effectivePeriod", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case last_review_date {
    Some(v) -> [#("lastReviewDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case approval_date {
    Some(v) -> [#("approvalDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case copyright {
    Some(v) -> [#("copyright", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case usage {
    Some(v) -> [#("usage", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case purpose {
    Some(v) -> [#("purpose", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case jurisdiction {
    [] -> fields
    _ -> [
      #("jurisdiction", json.array(jurisdiction, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case use_context {
    [] -> fields
    _ -> [
      #("useContext", json.array(use_context, usagecontext_to_json)),
      ..fields
    ]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case contact {
    [] -> fields
    _ -> [#("contact", json.array(contact, contactdetail_to_json)), ..fields]
  }
  let fields = case publisher {
    Some(v) -> [#("publisher", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case date {
    Some(v) -> [#("date", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case subject {
    Some(v) -> [
      #(
        "subject"
          <> case v {
          PlandefinitionSubjectCodeableconcept(_) -> "Codeableconcept"
          PlandefinitionSubjectReference(_) -> "Reference"
          PlandefinitionSubjectCanonical(_) -> "Canonical"
        },
        plandefinition_subject_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case experimental {
    Some(v) -> [#("experimental", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case subtitle {
    Some(v) -> [#("subtitle", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case title {
    Some(v) -> [#("title", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case version {
    Some(v) -> [#("version", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case url {
    Some(v) -> [#("url", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Plandefinition")), ..fields]
  json.object(fields)
}

pub fn plandefinition_decoder() -> Decoder(Plandefinition) {
  use action <- decode.optional_field(
    "action",
    [],
    decode.list(plandefinition_action_decoder()),
  )
  use goal <- decode.optional_field(
    "goal",
    [],
    decode.list(plandefinition_goal_decoder()),
  )
  use library <- decode.optional_field(
    "library",
    [],
    decode.list(decode.string),
  )
  use related_artifact <- decode.optional_field(
    "relatedArtifact",
    [],
    decode.list(relatedartifact_decoder()),
  )
  use endorser <- decode.optional_field(
    "endorser",
    [],
    decode.list(contactdetail_decoder()),
  )
  use reviewer <- decode.optional_field(
    "reviewer",
    [],
    decode.list(contactdetail_decoder()),
  )
  use editor <- decode.optional_field(
    "editor",
    [],
    decode.list(contactdetail_decoder()),
  )
  use author <- decode.optional_field(
    "author",
    [],
    decode.list(contactdetail_decoder()),
  )
  use topic <- decode.optional_field(
    "topic",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use effective_period <- decode.optional_field(
    "effectivePeriod",
    None,
    decode.optional(period_decoder()),
  )
  use last_review_date <- decode.optional_field(
    "lastReviewDate",
    None,
    decode.optional(decode.string),
  )
  use approval_date <- decode.optional_field(
    "approvalDate",
    None,
    decode.optional(decode.string),
  )
  use copyright <- decode.optional_field(
    "copyright",
    None,
    decode.optional(decode.string),
  )
  use usage <- decode.optional_field(
    "usage",
    None,
    decode.optional(decode.string),
  )
  use purpose <- decode.optional_field(
    "purpose",
    None,
    decode.optional(decode.string),
  )
  use jurisdiction <- decode.optional_field(
    "jurisdiction",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use use_context <- decode.optional_field(
    "useContext",
    [],
    decode.list(usagecontext_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use contact <- decode.optional_field(
    "contact",
    [],
    decode.list(contactdetail_decoder()),
  )
  use publisher <- decode.optional_field(
    "publisher",
    None,
    decode.optional(decode.string),
  )
  use date <- decode.optional_field(
    "date",
    None,
    decode.optional(decode.string),
  )
  use subject <- decode.then(none_if_omitted(plandefinition_subject_decoder()))
  use experimental <- decode.optional_field(
    "experimental",
    None,
    decode.optional(decode.bool),
  )
  use status <- decode.field("status", r4bvaluesets.publicationstatus_decoder())
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use subtitle <- decode.optional_field(
    "subtitle",
    None,
    decode.optional(decode.string),
  )
  use title <- decode.optional_field(
    "title",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use version <- decode.optional_field(
    "version",
    None,
    decode.optional(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use url <- decode.optional_field("url", None, decode.optional(decode.string))
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Plandefinition",
    decode.failure(plandefinition_new(status:), "resourceType"),
  )
  decode.success(Plandefinition(
    action:,
    goal:,
    library:,
    related_artifact:,
    endorser:,
    reviewer:,
    editor:,
    author:,
    topic:,
    effective_period:,
    last_review_date:,
    approval_date:,
    copyright:,
    usage:,
    purpose:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    subject:,
    experimental:,
    status:,
    type_:,
    subtitle:,
    title:,
    name:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/Practitioner#resource
pub type Practitioner {
  Practitioner(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    active: Option(Bool),
    name: List(Humanname),
    telecom: List(Contactpoint),
    address: List(Address),
    gender: Option(r4bvaluesets.Administrativegender),
    birth_date: Option(String),
    photo: List(Attachment),
    qualification: List(PractitionerQualification),
    communication: List(Codeableconcept),
  )
}

pub fn practitioner_new() -> Practitioner {
  Practitioner(
    communication: [],
    qualification: [],
    photo: [],
    birth_date: None,
    gender: None,
    address: [],
    telecom: [],
    name: [],
    active: None,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Practitioner#resource
pub type PractitionerQualification {
  PractitionerQualification(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    code: Codeableconcept,
    period: Option(Period),
    issuer: Option(Reference),
  )
}

pub fn practitioner_qualification_new(
  code code: Codeableconcept,
) -> PractitionerQualification {
  PractitionerQualification(
    issuer: None,
    period: None,
    code:,
    identifier: [],
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn practitioner_qualification_to_json(
  practitioner_qualification: PractitionerQualification,
) -> Json {
  let PractitionerQualification(
    issuer:,
    period:,
    code:,
    identifier:,
    modifier_extension:,
    extension:,
    id:,
  ) = practitioner_qualification
  let fields = [
    #("code", codeableconcept_to_json(code)),
  ]
  let fields = case issuer {
    Some(v) -> [#("issuer", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case period {
    Some(v) -> [#("period", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn practitioner_qualification_decoder() -> Decoder(
  PractitionerQualification,
) {
  use issuer <- decode.optional_field(
    "issuer",
    None,
    decode.optional(reference_decoder()),
  )
  use period <- decode.optional_field(
    "period",
    None,
    decode.optional(period_decoder()),
  )
  use code <- decode.field("code", codeableconcept_decoder())
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(PractitionerQualification(
    issuer:,
    period:,
    code:,
    identifier:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn practitioner_to_json(practitioner: Practitioner) -> Json {
  let Practitioner(
    communication:,
    qualification:,
    photo:,
    birth_date:,
    gender:,
    address:,
    telecom:,
    name:,
    active:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = practitioner
  let fields = []
  let fields = case communication {
    [] -> fields
    _ -> [
      #("communication", json.array(communication, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case qualification {
    [] -> fields
    _ -> [
      #(
        "qualification",
        json.array(qualification, practitioner_qualification_to_json),
      ),
      ..fields
    ]
  }
  let fields = case photo {
    [] -> fields
    _ -> [#("photo", json.array(photo, attachment_to_json)), ..fields]
  }
  let fields = case birth_date {
    Some(v) -> [#("birthDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case gender {
    Some(v) -> [
      #("gender", r4bvaluesets.administrativegender_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case address {
    [] -> fields
    _ -> [#("address", json.array(address, address_to_json)), ..fields]
  }
  let fields = case telecom {
    [] -> fields
    _ -> [#("telecom", json.array(telecom, contactpoint_to_json)), ..fields]
  }
  let fields = case name {
    [] -> fields
    _ -> [#("name", json.array(name, humanname_to_json)), ..fields]
  }
  let fields = case active {
    Some(v) -> [#("active", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Practitioner")), ..fields]
  json.object(fields)
}

pub fn practitioner_decoder() -> Decoder(Practitioner) {
  use communication <- decode.optional_field(
    "communication",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use qualification <- decode.optional_field(
    "qualification",
    [],
    decode.list(practitioner_qualification_decoder()),
  )
  use photo <- decode.optional_field(
    "photo",
    [],
    decode.list(attachment_decoder()),
  )
  use birth_date <- decode.optional_field(
    "birthDate",
    None,
    decode.optional(decode.string),
  )
  use gender <- decode.optional_field(
    "gender",
    None,
    decode.optional(r4bvaluesets.administrativegender_decoder()),
  )
  use address <- decode.optional_field(
    "address",
    [],
    decode.list(address_decoder()),
  )
  use telecom <- decode.optional_field(
    "telecom",
    [],
    decode.list(contactpoint_decoder()),
  )
  use name <- decode.optional_field(
    "name",
    [],
    decode.list(humanname_decoder()),
  )
  use active <- decode.optional_field(
    "active",
    None,
    decode.optional(decode.bool),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Practitioner",
    decode.failure(practitioner_new(), "resourceType"),
  )
  decode.success(Practitioner(
    communication:,
    qualification:,
    photo:,
    birth_date:,
    gender:,
    address:,
    telecom:,
    name:,
    active:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/PractitionerRole#resource
pub type Practitionerrole {
  Practitionerrole(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    active: Option(Bool),
    period: Option(Period),
    practitioner: Option(Reference),
    organization: Option(Reference),
    code: List(Codeableconcept),
    specialty: List(Codeableconcept),
    location: List(Reference),
    healthcare_service: List(Reference),
    telecom: List(Contactpoint),
    available_time: List(PractitionerroleAvailabletime),
    not_available: List(PractitionerroleNotavailable),
    availability_exceptions: Option(String),
    endpoint: List(Reference),
  )
}

pub fn practitionerrole_new() -> Practitionerrole {
  Practitionerrole(
    endpoint: [],
    availability_exceptions: None,
    not_available: [],
    available_time: [],
    telecom: [],
    healthcare_service: [],
    location: [],
    specialty: [],
    code: [],
    organization: None,
    practitioner: None,
    period: None,
    active: None,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/PractitionerRole#resource
pub type PractitionerroleAvailabletime {
  PractitionerroleAvailabletime(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    days_of_week: List(r4bvaluesets.Daysofweek),
    all_day: Option(Bool),
    available_start_time: Option(String),
    available_end_time: Option(String),
  )
}

pub fn practitionerrole_availabletime_new() -> PractitionerroleAvailabletime {
  PractitionerroleAvailabletime(
    available_end_time: None,
    available_start_time: None,
    all_day: None,
    days_of_week: [],
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/PractitionerRole#resource
pub type PractitionerroleNotavailable {
  PractitionerroleNotavailable(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    description: String,
    during: Option(Period),
  )
}

pub fn practitionerrole_notavailable_new(
  description description: String,
) -> PractitionerroleNotavailable {
  PractitionerroleNotavailable(
    during: None,
    description:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn practitionerrole_notavailable_to_json(
  practitionerrole_notavailable: PractitionerroleNotavailable,
) -> Json {
  let PractitionerroleNotavailable(
    during:,
    description:,
    modifier_extension:,
    extension:,
    id:,
  ) = practitionerrole_notavailable
  let fields = [
    #("description", json.string(description)),
  ]
  let fields = case during {
    Some(v) -> [#("during", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn practitionerrole_notavailable_decoder() -> Decoder(
  PractitionerroleNotavailable,
) {
  use during <- decode.optional_field(
    "during",
    None,
    decode.optional(period_decoder()),
  )
  use description <- decode.field("description", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(PractitionerroleNotavailable(
    during:,
    description:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn practitionerrole_availabletime_to_json(
  practitionerrole_availabletime: PractitionerroleAvailabletime,
) -> Json {
  let PractitionerroleAvailabletime(
    available_end_time:,
    available_start_time:,
    all_day:,
    days_of_week:,
    modifier_extension:,
    extension:,
    id:,
  ) = practitionerrole_availabletime
  let fields = []
  let fields = case available_end_time {
    Some(v) -> [#("availableEndTime", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case available_start_time {
    Some(v) -> [#("availableStartTime", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case all_day {
    Some(v) -> [#("allDay", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case days_of_week {
    [] -> fields
    _ -> [
      #("daysOfWeek", json.array(days_of_week, r4bvaluesets.daysofweek_to_json)),
      ..fields
    ]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn practitionerrole_availabletime_decoder() -> Decoder(
  PractitionerroleAvailabletime,
) {
  use available_end_time <- decode.optional_field(
    "availableEndTime",
    None,
    decode.optional(decode.string),
  )
  use available_start_time <- decode.optional_field(
    "availableStartTime",
    None,
    decode.optional(decode.string),
  )
  use all_day <- decode.optional_field(
    "allDay",
    None,
    decode.optional(decode.bool),
  )
  use days_of_week <- decode.optional_field(
    "daysOfWeek",
    [],
    decode.list(r4bvaluesets.daysofweek_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(PractitionerroleAvailabletime(
    available_end_time:,
    available_start_time:,
    all_day:,
    days_of_week:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn practitionerrole_to_json(practitionerrole: Practitionerrole) -> Json {
  let Practitionerrole(
    endpoint:,
    availability_exceptions:,
    not_available:,
    available_time:,
    telecom:,
    healthcare_service:,
    location:,
    specialty:,
    code:,
    organization:,
    practitioner:,
    period:,
    active:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = practitionerrole
  let fields = []
  let fields = case endpoint {
    [] -> fields
    _ -> [#("endpoint", json.array(endpoint, reference_to_json)), ..fields]
  }
  let fields = case availability_exceptions {
    Some(v) -> [#("availabilityExceptions", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case not_available {
    [] -> fields
    _ -> [
      #(
        "notAvailable",
        json.array(not_available, practitionerrole_notavailable_to_json),
      ),
      ..fields
    ]
  }
  let fields = case available_time {
    [] -> fields
    _ -> [
      #(
        "availableTime",
        json.array(available_time, practitionerrole_availabletime_to_json),
      ),
      ..fields
    ]
  }
  let fields = case telecom {
    [] -> fields
    _ -> [#("telecom", json.array(telecom, contactpoint_to_json)), ..fields]
  }
  let fields = case healthcare_service {
    [] -> fields
    _ -> [
      #("healthcareService", json.array(healthcare_service, reference_to_json)),
      ..fields
    ]
  }
  let fields = case location {
    [] -> fields
    _ -> [#("location", json.array(location, reference_to_json)), ..fields]
  }
  let fields = case specialty {
    [] -> fields
    _ -> [
      #("specialty", json.array(specialty, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case code {
    [] -> fields
    _ -> [#("code", json.array(code, codeableconcept_to_json)), ..fields]
  }
  let fields = case organization {
    Some(v) -> [#("organization", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case practitioner {
    Some(v) -> [#("practitioner", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case period {
    Some(v) -> [#("period", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case active {
    Some(v) -> [#("active", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Practitionerrole")), ..fields]
  json.object(fields)
}

pub fn practitionerrole_decoder() -> Decoder(Practitionerrole) {
  use endpoint <- decode.optional_field(
    "endpoint",
    [],
    decode.list(reference_decoder()),
  )
  use availability_exceptions <- decode.optional_field(
    "availabilityExceptions",
    None,
    decode.optional(decode.string),
  )
  use not_available <- decode.optional_field(
    "notAvailable",
    [],
    decode.list(practitionerrole_notavailable_decoder()),
  )
  use available_time <- decode.optional_field(
    "availableTime",
    [],
    decode.list(practitionerrole_availabletime_decoder()),
  )
  use telecom <- decode.optional_field(
    "telecom",
    [],
    decode.list(contactpoint_decoder()),
  )
  use healthcare_service <- decode.optional_field(
    "healthcareService",
    [],
    decode.list(reference_decoder()),
  )
  use location <- decode.optional_field(
    "location",
    [],
    decode.list(reference_decoder()),
  )
  use specialty <- decode.optional_field(
    "specialty",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use code <- decode.optional_field(
    "code",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use organization <- decode.optional_field(
    "organization",
    None,
    decode.optional(reference_decoder()),
  )
  use practitioner <- decode.optional_field(
    "practitioner",
    None,
    decode.optional(reference_decoder()),
  )
  use period <- decode.optional_field(
    "period",
    None,
    decode.optional(period_decoder()),
  )
  use active <- decode.optional_field(
    "active",
    None,
    decode.optional(decode.bool),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Practitionerrole",
    decode.failure(practitionerrole_new(), "resourceType"),
  )
  decode.success(Practitionerrole(
    endpoint:,
    availability_exceptions:,
    not_available:,
    available_time:,
    telecom:,
    healthcare_service:,
    location:,
    specialty:,
    code:,
    organization:,
    practitioner:,
    period:,
    active:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/Procedure#resource
pub type Procedure {
  Procedure(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    instantiates_canonical: List(String),
    instantiates_uri: List(String),
    based_on: List(Reference),
    part_of: List(Reference),
    status: r4bvaluesets.Eventstatus,
    status_reason: Option(Codeableconcept),
    category: Option(Codeableconcept),
    code: Option(Codeableconcept),
    subject: Reference,
    encounter: Option(Reference),
    performed: Option(ProcedurePerformed),
    recorder: Option(Reference),
    asserter: Option(Reference),
    performer: List(ProcedurePerformer),
    location: Option(Reference),
    reason_code: List(Codeableconcept),
    reason_reference: List(Reference),
    body_site: List(Codeableconcept),
    outcome: Option(Codeableconcept),
    report: List(Reference),
    complication: List(Codeableconcept),
    complication_detail: List(Reference),
    follow_up: List(Codeableconcept),
    note: List(Annotation),
    focal_device: List(ProcedureFocaldevice),
    used_reference: List(Reference),
    used_code: List(Codeableconcept),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Procedure#resource
pub type ProcedurePerformed {
  ProcedurePerformedDatetime(performed: String)
  ProcedurePerformedPeriod(performed: Period)
  ProcedurePerformedString(performed: String)
  ProcedurePerformedAge(performed: Age)
  ProcedurePerformedRange(performed: Range)
}

pub fn procedure_performed_to_json(elt: ProcedurePerformed) -> Json {
  case elt {
    ProcedurePerformedDatetime(v) -> json.string(v)
    ProcedurePerformedPeriod(v) -> period_to_json(v)
    ProcedurePerformedString(v) -> json.string(v)
    ProcedurePerformedAge(v) -> age_to_json(v)
    ProcedurePerformedRange(v) -> range_to_json(v)
  }
}

pub fn procedure_performed_decoder() -> Decoder(ProcedurePerformed) {
  decode.one_of(
    decode.field("performedDateTime", decode.string, decode.success)
      |> decode.map(ProcedurePerformedDatetime),
    [
      decode.field("performedPeriod", period_decoder(), decode.success)
        |> decode.map(ProcedurePerformedPeriod),
      decode.field("performedString", decode.string, decode.success)
        |> decode.map(ProcedurePerformedString),
      decode.field("performedAge", age_decoder(), decode.success)
        |> decode.map(ProcedurePerformedAge),
      decode.field("performedRange", range_decoder(), decode.success)
        |> decode.map(ProcedurePerformedRange),
    ],
  )
}

pub fn procedure_new(
  subject subject: Reference,
  status status: r4bvaluesets.Eventstatus,
) -> Procedure {
  Procedure(
    used_code: [],
    used_reference: [],
    focal_device: [],
    note: [],
    follow_up: [],
    complication_detail: [],
    complication: [],
    report: [],
    outcome: None,
    body_site: [],
    reason_reference: [],
    reason_code: [],
    location: None,
    performer: [],
    asserter: None,
    recorder: None,
    performed: None,
    encounter: None,
    subject:,
    code: None,
    category: None,
    status_reason: None,
    status:,
    part_of: [],
    based_on: [],
    instantiates_uri: [],
    instantiates_canonical: [],
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Procedure#resource
pub type ProcedurePerformer {
  ProcedurePerformer(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    function: Option(Codeableconcept),
    actor: Reference,
    on_behalf_of: Option(Reference),
  )
}

pub fn procedure_performer_new(actor actor: Reference) -> ProcedurePerformer {
  ProcedurePerformer(
    on_behalf_of: None,
    actor:,
    function: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Procedure#resource
pub type ProcedureFocaldevice {
  ProcedureFocaldevice(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    action: Option(Codeableconcept),
    manipulated: Reference,
  )
}

pub fn procedure_focaldevice_new(
  manipulated manipulated: Reference,
) -> ProcedureFocaldevice {
  ProcedureFocaldevice(
    manipulated:,
    action: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn procedure_focaldevice_to_json(
  procedure_focaldevice: ProcedureFocaldevice,
) -> Json {
  let ProcedureFocaldevice(
    manipulated:,
    action:,
    modifier_extension:,
    extension:,
    id:,
  ) = procedure_focaldevice
  let fields = [
    #("manipulated", reference_to_json(manipulated)),
  ]
  let fields = case action {
    Some(v) -> [#("action", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn procedure_focaldevice_decoder() -> Decoder(ProcedureFocaldevice) {
  use manipulated <- decode.field("manipulated", reference_decoder())
  use action <- decode.optional_field(
    "action",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ProcedureFocaldevice(
    manipulated:,
    action:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn procedure_performer_to_json(
  procedure_performer: ProcedurePerformer,
) -> Json {
  let ProcedurePerformer(
    on_behalf_of:,
    actor:,
    function:,
    modifier_extension:,
    extension:,
    id:,
  ) = procedure_performer
  let fields = [
    #("actor", reference_to_json(actor)),
  ]
  let fields = case on_behalf_of {
    Some(v) -> [#("onBehalfOf", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case function {
    Some(v) -> [#("function", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn procedure_performer_decoder() -> Decoder(ProcedurePerformer) {
  use on_behalf_of <- decode.optional_field(
    "onBehalfOf",
    None,
    decode.optional(reference_decoder()),
  )
  use actor <- decode.field("actor", reference_decoder())
  use function <- decode.optional_field(
    "function",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ProcedurePerformer(
    on_behalf_of:,
    actor:,
    function:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn procedure_to_json(procedure: Procedure) -> Json {
  let Procedure(
    used_code:,
    used_reference:,
    focal_device:,
    note:,
    follow_up:,
    complication_detail:,
    complication:,
    report:,
    outcome:,
    body_site:,
    reason_reference:,
    reason_code:,
    location:,
    performer:,
    asserter:,
    recorder:,
    performed:,
    encounter:,
    subject:,
    code:,
    category:,
    status_reason:,
    status:,
    part_of:,
    based_on:,
    instantiates_uri:,
    instantiates_canonical:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = procedure
  let fields = [
    #("subject", reference_to_json(subject)),
    #("status", r4bvaluesets.eventstatus_to_json(status)),
  ]
  let fields = case used_code {
    [] -> fields
    _ -> [
      #("usedCode", json.array(used_code, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case used_reference {
    [] -> fields
    _ -> [
      #("usedReference", json.array(used_reference, reference_to_json)),
      ..fields
    ]
  }
  let fields = case focal_device {
    [] -> fields
    _ -> [
      #("focalDevice", json.array(focal_device, procedure_focaldevice_to_json)),
      ..fields
    ]
  }
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case follow_up {
    [] -> fields
    _ -> [
      #("followUp", json.array(follow_up, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case complication_detail {
    [] -> fields
    _ -> [
      #(
        "complicationDetail",
        json.array(complication_detail, reference_to_json),
      ),
      ..fields
    ]
  }
  let fields = case complication {
    [] -> fields
    _ -> [
      #("complication", json.array(complication, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case report {
    [] -> fields
    _ -> [#("report", json.array(report, reference_to_json)), ..fields]
  }
  let fields = case outcome {
    Some(v) -> [#("outcome", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case body_site {
    [] -> fields
    _ -> [
      #("bodySite", json.array(body_site, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case reason_reference {
    [] -> fields
    _ -> [
      #("reasonReference", json.array(reason_reference, reference_to_json)),
      ..fields
    ]
  }
  let fields = case reason_code {
    [] -> fields
    _ -> [
      #("reasonCode", json.array(reason_code, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case location {
    Some(v) -> [#("location", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case performer {
    [] -> fields
    _ -> [
      #("performer", json.array(performer, procedure_performer_to_json)),
      ..fields
    ]
  }
  let fields = case asserter {
    Some(v) -> [#("asserter", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case recorder {
    Some(v) -> [#("recorder", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case performed {
    Some(v) -> [
      #(
        "performed"
          <> case v {
          ProcedurePerformedDatetime(_) -> "Datetime"
          ProcedurePerformedPeriod(_) -> "Period"
          ProcedurePerformedString(_) -> "String"
          ProcedurePerformedAge(_) -> "Age"
          ProcedurePerformedRange(_) -> "Range"
        },
        procedure_performed_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case encounter {
    Some(v) -> [#("encounter", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case code {
    Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case category {
    Some(v) -> [#("category", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case status_reason {
    Some(v) -> [#("statusReason", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case part_of {
    [] -> fields
    _ -> [#("partOf", json.array(part_of, reference_to_json)), ..fields]
  }
  let fields = case based_on {
    [] -> fields
    _ -> [#("basedOn", json.array(based_on, reference_to_json)), ..fields]
  }
  let fields = case instantiates_uri {
    [] -> fields
    _ -> [
      #("instantiatesUri", json.array(instantiates_uri, json.string)),
      ..fields
    ]
  }
  let fields = case instantiates_canonical {
    [] -> fields
    _ -> [
      #(
        "instantiatesCanonical",
        json.array(instantiates_canonical, json.string),
      ),
      ..fields
    ]
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Procedure")), ..fields]
  json.object(fields)
}

pub fn procedure_decoder() -> Decoder(Procedure) {
  use used_code <- decode.optional_field(
    "usedCode",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use used_reference <- decode.optional_field(
    "usedReference",
    [],
    decode.list(reference_decoder()),
  )
  use focal_device <- decode.optional_field(
    "focalDevice",
    [],
    decode.list(procedure_focaldevice_decoder()),
  )
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use follow_up <- decode.optional_field(
    "followUp",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use complication_detail <- decode.optional_field(
    "complicationDetail",
    [],
    decode.list(reference_decoder()),
  )
  use complication <- decode.optional_field(
    "complication",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use report <- decode.optional_field(
    "report",
    [],
    decode.list(reference_decoder()),
  )
  use outcome <- decode.optional_field(
    "outcome",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use body_site <- decode.optional_field(
    "bodySite",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use reason_reference <- decode.optional_field(
    "reasonReference",
    [],
    decode.list(reference_decoder()),
  )
  use reason_code <- decode.optional_field(
    "reasonCode",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use location <- decode.optional_field(
    "location",
    None,
    decode.optional(reference_decoder()),
  )
  use performer <- decode.optional_field(
    "performer",
    [],
    decode.list(procedure_performer_decoder()),
  )
  use asserter <- decode.optional_field(
    "asserter",
    None,
    decode.optional(reference_decoder()),
  )
  use recorder <- decode.optional_field(
    "recorder",
    None,
    decode.optional(reference_decoder()),
  )
  use performed <- decode.then(none_if_omitted(procedure_performed_decoder()))
  use encounter <- decode.optional_field(
    "encounter",
    None,
    decode.optional(reference_decoder()),
  )
  use subject <- decode.field("subject", reference_decoder())
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use category <- decode.optional_field(
    "category",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use status_reason <- decode.optional_field(
    "statusReason",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use status <- decode.field("status", r4bvaluesets.eventstatus_decoder())
  use part_of <- decode.optional_field(
    "partOf",
    [],
    decode.list(reference_decoder()),
  )
  use based_on <- decode.optional_field(
    "basedOn",
    [],
    decode.list(reference_decoder()),
  )
  use instantiates_uri <- decode.optional_field(
    "instantiatesUri",
    [],
    decode.list(decode.string),
  )
  use instantiates_canonical <- decode.optional_field(
    "instantiatesCanonical",
    [],
    decode.list(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Procedure",
    decode.failure(procedure_new(subject:, status:), "resourceType"),
  )
  decode.success(Procedure(
    used_code:,
    used_reference:,
    focal_device:,
    note:,
    follow_up:,
    complication_detail:,
    complication:,
    report:,
    outcome:,
    body_site:,
    reason_reference:,
    reason_code:,
    location:,
    performer:,
    asserter:,
    recorder:,
    performed:,
    encounter:,
    subject:,
    code:,
    category:,
    status_reason:,
    status:,
    part_of:,
    based_on:,
    instantiates_uri:,
    instantiates_canonical:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/Provenance#resource
pub type Provenance {
  Provenance(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    target: List(Reference),
    occurred: Option(ProvenanceOccurred),
    recorded: String,
    policy: List(String),
    location: Option(Reference),
    reason: List(Codeableconcept),
    activity: Option(Codeableconcept),
    agent: List(ProvenanceAgent),
    entity: List(ProvenanceEntity),
    signature: List(Signature),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Provenance#resource
pub type ProvenanceOccurred {
  ProvenanceOccurredPeriod(occurred: Period)
  ProvenanceOccurredDatetime(occurred: String)
}

pub fn provenance_occurred_to_json(elt: ProvenanceOccurred) -> Json {
  case elt {
    ProvenanceOccurredPeriod(v) -> period_to_json(v)
    ProvenanceOccurredDatetime(v) -> json.string(v)
  }
}

pub fn provenance_occurred_decoder() -> Decoder(ProvenanceOccurred) {
  decode.one_of(
    decode.field("occurredPeriod", period_decoder(), decode.success)
      |> decode.map(ProvenanceOccurredPeriod),
    [
      decode.field("occurredDateTime", decode.string, decode.success)
      |> decode.map(ProvenanceOccurredDatetime),
    ],
  )
}

pub fn provenance_new(recorded recorded: String) -> Provenance {
  Provenance(
    signature: [],
    entity: [],
    agent: [],
    activity: None,
    reason: [],
    location: None,
    policy: [],
    recorded:,
    occurred: None,
    target: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Provenance#resource
pub type ProvenanceAgent {
  ProvenanceAgent(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Option(Codeableconcept),
    role: List(Codeableconcept),
    who: Reference,
    on_behalf_of: Option(Reference),
  )
}

pub fn provenance_agent_new(who who: Reference) -> ProvenanceAgent {
  ProvenanceAgent(
    on_behalf_of: None,
    who:,
    role: [],
    type_: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Provenance#resource
pub type ProvenanceEntity {
  ProvenanceEntity(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    role: r4bvaluesets.Provenanceentityrole,
    what: Reference,
  )
}

pub fn provenance_entity_new(
  what what: Reference,
  role role: r4bvaluesets.Provenanceentityrole,
) -> ProvenanceEntity {
  ProvenanceEntity(
    what:,
    role:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn provenance_entity_to_json(provenance_entity: ProvenanceEntity) -> Json {
  let ProvenanceEntity(what:, role:, modifier_extension:, extension:, id:) =
    provenance_entity
  let fields = [
    #("what", reference_to_json(what)),
    #("role", r4bvaluesets.provenanceentityrole_to_json(role)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn provenance_entity_decoder() -> Decoder(ProvenanceEntity) {
  use what <- decode.field("what", reference_decoder())
  use role <- decode.field("role", r4bvaluesets.provenanceentityrole_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ProvenanceEntity(
    what:,
    role:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn provenance_agent_to_json(provenance_agent: ProvenanceAgent) -> Json {
  let ProvenanceAgent(
    on_behalf_of:,
    who:,
    role:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = provenance_agent
  let fields = [
    #("who", reference_to_json(who)),
  ]
  let fields = case on_behalf_of {
    Some(v) -> [#("onBehalfOf", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case role {
    [] -> fields
    _ -> [#("role", json.array(role, codeableconcept_to_json)), ..fields]
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn provenance_agent_decoder() -> Decoder(ProvenanceAgent) {
  use on_behalf_of <- decode.optional_field(
    "onBehalfOf",
    None,
    decode.optional(reference_decoder()),
  )
  use who <- decode.field("who", reference_decoder())
  use role <- decode.optional_field(
    "role",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ProvenanceAgent(
    on_behalf_of:,
    who:,
    role:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn provenance_to_json(provenance: Provenance) -> Json {
  let Provenance(
    signature:,
    entity:,
    agent:,
    activity:,
    reason:,
    location:,
    policy:,
    recorded:,
    occurred:,
    target:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = provenance
  let fields = [
    #("recorded", json.string(recorded)),
  ]
  let fields = case signature {
    [] -> fields
    _ -> [#("signature", json.array(signature, signature_to_json)), ..fields]
  }
  let fields = case entity {
    [] -> fields
    _ -> [#("entity", json.array(entity, provenance_entity_to_json)), ..fields]
  }
  let fields = case agent {
    [] -> fields
    _ -> [#("agent", json.array(agent, provenance_agent_to_json)), ..fields]
  }
  let fields = case activity {
    Some(v) -> [#("activity", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case reason {
    [] -> fields
    _ -> [#("reason", json.array(reason, codeableconcept_to_json)), ..fields]
  }
  let fields = case location {
    Some(v) -> [#("location", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case policy {
    [] -> fields
    _ -> [#("policy", json.array(policy, json.string)), ..fields]
  }
  let fields = case occurred {
    Some(v) -> [
      #(
        "occurred"
          <> case v {
          ProvenanceOccurredPeriod(_) -> "Period"
          ProvenanceOccurredDatetime(_) -> "Datetime"
        },
        provenance_occurred_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case target {
    [] -> fields
    _ -> [#("target", json.array(target, reference_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Provenance")), ..fields]
  json.object(fields)
}

pub fn provenance_decoder() -> Decoder(Provenance) {
  use signature <- decode.optional_field(
    "signature",
    [],
    decode.list(signature_decoder()),
  )
  use entity <- decode.optional_field(
    "entity",
    [],
    decode.list(provenance_entity_decoder()),
  )
  use agent <- decode.optional_field(
    "agent",
    [],
    decode.list(provenance_agent_decoder()),
  )
  use activity <- decode.optional_field(
    "activity",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use reason <- decode.optional_field(
    "reason",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use location <- decode.optional_field(
    "location",
    None,
    decode.optional(reference_decoder()),
  )
  use policy <- decode.optional_field("policy", [], decode.list(decode.string))
  use recorded <- decode.field("recorded", decode.string)
  use occurred <- decode.then(none_if_omitted(provenance_occurred_decoder()))
  use target <- decode.optional_field(
    "target",
    [],
    decode.list(reference_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Provenance",
    decode.failure(provenance_new(recorded:), "resourceType"),
  )
  decode.success(Provenance(
    signature:,
    entity:,
    agent:,
    activity:,
    reason:,
    location:,
    policy:,
    recorded:,
    occurred:,
    target:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/Questionnaire#resource
pub type Questionnaire {
  Questionnaire(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    url: Option(String),
    identifier: List(Identifier),
    version: Option(String),
    name: Option(String),
    title: Option(String),
    derived_from: List(String),
    status: r4bvaluesets.Publicationstatus,
    experimental: Option(Bool),
    subject_type: List(r4bvaluesets.Resourcetypes),
    date: Option(String),
    publisher: Option(String),
    contact: List(Contactdetail),
    description: Option(String),
    use_context: List(Usagecontext),
    jurisdiction: List(Codeableconcept),
    purpose: Option(String),
    copyright: Option(String),
    approval_date: Option(String),
    last_review_date: Option(String),
    effective_period: Option(Period),
    code: List(Coding),
    item: List(QuestionnaireItem),
  )
}

pub fn questionnaire_new(
  status status: r4bvaluesets.Publicationstatus,
) -> Questionnaire {
  Questionnaire(
    item: [],
    code: [],
    effective_period: None,
    last_review_date: None,
    approval_date: None,
    copyright: None,
    purpose: None,
    jurisdiction: [],
    use_context: [],
    description: None,
    contact: [],
    publisher: None,
    date: None,
    subject_type: [],
    experimental: None,
    status:,
    derived_from: [],
    title: None,
    name: None,
    version: None,
    identifier: [],
    url: None,
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Questionnaire#resource
pub type QuestionnaireItem {
  QuestionnaireItem(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    link_id: String,
    definition: Option(String),
    code: List(Coding),
    prefix: Option(String),
    text: Option(String),
    type_: r4bvaluesets.Itemtype,
    enable_when: List(QuestionnaireItemEnablewhen),
    enable_behavior: Option(r4bvaluesets.Questionnaireenablebehavior),
    required: Option(Bool),
    repeats: Option(Bool),
    read_only: Option(Bool),
    max_length: Option(Int),
    answer_value_set: Option(String),
    answer_option: List(QuestionnaireItemAnsweroption),
    initial: List(QuestionnaireItemInitial),
  )
}

pub fn questionnaire_item_new(
  type_ type_: r4bvaluesets.Itemtype,
  link_id link_id: String,
) -> QuestionnaireItem {
  QuestionnaireItem(
    initial: [],
    answer_option: [],
    answer_value_set: None,
    max_length: None,
    read_only: None,
    repeats: None,
    required: None,
    enable_behavior: None,
    enable_when: [],
    type_:,
    text: None,
    prefix: None,
    code: [],
    definition: None,
    link_id:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Questionnaire#resource
pub type QuestionnaireItemEnablewhen {
  QuestionnaireItemEnablewhen(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    question: String,
    operator: r4bvaluesets.Questionnaireenableoperator,
    answer: QuestionnaireItemEnablewhenAnswer,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Questionnaire#resource
pub type QuestionnaireItemEnablewhenAnswer {
  QuestionnaireItemEnablewhenAnswerBoolean(answer: Bool)
  QuestionnaireItemEnablewhenAnswerDecimal(answer: Float)
  QuestionnaireItemEnablewhenAnswerInteger(answer: Int)
  QuestionnaireItemEnablewhenAnswerDate(answer: String)
  QuestionnaireItemEnablewhenAnswerDatetime(answer: String)
  QuestionnaireItemEnablewhenAnswerTime(answer: String)
  QuestionnaireItemEnablewhenAnswerString(answer: String)
  QuestionnaireItemEnablewhenAnswerCoding(answer: Coding)
  QuestionnaireItemEnablewhenAnswerQuantity(answer: Quantity)
  QuestionnaireItemEnablewhenAnswerReference(answer: Reference)
}

pub fn questionnaire_item_enablewhen_answer_to_json(
  elt: QuestionnaireItemEnablewhenAnswer,
) -> Json {
  case elt {
    QuestionnaireItemEnablewhenAnswerBoolean(v) -> json.bool(v)
    QuestionnaireItemEnablewhenAnswerDecimal(v) -> json.float(v)
    QuestionnaireItemEnablewhenAnswerInteger(v) -> json.int(v)
    QuestionnaireItemEnablewhenAnswerDate(v) -> json.string(v)
    QuestionnaireItemEnablewhenAnswerDatetime(v) -> json.string(v)
    QuestionnaireItemEnablewhenAnswerTime(v) -> json.string(v)
    QuestionnaireItemEnablewhenAnswerString(v) -> json.string(v)
    QuestionnaireItemEnablewhenAnswerCoding(v) -> coding_to_json(v)
    QuestionnaireItemEnablewhenAnswerQuantity(v) -> quantity_to_json(v)
    QuestionnaireItemEnablewhenAnswerReference(v) -> reference_to_json(v)
  }
}

pub fn questionnaire_item_enablewhen_answer_decoder() -> Decoder(
  QuestionnaireItemEnablewhenAnswer,
) {
  decode.one_of(
    decode.field("answerBoolean", decode.bool, decode.success)
      |> decode.map(QuestionnaireItemEnablewhenAnswerBoolean),
    [
      decode.field("answerDecimal", decode.float, decode.success)
        |> decode.map(QuestionnaireItemEnablewhenAnswerDecimal),
      decode.field("answerInteger", decode.int, decode.success)
        |> decode.map(QuestionnaireItemEnablewhenAnswerInteger),
      decode.field("answerDate", decode.string, decode.success)
        |> decode.map(QuestionnaireItemEnablewhenAnswerDate),
      decode.field("answerDateTime", decode.string, decode.success)
        |> decode.map(QuestionnaireItemEnablewhenAnswerDatetime),
      decode.field("answerTime", decode.string, decode.success)
        |> decode.map(QuestionnaireItemEnablewhenAnswerTime),
      decode.field("answerString", decode.string, decode.success)
        |> decode.map(QuestionnaireItemEnablewhenAnswerString),
      decode.field("answerCoding", coding_decoder(), decode.success)
        |> decode.map(QuestionnaireItemEnablewhenAnswerCoding),
      decode.field("answerQuantity", quantity_decoder(), decode.success)
        |> decode.map(QuestionnaireItemEnablewhenAnswerQuantity),
      decode.field("answerReference", reference_decoder(), decode.success)
        |> decode.map(QuestionnaireItemEnablewhenAnswerReference),
    ],
  )
}

pub fn questionnaire_item_enablewhen_new(
  answer answer: QuestionnaireItemEnablewhenAnswer,
  operator operator: r4bvaluesets.Questionnaireenableoperator,
  question question: String,
) -> QuestionnaireItemEnablewhen {
  QuestionnaireItemEnablewhen(
    answer:,
    operator:,
    question:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Questionnaire#resource
pub type QuestionnaireItemAnsweroption {
  QuestionnaireItemAnsweroption(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    value: QuestionnaireItemAnsweroptionValue,
    initial_selected: Option(Bool),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Questionnaire#resource
pub type QuestionnaireItemAnsweroptionValue {
  QuestionnaireItemAnsweroptionValueInteger(value: Int)
  QuestionnaireItemAnsweroptionValueDate(value: String)
  QuestionnaireItemAnsweroptionValueTime(value: String)
  QuestionnaireItemAnsweroptionValueString(value: String)
  QuestionnaireItemAnsweroptionValueCoding(value: Coding)
  QuestionnaireItemAnsweroptionValueReference(value: Reference)
}

pub fn questionnaire_item_answeroption_value_to_json(
  elt: QuestionnaireItemAnsweroptionValue,
) -> Json {
  case elt {
    QuestionnaireItemAnsweroptionValueInteger(v) -> json.int(v)
    QuestionnaireItemAnsweroptionValueDate(v) -> json.string(v)
    QuestionnaireItemAnsweroptionValueTime(v) -> json.string(v)
    QuestionnaireItemAnsweroptionValueString(v) -> json.string(v)
    QuestionnaireItemAnsweroptionValueCoding(v) -> coding_to_json(v)
    QuestionnaireItemAnsweroptionValueReference(v) -> reference_to_json(v)
  }
}

pub fn questionnaire_item_answeroption_value_decoder() -> Decoder(
  QuestionnaireItemAnsweroptionValue,
) {
  decode.one_of(
    decode.field("valueInteger", decode.int, decode.success)
      |> decode.map(QuestionnaireItemAnsweroptionValueInteger),
    [
      decode.field("valueDate", decode.string, decode.success)
        |> decode.map(QuestionnaireItemAnsweroptionValueDate),
      decode.field("valueTime", decode.string, decode.success)
        |> decode.map(QuestionnaireItemAnsweroptionValueTime),
      decode.field("valueString", decode.string, decode.success)
        |> decode.map(QuestionnaireItemAnsweroptionValueString),
      decode.field("valueCoding", coding_decoder(), decode.success)
        |> decode.map(QuestionnaireItemAnsweroptionValueCoding),
      decode.field("valueReference", reference_decoder(), decode.success)
        |> decode.map(QuestionnaireItemAnsweroptionValueReference),
    ],
  )
}

pub fn questionnaire_item_answeroption_new(
  value value: QuestionnaireItemAnsweroptionValue,
) -> QuestionnaireItemAnsweroption {
  QuestionnaireItemAnsweroption(
    initial_selected: None,
    value:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Questionnaire#resource
pub type QuestionnaireItemInitial {
  QuestionnaireItemInitial(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    value: QuestionnaireItemInitialValue,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Questionnaire#resource
pub type QuestionnaireItemInitialValue {
  QuestionnaireItemInitialValueBoolean(value: Bool)
  QuestionnaireItemInitialValueDecimal(value: Float)
  QuestionnaireItemInitialValueInteger(value: Int)
  QuestionnaireItemInitialValueDate(value: String)
  QuestionnaireItemInitialValueDatetime(value: String)
  QuestionnaireItemInitialValueTime(value: String)
  QuestionnaireItemInitialValueString(value: String)
  QuestionnaireItemInitialValueUri(value: String)
  QuestionnaireItemInitialValueAttachment(value: Attachment)
  QuestionnaireItemInitialValueCoding(value: Coding)
  QuestionnaireItemInitialValueQuantity(value: Quantity)
  QuestionnaireItemInitialValueReference(value: Reference)
}

pub fn questionnaire_item_initial_value_to_json(
  elt: QuestionnaireItemInitialValue,
) -> Json {
  case elt {
    QuestionnaireItemInitialValueBoolean(v) -> json.bool(v)
    QuestionnaireItemInitialValueDecimal(v) -> json.float(v)
    QuestionnaireItemInitialValueInteger(v) -> json.int(v)
    QuestionnaireItemInitialValueDate(v) -> json.string(v)
    QuestionnaireItemInitialValueDatetime(v) -> json.string(v)
    QuestionnaireItemInitialValueTime(v) -> json.string(v)
    QuestionnaireItemInitialValueString(v) -> json.string(v)
    QuestionnaireItemInitialValueUri(v) -> json.string(v)
    QuestionnaireItemInitialValueAttachment(v) -> attachment_to_json(v)
    QuestionnaireItemInitialValueCoding(v) -> coding_to_json(v)
    QuestionnaireItemInitialValueQuantity(v) -> quantity_to_json(v)
    QuestionnaireItemInitialValueReference(v) -> reference_to_json(v)
  }
}

pub fn questionnaire_item_initial_value_decoder() -> Decoder(
  QuestionnaireItemInitialValue,
) {
  decode.one_of(
    decode.field("valueBoolean", decode.bool, decode.success)
      |> decode.map(QuestionnaireItemInitialValueBoolean),
    [
      decode.field("valueDecimal", decode.float, decode.success)
        |> decode.map(QuestionnaireItemInitialValueDecimal),
      decode.field("valueInteger", decode.int, decode.success)
        |> decode.map(QuestionnaireItemInitialValueInteger),
      decode.field("valueDate", decode.string, decode.success)
        |> decode.map(QuestionnaireItemInitialValueDate),
      decode.field("valueDateTime", decode.string, decode.success)
        |> decode.map(QuestionnaireItemInitialValueDatetime),
      decode.field("valueTime", decode.string, decode.success)
        |> decode.map(QuestionnaireItemInitialValueTime),
      decode.field("valueString", decode.string, decode.success)
        |> decode.map(QuestionnaireItemInitialValueString),
      decode.field("valueUri", decode.string, decode.success)
        |> decode.map(QuestionnaireItemInitialValueUri),
      decode.field("valueAttachment", attachment_decoder(), decode.success)
        |> decode.map(QuestionnaireItemInitialValueAttachment),
      decode.field("valueCoding", coding_decoder(), decode.success)
        |> decode.map(QuestionnaireItemInitialValueCoding),
      decode.field("valueQuantity", quantity_decoder(), decode.success)
        |> decode.map(QuestionnaireItemInitialValueQuantity),
      decode.field("valueReference", reference_decoder(), decode.success)
        |> decode.map(QuestionnaireItemInitialValueReference),
    ],
  )
}

pub fn questionnaire_item_initial_new(
  value value: QuestionnaireItemInitialValue,
) -> QuestionnaireItemInitial {
  QuestionnaireItemInitial(
    value:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn questionnaire_item_initial_to_json(
  questionnaire_item_initial: QuestionnaireItemInitial,
) -> Json {
  let QuestionnaireItemInitial(value:, modifier_extension:, extension:, id:) =
    questionnaire_item_initial
  let fields = [
    #("value", questionnaire_item_initial_value_to_json(value)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn questionnaire_item_initial_decoder() -> Decoder(QuestionnaireItemInitial) {
  use value <- decode.then(questionnaire_item_initial_value_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(QuestionnaireItemInitial(
    value:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn questionnaire_item_answeroption_to_json(
  questionnaire_item_answeroption: QuestionnaireItemAnsweroption,
) -> Json {
  let QuestionnaireItemAnsweroption(
    initial_selected:,
    value:,
    modifier_extension:,
    extension:,
    id:,
  ) = questionnaire_item_answeroption
  let fields = [
    #("value", questionnaire_item_answeroption_value_to_json(value)),
  ]
  let fields = case initial_selected {
    Some(v) -> [#("initialSelected", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn questionnaire_item_answeroption_decoder() -> Decoder(
  QuestionnaireItemAnsweroption,
) {
  use initial_selected <- decode.optional_field(
    "initialSelected",
    None,
    decode.optional(decode.bool),
  )
  use value <- decode.then(questionnaire_item_answeroption_value_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(QuestionnaireItemAnsweroption(
    initial_selected:,
    value:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn questionnaire_item_enablewhen_to_json(
  questionnaire_item_enablewhen: QuestionnaireItemEnablewhen,
) -> Json {
  let QuestionnaireItemEnablewhen(
    answer:,
    operator:,
    question:,
    modifier_extension:,
    extension:,
    id:,
  ) = questionnaire_item_enablewhen
  let fields = [
    #("answer", questionnaire_item_enablewhen_answer_to_json(answer)),
    #("operator", r4bvaluesets.questionnaireenableoperator_to_json(operator)),
    #("question", json.string(question)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn questionnaire_item_enablewhen_decoder() -> Decoder(
  QuestionnaireItemEnablewhen,
) {
  use answer <- decode.then(questionnaire_item_enablewhen_answer_decoder())
  use operator <- decode.field(
    "operator",
    r4bvaluesets.questionnaireenableoperator_decoder(),
  )
  use question <- decode.field("question", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(QuestionnaireItemEnablewhen(
    answer:,
    operator:,
    question:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn questionnaire_item_to_json(questionnaire_item: QuestionnaireItem) -> Json {
  let QuestionnaireItem(
    initial:,
    answer_option:,
    answer_value_set:,
    max_length:,
    read_only:,
    repeats:,
    required:,
    enable_behavior:,
    enable_when:,
    type_:,
    text:,
    prefix:,
    code:,
    definition:,
    link_id:,
    modifier_extension:,
    extension:,
    id:,
  ) = questionnaire_item
  let fields = [
    #("type", r4bvaluesets.itemtype_to_json(type_)),
    #("linkId", json.string(link_id)),
  ]
  let fields = case initial {
    [] -> fields
    _ -> [
      #("initial", json.array(initial, questionnaire_item_initial_to_json)),
      ..fields
    ]
  }
  let fields = case answer_option {
    [] -> fields
    _ -> [
      #(
        "answerOption",
        json.array(answer_option, questionnaire_item_answeroption_to_json),
      ),
      ..fields
    ]
  }
  let fields = case answer_value_set {
    Some(v) -> [#("answerValueSet", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case max_length {
    Some(v) -> [#("maxLength", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case read_only {
    Some(v) -> [#("readOnly", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case repeats {
    Some(v) -> [#("repeats", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case required {
    Some(v) -> [#("required", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case enable_behavior {
    Some(v) -> [
      #("enableBehavior", r4bvaluesets.questionnaireenablebehavior_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case enable_when {
    [] -> fields
    _ -> [
      #(
        "enableWhen",
        json.array(enable_when, questionnaire_item_enablewhen_to_json),
      ),
      ..fields
    ]
  }
  let fields = case text {
    Some(v) -> [#("text", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case prefix {
    Some(v) -> [#("prefix", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case code {
    [] -> fields
    _ -> [#("code", json.array(code, coding_to_json)), ..fields]
  }
  let fields = case definition {
    Some(v) -> [#("definition", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn questionnaire_item_decoder() -> Decoder(QuestionnaireItem) {
  use initial <- decode.optional_field(
    "initial",
    [],
    decode.list(questionnaire_item_initial_decoder()),
  )
  use answer_option <- decode.optional_field(
    "answerOption",
    [],
    decode.list(questionnaire_item_answeroption_decoder()),
  )
  use answer_value_set <- decode.optional_field(
    "answerValueSet",
    None,
    decode.optional(decode.string),
  )
  use max_length <- decode.optional_field(
    "maxLength",
    None,
    decode.optional(decode.int),
  )
  use read_only <- decode.optional_field(
    "readOnly",
    None,
    decode.optional(decode.bool),
  )
  use repeats <- decode.optional_field(
    "repeats",
    None,
    decode.optional(decode.bool),
  )
  use required <- decode.optional_field(
    "required",
    None,
    decode.optional(decode.bool),
  )
  use enable_behavior <- decode.optional_field(
    "enableBehavior",
    None,
    decode.optional(r4bvaluesets.questionnaireenablebehavior_decoder()),
  )
  use enable_when <- decode.optional_field(
    "enableWhen",
    [],
    decode.list(questionnaire_item_enablewhen_decoder()),
  )
  use type_ <- decode.field("type", r4bvaluesets.itemtype_decoder())
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(decode.string),
  )
  use prefix <- decode.optional_field(
    "prefix",
    None,
    decode.optional(decode.string),
  )
  use code <- decode.optional_field("code", [], decode.list(coding_decoder()))
  use definition <- decode.optional_field(
    "definition",
    None,
    decode.optional(decode.string),
  )
  use link_id <- decode.field("linkId", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(QuestionnaireItem(
    initial:,
    answer_option:,
    answer_value_set:,
    max_length:,
    read_only:,
    repeats:,
    required:,
    enable_behavior:,
    enable_when:,
    type_:,
    text:,
    prefix:,
    code:,
    definition:,
    link_id:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn questionnaire_to_json(questionnaire: Questionnaire) -> Json {
  let Questionnaire(
    item:,
    code:,
    effective_period:,
    last_review_date:,
    approval_date:,
    copyright:,
    purpose:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    subject_type:,
    experimental:,
    status:,
    derived_from:,
    title:,
    name:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = questionnaire
  let fields = [
    #("status", r4bvaluesets.publicationstatus_to_json(status)),
  ]
  let fields = case item {
    [] -> fields
    _ -> [#("item", json.array(item, questionnaire_item_to_json)), ..fields]
  }
  let fields = case code {
    [] -> fields
    _ -> [#("code", json.array(code, coding_to_json)), ..fields]
  }
  let fields = case effective_period {
    Some(v) -> [#("effectivePeriod", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case last_review_date {
    Some(v) -> [#("lastReviewDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case approval_date {
    Some(v) -> [#("approvalDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case copyright {
    Some(v) -> [#("copyright", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case purpose {
    Some(v) -> [#("purpose", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case jurisdiction {
    [] -> fields
    _ -> [
      #("jurisdiction", json.array(jurisdiction, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case use_context {
    [] -> fields
    _ -> [
      #("useContext", json.array(use_context, usagecontext_to_json)),
      ..fields
    ]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case contact {
    [] -> fields
    _ -> [#("contact", json.array(contact, contactdetail_to_json)), ..fields]
  }
  let fields = case publisher {
    Some(v) -> [#("publisher", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case date {
    Some(v) -> [#("date", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case subject_type {
    [] -> fields
    _ -> [
      #(
        "subjectType",
        json.array(subject_type, r4bvaluesets.resourcetypes_to_json),
      ),
      ..fields
    ]
  }
  let fields = case experimental {
    Some(v) -> [#("experimental", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case derived_from {
    [] -> fields
    _ -> [#("derivedFrom", json.array(derived_from, json.string)), ..fields]
  }
  let fields = case title {
    Some(v) -> [#("title", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case version {
    Some(v) -> [#("version", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case url {
    Some(v) -> [#("url", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Questionnaire")), ..fields]
  json.object(fields)
}

pub fn questionnaire_decoder() -> Decoder(Questionnaire) {
  use item <- decode.optional_field(
    "item",
    [],
    decode.list(questionnaire_item_decoder()),
  )
  use code <- decode.optional_field("code", [], decode.list(coding_decoder()))
  use effective_period <- decode.optional_field(
    "effectivePeriod",
    None,
    decode.optional(period_decoder()),
  )
  use last_review_date <- decode.optional_field(
    "lastReviewDate",
    None,
    decode.optional(decode.string),
  )
  use approval_date <- decode.optional_field(
    "approvalDate",
    None,
    decode.optional(decode.string),
  )
  use copyright <- decode.optional_field(
    "copyright",
    None,
    decode.optional(decode.string),
  )
  use purpose <- decode.optional_field(
    "purpose",
    None,
    decode.optional(decode.string),
  )
  use jurisdiction <- decode.optional_field(
    "jurisdiction",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use use_context <- decode.optional_field(
    "useContext",
    [],
    decode.list(usagecontext_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use contact <- decode.optional_field(
    "contact",
    [],
    decode.list(contactdetail_decoder()),
  )
  use publisher <- decode.optional_field(
    "publisher",
    None,
    decode.optional(decode.string),
  )
  use date <- decode.optional_field(
    "date",
    None,
    decode.optional(decode.string),
  )
  use subject_type <- decode.optional_field(
    "subjectType",
    [],
    decode.list(r4bvaluesets.resourcetypes_decoder()),
  )
  use experimental <- decode.optional_field(
    "experimental",
    None,
    decode.optional(decode.bool),
  )
  use status <- decode.field("status", r4bvaluesets.publicationstatus_decoder())
  use derived_from <- decode.optional_field(
    "derivedFrom",
    [],
    decode.list(decode.string),
  )
  use title <- decode.optional_field(
    "title",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use version <- decode.optional_field(
    "version",
    None,
    decode.optional(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use url <- decode.optional_field("url", None, decode.optional(decode.string))
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Questionnaire",
    decode.failure(questionnaire_new(status:), "resourceType"),
  )
  decode.success(Questionnaire(
    item:,
    code:,
    effective_period:,
    last_review_date:,
    approval_date:,
    copyright:,
    purpose:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    subject_type:,
    experimental:,
    status:,
    derived_from:,
    title:,
    name:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/QuestionnaireResponse#resource
pub type Questionnaireresponse {
  Questionnaireresponse(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: Option(Identifier),
    based_on: List(Reference),
    part_of: List(Reference),
    questionnaire: Option(String),
    status: r4bvaluesets.Questionnaireanswersstatus,
    subject: Option(Reference),
    encounter: Option(Reference),
    authored: Option(String),
    author: Option(Reference),
    source: Option(Reference),
    item: List(QuestionnaireresponseItem),
  )
}

pub fn questionnaireresponse_new(
  status status: r4bvaluesets.Questionnaireanswersstatus,
) -> Questionnaireresponse {
  Questionnaireresponse(
    item: [],
    source: None,
    author: None,
    authored: None,
    encounter: None,
    subject: None,
    status:,
    questionnaire: None,
    part_of: [],
    based_on: [],
    identifier: None,
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/QuestionnaireResponse#resource
pub type QuestionnaireresponseItem {
  QuestionnaireresponseItem(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    link_id: String,
    definition: Option(String),
    text: Option(String),
    answer: List(QuestionnaireresponseItemAnswer),
  )
}

pub fn questionnaireresponse_item_new(
  link_id link_id: String,
) -> QuestionnaireresponseItem {
  QuestionnaireresponseItem(
    answer: [],
    text: None,
    definition: None,
    link_id:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/QuestionnaireResponse#resource
pub type QuestionnaireresponseItemAnswer {
  QuestionnaireresponseItemAnswer(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    value: Option(QuestionnaireresponseItemAnswerValue),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/QuestionnaireResponse#resource
pub type QuestionnaireresponseItemAnswerValue {
  QuestionnaireresponseItemAnswerValueBoolean(value: Bool)
  QuestionnaireresponseItemAnswerValueDecimal(value: Float)
  QuestionnaireresponseItemAnswerValueInteger(value: Int)
  QuestionnaireresponseItemAnswerValueDate(value: String)
  QuestionnaireresponseItemAnswerValueDatetime(value: String)
  QuestionnaireresponseItemAnswerValueTime(value: String)
  QuestionnaireresponseItemAnswerValueString(value: String)
  QuestionnaireresponseItemAnswerValueUri(value: String)
  QuestionnaireresponseItemAnswerValueAttachment(value: Attachment)
  QuestionnaireresponseItemAnswerValueCoding(value: Coding)
  QuestionnaireresponseItemAnswerValueQuantity(value: Quantity)
  QuestionnaireresponseItemAnswerValueReference(value: Reference)
}

pub fn questionnaireresponse_item_answer_value_to_json(
  elt: QuestionnaireresponseItemAnswerValue,
) -> Json {
  case elt {
    QuestionnaireresponseItemAnswerValueBoolean(v) -> json.bool(v)
    QuestionnaireresponseItemAnswerValueDecimal(v) -> json.float(v)
    QuestionnaireresponseItemAnswerValueInteger(v) -> json.int(v)
    QuestionnaireresponseItemAnswerValueDate(v) -> json.string(v)
    QuestionnaireresponseItemAnswerValueDatetime(v) -> json.string(v)
    QuestionnaireresponseItemAnswerValueTime(v) -> json.string(v)
    QuestionnaireresponseItemAnswerValueString(v) -> json.string(v)
    QuestionnaireresponseItemAnswerValueUri(v) -> json.string(v)
    QuestionnaireresponseItemAnswerValueAttachment(v) -> attachment_to_json(v)
    QuestionnaireresponseItemAnswerValueCoding(v) -> coding_to_json(v)
    QuestionnaireresponseItemAnswerValueQuantity(v) -> quantity_to_json(v)
    QuestionnaireresponseItemAnswerValueReference(v) -> reference_to_json(v)
  }
}

pub fn questionnaireresponse_item_answer_value_decoder() -> Decoder(
  QuestionnaireresponseItemAnswerValue,
) {
  decode.one_of(
    decode.field("valueBoolean", decode.bool, decode.success)
      |> decode.map(QuestionnaireresponseItemAnswerValueBoolean),
    [
      decode.field("valueDecimal", decode.float, decode.success)
        |> decode.map(QuestionnaireresponseItemAnswerValueDecimal),
      decode.field("valueInteger", decode.int, decode.success)
        |> decode.map(QuestionnaireresponseItemAnswerValueInteger),
      decode.field("valueDate", decode.string, decode.success)
        |> decode.map(QuestionnaireresponseItemAnswerValueDate),
      decode.field("valueDateTime", decode.string, decode.success)
        |> decode.map(QuestionnaireresponseItemAnswerValueDatetime),
      decode.field("valueTime", decode.string, decode.success)
        |> decode.map(QuestionnaireresponseItemAnswerValueTime),
      decode.field("valueString", decode.string, decode.success)
        |> decode.map(QuestionnaireresponseItemAnswerValueString),
      decode.field("valueUri", decode.string, decode.success)
        |> decode.map(QuestionnaireresponseItemAnswerValueUri),
      decode.field("valueAttachment", attachment_decoder(), decode.success)
        |> decode.map(QuestionnaireresponseItemAnswerValueAttachment),
      decode.field("valueCoding", coding_decoder(), decode.success)
        |> decode.map(QuestionnaireresponseItemAnswerValueCoding),
      decode.field("valueQuantity", quantity_decoder(), decode.success)
        |> decode.map(QuestionnaireresponseItemAnswerValueQuantity),
      decode.field("valueReference", reference_decoder(), decode.success)
        |> decode.map(QuestionnaireresponseItemAnswerValueReference),
    ],
  )
}

pub fn questionnaireresponse_item_answer_new() -> QuestionnaireresponseItemAnswer {
  QuestionnaireresponseItemAnswer(
    value: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn questionnaireresponse_item_answer_to_json(
  questionnaireresponse_item_answer: QuestionnaireresponseItemAnswer,
) -> Json {
  let QuestionnaireresponseItemAnswer(
    value:,
    modifier_extension:,
    extension:,
    id:,
  ) = questionnaireresponse_item_answer
  let fields = []
  let fields = case value {
    Some(v) -> [
      #(
        "value"
          <> case v {
          QuestionnaireresponseItemAnswerValueBoolean(_) -> "Boolean"
          QuestionnaireresponseItemAnswerValueDecimal(_) -> "Decimal"
          QuestionnaireresponseItemAnswerValueInteger(_) -> "Integer"
          QuestionnaireresponseItemAnswerValueDate(_) -> "Date"
          QuestionnaireresponseItemAnswerValueDatetime(_) -> "Datetime"
          QuestionnaireresponseItemAnswerValueTime(_) -> "Time"
          QuestionnaireresponseItemAnswerValueString(_) -> "String"
          QuestionnaireresponseItemAnswerValueUri(_) -> "Uri"
          QuestionnaireresponseItemAnswerValueAttachment(_) -> "Attachment"
          QuestionnaireresponseItemAnswerValueCoding(_) -> "Coding"
          QuestionnaireresponseItemAnswerValueQuantity(_) -> "Quantity"
          QuestionnaireresponseItemAnswerValueReference(_) -> "Reference"
        },
        questionnaireresponse_item_answer_value_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn questionnaireresponse_item_answer_decoder() -> Decoder(
  QuestionnaireresponseItemAnswer,
) {
  use value <- decode.then(
    none_if_omitted(questionnaireresponse_item_answer_value_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(QuestionnaireresponseItemAnswer(
    value:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn questionnaireresponse_item_to_json(
  questionnaireresponse_item: QuestionnaireresponseItem,
) -> Json {
  let QuestionnaireresponseItem(
    answer:,
    text:,
    definition:,
    link_id:,
    modifier_extension:,
    extension:,
    id:,
  ) = questionnaireresponse_item
  let fields = [
    #("linkId", json.string(link_id)),
  ]
  let fields = case answer {
    [] -> fields
    _ -> [
      #("answer", json.array(answer, questionnaireresponse_item_answer_to_json)),
      ..fields
    ]
  }
  let fields = case text {
    Some(v) -> [#("text", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case definition {
    Some(v) -> [#("definition", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn questionnaireresponse_item_decoder() -> Decoder(
  QuestionnaireresponseItem,
) {
  use answer <- decode.optional_field(
    "answer",
    [],
    decode.list(questionnaireresponse_item_answer_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(decode.string),
  )
  use definition <- decode.optional_field(
    "definition",
    None,
    decode.optional(decode.string),
  )
  use link_id <- decode.field("linkId", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(QuestionnaireresponseItem(
    answer:,
    text:,
    definition:,
    link_id:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn questionnaireresponse_to_json(
  questionnaireresponse: Questionnaireresponse,
) -> Json {
  let Questionnaireresponse(
    item:,
    source:,
    author:,
    authored:,
    encounter:,
    subject:,
    status:,
    questionnaire:,
    part_of:,
    based_on:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = questionnaireresponse
  let fields = [
    #("status", r4bvaluesets.questionnaireanswersstatus_to_json(status)),
  ]
  let fields = case item {
    [] -> fields
    _ -> [
      #("item", json.array(item, questionnaireresponse_item_to_json)),
      ..fields
    ]
  }
  let fields = case source {
    Some(v) -> [#("source", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case author {
    Some(v) -> [#("author", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case authored {
    Some(v) -> [#("authored", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case encounter {
    Some(v) -> [#("encounter", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case subject {
    Some(v) -> [#("subject", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case questionnaire {
    Some(v) -> [#("questionnaire", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case part_of {
    [] -> fields
    _ -> [#("partOf", json.array(part_of, reference_to_json)), ..fields]
  }
  let fields = case based_on {
    [] -> fields
    _ -> [#("basedOn", json.array(based_on, reference_to_json)), ..fields]
  }
  let fields = case identifier {
    Some(v) -> [#("identifier", identifier_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [
    #("resourceType", json.string("Questionnaireresponse")),
    ..fields
  ]
  json.object(fields)
}

pub fn questionnaireresponse_decoder() -> Decoder(Questionnaireresponse) {
  use item <- decode.optional_field(
    "item",
    [],
    decode.list(questionnaireresponse_item_decoder()),
  )
  use source <- decode.optional_field(
    "source",
    None,
    decode.optional(reference_decoder()),
  )
  use author <- decode.optional_field(
    "author",
    None,
    decode.optional(reference_decoder()),
  )
  use authored <- decode.optional_field(
    "authored",
    None,
    decode.optional(decode.string),
  )
  use encounter <- decode.optional_field(
    "encounter",
    None,
    decode.optional(reference_decoder()),
  )
  use subject <- decode.optional_field(
    "subject",
    None,
    decode.optional(reference_decoder()),
  )
  use status <- decode.field(
    "status",
    r4bvaluesets.questionnaireanswersstatus_decoder(),
  )
  use questionnaire <- decode.optional_field(
    "questionnaire",
    None,
    decode.optional(decode.string),
  )
  use part_of <- decode.optional_field(
    "partOf",
    [],
    decode.list(reference_decoder()),
  )
  use based_on <- decode.optional_field(
    "basedOn",
    [],
    decode.list(reference_decoder()),
  )
  use identifier <- decode.optional_field(
    "identifier",
    None,
    decode.optional(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Questionnaireresponse",
    decode.failure(questionnaireresponse_new(status:), "resourceType"),
  )
  decode.success(Questionnaireresponse(
    item:,
    source:,
    author:,
    authored:,
    encounter:,
    subject:,
    status:,
    questionnaire:,
    part_of:,
    based_on:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/RegulatedAuthorization#resource
pub type Regulatedauthorization {
  Regulatedauthorization(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    subject: List(Reference),
    type_: Option(Codeableconcept),
    description: Option(String),
    region: List(Codeableconcept),
    status: Option(Codeableconcept),
    status_date: Option(String),
    validity_period: Option(Period),
    indication: Option(Codeablereference),
    intended_use: Option(Codeableconcept),
    basis: List(Codeableconcept),
    holder: Option(Reference),
    regulator: Option(Reference),
    case_: Option(RegulatedauthorizationCase),
  )
}

pub fn regulatedauthorization_new() -> Regulatedauthorization {
  Regulatedauthorization(
    case_: None,
    regulator: None,
    holder: None,
    basis: [],
    intended_use: None,
    indication: None,
    validity_period: None,
    status_date: None,
    status: None,
    region: [],
    description: None,
    type_: None,
    subject: [],
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/RegulatedAuthorization#resource
pub type RegulatedauthorizationCase {
  RegulatedauthorizationCase(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: Option(Identifier),
    type_: Option(Codeableconcept),
    status: Option(Codeableconcept),
    date: Option(RegulatedauthorizationCaseDate),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/RegulatedAuthorization#resource
pub type RegulatedauthorizationCaseDate {
  RegulatedauthorizationCaseDatePeriod(date: Period)
  RegulatedauthorizationCaseDateDatetime(date: String)
}

pub fn regulatedauthorization_case_date_to_json(
  elt: RegulatedauthorizationCaseDate,
) -> Json {
  case elt {
    RegulatedauthorizationCaseDatePeriod(v) -> period_to_json(v)
    RegulatedauthorizationCaseDateDatetime(v) -> json.string(v)
  }
}

pub fn regulatedauthorization_case_date_decoder() -> Decoder(
  RegulatedauthorizationCaseDate,
) {
  decode.one_of(
    decode.field("datePeriod", period_decoder(), decode.success)
      |> decode.map(RegulatedauthorizationCaseDatePeriod),
    [
      decode.field("dateDateTime", decode.string, decode.success)
      |> decode.map(RegulatedauthorizationCaseDateDatetime),
    ],
  )
}

pub fn regulatedauthorization_case_new() -> RegulatedauthorizationCase {
  RegulatedauthorizationCase(
    date: None,
    status: None,
    type_: None,
    identifier: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn regulatedauthorization_case_to_json(
  regulatedauthorization_case: RegulatedauthorizationCase,
) -> Json {
  let RegulatedauthorizationCase(
    date:,
    status:,
    type_:,
    identifier:,
    modifier_extension:,
    extension:,
    id:,
  ) = regulatedauthorization_case
  let fields = []
  let fields = case date {
    Some(v) -> [
      #(
        "date"
          <> case v {
          RegulatedauthorizationCaseDatePeriod(_) -> "Period"
          RegulatedauthorizationCaseDateDatetime(_) -> "Datetime"
        },
        regulatedauthorization_case_date_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case status {
    Some(v) -> [#("status", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    Some(v) -> [#("identifier", identifier_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn regulatedauthorization_case_decoder() -> Decoder(
  RegulatedauthorizationCase,
) {
  use date <- decode.then(
    none_if_omitted(regulatedauthorization_case_date_decoder()),
  )
  use status <- decode.optional_field(
    "status",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use identifier <- decode.optional_field(
    "identifier",
    None,
    decode.optional(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(RegulatedauthorizationCase(
    date:,
    status:,
    type_:,
    identifier:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn regulatedauthorization_to_json(
  regulatedauthorization: Regulatedauthorization,
) -> Json {
  let Regulatedauthorization(
    case_:,
    regulator:,
    holder:,
    basis:,
    intended_use:,
    indication:,
    validity_period:,
    status_date:,
    status:,
    region:,
    description:,
    type_:,
    subject:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = regulatedauthorization
  let fields = []
  let fields = case case_ {
    Some(v) -> [#("case", regulatedauthorization_case_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case regulator {
    Some(v) -> [#("regulator", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case holder {
    Some(v) -> [#("holder", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case basis {
    [] -> fields
    _ -> [#("basis", json.array(basis, codeableconcept_to_json)), ..fields]
  }
  let fields = case intended_use {
    Some(v) -> [#("intendedUse", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case indication {
    Some(v) -> [#("indication", codeablereference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case validity_period {
    Some(v) -> [#("validityPeriod", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case status_date {
    Some(v) -> [#("statusDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case status {
    Some(v) -> [#("status", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case region {
    [] -> fields
    _ -> [#("region", json.array(region, codeableconcept_to_json)), ..fields]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case subject {
    [] -> fields
    _ -> [#("subject", json.array(subject, reference_to_json)), ..fields]
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [
    #("resourceType", json.string("Regulatedauthorization")),
    ..fields
  ]
  json.object(fields)
}

pub fn regulatedauthorization_decoder() -> Decoder(Regulatedauthorization) {
  use case_ <- decode.optional_field(
    "case",
    None,
    decode.optional(regulatedauthorization_case_decoder()),
  )
  use regulator <- decode.optional_field(
    "regulator",
    None,
    decode.optional(reference_decoder()),
  )
  use holder <- decode.optional_field(
    "holder",
    None,
    decode.optional(reference_decoder()),
  )
  use basis <- decode.optional_field(
    "basis",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use intended_use <- decode.optional_field(
    "intendedUse",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use indication <- decode.optional_field(
    "indication",
    None,
    decode.optional(codeablereference_decoder()),
  )
  use validity_period <- decode.optional_field(
    "validityPeriod",
    None,
    decode.optional(period_decoder()),
  )
  use status_date <- decode.optional_field(
    "statusDate",
    None,
    decode.optional(decode.string),
  )
  use status <- decode.optional_field(
    "status",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use region <- decode.optional_field(
    "region",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use subject <- decode.optional_field(
    "subject",
    [],
    decode.list(reference_decoder()),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Regulatedauthorization",
    decode.failure(regulatedauthorization_new(), "resourceType"),
  )
  decode.success(Regulatedauthorization(
    case_:,
    regulator:,
    holder:,
    basis:,
    intended_use:,
    indication:,
    validity_period:,
    status_date:,
    status:,
    region:,
    description:,
    type_:,
    subject:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/RelatedPerson#resource
pub type Relatedperson {
  Relatedperson(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    active: Option(Bool),
    patient: Reference,
    relationship: List(Codeableconcept),
    name: List(Humanname),
    telecom: List(Contactpoint),
    gender: Option(r4bvaluesets.Administrativegender),
    birth_date: Option(String),
    address: List(Address),
    photo: List(Attachment),
    period: Option(Period),
    communication: List(RelatedpersonCommunication),
  )
}

pub fn relatedperson_new(patient patient: Reference) -> Relatedperson {
  Relatedperson(
    communication: [],
    period: None,
    photo: [],
    address: [],
    birth_date: None,
    gender: None,
    telecom: [],
    name: [],
    relationship: [],
    patient:,
    active: None,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/RelatedPerson#resource
pub type RelatedpersonCommunication {
  RelatedpersonCommunication(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    language: Codeableconcept,
    preferred: Option(Bool),
  )
}

pub fn relatedperson_communication_new(
  language language: Codeableconcept,
) -> RelatedpersonCommunication {
  RelatedpersonCommunication(
    preferred: None,
    language:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn relatedperson_communication_to_json(
  relatedperson_communication: RelatedpersonCommunication,
) -> Json {
  let RelatedpersonCommunication(
    preferred:,
    language:,
    modifier_extension:,
    extension:,
    id:,
  ) = relatedperson_communication
  let fields = [
    #("language", codeableconcept_to_json(language)),
  ]
  let fields = case preferred {
    Some(v) -> [#("preferred", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn relatedperson_communication_decoder() -> Decoder(
  RelatedpersonCommunication,
) {
  use preferred <- decode.optional_field(
    "preferred",
    None,
    decode.optional(decode.bool),
  )
  use language <- decode.field("language", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(RelatedpersonCommunication(
    preferred:,
    language:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn relatedperson_to_json(relatedperson: Relatedperson) -> Json {
  let Relatedperson(
    communication:,
    period:,
    photo:,
    address:,
    birth_date:,
    gender:,
    telecom:,
    name:,
    relationship:,
    patient:,
    active:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = relatedperson
  let fields = [
    #("patient", reference_to_json(patient)),
  ]
  let fields = case communication {
    [] -> fields
    _ -> [
      #(
        "communication",
        json.array(communication, relatedperson_communication_to_json),
      ),
      ..fields
    ]
  }
  let fields = case period {
    Some(v) -> [#("period", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case photo {
    [] -> fields
    _ -> [#("photo", json.array(photo, attachment_to_json)), ..fields]
  }
  let fields = case address {
    [] -> fields
    _ -> [#("address", json.array(address, address_to_json)), ..fields]
  }
  let fields = case birth_date {
    Some(v) -> [#("birthDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case gender {
    Some(v) -> [
      #("gender", r4bvaluesets.administrativegender_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case telecom {
    [] -> fields
    _ -> [#("telecom", json.array(telecom, contactpoint_to_json)), ..fields]
  }
  let fields = case name {
    [] -> fields
    _ -> [#("name", json.array(name, humanname_to_json)), ..fields]
  }
  let fields = case relationship {
    [] -> fields
    _ -> [
      #("relationship", json.array(relationship, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case active {
    Some(v) -> [#("active", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Relatedperson")), ..fields]
  json.object(fields)
}

pub fn relatedperson_decoder() -> Decoder(Relatedperson) {
  use communication <- decode.optional_field(
    "communication",
    [],
    decode.list(relatedperson_communication_decoder()),
  )
  use period <- decode.optional_field(
    "period",
    None,
    decode.optional(period_decoder()),
  )
  use photo <- decode.optional_field(
    "photo",
    [],
    decode.list(attachment_decoder()),
  )
  use address <- decode.optional_field(
    "address",
    [],
    decode.list(address_decoder()),
  )
  use birth_date <- decode.optional_field(
    "birthDate",
    None,
    decode.optional(decode.string),
  )
  use gender <- decode.optional_field(
    "gender",
    None,
    decode.optional(r4bvaluesets.administrativegender_decoder()),
  )
  use telecom <- decode.optional_field(
    "telecom",
    [],
    decode.list(contactpoint_decoder()),
  )
  use name <- decode.optional_field(
    "name",
    [],
    decode.list(humanname_decoder()),
  )
  use relationship <- decode.optional_field(
    "relationship",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use patient <- decode.field("patient", reference_decoder())
  use active <- decode.optional_field(
    "active",
    None,
    decode.optional(decode.bool),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Relatedperson",
    decode.failure(relatedperson_new(patient:), "resourceType"),
  )
  decode.success(Relatedperson(
    communication:,
    period:,
    photo:,
    address:,
    birth_date:,
    gender:,
    telecom:,
    name:,
    relationship:,
    patient:,
    active:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/RequestGroup#resource
pub type Requestgroup {
  Requestgroup(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    instantiates_canonical: List(String),
    instantiates_uri: List(String),
    based_on: List(Reference),
    replaces: List(Reference),
    group_identifier: Option(Identifier),
    status: r4bvaluesets.Requeststatus,
    intent: r4bvaluesets.Requestintent,
    priority: Option(r4bvaluesets.Requestpriority),
    code: Option(Codeableconcept),
    subject: Option(Reference),
    encounter: Option(Reference),
    authored_on: Option(String),
    author: Option(Reference),
    reason_code: List(Codeableconcept),
    reason_reference: List(Reference),
    note: List(Annotation),
    action: List(RequestgroupAction),
  )
}

pub fn requestgroup_new(
  intent intent: r4bvaluesets.Requestintent,
  status status: r4bvaluesets.Requeststatus,
) -> Requestgroup {
  Requestgroup(
    action: [],
    note: [],
    reason_reference: [],
    reason_code: [],
    author: None,
    authored_on: None,
    encounter: None,
    subject: None,
    code: None,
    priority: None,
    intent:,
    status:,
    group_identifier: None,
    replaces: [],
    based_on: [],
    instantiates_uri: [],
    instantiates_canonical: [],
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/RequestGroup#resource
pub type RequestgroupAction {
  RequestgroupAction(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    prefix: Option(String),
    title: Option(String),
    description: Option(String),
    text_equivalent: Option(String),
    priority: Option(r4bvaluesets.Requestpriority),
    code: List(Codeableconcept),
    documentation: List(Relatedartifact),
    condition: List(RequestgroupActionCondition),
    related_action: List(RequestgroupActionRelatedaction),
    timing: Option(RequestgroupActionTiming),
    participant: List(Reference),
    type_: Option(Codeableconcept),
    grouping_behavior: Option(r4bvaluesets.Actiongroupingbehavior),
    selection_behavior: Option(r4bvaluesets.Actionselectionbehavior),
    required_behavior: Option(r4bvaluesets.Actionrequiredbehavior),
    precheck_behavior: Option(r4bvaluesets.Actionprecheckbehavior),
    cardinality_behavior: Option(r4bvaluesets.Actioncardinalitybehavior),
    resource: Option(Reference),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/RequestGroup#resource
pub type RequestgroupActionTiming {
  RequestgroupActionTimingDatetime(timing: String)
  RequestgroupActionTimingAge(timing: Age)
  RequestgroupActionTimingPeriod(timing: Period)
  RequestgroupActionTimingDuration(timing: Duration)
  RequestgroupActionTimingRange(timing: Range)
  RequestgroupActionTimingTiming(timing: Timing)
}

pub fn requestgroup_action_timing_to_json(elt: RequestgroupActionTiming) -> Json {
  case elt {
    RequestgroupActionTimingDatetime(v) -> json.string(v)
    RequestgroupActionTimingAge(v) -> age_to_json(v)
    RequestgroupActionTimingPeriod(v) -> period_to_json(v)
    RequestgroupActionTimingDuration(v) -> duration_to_json(v)
    RequestgroupActionTimingRange(v) -> range_to_json(v)
    RequestgroupActionTimingTiming(v) -> timing_to_json(v)
  }
}

pub fn requestgroup_action_timing_decoder() -> Decoder(RequestgroupActionTiming) {
  decode.one_of(
    decode.field("timingDateTime", decode.string, decode.success)
      |> decode.map(RequestgroupActionTimingDatetime),
    [
      decode.field("timingAge", age_decoder(), decode.success)
        |> decode.map(RequestgroupActionTimingAge),
      decode.field("timingPeriod", period_decoder(), decode.success)
        |> decode.map(RequestgroupActionTimingPeriod),
      decode.field("timingDuration", duration_decoder(), decode.success)
        |> decode.map(RequestgroupActionTimingDuration),
      decode.field("timingRange", range_decoder(), decode.success)
        |> decode.map(RequestgroupActionTimingRange),
      decode.field("timingTiming", timing_decoder(), decode.success)
        |> decode.map(RequestgroupActionTimingTiming),
    ],
  )
}

pub fn requestgroup_action_new() -> RequestgroupAction {
  RequestgroupAction(
    resource: None,
    cardinality_behavior: None,
    precheck_behavior: None,
    required_behavior: None,
    selection_behavior: None,
    grouping_behavior: None,
    type_: None,
    participant: [],
    timing: None,
    related_action: [],
    condition: [],
    documentation: [],
    code: [],
    priority: None,
    text_equivalent: None,
    description: None,
    title: None,
    prefix: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/RequestGroup#resource
pub type RequestgroupActionCondition {
  RequestgroupActionCondition(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    kind: r4bvaluesets.Actionconditionkind,
    expression: Option(Expression),
  )
}

pub fn requestgroup_action_condition_new(
  kind kind: r4bvaluesets.Actionconditionkind,
) -> RequestgroupActionCondition {
  RequestgroupActionCondition(
    expression: None,
    kind:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/RequestGroup#resource
pub type RequestgroupActionRelatedaction {
  RequestgroupActionRelatedaction(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    action_id: String,
    relationship: r4bvaluesets.Actionrelationshiptype,
    offset: Option(RequestgroupActionRelatedactionOffset),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/RequestGroup#resource
pub type RequestgroupActionRelatedactionOffset {
  RequestgroupActionRelatedactionOffsetDuration(offset: Duration)
  RequestgroupActionRelatedactionOffsetRange(offset: Range)
}

pub fn requestgroup_action_relatedaction_offset_to_json(
  elt: RequestgroupActionRelatedactionOffset,
) -> Json {
  case elt {
    RequestgroupActionRelatedactionOffsetDuration(v) -> duration_to_json(v)
    RequestgroupActionRelatedactionOffsetRange(v) -> range_to_json(v)
  }
}

pub fn requestgroup_action_relatedaction_offset_decoder() -> Decoder(
  RequestgroupActionRelatedactionOffset,
) {
  decode.one_of(
    decode.field("offsetDuration", duration_decoder(), decode.success)
      |> decode.map(RequestgroupActionRelatedactionOffsetDuration),
    [
      decode.field("offsetRange", range_decoder(), decode.success)
      |> decode.map(RequestgroupActionRelatedactionOffsetRange),
    ],
  )
}

pub fn requestgroup_action_relatedaction_new(
  relationship relationship: r4bvaluesets.Actionrelationshiptype,
  action_id action_id: String,
) -> RequestgroupActionRelatedaction {
  RequestgroupActionRelatedaction(
    offset: None,
    relationship:,
    action_id:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn requestgroup_action_relatedaction_to_json(
  requestgroup_action_relatedaction: RequestgroupActionRelatedaction,
) -> Json {
  let RequestgroupActionRelatedaction(
    offset:,
    relationship:,
    action_id:,
    modifier_extension:,
    extension:,
    id:,
  ) = requestgroup_action_relatedaction
  let fields = [
    #("relationship", r4bvaluesets.actionrelationshiptype_to_json(relationship)),
    #("actionId", json.string(action_id)),
  ]
  let fields = case offset {
    Some(v) -> [
      #(
        "offset"
          <> case v {
          RequestgroupActionRelatedactionOffsetDuration(_) -> "Duration"
          RequestgroupActionRelatedactionOffsetRange(_) -> "Range"
        },
        requestgroup_action_relatedaction_offset_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn requestgroup_action_relatedaction_decoder() -> Decoder(
  RequestgroupActionRelatedaction,
) {
  use offset <- decode.then(
    none_if_omitted(requestgroup_action_relatedaction_offset_decoder()),
  )
  use relationship <- decode.field(
    "relationship",
    r4bvaluesets.actionrelationshiptype_decoder(),
  )
  use action_id <- decode.field("actionId", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(RequestgroupActionRelatedaction(
    offset:,
    relationship:,
    action_id:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn requestgroup_action_condition_to_json(
  requestgroup_action_condition: RequestgroupActionCondition,
) -> Json {
  let RequestgroupActionCondition(
    expression:,
    kind:,
    modifier_extension:,
    extension:,
    id:,
  ) = requestgroup_action_condition
  let fields = [
    #("kind", r4bvaluesets.actionconditionkind_to_json(kind)),
  ]
  let fields = case expression {
    Some(v) -> [#("expression", expression_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn requestgroup_action_condition_decoder() -> Decoder(
  RequestgroupActionCondition,
) {
  use expression <- decode.optional_field(
    "expression",
    None,
    decode.optional(expression_decoder()),
  )
  use kind <- decode.field("kind", r4bvaluesets.actionconditionkind_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(RequestgroupActionCondition(
    expression:,
    kind:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn requestgroup_action_to_json(
  requestgroup_action: RequestgroupAction,
) -> Json {
  let RequestgroupAction(
    resource:,
    cardinality_behavior:,
    precheck_behavior:,
    required_behavior:,
    selection_behavior:,
    grouping_behavior:,
    type_:,
    participant:,
    timing:,
    related_action:,
    condition:,
    documentation:,
    code:,
    priority:,
    text_equivalent:,
    description:,
    title:,
    prefix:,
    modifier_extension:,
    extension:,
    id:,
  ) = requestgroup_action
  let fields = []
  let fields = case resource {
    Some(v) -> [#("resource", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case cardinality_behavior {
    Some(v) -> [
      #(
        "cardinalityBehavior",
        r4bvaluesets.actioncardinalitybehavior_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case precheck_behavior {
    Some(v) -> [
      #("precheckBehavior", r4bvaluesets.actionprecheckbehavior_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case required_behavior {
    Some(v) -> [
      #("requiredBehavior", r4bvaluesets.actionrequiredbehavior_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case selection_behavior {
    Some(v) -> [
      #("selectionBehavior", r4bvaluesets.actionselectionbehavior_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case grouping_behavior {
    Some(v) -> [
      #("groupingBehavior", r4bvaluesets.actiongroupingbehavior_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case participant {
    [] -> fields
    _ -> [
      #("participant", json.array(participant, reference_to_json)),
      ..fields
    ]
  }
  let fields = case timing {
    Some(v) -> [
      #(
        "timing"
          <> case v {
          RequestgroupActionTimingDatetime(_) -> "Datetime"
          RequestgroupActionTimingAge(_) -> "Age"
          RequestgroupActionTimingPeriod(_) -> "Period"
          RequestgroupActionTimingDuration(_) -> "Duration"
          RequestgroupActionTimingRange(_) -> "Range"
          RequestgroupActionTimingTiming(_) -> "Timing"
        },
        requestgroup_action_timing_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case related_action {
    [] -> fields
    _ -> [
      #(
        "relatedAction",
        json.array(related_action, requestgroup_action_relatedaction_to_json),
      ),
      ..fields
    ]
  }
  let fields = case condition {
    [] -> fields
    _ -> [
      #(
        "condition",
        json.array(condition, requestgroup_action_condition_to_json),
      ),
      ..fields
    ]
  }
  let fields = case documentation {
    [] -> fields
    _ -> [
      #("documentation", json.array(documentation, relatedartifact_to_json)),
      ..fields
    ]
  }
  let fields = case code {
    [] -> fields
    _ -> [#("code", json.array(code, codeableconcept_to_json)), ..fields]
  }
  let fields = case priority {
    Some(v) -> [
      #("priority", r4bvaluesets.requestpriority_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case text_equivalent {
    Some(v) -> [#("textEquivalent", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case title {
    Some(v) -> [#("title", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case prefix {
    Some(v) -> [#("prefix", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn requestgroup_action_decoder() -> Decoder(RequestgroupAction) {
  use resource <- decode.optional_field(
    "resource",
    None,
    decode.optional(reference_decoder()),
  )
  use cardinality_behavior <- decode.optional_field(
    "cardinalityBehavior",
    None,
    decode.optional(r4bvaluesets.actioncardinalitybehavior_decoder()),
  )
  use precheck_behavior <- decode.optional_field(
    "precheckBehavior",
    None,
    decode.optional(r4bvaluesets.actionprecheckbehavior_decoder()),
  )
  use required_behavior <- decode.optional_field(
    "requiredBehavior",
    None,
    decode.optional(r4bvaluesets.actionrequiredbehavior_decoder()),
  )
  use selection_behavior <- decode.optional_field(
    "selectionBehavior",
    None,
    decode.optional(r4bvaluesets.actionselectionbehavior_decoder()),
  )
  use grouping_behavior <- decode.optional_field(
    "groupingBehavior",
    None,
    decode.optional(r4bvaluesets.actiongroupingbehavior_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use participant <- decode.optional_field(
    "participant",
    [],
    decode.list(reference_decoder()),
  )
  use timing <- decode.then(
    none_if_omitted(requestgroup_action_timing_decoder()),
  )
  use related_action <- decode.optional_field(
    "relatedAction",
    [],
    decode.list(requestgroup_action_relatedaction_decoder()),
  )
  use condition <- decode.optional_field(
    "condition",
    [],
    decode.list(requestgroup_action_condition_decoder()),
  )
  use documentation <- decode.optional_field(
    "documentation",
    [],
    decode.list(relatedartifact_decoder()),
  )
  use code <- decode.optional_field(
    "code",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use priority <- decode.optional_field(
    "priority",
    None,
    decode.optional(r4bvaluesets.requestpriority_decoder()),
  )
  use text_equivalent <- decode.optional_field(
    "textEquivalent",
    None,
    decode.optional(decode.string),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use title <- decode.optional_field(
    "title",
    None,
    decode.optional(decode.string),
  )
  use prefix <- decode.optional_field(
    "prefix",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(RequestgroupAction(
    resource:,
    cardinality_behavior:,
    precheck_behavior:,
    required_behavior:,
    selection_behavior:,
    grouping_behavior:,
    type_:,
    participant:,
    timing:,
    related_action:,
    condition:,
    documentation:,
    code:,
    priority:,
    text_equivalent:,
    description:,
    title:,
    prefix:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn requestgroup_to_json(requestgroup: Requestgroup) -> Json {
  let Requestgroup(
    action:,
    note:,
    reason_reference:,
    reason_code:,
    author:,
    authored_on:,
    encounter:,
    subject:,
    code:,
    priority:,
    intent:,
    status:,
    group_identifier:,
    replaces:,
    based_on:,
    instantiates_uri:,
    instantiates_canonical:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = requestgroup
  let fields = [
    #("intent", r4bvaluesets.requestintent_to_json(intent)),
    #("status", r4bvaluesets.requeststatus_to_json(status)),
  ]
  let fields = case action {
    [] -> fields
    _ -> [
      #("action", json.array(action, requestgroup_action_to_json)),
      ..fields
    ]
  }
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case reason_reference {
    [] -> fields
    _ -> [
      #("reasonReference", json.array(reason_reference, reference_to_json)),
      ..fields
    ]
  }
  let fields = case reason_code {
    [] -> fields
    _ -> [
      #("reasonCode", json.array(reason_code, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case author {
    Some(v) -> [#("author", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case authored_on {
    Some(v) -> [#("authoredOn", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case encounter {
    Some(v) -> [#("encounter", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case subject {
    Some(v) -> [#("subject", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case code {
    Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case priority {
    Some(v) -> [
      #("priority", r4bvaluesets.requestpriority_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case group_identifier {
    Some(v) -> [#("groupIdentifier", identifier_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case replaces {
    [] -> fields
    _ -> [#("replaces", json.array(replaces, reference_to_json)), ..fields]
  }
  let fields = case based_on {
    [] -> fields
    _ -> [#("basedOn", json.array(based_on, reference_to_json)), ..fields]
  }
  let fields = case instantiates_uri {
    [] -> fields
    _ -> [
      #("instantiatesUri", json.array(instantiates_uri, json.string)),
      ..fields
    ]
  }
  let fields = case instantiates_canonical {
    [] -> fields
    _ -> [
      #(
        "instantiatesCanonical",
        json.array(instantiates_canonical, json.string),
      ),
      ..fields
    ]
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Requestgroup")), ..fields]
  json.object(fields)
}

pub fn requestgroup_decoder() -> Decoder(Requestgroup) {
  use action <- decode.optional_field(
    "action",
    [],
    decode.list(requestgroup_action_decoder()),
  )
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use reason_reference <- decode.optional_field(
    "reasonReference",
    [],
    decode.list(reference_decoder()),
  )
  use reason_code <- decode.optional_field(
    "reasonCode",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use author <- decode.optional_field(
    "author",
    None,
    decode.optional(reference_decoder()),
  )
  use authored_on <- decode.optional_field(
    "authoredOn",
    None,
    decode.optional(decode.string),
  )
  use encounter <- decode.optional_field(
    "encounter",
    None,
    decode.optional(reference_decoder()),
  )
  use subject <- decode.optional_field(
    "subject",
    None,
    decode.optional(reference_decoder()),
  )
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use priority <- decode.optional_field(
    "priority",
    None,
    decode.optional(r4bvaluesets.requestpriority_decoder()),
  )
  use intent <- decode.field("intent", r4bvaluesets.requestintent_decoder())
  use status <- decode.field("status", r4bvaluesets.requeststatus_decoder())
  use group_identifier <- decode.optional_field(
    "groupIdentifier",
    None,
    decode.optional(identifier_decoder()),
  )
  use replaces <- decode.optional_field(
    "replaces",
    [],
    decode.list(reference_decoder()),
  )
  use based_on <- decode.optional_field(
    "basedOn",
    [],
    decode.list(reference_decoder()),
  )
  use instantiates_uri <- decode.optional_field(
    "instantiatesUri",
    [],
    decode.list(decode.string),
  )
  use instantiates_canonical <- decode.optional_field(
    "instantiatesCanonical",
    [],
    decode.list(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Requestgroup",
    decode.failure(requestgroup_new(intent:, status:), "resourceType"),
  )
  decode.success(Requestgroup(
    action:,
    note:,
    reason_reference:,
    reason_code:,
    author:,
    authored_on:,
    encounter:,
    subject:,
    code:,
    priority:,
    intent:,
    status:,
    group_identifier:,
    replaces:,
    based_on:,
    instantiates_uri:,
    instantiates_canonical:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/ResearchDefinition#resource
pub type Researchdefinition {
  Researchdefinition(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    url: Option(String),
    identifier: List(Identifier),
    version: Option(String),
    name: Option(String),
    title: Option(String),
    short_title: Option(String),
    subtitle: Option(String),
    status: r4bvaluesets.Publicationstatus,
    experimental: Option(Bool),
    subject: Option(ResearchdefinitionSubject),
    date: Option(String),
    publisher: Option(String),
    contact: List(Contactdetail),
    description: Option(String),
    comment: List(String),
    use_context: List(Usagecontext),
    jurisdiction: List(Codeableconcept),
    purpose: Option(String),
    usage: Option(String),
    copyright: Option(String),
    approval_date: Option(String),
    last_review_date: Option(String),
    effective_period: Option(Period),
    topic: List(Codeableconcept),
    author: List(Contactdetail),
    editor: List(Contactdetail),
    reviewer: List(Contactdetail),
    endorser: List(Contactdetail),
    related_artifact: List(Relatedartifact),
    library: List(String),
    population: Reference,
    exposure: Option(Reference),
    exposure_alternative: Option(Reference),
    outcome: Option(Reference),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ResearchDefinition#resource
pub type ResearchdefinitionSubject {
  ResearchdefinitionSubjectCodeableconcept(subject: Codeableconcept)
  ResearchdefinitionSubjectReference(subject: Reference)
}

pub fn researchdefinition_subject_to_json(
  elt: ResearchdefinitionSubject,
) -> Json {
  case elt {
    ResearchdefinitionSubjectCodeableconcept(v) -> codeableconcept_to_json(v)
    ResearchdefinitionSubjectReference(v) -> reference_to_json(v)
  }
}

pub fn researchdefinition_subject_decoder() -> Decoder(
  ResearchdefinitionSubject,
) {
  decode.one_of(
    decode.field(
      "subjectCodeableConcept",
      codeableconcept_decoder(),
      decode.success,
    )
      |> decode.map(ResearchdefinitionSubjectCodeableconcept),
    [
      decode.field("subjectReference", reference_decoder(), decode.success)
      |> decode.map(ResearchdefinitionSubjectReference),
    ],
  )
}

pub fn researchdefinition_new(
  population population: Reference,
  status status: r4bvaluesets.Publicationstatus,
) -> Researchdefinition {
  Researchdefinition(
    outcome: None,
    exposure_alternative: None,
    exposure: None,
    population:,
    library: [],
    related_artifact: [],
    endorser: [],
    reviewer: [],
    editor: [],
    author: [],
    topic: [],
    effective_period: None,
    last_review_date: None,
    approval_date: None,
    copyright: None,
    usage: None,
    purpose: None,
    jurisdiction: [],
    use_context: [],
    comment: [],
    description: None,
    contact: [],
    publisher: None,
    date: None,
    subject: None,
    experimental: None,
    status:,
    subtitle: None,
    short_title: None,
    title: None,
    name: None,
    version: None,
    identifier: [],
    url: None,
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

pub fn researchdefinition_to_json(
  researchdefinition: Researchdefinition,
) -> Json {
  let Researchdefinition(
    outcome:,
    exposure_alternative:,
    exposure:,
    population:,
    library:,
    related_artifact:,
    endorser:,
    reviewer:,
    editor:,
    author:,
    topic:,
    effective_period:,
    last_review_date:,
    approval_date:,
    copyright:,
    usage:,
    purpose:,
    jurisdiction:,
    use_context:,
    comment:,
    description:,
    contact:,
    publisher:,
    date:,
    subject:,
    experimental:,
    status:,
    subtitle:,
    short_title:,
    title:,
    name:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = researchdefinition
  let fields = [
    #("population", reference_to_json(population)),
    #("status", r4bvaluesets.publicationstatus_to_json(status)),
  ]
  let fields = case outcome {
    Some(v) -> [#("outcome", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case exposure_alternative {
    Some(v) -> [#("exposureAlternative", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case exposure {
    Some(v) -> [#("exposure", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case library {
    [] -> fields
    _ -> [#("library", json.array(library, json.string)), ..fields]
  }
  let fields = case related_artifact {
    [] -> fields
    _ -> [
      #(
        "relatedArtifact",
        json.array(related_artifact, relatedartifact_to_json),
      ),
      ..fields
    ]
  }
  let fields = case endorser {
    [] -> fields
    _ -> [#("endorser", json.array(endorser, contactdetail_to_json)), ..fields]
  }
  let fields = case reviewer {
    [] -> fields
    _ -> [#("reviewer", json.array(reviewer, contactdetail_to_json)), ..fields]
  }
  let fields = case editor {
    [] -> fields
    _ -> [#("editor", json.array(editor, contactdetail_to_json)), ..fields]
  }
  let fields = case author {
    [] -> fields
    _ -> [#("author", json.array(author, contactdetail_to_json)), ..fields]
  }
  let fields = case topic {
    [] -> fields
    _ -> [#("topic", json.array(topic, codeableconcept_to_json)), ..fields]
  }
  let fields = case effective_period {
    Some(v) -> [#("effectivePeriod", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case last_review_date {
    Some(v) -> [#("lastReviewDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case approval_date {
    Some(v) -> [#("approvalDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case copyright {
    Some(v) -> [#("copyright", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case usage {
    Some(v) -> [#("usage", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case purpose {
    Some(v) -> [#("purpose", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case jurisdiction {
    [] -> fields
    _ -> [
      #("jurisdiction", json.array(jurisdiction, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case use_context {
    [] -> fields
    _ -> [
      #("useContext", json.array(use_context, usagecontext_to_json)),
      ..fields
    ]
  }
  let fields = case comment {
    [] -> fields
    _ -> [#("comment", json.array(comment, json.string)), ..fields]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case contact {
    [] -> fields
    _ -> [#("contact", json.array(contact, contactdetail_to_json)), ..fields]
  }
  let fields = case publisher {
    Some(v) -> [#("publisher", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case date {
    Some(v) -> [#("date", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case subject {
    Some(v) -> [
      #(
        "subject"
          <> case v {
          ResearchdefinitionSubjectCodeableconcept(_) -> "Codeableconcept"
          ResearchdefinitionSubjectReference(_) -> "Reference"
        },
        researchdefinition_subject_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case experimental {
    Some(v) -> [#("experimental", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case subtitle {
    Some(v) -> [#("subtitle", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case short_title {
    Some(v) -> [#("shortTitle", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case title {
    Some(v) -> [#("title", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case version {
    Some(v) -> [#("version", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case url {
    Some(v) -> [#("url", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Researchdefinition")), ..fields]
  json.object(fields)
}

pub fn researchdefinition_decoder() -> Decoder(Researchdefinition) {
  use outcome <- decode.optional_field(
    "outcome",
    None,
    decode.optional(reference_decoder()),
  )
  use exposure_alternative <- decode.optional_field(
    "exposureAlternative",
    None,
    decode.optional(reference_decoder()),
  )
  use exposure <- decode.optional_field(
    "exposure",
    None,
    decode.optional(reference_decoder()),
  )
  use population <- decode.field("population", reference_decoder())
  use library <- decode.optional_field(
    "library",
    [],
    decode.list(decode.string),
  )
  use related_artifact <- decode.optional_field(
    "relatedArtifact",
    [],
    decode.list(relatedartifact_decoder()),
  )
  use endorser <- decode.optional_field(
    "endorser",
    [],
    decode.list(contactdetail_decoder()),
  )
  use reviewer <- decode.optional_field(
    "reviewer",
    [],
    decode.list(contactdetail_decoder()),
  )
  use editor <- decode.optional_field(
    "editor",
    [],
    decode.list(contactdetail_decoder()),
  )
  use author <- decode.optional_field(
    "author",
    [],
    decode.list(contactdetail_decoder()),
  )
  use topic <- decode.optional_field(
    "topic",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use effective_period <- decode.optional_field(
    "effectivePeriod",
    None,
    decode.optional(period_decoder()),
  )
  use last_review_date <- decode.optional_field(
    "lastReviewDate",
    None,
    decode.optional(decode.string),
  )
  use approval_date <- decode.optional_field(
    "approvalDate",
    None,
    decode.optional(decode.string),
  )
  use copyright <- decode.optional_field(
    "copyright",
    None,
    decode.optional(decode.string),
  )
  use usage <- decode.optional_field(
    "usage",
    None,
    decode.optional(decode.string),
  )
  use purpose <- decode.optional_field(
    "purpose",
    None,
    decode.optional(decode.string),
  )
  use jurisdiction <- decode.optional_field(
    "jurisdiction",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use use_context <- decode.optional_field(
    "useContext",
    [],
    decode.list(usagecontext_decoder()),
  )
  use comment <- decode.optional_field(
    "comment",
    [],
    decode.list(decode.string),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use contact <- decode.optional_field(
    "contact",
    [],
    decode.list(contactdetail_decoder()),
  )
  use publisher <- decode.optional_field(
    "publisher",
    None,
    decode.optional(decode.string),
  )
  use date <- decode.optional_field(
    "date",
    None,
    decode.optional(decode.string),
  )
  use subject <- decode.then(
    none_if_omitted(researchdefinition_subject_decoder()),
  )
  use experimental <- decode.optional_field(
    "experimental",
    None,
    decode.optional(decode.bool),
  )
  use status <- decode.field("status", r4bvaluesets.publicationstatus_decoder())
  use subtitle <- decode.optional_field(
    "subtitle",
    None,
    decode.optional(decode.string),
  )
  use short_title <- decode.optional_field(
    "shortTitle",
    None,
    decode.optional(decode.string),
  )
  use title <- decode.optional_field(
    "title",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use version <- decode.optional_field(
    "version",
    None,
    decode.optional(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use url <- decode.optional_field("url", None, decode.optional(decode.string))
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Researchdefinition",
    decode.failure(researchdefinition_new(population:, status:), "resourceType"),
  )
  decode.success(Researchdefinition(
    outcome:,
    exposure_alternative:,
    exposure:,
    population:,
    library:,
    related_artifact:,
    endorser:,
    reviewer:,
    editor:,
    author:,
    topic:,
    effective_period:,
    last_review_date:,
    approval_date:,
    copyright:,
    usage:,
    purpose:,
    jurisdiction:,
    use_context:,
    comment:,
    description:,
    contact:,
    publisher:,
    date:,
    subject:,
    experimental:,
    status:,
    subtitle:,
    short_title:,
    title:,
    name:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/ResearchElementDefinition#resource
pub type Researchelementdefinition {
  Researchelementdefinition(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    url: Option(String),
    identifier: List(Identifier),
    version: Option(String),
    name: Option(String),
    title: Option(String),
    short_title: Option(String),
    subtitle: Option(String),
    status: r4bvaluesets.Publicationstatus,
    experimental: Option(Bool),
    subject: Option(ResearchelementdefinitionSubject),
    date: Option(String),
    publisher: Option(String),
    contact: List(Contactdetail),
    description: Option(String),
    comment: List(String),
    use_context: List(Usagecontext),
    jurisdiction: List(Codeableconcept),
    purpose: Option(String),
    usage: Option(String),
    copyright: Option(String),
    approval_date: Option(String),
    last_review_date: Option(String),
    effective_period: Option(Period),
    topic: List(Codeableconcept),
    author: List(Contactdetail),
    editor: List(Contactdetail),
    reviewer: List(Contactdetail),
    endorser: List(Contactdetail),
    related_artifact: List(Relatedartifact),
    library: List(String),
    type_: r4bvaluesets.Researchelementtype,
    variable_type: Option(r4bvaluesets.Variabletype),
    characteristic: List(ResearchelementdefinitionCharacteristic),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ResearchElementDefinition#resource
pub type ResearchelementdefinitionSubject {
  ResearchelementdefinitionSubjectCodeableconcept(subject: Codeableconcept)
  ResearchelementdefinitionSubjectReference(subject: Reference)
}

pub fn researchelementdefinition_subject_to_json(
  elt: ResearchelementdefinitionSubject,
) -> Json {
  case elt {
    ResearchelementdefinitionSubjectCodeableconcept(v) ->
      codeableconcept_to_json(v)
    ResearchelementdefinitionSubjectReference(v) -> reference_to_json(v)
  }
}

pub fn researchelementdefinition_subject_decoder() -> Decoder(
  ResearchelementdefinitionSubject,
) {
  decode.one_of(
    decode.field(
      "subjectCodeableConcept",
      codeableconcept_decoder(),
      decode.success,
    )
      |> decode.map(ResearchelementdefinitionSubjectCodeableconcept),
    [
      decode.field("subjectReference", reference_decoder(), decode.success)
      |> decode.map(ResearchelementdefinitionSubjectReference),
    ],
  )
}

pub fn researchelementdefinition_new(
  type_ type_: r4bvaluesets.Researchelementtype,
  status status: r4bvaluesets.Publicationstatus,
) -> Researchelementdefinition {
  Researchelementdefinition(
    characteristic: [],
    variable_type: None,
    type_:,
    library: [],
    related_artifact: [],
    endorser: [],
    reviewer: [],
    editor: [],
    author: [],
    topic: [],
    effective_period: None,
    last_review_date: None,
    approval_date: None,
    copyright: None,
    usage: None,
    purpose: None,
    jurisdiction: [],
    use_context: [],
    comment: [],
    description: None,
    contact: [],
    publisher: None,
    date: None,
    subject: None,
    experimental: None,
    status:,
    subtitle: None,
    short_title: None,
    title: None,
    name: None,
    version: None,
    identifier: [],
    url: None,
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ResearchElementDefinition#resource
pub type ResearchelementdefinitionCharacteristic {
  ResearchelementdefinitionCharacteristic(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    definition: ResearchelementdefinitionCharacteristicDefinition,
    usage_context: List(Usagecontext),
    exclude: Option(Bool),
    unit_of_measure: Option(Codeableconcept),
    study_effective_description: Option(String),
    study_effective: Option(
      ResearchelementdefinitionCharacteristicStudyeffective,
    ),
    study_effective_time_from_start: Option(Duration),
    study_effective_group_measure: Option(r4bvaluesets.Groupmeasure),
    participant_effective_description: Option(String),
    participant_effective: Option(
      ResearchelementdefinitionCharacteristicParticipanteffective,
    ),
    participant_effective_time_from_start: Option(Duration),
    participant_effective_group_measure: Option(r4bvaluesets.Groupmeasure),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ResearchElementDefinition#resource
pub type ResearchelementdefinitionCharacteristicDefinition {
  ResearchelementdefinitionCharacteristicDefinitionCodeableconcept(
    definition: Codeableconcept,
  )
  ResearchelementdefinitionCharacteristicDefinitionCanonical(definition: String)
  ResearchelementdefinitionCharacteristicDefinitionExpression(
    definition: Expression,
  )
  ResearchelementdefinitionCharacteristicDefinitionDatarequirement(
    definition: Datarequirement,
  )
}

pub fn researchelementdefinition_characteristic_definition_to_json(
  elt: ResearchelementdefinitionCharacteristicDefinition,
) -> Json {
  case elt {
    ResearchelementdefinitionCharacteristicDefinitionCodeableconcept(v) ->
      codeableconcept_to_json(v)
    ResearchelementdefinitionCharacteristicDefinitionCanonical(v) ->
      json.string(v)
    ResearchelementdefinitionCharacteristicDefinitionExpression(v) ->
      expression_to_json(v)
    ResearchelementdefinitionCharacteristicDefinitionDatarequirement(v) ->
      datarequirement_to_json(v)
  }
}

pub fn researchelementdefinition_characteristic_definition_decoder() -> Decoder(
  ResearchelementdefinitionCharacteristicDefinition,
) {
  decode.one_of(
    decode.field(
      "definitionCodeableConcept",
      codeableconcept_decoder(),
      decode.success,
    )
      |> decode.map(
        ResearchelementdefinitionCharacteristicDefinitionCodeableconcept,
      ),
    [
      decode.field("definitionCanonical", decode.string, decode.success)
        |> decode.map(
          ResearchelementdefinitionCharacteristicDefinitionCanonical,
        ),
      decode.field("definitionExpression", expression_decoder(), decode.success)
        |> decode.map(
          ResearchelementdefinitionCharacteristicDefinitionExpression,
        ),
      decode.field(
        "definitionDataRequirement",
        datarequirement_decoder(),
        decode.success,
      )
        |> decode.map(
          ResearchelementdefinitionCharacteristicDefinitionDatarequirement,
        ),
    ],
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ResearchElementDefinition#resource
pub type ResearchelementdefinitionCharacteristicStudyeffective {
  ResearchelementdefinitionCharacteristicStudyeffectiveDatetime(
    study_effective: String,
  )
  ResearchelementdefinitionCharacteristicStudyeffectivePeriod(
    study_effective: Period,
  )
  ResearchelementdefinitionCharacteristicStudyeffectiveDuration(
    study_effective: Duration,
  )
  ResearchelementdefinitionCharacteristicStudyeffectiveTiming(
    study_effective: Timing,
  )
}

pub fn researchelementdefinition_characteristic_studyeffective_to_json(
  elt: ResearchelementdefinitionCharacteristicStudyeffective,
) -> Json {
  case elt {
    ResearchelementdefinitionCharacteristicStudyeffectiveDatetime(v) ->
      json.string(v)
    ResearchelementdefinitionCharacteristicStudyeffectivePeriod(v) ->
      period_to_json(v)
    ResearchelementdefinitionCharacteristicStudyeffectiveDuration(v) ->
      duration_to_json(v)
    ResearchelementdefinitionCharacteristicStudyeffectiveTiming(v) ->
      timing_to_json(v)
  }
}

pub fn researchelementdefinition_characteristic_studyeffective_decoder() -> Decoder(
  ResearchelementdefinitionCharacteristicStudyeffective,
) {
  decode.one_of(
    decode.field("studyEffectiveDateTime", decode.string, decode.success)
      |> decode.map(
        ResearchelementdefinitionCharacteristicStudyeffectiveDatetime,
      ),
    [
      decode.field("studyEffectivePeriod", period_decoder(), decode.success)
        |> decode.map(
          ResearchelementdefinitionCharacteristicStudyeffectivePeriod,
        ),
      decode.field("studyEffectiveDuration", duration_decoder(), decode.success)
        |> decode.map(
          ResearchelementdefinitionCharacteristicStudyeffectiveDuration,
        ),
      decode.field("studyEffectiveTiming", timing_decoder(), decode.success)
        |> decode.map(
          ResearchelementdefinitionCharacteristicStudyeffectiveTiming,
        ),
    ],
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ResearchElementDefinition#resource
pub type ResearchelementdefinitionCharacteristicParticipanteffective {
  ResearchelementdefinitionCharacteristicParticipanteffectiveDatetime(
    participant_effective: String,
  )
  ResearchelementdefinitionCharacteristicParticipanteffectivePeriod(
    participant_effective: Period,
  )
  ResearchelementdefinitionCharacteristicParticipanteffectiveDuration(
    participant_effective: Duration,
  )
  ResearchelementdefinitionCharacteristicParticipanteffectiveTiming(
    participant_effective: Timing,
  )
}

pub fn researchelementdefinition_characteristic_participanteffective_to_json(
  elt: ResearchelementdefinitionCharacteristicParticipanteffective,
) -> Json {
  case elt {
    ResearchelementdefinitionCharacteristicParticipanteffectiveDatetime(v) ->
      json.string(v)
    ResearchelementdefinitionCharacteristicParticipanteffectivePeriod(v) ->
      period_to_json(v)
    ResearchelementdefinitionCharacteristicParticipanteffectiveDuration(v) ->
      duration_to_json(v)
    ResearchelementdefinitionCharacteristicParticipanteffectiveTiming(v) ->
      timing_to_json(v)
  }
}

pub fn researchelementdefinition_characteristic_participanteffective_decoder() -> Decoder(
  ResearchelementdefinitionCharacteristicParticipanteffective,
) {
  decode.one_of(
    decode.field("participantEffectiveDateTime", decode.string, decode.success)
      |> decode.map(
        ResearchelementdefinitionCharacteristicParticipanteffectiveDatetime,
      ),
    [
      decode.field(
        "participantEffectivePeriod",
        period_decoder(),
        decode.success,
      )
        |> decode.map(
          ResearchelementdefinitionCharacteristicParticipanteffectivePeriod,
        ),
      decode.field(
        "participantEffectiveDuration",
        duration_decoder(),
        decode.success,
      )
        |> decode.map(
          ResearchelementdefinitionCharacteristicParticipanteffectiveDuration,
        ),
      decode.field(
        "participantEffectiveTiming",
        timing_decoder(),
        decode.success,
      )
        |> decode.map(
          ResearchelementdefinitionCharacteristicParticipanteffectiveTiming,
        ),
    ],
  )
}

pub fn researchelementdefinition_characteristic_new(
  definition definition: ResearchelementdefinitionCharacteristicDefinition,
) -> ResearchelementdefinitionCharacteristic {
  ResearchelementdefinitionCharacteristic(
    participant_effective_group_measure: None,
    participant_effective_time_from_start: None,
    participant_effective: None,
    participant_effective_description: None,
    study_effective_group_measure: None,
    study_effective_time_from_start: None,
    study_effective: None,
    study_effective_description: None,
    unit_of_measure: None,
    exclude: None,
    usage_context: [],
    definition:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn researchelementdefinition_characteristic_to_json(
  researchelementdefinition_characteristic: ResearchelementdefinitionCharacteristic,
) -> Json {
  let ResearchelementdefinitionCharacteristic(
    participant_effective_group_measure:,
    participant_effective_time_from_start:,
    participant_effective:,
    participant_effective_description:,
    study_effective_group_measure:,
    study_effective_time_from_start:,
    study_effective:,
    study_effective_description:,
    unit_of_measure:,
    exclude:,
    usage_context:,
    definition:,
    modifier_extension:,
    extension:,
    id:,
  ) = researchelementdefinition_characteristic
  let fields = [
    #(
      "definition",
      researchelementdefinition_characteristic_definition_to_json(definition),
    ),
  ]
  let fields = case participant_effective_group_measure {
    Some(v) -> [
      #(
        "participantEffectiveGroupMeasure",
        r4bvaluesets.groupmeasure_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case participant_effective_time_from_start {
    Some(v) -> [
      #("participantEffectiveTimeFromStart", duration_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case participant_effective {
    Some(v) -> [
      #(
        "participantEffective"
          <> case v {
          ResearchelementdefinitionCharacteristicParticipanteffectiveDatetime(_) ->
            "Datetime"
          ResearchelementdefinitionCharacteristicParticipanteffectivePeriod(_) ->
            "Period"
          ResearchelementdefinitionCharacteristicParticipanteffectiveDuration(_) ->
            "Duration"
          ResearchelementdefinitionCharacteristicParticipanteffectiveTiming(_) ->
            "Timing"
        },
        researchelementdefinition_characteristic_participanteffective_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case participant_effective_description {
    Some(v) -> [#("participantEffectiveDescription", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case study_effective_group_measure {
    Some(v) -> [
      #("studyEffectiveGroupMeasure", r4bvaluesets.groupmeasure_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case study_effective_time_from_start {
    Some(v) -> [#("studyEffectiveTimeFromStart", duration_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case study_effective {
    Some(v) -> [
      #(
        "studyEffective"
          <> case v {
          ResearchelementdefinitionCharacteristicStudyeffectiveDatetime(_) ->
            "Datetime"
          ResearchelementdefinitionCharacteristicStudyeffectivePeriod(_) ->
            "Period"
          ResearchelementdefinitionCharacteristicStudyeffectiveDuration(_) ->
            "Duration"
          ResearchelementdefinitionCharacteristicStudyeffectiveTiming(_) ->
            "Timing"
        },
        researchelementdefinition_characteristic_studyeffective_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case study_effective_description {
    Some(v) -> [#("studyEffectiveDescription", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case unit_of_measure {
    Some(v) -> [#("unitOfMeasure", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case exclude {
    Some(v) -> [#("exclude", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case usage_context {
    [] -> fields
    _ -> [
      #("usageContext", json.array(usage_context, usagecontext_to_json)),
      ..fields
    ]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn researchelementdefinition_characteristic_decoder() -> Decoder(
  ResearchelementdefinitionCharacteristic,
) {
  use participant_effective_group_measure <- decode.optional_field(
    "participantEffectiveGroupMeasure",
    None,
    decode.optional(r4bvaluesets.groupmeasure_decoder()),
  )
  use participant_effective_time_from_start <- decode.optional_field(
    "participantEffectiveTimeFromStart",
    None,
    decode.optional(duration_decoder()),
  )
  use participant_effective <- decode.then(
    none_if_omitted(
      researchelementdefinition_characteristic_participanteffective_decoder(),
    ),
  )
  use participant_effective_description <- decode.optional_field(
    "participantEffectiveDescription",
    None,
    decode.optional(decode.string),
  )
  use study_effective_group_measure <- decode.optional_field(
    "studyEffectiveGroupMeasure",
    None,
    decode.optional(r4bvaluesets.groupmeasure_decoder()),
  )
  use study_effective_time_from_start <- decode.optional_field(
    "studyEffectiveTimeFromStart",
    None,
    decode.optional(duration_decoder()),
  )
  use study_effective <- decode.then(
    none_if_omitted(
      researchelementdefinition_characteristic_studyeffective_decoder(),
    ),
  )
  use study_effective_description <- decode.optional_field(
    "studyEffectiveDescription",
    None,
    decode.optional(decode.string),
  )
  use unit_of_measure <- decode.optional_field(
    "unitOfMeasure",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use exclude <- decode.optional_field(
    "exclude",
    None,
    decode.optional(decode.bool),
  )
  use usage_context <- decode.optional_field(
    "usageContext",
    [],
    decode.list(usagecontext_decoder()),
  )
  use definition <- decode.then(
    researchelementdefinition_characteristic_definition_decoder(),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ResearchelementdefinitionCharacteristic(
    participant_effective_group_measure:,
    participant_effective_time_from_start:,
    participant_effective:,
    participant_effective_description:,
    study_effective_group_measure:,
    study_effective_time_from_start:,
    study_effective:,
    study_effective_description:,
    unit_of_measure:,
    exclude:,
    usage_context:,
    definition:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn researchelementdefinition_to_json(
  researchelementdefinition: Researchelementdefinition,
) -> Json {
  let Researchelementdefinition(
    characteristic:,
    variable_type:,
    type_:,
    library:,
    related_artifact:,
    endorser:,
    reviewer:,
    editor:,
    author:,
    topic:,
    effective_period:,
    last_review_date:,
    approval_date:,
    copyright:,
    usage:,
    purpose:,
    jurisdiction:,
    use_context:,
    comment:,
    description:,
    contact:,
    publisher:,
    date:,
    subject:,
    experimental:,
    status:,
    subtitle:,
    short_title:,
    title:,
    name:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = researchelementdefinition
  let fields = [
    #("type", r4bvaluesets.researchelementtype_to_json(type_)),
    #("status", r4bvaluesets.publicationstatus_to_json(status)),
  ]
  let fields = case characteristic {
    [] -> fields
    _ -> [
      #(
        "characteristic",
        json.array(
          characteristic,
          researchelementdefinition_characteristic_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case variable_type {
    Some(v) -> [
      #("variableType", r4bvaluesets.variabletype_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case library {
    [] -> fields
    _ -> [#("library", json.array(library, json.string)), ..fields]
  }
  let fields = case related_artifact {
    [] -> fields
    _ -> [
      #(
        "relatedArtifact",
        json.array(related_artifact, relatedartifact_to_json),
      ),
      ..fields
    ]
  }
  let fields = case endorser {
    [] -> fields
    _ -> [#("endorser", json.array(endorser, contactdetail_to_json)), ..fields]
  }
  let fields = case reviewer {
    [] -> fields
    _ -> [#("reviewer", json.array(reviewer, contactdetail_to_json)), ..fields]
  }
  let fields = case editor {
    [] -> fields
    _ -> [#("editor", json.array(editor, contactdetail_to_json)), ..fields]
  }
  let fields = case author {
    [] -> fields
    _ -> [#("author", json.array(author, contactdetail_to_json)), ..fields]
  }
  let fields = case topic {
    [] -> fields
    _ -> [#("topic", json.array(topic, codeableconcept_to_json)), ..fields]
  }
  let fields = case effective_period {
    Some(v) -> [#("effectivePeriod", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case last_review_date {
    Some(v) -> [#("lastReviewDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case approval_date {
    Some(v) -> [#("approvalDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case copyright {
    Some(v) -> [#("copyright", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case usage {
    Some(v) -> [#("usage", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case purpose {
    Some(v) -> [#("purpose", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case jurisdiction {
    [] -> fields
    _ -> [
      #("jurisdiction", json.array(jurisdiction, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case use_context {
    [] -> fields
    _ -> [
      #("useContext", json.array(use_context, usagecontext_to_json)),
      ..fields
    ]
  }
  let fields = case comment {
    [] -> fields
    _ -> [#("comment", json.array(comment, json.string)), ..fields]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case contact {
    [] -> fields
    _ -> [#("contact", json.array(contact, contactdetail_to_json)), ..fields]
  }
  let fields = case publisher {
    Some(v) -> [#("publisher", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case date {
    Some(v) -> [#("date", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case subject {
    Some(v) -> [
      #(
        "subject"
          <> case v {
          ResearchelementdefinitionSubjectCodeableconcept(_) ->
            "Codeableconcept"
          ResearchelementdefinitionSubjectReference(_) -> "Reference"
        },
        researchelementdefinition_subject_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case experimental {
    Some(v) -> [#("experimental", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case subtitle {
    Some(v) -> [#("subtitle", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case short_title {
    Some(v) -> [#("shortTitle", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case title {
    Some(v) -> [#("title", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case version {
    Some(v) -> [#("version", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case url {
    Some(v) -> [#("url", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [
    #("resourceType", json.string("Researchelementdefinition")),
    ..fields
  ]
  json.object(fields)
}

pub fn researchelementdefinition_decoder() -> Decoder(Researchelementdefinition) {
  use characteristic <- decode.optional_field(
    "characteristic",
    [],
    decode.list(researchelementdefinition_characteristic_decoder()),
  )
  use variable_type <- decode.optional_field(
    "variableType",
    None,
    decode.optional(r4bvaluesets.variabletype_decoder()),
  )
  use type_ <- decode.field("type", r4bvaluesets.researchelementtype_decoder())
  use library <- decode.optional_field(
    "library",
    [],
    decode.list(decode.string),
  )
  use related_artifact <- decode.optional_field(
    "relatedArtifact",
    [],
    decode.list(relatedartifact_decoder()),
  )
  use endorser <- decode.optional_field(
    "endorser",
    [],
    decode.list(contactdetail_decoder()),
  )
  use reviewer <- decode.optional_field(
    "reviewer",
    [],
    decode.list(contactdetail_decoder()),
  )
  use editor <- decode.optional_field(
    "editor",
    [],
    decode.list(contactdetail_decoder()),
  )
  use author <- decode.optional_field(
    "author",
    [],
    decode.list(contactdetail_decoder()),
  )
  use topic <- decode.optional_field(
    "topic",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use effective_period <- decode.optional_field(
    "effectivePeriod",
    None,
    decode.optional(period_decoder()),
  )
  use last_review_date <- decode.optional_field(
    "lastReviewDate",
    None,
    decode.optional(decode.string),
  )
  use approval_date <- decode.optional_field(
    "approvalDate",
    None,
    decode.optional(decode.string),
  )
  use copyright <- decode.optional_field(
    "copyright",
    None,
    decode.optional(decode.string),
  )
  use usage <- decode.optional_field(
    "usage",
    None,
    decode.optional(decode.string),
  )
  use purpose <- decode.optional_field(
    "purpose",
    None,
    decode.optional(decode.string),
  )
  use jurisdiction <- decode.optional_field(
    "jurisdiction",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use use_context <- decode.optional_field(
    "useContext",
    [],
    decode.list(usagecontext_decoder()),
  )
  use comment <- decode.optional_field(
    "comment",
    [],
    decode.list(decode.string),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use contact <- decode.optional_field(
    "contact",
    [],
    decode.list(contactdetail_decoder()),
  )
  use publisher <- decode.optional_field(
    "publisher",
    None,
    decode.optional(decode.string),
  )
  use date <- decode.optional_field(
    "date",
    None,
    decode.optional(decode.string),
  )
  use subject <- decode.then(
    none_if_omitted(researchelementdefinition_subject_decoder()),
  )
  use experimental <- decode.optional_field(
    "experimental",
    None,
    decode.optional(decode.bool),
  )
  use status <- decode.field("status", r4bvaluesets.publicationstatus_decoder())
  use subtitle <- decode.optional_field(
    "subtitle",
    None,
    decode.optional(decode.string),
  )
  use short_title <- decode.optional_field(
    "shortTitle",
    None,
    decode.optional(decode.string),
  )
  use title <- decode.optional_field(
    "title",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use version <- decode.optional_field(
    "version",
    None,
    decode.optional(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use url <- decode.optional_field("url", None, decode.optional(decode.string))
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Researchelementdefinition",
    decode.failure(
      researchelementdefinition_new(type_:, status:),
      "resourceType",
    ),
  )
  decode.success(Researchelementdefinition(
    characteristic:,
    variable_type:,
    type_:,
    library:,
    related_artifact:,
    endorser:,
    reviewer:,
    editor:,
    author:,
    topic:,
    effective_period:,
    last_review_date:,
    approval_date:,
    copyright:,
    usage:,
    purpose:,
    jurisdiction:,
    use_context:,
    comment:,
    description:,
    contact:,
    publisher:,
    date:,
    subject:,
    experimental:,
    status:,
    subtitle:,
    short_title:,
    title:,
    name:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/ResearchStudy#resource
pub type Researchstudy {
  Researchstudy(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    title: Option(String),
    protocol: List(Reference),
    part_of: List(Reference),
    status: r4bvaluesets.Researchstudystatus,
    primary_purpose_type: Option(Codeableconcept),
    phase: Option(Codeableconcept),
    category: List(Codeableconcept),
    focus: List(Codeableconcept),
    condition: List(Codeableconcept),
    contact: List(Contactdetail),
    related_artifact: List(Relatedartifact),
    keyword: List(Codeableconcept),
    location: List(Codeableconcept),
    description: Option(String),
    enrollment: List(Reference),
    period: Option(Period),
    sponsor: Option(Reference),
    principal_investigator: Option(Reference),
    site: List(Reference),
    reason_stopped: Option(Codeableconcept),
    note: List(Annotation),
    arm: List(ResearchstudyArm),
    objective: List(ResearchstudyObjective),
  )
}

pub fn researchstudy_new(
  status status: r4bvaluesets.Researchstudystatus,
) -> Researchstudy {
  Researchstudy(
    objective: [],
    arm: [],
    note: [],
    reason_stopped: None,
    site: [],
    principal_investigator: None,
    sponsor: None,
    period: None,
    enrollment: [],
    description: None,
    location: [],
    keyword: [],
    related_artifact: [],
    contact: [],
    condition: [],
    focus: [],
    category: [],
    phase: None,
    primary_purpose_type: None,
    status:,
    part_of: [],
    protocol: [],
    title: None,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ResearchStudy#resource
pub type ResearchstudyArm {
  ResearchstudyArm(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    name: String,
    type_: Option(Codeableconcept),
    description: Option(String),
  )
}

pub fn researchstudy_arm_new(name name: String) -> ResearchstudyArm {
  ResearchstudyArm(
    description: None,
    type_: None,
    name:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ResearchStudy#resource
pub type ResearchstudyObjective {
  ResearchstudyObjective(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    name: Option(String),
    type_: Option(Codeableconcept),
  )
}

pub fn researchstudy_objective_new() -> ResearchstudyObjective {
  ResearchstudyObjective(
    type_: None,
    name: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn researchstudy_objective_to_json(
  researchstudy_objective: ResearchstudyObjective,
) -> Json {
  let ResearchstudyObjective(
    type_:,
    name:,
    modifier_extension:,
    extension:,
    id:,
  ) = researchstudy_objective
  let fields = []
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn researchstudy_objective_decoder() -> Decoder(ResearchstudyObjective) {
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ResearchstudyObjective(
    type_:,
    name:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn researchstudy_arm_to_json(researchstudy_arm: ResearchstudyArm) -> Json {
  let ResearchstudyArm(
    description:,
    type_:,
    name:,
    modifier_extension:,
    extension:,
    id:,
  ) = researchstudy_arm
  let fields = [
    #("name", json.string(name)),
  ]
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn researchstudy_arm_decoder() -> Decoder(ResearchstudyArm) {
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use name <- decode.field("name", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ResearchstudyArm(
    description:,
    type_:,
    name:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn researchstudy_to_json(researchstudy: Researchstudy) -> Json {
  let Researchstudy(
    objective:,
    arm:,
    note:,
    reason_stopped:,
    site:,
    principal_investigator:,
    sponsor:,
    period:,
    enrollment:,
    description:,
    location:,
    keyword:,
    related_artifact:,
    contact:,
    condition:,
    focus:,
    category:,
    phase:,
    primary_purpose_type:,
    status:,
    part_of:,
    protocol:,
    title:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = researchstudy
  let fields = [
    #("status", r4bvaluesets.researchstudystatus_to_json(status)),
  ]
  let fields = case objective {
    [] -> fields
    _ -> [
      #("objective", json.array(objective, researchstudy_objective_to_json)),
      ..fields
    ]
  }
  let fields = case arm {
    [] -> fields
    _ -> [#("arm", json.array(arm, researchstudy_arm_to_json)), ..fields]
  }
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case reason_stopped {
    Some(v) -> [#("reasonStopped", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case site {
    [] -> fields
    _ -> [#("site", json.array(site, reference_to_json)), ..fields]
  }
  let fields = case principal_investigator {
    Some(v) -> [#("principalInvestigator", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case sponsor {
    Some(v) -> [#("sponsor", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case period {
    Some(v) -> [#("period", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case enrollment {
    [] -> fields
    _ -> [#("enrollment", json.array(enrollment, reference_to_json)), ..fields]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case location {
    [] -> fields
    _ -> [
      #("location", json.array(location, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case keyword {
    [] -> fields
    _ -> [#("keyword", json.array(keyword, codeableconcept_to_json)), ..fields]
  }
  let fields = case related_artifact {
    [] -> fields
    _ -> [
      #(
        "relatedArtifact",
        json.array(related_artifact, relatedartifact_to_json),
      ),
      ..fields
    ]
  }
  let fields = case contact {
    [] -> fields
    _ -> [#("contact", json.array(contact, contactdetail_to_json)), ..fields]
  }
  let fields = case condition {
    [] -> fields
    _ -> [
      #("condition", json.array(condition, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case focus {
    [] -> fields
    _ -> [#("focus", json.array(focus, codeableconcept_to_json)), ..fields]
  }
  let fields = case category {
    [] -> fields
    _ -> [
      #("category", json.array(category, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case phase {
    Some(v) -> [#("phase", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case primary_purpose_type {
    Some(v) -> [#("primaryPurposeType", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case part_of {
    [] -> fields
    _ -> [#("partOf", json.array(part_of, reference_to_json)), ..fields]
  }
  let fields = case protocol {
    [] -> fields
    _ -> [#("protocol", json.array(protocol, reference_to_json)), ..fields]
  }
  let fields = case title {
    Some(v) -> [#("title", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Researchstudy")), ..fields]
  json.object(fields)
}

pub fn researchstudy_decoder() -> Decoder(Researchstudy) {
  use objective <- decode.optional_field(
    "objective",
    [],
    decode.list(researchstudy_objective_decoder()),
  )
  use arm <- decode.optional_field(
    "arm",
    [],
    decode.list(researchstudy_arm_decoder()),
  )
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use reason_stopped <- decode.optional_field(
    "reasonStopped",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use site <- decode.optional_field(
    "site",
    [],
    decode.list(reference_decoder()),
  )
  use principal_investigator <- decode.optional_field(
    "principalInvestigator",
    None,
    decode.optional(reference_decoder()),
  )
  use sponsor <- decode.optional_field(
    "sponsor",
    None,
    decode.optional(reference_decoder()),
  )
  use period <- decode.optional_field(
    "period",
    None,
    decode.optional(period_decoder()),
  )
  use enrollment <- decode.optional_field(
    "enrollment",
    [],
    decode.list(reference_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use location <- decode.optional_field(
    "location",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use keyword <- decode.optional_field(
    "keyword",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use related_artifact <- decode.optional_field(
    "relatedArtifact",
    [],
    decode.list(relatedartifact_decoder()),
  )
  use contact <- decode.optional_field(
    "contact",
    [],
    decode.list(contactdetail_decoder()),
  )
  use condition <- decode.optional_field(
    "condition",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use focus <- decode.optional_field(
    "focus",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use category <- decode.optional_field(
    "category",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use phase <- decode.optional_field(
    "phase",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use primary_purpose_type <- decode.optional_field(
    "primaryPurposeType",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use status <- decode.field(
    "status",
    r4bvaluesets.researchstudystatus_decoder(),
  )
  use part_of <- decode.optional_field(
    "partOf",
    [],
    decode.list(reference_decoder()),
  )
  use protocol <- decode.optional_field(
    "protocol",
    [],
    decode.list(reference_decoder()),
  )
  use title <- decode.optional_field(
    "title",
    None,
    decode.optional(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Researchstudy",
    decode.failure(researchstudy_new(status:), "resourceType"),
  )
  decode.success(Researchstudy(
    objective:,
    arm:,
    note:,
    reason_stopped:,
    site:,
    principal_investigator:,
    sponsor:,
    period:,
    enrollment:,
    description:,
    location:,
    keyword:,
    related_artifact:,
    contact:,
    condition:,
    focus:,
    category:,
    phase:,
    primary_purpose_type:,
    status:,
    part_of:,
    protocol:,
    title:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/ResearchSubject#resource
pub type Researchsubject {
  Researchsubject(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    status: r4bvaluesets.Researchsubjectstatus,
    period: Option(Period),
    study: Reference,
    individual: Reference,
    assigned_arm: Option(String),
    actual_arm: Option(String),
    consent: Option(Reference),
  )
}

pub fn researchsubject_new(
  individual individual: Reference,
  study study: Reference,
  status status: r4bvaluesets.Researchsubjectstatus,
) -> Researchsubject {
  Researchsubject(
    consent: None,
    actual_arm: None,
    assigned_arm: None,
    individual:,
    study:,
    period: None,
    status:,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

pub fn researchsubject_to_json(researchsubject: Researchsubject) -> Json {
  let Researchsubject(
    consent:,
    actual_arm:,
    assigned_arm:,
    individual:,
    study:,
    period:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = researchsubject
  let fields = [
    #("individual", reference_to_json(individual)),
    #("study", reference_to_json(study)),
    #("status", r4bvaluesets.researchsubjectstatus_to_json(status)),
  ]
  let fields = case consent {
    Some(v) -> [#("consent", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case actual_arm {
    Some(v) -> [#("actualArm", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case assigned_arm {
    Some(v) -> [#("assignedArm", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case period {
    Some(v) -> [#("period", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Researchsubject")), ..fields]
  json.object(fields)
}

pub fn researchsubject_decoder() -> Decoder(Researchsubject) {
  use consent <- decode.optional_field(
    "consent",
    None,
    decode.optional(reference_decoder()),
  )
  use actual_arm <- decode.optional_field(
    "actualArm",
    None,
    decode.optional(decode.string),
  )
  use assigned_arm <- decode.optional_field(
    "assignedArm",
    None,
    decode.optional(decode.string),
  )
  use individual <- decode.field("individual", reference_decoder())
  use study <- decode.field("study", reference_decoder())
  use period <- decode.optional_field(
    "period",
    None,
    decode.optional(period_decoder()),
  )
  use status <- decode.field(
    "status",
    r4bvaluesets.researchsubjectstatus_decoder(),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Researchsubject",
    decode.failure(
      researchsubject_new(individual:, study:, status:),
      "resourceType",
    ),
  )
  decode.success(Researchsubject(
    consent:,
    actual_arm:,
    assigned_arm:,
    individual:,
    study:,
    period:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/RiskAssessment#resource
pub type Riskassessment {
  Riskassessment(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    based_on: Option(Reference),
    parent: Option(Reference),
    status: r4bvaluesets.Observationstatus,
    method: Option(Codeableconcept),
    code: Option(Codeableconcept),
    subject: Reference,
    encounter: Option(Reference),
    occurrence: Option(RiskassessmentOccurrence),
    condition: Option(Reference),
    performer: Option(Reference),
    reason_code: List(Codeableconcept),
    reason_reference: List(Reference),
    basis: List(Reference),
    prediction: List(RiskassessmentPrediction),
    mitigation: Option(String),
    note: List(Annotation),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/RiskAssessment#resource
pub type RiskassessmentOccurrence {
  RiskassessmentOccurrenceDatetime(occurrence: String)
  RiskassessmentOccurrencePeriod(occurrence: Period)
}

pub fn riskassessment_occurrence_to_json(elt: RiskassessmentOccurrence) -> Json {
  case elt {
    RiskassessmentOccurrenceDatetime(v) -> json.string(v)
    RiskassessmentOccurrencePeriod(v) -> period_to_json(v)
  }
}

pub fn riskassessment_occurrence_decoder() -> Decoder(RiskassessmentOccurrence) {
  decode.one_of(
    decode.field("occurrenceDateTime", decode.string, decode.success)
      |> decode.map(RiskassessmentOccurrenceDatetime),
    [
      decode.field("occurrencePeriod", period_decoder(), decode.success)
      |> decode.map(RiskassessmentOccurrencePeriod),
    ],
  )
}

pub fn riskassessment_new(
  subject subject: Reference,
  status status: r4bvaluesets.Observationstatus,
) -> Riskassessment {
  Riskassessment(
    note: [],
    mitigation: None,
    prediction: [],
    basis: [],
    reason_reference: [],
    reason_code: [],
    performer: None,
    condition: None,
    occurrence: None,
    encounter: None,
    subject:,
    code: None,
    method: None,
    status:,
    parent: None,
    based_on: None,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/RiskAssessment#resource
pub type RiskassessmentPrediction {
  RiskassessmentPrediction(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    outcome: Option(Codeableconcept),
    probability: Option(RiskassessmentPredictionProbability),
    qualitative_risk: Option(Codeableconcept),
    relative_risk: Option(Float),
    when: Option(RiskassessmentPredictionWhen),
    rationale: Option(String),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/RiskAssessment#resource
pub type RiskassessmentPredictionProbability {
  RiskassessmentPredictionProbabilityDecimal(probability: Float)
  RiskassessmentPredictionProbabilityRange(probability: Range)
}

pub fn riskassessment_prediction_probability_to_json(
  elt: RiskassessmentPredictionProbability,
) -> Json {
  case elt {
    RiskassessmentPredictionProbabilityDecimal(v) -> json.float(v)
    RiskassessmentPredictionProbabilityRange(v) -> range_to_json(v)
  }
}

pub fn riskassessment_prediction_probability_decoder() -> Decoder(
  RiskassessmentPredictionProbability,
) {
  decode.one_of(
    decode.field("probabilityDecimal", decode.float, decode.success)
      |> decode.map(RiskassessmentPredictionProbabilityDecimal),
    [
      decode.field("probabilityRange", range_decoder(), decode.success)
      |> decode.map(RiskassessmentPredictionProbabilityRange),
    ],
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/RiskAssessment#resource
pub type RiskassessmentPredictionWhen {
  RiskassessmentPredictionWhenPeriod(when: Period)
  RiskassessmentPredictionWhenRange(when: Range)
}

pub fn riskassessment_prediction_when_to_json(
  elt: RiskassessmentPredictionWhen,
) -> Json {
  case elt {
    RiskassessmentPredictionWhenPeriod(v) -> period_to_json(v)
    RiskassessmentPredictionWhenRange(v) -> range_to_json(v)
  }
}

pub fn riskassessment_prediction_when_decoder() -> Decoder(
  RiskassessmentPredictionWhen,
) {
  decode.one_of(
    decode.field("whenPeriod", period_decoder(), decode.success)
      |> decode.map(RiskassessmentPredictionWhenPeriod),
    [
      decode.field("whenRange", range_decoder(), decode.success)
      |> decode.map(RiskassessmentPredictionWhenRange),
    ],
  )
}

pub fn riskassessment_prediction_new() -> RiskassessmentPrediction {
  RiskassessmentPrediction(
    rationale: None,
    when: None,
    relative_risk: None,
    qualitative_risk: None,
    probability: None,
    outcome: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn riskassessment_prediction_to_json(
  riskassessment_prediction: RiskassessmentPrediction,
) -> Json {
  let RiskassessmentPrediction(
    rationale:,
    when:,
    relative_risk:,
    qualitative_risk:,
    probability:,
    outcome:,
    modifier_extension:,
    extension:,
    id:,
  ) = riskassessment_prediction
  let fields = []
  let fields = case rationale {
    Some(v) -> [#("rationale", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case when {
    Some(v) -> [
      #(
        "when"
          <> case v {
          RiskassessmentPredictionWhenPeriod(_) -> "Period"
          RiskassessmentPredictionWhenRange(_) -> "Range"
        },
        riskassessment_prediction_when_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case relative_risk {
    Some(v) -> [#("relativeRisk", json.float(v)), ..fields]
    None -> fields
  }
  let fields = case qualitative_risk {
    Some(v) -> [#("qualitativeRisk", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case probability {
    Some(v) -> [
      #(
        "probability"
          <> case v {
          RiskassessmentPredictionProbabilityDecimal(_) -> "Decimal"
          RiskassessmentPredictionProbabilityRange(_) -> "Range"
        },
        riskassessment_prediction_probability_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case outcome {
    Some(v) -> [#("outcome", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn riskassessment_prediction_decoder() -> Decoder(RiskassessmentPrediction) {
  use rationale <- decode.optional_field(
    "rationale",
    None,
    decode.optional(decode.string),
  )
  use when <- decode.then(
    none_if_omitted(riskassessment_prediction_when_decoder()),
  )
  use relative_risk <- decode.optional_field(
    "relativeRisk",
    None,
    decode.optional(decode.float),
  )
  use qualitative_risk <- decode.optional_field(
    "qualitativeRisk",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use probability <- decode.then(
    none_if_omitted(riskassessment_prediction_probability_decoder()),
  )
  use outcome <- decode.optional_field(
    "outcome",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(RiskassessmentPrediction(
    rationale:,
    when:,
    relative_risk:,
    qualitative_risk:,
    probability:,
    outcome:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn riskassessment_to_json(riskassessment: Riskassessment) -> Json {
  let Riskassessment(
    note:,
    mitigation:,
    prediction:,
    basis:,
    reason_reference:,
    reason_code:,
    performer:,
    condition:,
    occurrence:,
    encounter:,
    subject:,
    code:,
    method:,
    status:,
    parent:,
    based_on:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = riskassessment
  let fields = [
    #("subject", reference_to_json(subject)),
    #("status", r4bvaluesets.observationstatus_to_json(status)),
  ]
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case mitigation {
    Some(v) -> [#("mitigation", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case prediction {
    [] -> fields
    _ -> [
      #("prediction", json.array(prediction, riskassessment_prediction_to_json)),
      ..fields
    ]
  }
  let fields = case basis {
    [] -> fields
    _ -> [#("basis", json.array(basis, reference_to_json)), ..fields]
  }
  let fields = case reason_reference {
    [] -> fields
    _ -> [
      #("reasonReference", json.array(reason_reference, reference_to_json)),
      ..fields
    ]
  }
  let fields = case reason_code {
    [] -> fields
    _ -> [
      #("reasonCode", json.array(reason_code, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case performer {
    Some(v) -> [#("performer", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case condition {
    Some(v) -> [#("condition", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case occurrence {
    Some(v) -> [
      #(
        "occurrence"
          <> case v {
          RiskassessmentOccurrenceDatetime(_) -> "Datetime"
          RiskassessmentOccurrencePeriod(_) -> "Period"
        },
        riskassessment_occurrence_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case encounter {
    Some(v) -> [#("encounter", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case code {
    Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case method {
    Some(v) -> [#("method", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case parent {
    Some(v) -> [#("parent", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case based_on {
    Some(v) -> [#("basedOn", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Riskassessment")), ..fields]
  json.object(fields)
}

pub fn riskassessment_decoder() -> Decoder(Riskassessment) {
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use mitigation <- decode.optional_field(
    "mitigation",
    None,
    decode.optional(decode.string),
  )
  use prediction <- decode.optional_field(
    "prediction",
    [],
    decode.list(riskassessment_prediction_decoder()),
  )
  use basis <- decode.optional_field(
    "basis",
    [],
    decode.list(reference_decoder()),
  )
  use reason_reference <- decode.optional_field(
    "reasonReference",
    [],
    decode.list(reference_decoder()),
  )
  use reason_code <- decode.optional_field(
    "reasonCode",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use performer <- decode.optional_field(
    "performer",
    None,
    decode.optional(reference_decoder()),
  )
  use condition <- decode.optional_field(
    "condition",
    None,
    decode.optional(reference_decoder()),
  )
  use occurrence <- decode.then(
    none_if_omitted(riskassessment_occurrence_decoder()),
  )
  use encounter <- decode.optional_field(
    "encounter",
    None,
    decode.optional(reference_decoder()),
  )
  use subject <- decode.field("subject", reference_decoder())
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use method <- decode.optional_field(
    "method",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use status <- decode.field("status", r4bvaluesets.observationstatus_decoder())
  use parent <- decode.optional_field(
    "parent",
    None,
    decode.optional(reference_decoder()),
  )
  use based_on <- decode.optional_field(
    "basedOn",
    None,
    decode.optional(reference_decoder()),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Riskassessment",
    decode.failure(riskassessment_new(subject:, status:), "resourceType"),
  )
  decode.success(Riskassessment(
    note:,
    mitigation:,
    prediction:,
    basis:,
    reason_reference:,
    reason_code:,
    performer:,
    condition:,
    occurrence:,
    encounter:,
    subject:,
    code:,
    method:,
    status:,
    parent:,
    based_on:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/Schedule#resource
pub type Schedule {
  Schedule(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    active: Option(Bool),
    service_category: List(Codeableconcept),
    service_type: List(Codeableconcept),
    specialty: List(Codeableconcept),
    actor: List(Reference),
    planning_horizon: Option(Period),
    comment: Option(String),
  )
}

pub fn schedule_new() -> Schedule {
  Schedule(
    comment: None,
    planning_horizon: None,
    actor: [],
    specialty: [],
    service_type: [],
    service_category: [],
    active: None,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

pub fn schedule_to_json(schedule: Schedule) -> Json {
  let Schedule(
    comment:,
    planning_horizon:,
    actor:,
    specialty:,
    service_type:,
    service_category:,
    active:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = schedule
  let fields = []
  let fields = case comment {
    Some(v) -> [#("comment", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case planning_horizon {
    Some(v) -> [#("planningHorizon", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case actor {
    [] -> fields
    _ -> [#("actor", json.array(actor, reference_to_json)), ..fields]
  }
  let fields = case specialty {
    [] -> fields
    _ -> [
      #("specialty", json.array(specialty, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case service_type {
    [] -> fields
    _ -> [
      #("serviceType", json.array(service_type, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case service_category {
    [] -> fields
    _ -> [
      #(
        "serviceCategory",
        json.array(service_category, codeableconcept_to_json),
      ),
      ..fields
    ]
  }
  let fields = case active {
    Some(v) -> [#("active", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Schedule")), ..fields]
  json.object(fields)
}

pub fn schedule_decoder() -> Decoder(Schedule) {
  use comment <- decode.optional_field(
    "comment",
    None,
    decode.optional(decode.string),
  )
  use planning_horizon <- decode.optional_field(
    "planningHorizon",
    None,
    decode.optional(period_decoder()),
  )
  use actor <- decode.optional_field(
    "actor",
    [],
    decode.list(reference_decoder()),
  )
  use specialty <- decode.optional_field(
    "specialty",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use service_type <- decode.optional_field(
    "serviceType",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use service_category <- decode.optional_field(
    "serviceCategory",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use active <- decode.optional_field(
    "active",
    None,
    decode.optional(decode.bool),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Schedule",
    decode.failure(schedule_new(), "resourceType"),
  )
  decode.success(Schedule(
    comment:,
    planning_horizon:,
    actor:,
    specialty:,
    service_type:,
    service_category:,
    active:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/SearchParameter#resource
pub type Searchparameter {
  Searchparameter(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    url: String,
    version: Option(String),
    name: String,
    derived_from: Option(String),
    status: r4bvaluesets.Publicationstatus,
    experimental: Option(Bool),
    date: Option(String),
    publisher: Option(String),
    contact: List(Contactdetail),
    description: String,
    use_context: List(Usagecontext),
    jurisdiction: List(Codeableconcept),
    purpose: Option(String),
    code: String,
    base: List(r4bvaluesets.Resourcetypes),
    type_: r4bvaluesets.Searchparamtype,
    expression: Option(String),
    xpath: Option(String),
    xpath_usage: Option(r4bvaluesets.Searchxpathusage),
    target: List(r4bvaluesets.Resourcetypes),
    multiple_or: Option(Bool),
    multiple_and: Option(Bool),
    comparator: List(r4bvaluesets.Searchcomparator),
    modifier: List(r4bvaluesets.Searchmodifiercode),
    chain: List(String),
    component: List(SearchparameterComponent),
  )
}

pub fn searchparameter_new(
  type_ type_: r4bvaluesets.Searchparamtype,
  code code: String,
  description description: String,
  status status: r4bvaluesets.Publicationstatus,
  name name: String,
  url url: String,
) -> Searchparameter {
  Searchparameter(
    component: [],
    chain: [],
    modifier: [],
    comparator: [],
    multiple_and: None,
    multiple_or: None,
    target: [],
    xpath_usage: None,
    xpath: None,
    expression: None,
    type_:,
    base: [],
    code:,
    purpose: None,
    jurisdiction: [],
    use_context: [],
    description:,
    contact: [],
    publisher: None,
    date: None,
    experimental: None,
    status:,
    derived_from: None,
    name:,
    version: None,
    url:,
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/SearchParameter#resource
pub type SearchparameterComponent {
  SearchparameterComponent(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    definition: String,
    expression: String,
  )
}

pub fn searchparameter_component_new(
  expression expression: String,
  definition definition: String,
) -> SearchparameterComponent {
  SearchparameterComponent(
    expression:,
    definition:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn searchparameter_component_to_json(
  searchparameter_component: SearchparameterComponent,
) -> Json {
  let SearchparameterComponent(
    expression:,
    definition:,
    modifier_extension:,
    extension:,
    id:,
  ) = searchparameter_component
  let fields = [
    #("expression", json.string(expression)),
    #("definition", json.string(definition)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn searchparameter_component_decoder() -> Decoder(SearchparameterComponent) {
  use expression <- decode.field("expression", decode.string)
  use definition <- decode.field("definition", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(SearchparameterComponent(
    expression:,
    definition:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn searchparameter_to_json(searchparameter: Searchparameter) -> Json {
  let Searchparameter(
    component:,
    chain:,
    modifier:,
    comparator:,
    multiple_and:,
    multiple_or:,
    target:,
    xpath_usage:,
    xpath:,
    expression:,
    type_:,
    base:,
    code:,
    purpose:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    experimental:,
    status:,
    derived_from:,
    name:,
    version:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = searchparameter
  let fields = [
    #("type", r4bvaluesets.searchparamtype_to_json(type_)),
    #("code", json.string(code)),
    #("description", json.string(description)),
    #("status", r4bvaluesets.publicationstatus_to_json(status)),
    #("name", json.string(name)),
    #("url", json.string(url)),
  ]
  let fields = case component {
    [] -> fields
    _ -> [
      #("component", json.array(component, searchparameter_component_to_json)),
      ..fields
    ]
  }
  let fields = case chain {
    [] -> fields
    _ -> [#("chain", json.array(chain, json.string)), ..fields]
  }
  let fields = case modifier {
    [] -> fields
    _ -> [
      #(
        "modifier",
        json.array(modifier, r4bvaluesets.searchmodifiercode_to_json),
      ),
      ..fields
    ]
  }
  let fields = case comparator {
    [] -> fields
    _ -> [
      #(
        "comparator",
        json.array(comparator, r4bvaluesets.searchcomparator_to_json),
      ),
      ..fields
    ]
  }
  let fields = case multiple_and {
    Some(v) -> [#("multipleAnd", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case multiple_or {
    Some(v) -> [#("multipleOr", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case target {
    [] -> fields
    _ -> [
      #("target", json.array(target, r4bvaluesets.resourcetypes_to_json)),
      ..fields
    ]
  }
  let fields = case xpath_usage {
    Some(v) -> [
      #("xpathUsage", r4bvaluesets.searchxpathusage_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case xpath {
    Some(v) -> [#("xpath", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case expression {
    Some(v) -> [#("expression", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case base {
    [] -> fields
    _ -> [
      #("base", json.array(base, r4bvaluesets.resourcetypes_to_json)),
      ..fields
    ]
  }
  let fields = case purpose {
    Some(v) -> [#("purpose", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case jurisdiction {
    [] -> fields
    _ -> [
      #("jurisdiction", json.array(jurisdiction, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case use_context {
    [] -> fields
    _ -> [
      #("useContext", json.array(use_context, usagecontext_to_json)),
      ..fields
    ]
  }
  let fields = case contact {
    [] -> fields
    _ -> [#("contact", json.array(contact, contactdetail_to_json)), ..fields]
  }
  let fields = case publisher {
    Some(v) -> [#("publisher", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case date {
    Some(v) -> [#("date", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case experimental {
    Some(v) -> [#("experimental", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case derived_from {
    Some(v) -> [#("derivedFrom", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case version {
    Some(v) -> [#("version", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Searchparameter")), ..fields]
  json.object(fields)
}

pub fn searchparameter_decoder() -> Decoder(Searchparameter) {
  use component <- decode.optional_field(
    "component",
    [],
    decode.list(searchparameter_component_decoder()),
  )
  use chain <- decode.optional_field("chain", [], decode.list(decode.string))
  use modifier <- decode.optional_field(
    "modifier",
    [],
    decode.list(r4bvaluesets.searchmodifiercode_decoder()),
  )
  use comparator <- decode.optional_field(
    "comparator",
    [],
    decode.list(r4bvaluesets.searchcomparator_decoder()),
  )
  use multiple_and <- decode.optional_field(
    "multipleAnd",
    None,
    decode.optional(decode.bool),
  )
  use multiple_or <- decode.optional_field(
    "multipleOr",
    None,
    decode.optional(decode.bool),
  )
  use target <- decode.optional_field(
    "target",
    [],
    decode.list(r4bvaluesets.resourcetypes_decoder()),
  )
  use xpath_usage <- decode.optional_field(
    "xpathUsage",
    None,
    decode.optional(r4bvaluesets.searchxpathusage_decoder()),
  )
  use xpath <- decode.optional_field(
    "xpath",
    None,
    decode.optional(decode.string),
  )
  use expression <- decode.optional_field(
    "expression",
    None,
    decode.optional(decode.string),
  )
  use type_ <- decode.field("type", r4bvaluesets.searchparamtype_decoder())
  use base <- decode.optional_field(
    "base",
    [],
    decode.list(r4bvaluesets.resourcetypes_decoder()),
  )
  use code <- decode.field("code", decode.string)
  use purpose <- decode.optional_field(
    "purpose",
    None,
    decode.optional(decode.string),
  )
  use jurisdiction <- decode.optional_field(
    "jurisdiction",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use use_context <- decode.optional_field(
    "useContext",
    [],
    decode.list(usagecontext_decoder()),
  )
  use description <- decode.field("description", decode.string)
  use contact <- decode.optional_field(
    "contact",
    [],
    decode.list(contactdetail_decoder()),
  )
  use publisher <- decode.optional_field(
    "publisher",
    None,
    decode.optional(decode.string),
  )
  use date <- decode.optional_field(
    "date",
    None,
    decode.optional(decode.string),
  )
  use experimental <- decode.optional_field(
    "experimental",
    None,
    decode.optional(decode.bool),
  )
  use status <- decode.field("status", r4bvaluesets.publicationstatus_decoder())
  use derived_from <- decode.optional_field(
    "derivedFrom",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.field("name", decode.string)
  use version <- decode.optional_field(
    "version",
    None,
    decode.optional(decode.string),
  )
  use url <- decode.field("url", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Searchparameter",
    decode.failure(
      searchparameter_new(type_:, code:, description:, status:, name:, url:),
      "resourceType",
    ),
  )
  decode.success(Searchparameter(
    component:,
    chain:,
    modifier:,
    comparator:,
    multiple_and:,
    multiple_or:,
    target:,
    xpath_usage:,
    xpath:,
    expression:,
    type_:,
    base:,
    code:,
    purpose:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    experimental:,
    status:,
    derived_from:,
    name:,
    version:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/ServiceRequest#resource
pub type Servicerequest {
  Servicerequest(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    instantiates_canonical: List(String),
    instantiates_uri: List(String),
    based_on: List(Reference),
    replaces: List(Reference),
    requisition: Option(Identifier),
    status: r4bvaluesets.Requeststatus,
    intent: r4bvaluesets.Requestintent,
    category: List(Codeableconcept),
    priority: Option(r4bvaluesets.Requestpriority),
    do_not_perform: Option(Bool),
    code: Option(Codeableconcept),
    order_detail: List(Codeableconcept),
    quantity: Option(ServicerequestQuantity),
    subject: Reference,
    encounter: Option(Reference),
    occurrence: Option(ServicerequestOccurrence),
    as_needed: Option(ServicerequestAsneeded),
    authored_on: Option(String),
    requester: Option(Reference),
    performer_type: Option(Codeableconcept),
    performer: List(Reference),
    location_code: List(Codeableconcept),
    location_reference: List(Reference),
    reason_code: List(Codeableconcept),
    reason_reference: List(Reference),
    insurance: List(Reference),
    supporting_info: List(Reference),
    specimen: List(Reference),
    body_site: List(Codeableconcept),
    note: List(Annotation),
    patient_instruction: Option(String),
    relevant_history: List(Reference),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ServiceRequest#resource
pub type ServicerequestQuantity {
  ServicerequestQuantityQuantity(quantity: Quantity)
  ServicerequestQuantityRatio(quantity: Ratio)
  ServicerequestQuantityRange(quantity: Range)
}

pub fn servicerequest_quantity_to_json(elt: ServicerequestQuantity) -> Json {
  case elt {
    ServicerequestQuantityQuantity(v) -> quantity_to_json(v)
    ServicerequestQuantityRatio(v) -> ratio_to_json(v)
    ServicerequestQuantityRange(v) -> range_to_json(v)
  }
}

pub fn servicerequest_quantity_decoder() -> Decoder(ServicerequestQuantity) {
  decode.one_of(
    decode.field("quantityQuantity", quantity_decoder(), decode.success)
      |> decode.map(ServicerequestQuantityQuantity),
    [
      decode.field("quantityRatio", ratio_decoder(), decode.success)
        |> decode.map(ServicerequestQuantityRatio),
      decode.field("quantityRange", range_decoder(), decode.success)
        |> decode.map(ServicerequestQuantityRange),
    ],
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ServiceRequest#resource
pub type ServicerequestOccurrence {
  ServicerequestOccurrenceDatetime(occurrence: String)
  ServicerequestOccurrencePeriod(occurrence: Period)
  ServicerequestOccurrenceTiming(occurrence: Timing)
}

pub fn servicerequest_occurrence_to_json(elt: ServicerequestOccurrence) -> Json {
  case elt {
    ServicerequestOccurrenceDatetime(v) -> json.string(v)
    ServicerequestOccurrencePeriod(v) -> period_to_json(v)
    ServicerequestOccurrenceTiming(v) -> timing_to_json(v)
  }
}

pub fn servicerequest_occurrence_decoder() -> Decoder(ServicerequestOccurrence) {
  decode.one_of(
    decode.field("occurrenceDateTime", decode.string, decode.success)
      |> decode.map(ServicerequestOccurrenceDatetime),
    [
      decode.field("occurrencePeriod", period_decoder(), decode.success)
        |> decode.map(ServicerequestOccurrencePeriod),
      decode.field("occurrenceTiming", timing_decoder(), decode.success)
        |> decode.map(ServicerequestOccurrenceTiming),
    ],
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ServiceRequest#resource
pub type ServicerequestAsneeded {
  ServicerequestAsneededBoolean(as_needed: Bool)
  ServicerequestAsneededCodeableconcept(as_needed: Codeableconcept)
}

pub fn servicerequest_asneeded_to_json(elt: ServicerequestAsneeded) -> Json {
  case elt {
    ServicerequestAsneededBoolean(v) -> json.bool(v)
    ServicerequestAsneededCodeableconcept(v) -> codeableconcept_to_json(v)
  }
}

pub fn servicerequest_asneeded_decoder() -> Decoder(ServicerequestAsneeded) {
  decode.one_of(
    decode.field("asNeededBoolean", decode.bool, decode.success)
      |> decode.map(ServicerequestAsneededBoolean),
    [
      decode.field(
        "asNeededCodeableConcept",
        codeableconcept_decoder(),
        decode.success,
      )
      |> decode.map(ServicerequestAsneededCodeableconcept),
    ],
  )
}

pub fn servicerequest_new(
  subject subject: Reference,
  intent intent: r4bvaluesets.Requestintent,
  status status: r4bvaluesets.Requeststatus,
) -> Servicerequest {
  Servicerequest(
    relevant_history: [],
    patient_instruction: None,
    note: [],
    body_site: [],
    specimen: [],
    supporting_info: [],
    insurance: [],
    reason_reference: [],
    reason_code: [],
    location_reference: [],
    location_code: [],
    performer: [],
    performer_type: None,
    requester: None,
    authored_on: None,
    as_needed: None,
    occurrence: None,
    encounter: None,
    subject:,
    quantity: None,
    order_detail: [],
    code: None,
    do_not_perform: None,
    priority: None,
    category: [],
    intent:,
    status:,
    requisition: None,
    replaces: [],
    based_on: [],
    instantiates_uri: [],
    instantiates_canonical: [],
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

pub fn servicerequest_to_json(servicerequest: Servicerequest) -> Json {
  let Servicerequest(
    relevant_history:,
    patient_instruction:,
    note:,
    body_site:,
    specimen:,
    supporting_info:,
    insurance:,
    reason_reference:,
    reason_code:,
    location_reference:,
    location_code:,
    performer:,
    performer_type:,
    requester:,
    authored_on:,
    as_needed:,
    occurrence:,
    encounter:,
    subject:,
    quantity:,
    order_detail:,
    code:,
    do_not_perform:,
    priority:,
    category:,
    intent:,
    status:,
    requisition:,
    replaces:,
    based_on:,
    instantiates_uri:,
    instantiates_canonical:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = servicerequest
  let fields = [
    #("subject", reference_to_json(subject)),
    #("intent", r4bvaluesets.requestintent_to_json(intent)),
    #("status", r4bvaluesets.requeststatus_to_json(status)),
  ]
  let fields = case relevant_history {
    [] -> fields
    _ -> [
      #("relevantHistory", json.array(relevant_history, reference_to_json)),
      ..fields
    ]
  }
  let fields = case patient_instruction {
    Some(v) -> [#("patientInstruction", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case body_site {
    [] -> fields
    _ -> [
      #("bodySite", json.array(body_site, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case specimen {
    [] -> fields
    _ -> [#("specimen", json.array(specimen, reference_to_json)), ..fields]
  }
  let fields = case supporting_info {
    [] -> fields
    _ -> [
      #("supportingInfo", json.array(supporting_info, reference_to_json)),
      ..fields
    ]
  }
  let fields = case insurance {
    [] -> fields
    _ -> [#("insurance", json.array(insurance, reference_to_json)), ..fields]
  }
  let fields = case reason_reference {
    [] -> fields
    _ -> [
      #("reasonReference", json.array(reason_reference, reference_to_json)),
      ..fields
    ]
  }
  let fields = case reason_code {
    [] -> fields
    _ -> [
      #("reasonCode", json.array(reason_code, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case location_reference {
    [] -> fields
    _ -> [
      #("locationReference", json.array(location_reference, reference_to_json)),
      ..fields
    ]
  }
  let fields = case location_code {
    [] -> fields
    _ -> [
      #("locationCode", json.array(location_code, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case performer {
    [] -> fields
    _ -> [#("performer", json.array(performer, reference_to_json)), ..fields]
  }
  let fields = case performer_type {
    Some(v) -> [#("performerType", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case requester {
    Some(v) -> [#("requester", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case authored_on {
    Some(v) -> [#("authoredOn", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case as_needed {
    Some(v) -> [
      #(
        "asNeeded"
          <> case v {
          ServicerequestAsneededBoolean(_) -> "Boolean"
          ServicerequestAsneededCodeableconcept(_) -> "Codeableconcept"
        },
        servicerequest_asneeded_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case occurrence {
    Some(v) -> [
      #(
        "occurrence"
          <> case v {
          ServicerequestOccurrenceDatetime(_) -> "Datetime"
          ServicerequestOccurrencePeriod(_) -> "Period"
          ServicerequestOccurrenceTiming(_) -> "Timing"
        },
        servicerequest_occurrence_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case encounter {
    Some(v) -> [#("encounter", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case quantity {
    Some(v) -> [
      #(
        "quantity"
          <> case v {
          ServicerequestQuantityQuantity(_) -> "Quantity"
          ServicerequestQuantityRatio(_) -> "Ratio"
          ServicerequestQuantityRange(_) -> "Range"
        },
        servicerequest_quantity_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case order_detail {
    [] -> fields
    _ -> [
      #("orderDetail", json.array(order_detail, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case code {
    Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case do_not_perform {
    Some(v) -> [#("doNotPerform", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case priority {
    Some(v) -> [
      #("priority", r4bvaluesets.requestpriority_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case category {
    [] -> fields
    _ -> [
      #("category", json.array(category, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case requisition {
    Some(v) -> [#("requisition", identifier_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case replaces {
    [] -> fields
    _ -> [#("replaces", json.array(replaces, reference_to_json)), ..fields]
  }
  let fields = case based_on {
    [] -> fields
    _ -> [#("basedOn", json.array(based_on, reference_to_json)), ..fields]
  }
  let fields = case instantiates_uri {
    [] -> fields
    _ -> [
      #("instantiatesUri", json.array(instantiates_uri, json.string)),
      ..fields
    ]
  }
  let fields = case instantiates_canonical {
    [] -> fields
    _ -> [
      #(
        "instantiatesCanonical",
        json.array(instantiates_canonical, json.string),
      ),
      ..fields
    ]
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Servicerequest")), ..fields]
  json.object(fields)
}

pub fn servicerequest_decoder() -> Decoder(Servicerequest) {
  use relevant_history <- decode.optional_field(
    "relevantHistory",
    [],
    decode.list(reference_decoder()),
  )
  use patient_instruction <- decode.optional_field(
    "patientInstruction",
    None,
    decode.optional(decode.string),
  )
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use body_site <- decode.optional_field(
    "bodySite",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use specimen <- decode.optional_field(
    "specimen",
    [],
    decode.list(reference_decoder()),
  )
  use supporting_info <- decode.optional_field(
    "supportingInfo",
    [],
    decode.list(reference_decoder()),
  )
  use insurance <- decode.optional_field(
    "insurance",
    [],
    decode.list(reference_decoder()),
  )
  use reason_reference <- decode.optional_field(
    "reasonReference",
    [],
    decode.list(reference_decoder()),
  )
  use reason_code <- decode.optional_field(
    "reasonCode",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use location_reference <- decode.optional_field(
    "locationReference",
    [],
    decode.list(reference_decoder()),
  )
  use location_code <- decode.optional_field(
    "locationCode",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use performer <- decode.optional_field(
    "performer",
    [],
    decode.list(reference_decoder()),
  )
  use performer_type <- decode.optional_field(
    "performerType",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use requester <- decode.optional_field(
    "requester",
    None,
    decode.optional(reference_decoder()),
  )
  use authored_on <- decode.optional_field(
    "authoredOn",
    None,
    decode.optional(decode.string),
  )
  use as_needed <- decode.then(
    none_if_omitted(servicerequest_asneeded_decoder()),
  )
  use occurrence <- decode.then(
    none_if_omitted(servicerequest_occurrence_decoder()),
  )
  use encounter <- decode.optional_field(
    "encounter",
    None,
    decode.optional(reference_decoder()),
  )
  use subject <- decode.field("subject", reference_decoder())
  use quantity <- decode.then(
    none_if_omitted(servicerequest_quantity_decoder()),
  )
  use order_detail <- decode.optional_field(
    "orderDetail",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use do_not_perform <- decode.optional_field(
    "doNotPerform",
    None,
    decode.optional(decode.bool),
  )
  use priority <- decode.optional_field(
    "priority",
    None,
    decode.optional(r4bvaluesets.requestpriority_decoder()),
  )
  use category <- decode.optional_field(
    "category",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use intent <- decode.field("intent", r4bvaluesets.requestintent_decoder())
  use status <- decode.field("status", r4bvaluesets.requeststatus_decoder())
  use requisition <- decode.optional_field(
    "requisition",
    None,
    decode.optional(identifier_decoder()),
  )
  use replaces <- decode.optional_field(
    "replaces",
    [],
    decode.list(reference_decoder()),
  )
  use based_on <- decode.optional_field(
    "basedOn",
    [],
    decode.list(reference_decoder()),
  )
  use instantiates_uri <- decode.optional_field(
    "instantiatesUri",
    [],
    decode.list(decode.string),
  )
  use instantiates_canonical <- decode.optional_field(
    "instantiatesCanonical",
    [],
    decode.list(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Servicerequest",
    decode.failure(
      servicerequest_new(subject:, intent:, status:),
      "resourceType",
    ),
  )
  decode.success(Servicerequest(
    relevant_history:,
    patient_instruction:,
    note:,
    body_site:,
    specimen:,
    supporting_info:,
    insurance:,
    reason_reference:,
    reason_code:,
    location_reference:,
    location_code:,
    performer:,
    performer_type:,
    requester:,
    authored_on:,
    as_needed:,
    occurrence:,
    encounter:,
    subject:,
    quantity:,
    order_detail:,
    code:,
    do_not_perform:,
    priority:,
    category:,
    intent:,
    status:,
    requisition:,
    replaces:,
    based_on:,
    instantiates_uri:,
    instantiates_canonical:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/Slot#resource
pub type Slot {
  Slot(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    service_category: List(Codeableconcept),
    service_type: List(Codeableconcept),
    specialty: List(Codeableconcept),
    appointment_type: Option(Codeableconcept),
    schedule: Reference,
    status: r4bvaluesets.Slotstatus,
    start: String,
    end: String,
    overbooked: Option(Bool),
    comment: Option(String),
  )
}

pub fn slot_new(
  end end: String,
  start start: String,
  status status: r4bvaluesets.Slotstatus,
  schedule schedule: Reference,
) -> Slot {
  Slot(
    comment: None,
    overbooked: None,
    end:,
    start:,
    status:,
    schedule:,
    appointment_type: None,
    specialty: [],
    service_type: [],
    service_category: [],
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

pub fn slot_to_json(slot: Slot) -> Json {
  let Slot(
    comment:,
    overbooked:,
    end:,
    start:,
    status:,
    schedule:,
    appointment_type:,
    specialty:,
    service_type:,
    service_category:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = slot
  let fields = [
    #("end", json.string(end)),
    #("start", json.string(start)),
    #("status", r4bvaluesets.slotstatus_to_json(status)),
    #("schedule", reference_to_json(schedule)),
  ]
  let fields = case comment {
    Some(v) -> [#("comment", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case overbooked {
    Some(v) -> [#("overbooked", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case appointment_type {
    Some(v) -> [#("appointmentType", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case specialty {
    [] -> fields
    _ -> [
      #("specialty", json.array(specialty, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case service_type {
    [] -> fields
    _ -> [
      #("serviceType", json.array(service_type, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case service_category {
    [] -> fields
    _ -> [
      #(
        "serviceCategory",
        json.array(service_category, codeableconcept_to_json),
      ),
      ..fields
    ]
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Slot")), ..fields]
  json.object(fields)
}

pub fn slot_decoder() -> Decoder(Slot) {
  use comment <- decode.optional_field(
    "comment",
    None,
    decode.optional(decode.string),
  )
  use overbooked <- decode.optional_field(
    "overbooked",
    None,
    decode.optional(decode.bool),
  )
  use end <- decode.field("end", decode.string)
  use start <- decode.field("start", decode.string)
  use status <- decode.field("status", r4bvaluesets.slotstatus_decoder())
  use schedule <- decode.field("schedule", reference_decoder())
  use appointment_type <- decode.optional_field(
    "appointmentType",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use specialty <- decode.optional_field(
    "specialty",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use service_type <- decode.optional_field(
    "serviceType",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use service_category <- decode.optional_field(
    "serviceCategory",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Slot",
    decode.failure(slot_new(end:, start:, status:, schedule:), "resourceType"),
  )
  decode.success(Slot(
    comment:,
    overbooked:,
    end:,
    start:,
    status:,
    schedule:,
    appointment_type:,
    specialty:,
    service_type:,
    service_category:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/Specimen#resource
pub type Specimen {
  Specimen(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    accession_identifier: Option(Identifier),
    status: Option(r4bvaluesets.Specimenstatus),
    type_: Option(Codeableconcept),
    subject: Option(Reference),
    received_time: Option(String),
    parent: List(Reference),
    request: List(Reference),
    collection: Option(SpecimenCollection),
    processing: List(SpecimenProcessing),
    container: List(SpecimenContainer),
    condition: List(Codeableconcept),
    note: List(Annotation),
  )
}

pub fn specimen_new() -> Specimen {
  Specimen(
    note: [],
    condition: [],
    container: [],
    processing: [],
    collection: None,
    request: [],
    parent: [],
    received_time: None,
    subject: None,
    type_: None,
    status: None,
    accession_identifier: None,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Specimen#resource
pub type SpecimenCollection {
  SpecimenCollection(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    collector: Option(Reference),
    collected: Option(SpecimenCollectionCollected),
    duration: Option(Duration),
    quantity: Option(Quantity),
    method: Option(Codeableconcept),
    body_site: Option(Codeableconcept),
    fasting_status: Option(SpecimenCollectionFastingstatus),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Specimen#resource
pub type SpecimenCollectionCollected {
  SpecimenCollectionCollectedDatetime(collected: String)
  SpecimenCollectionCollectedPeriod(collected: Period)
}

pub fn specimen_collection_collected_to_json(
  elt: SpecimenCollectionCollected,
) -> Json {
  case elt {
    SpecimenCollectionCollectedDatetime(v) -> json.string(v)
    SpecimenCollectionCollectedPeriod(v) -> period_to_json(v)
  }
}

pub fn specimen_collection_collected_decoder() -> Decoder(
  SpecimenCollectionCollected,
) {
  decode.one_of(
    decode.field("collectedDateTime", decode.string, decode.success)
      |> decode.map(SpecimenCollectionCollectedDatetime),
    [
      decode.field("collectedPeriod", period_decoder(), decode.success)
      |> decode.map(SpecimenCollectionCollectedPeriod),
    ],
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Specimen#resource
pub type SpecimenCollectionFastingstatus {
  SpecimenCollectionFastingstatusCodeableconcept(
    fasting_status: Codeableconcept,
  )
  SpecimenCollectionFastingstatusDuration(fasting_status: Duration)
}

pub fn specimen_collection_fastingstatus_to_json(
  elt: SpecimenCollectionFastingstatus,
) -> Json {
  case elt {
    SpecimenCollectionFastingstatusCodeableconcept(v) ->
      codeableconcept_to_json(v)
    SpecimenCollectionFastingstatusDuration(v) -> duration_to_json(v)
  }
}

pub fn specimen_collection_fastingstatus_decoder() -> Decoder(
  SpecimenCollectionFastingstatus,
) {
  decode.one_of(
    decode.field(
      "fastingStatusCodeableConcept",
      codeableconcept_decoder(),
      decode.success,
    )
      |> decode.map(SpecimenCollectionFastingstatusCodeableconcept),
    [
      decode.field("fastingStatusDuration", duration_decoder(), decode.success)
      |> decode.map(SpecimenCollectionFastingstatusDuration),
    ],
  )
}

pub fn specimen_collection_new() -> SpecimenCollection {
  SpecimenCollection(
    fasting_status: None,
    body_site: None,
    method: None,
    quantity: None,
    duration: None,
    collected: None,
    collector: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Specimen#resource
pub type SpecimenProcessing {
  SpecimenProcessing(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    description: Option(String),
    procedure: Option(Codeableconcept),
    additive: List(Reference),
    time: Option(SpecimenProcessingTime),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Specimen#resource
pub type SpecimenProcessingTime {
  SpecimenProcessingTimeDatetime(time: String)
  SpecimenProcessingTimePeriod(time: Period)
}

pub fn specimen_processing_time_to_json(elt: SpecimenProcessingTime) -> Json {
  case elt {
    SpecimenProcessingTimeDatetime(v) -> json.string(v)
    SpecimenProcessingTimePeriod(v) -> period_to_json(v)
  }
}

pub fn specimen_processing_time_decoder() -> Decoder(SpecimenProcessingTime) {
  decode.one_of(
    decode.field("timeDateTime", decode.string, decode.success)
      |> decode.map(SpecimenProcessingTimeDatetime),
    [
      decode.field("timePeriod", period_decoder(), decode.success)
      |> decode.map(SpecimenProcessingTimePeriod),
    ],
  )
}

pub fn specimen_processing_new() -> SpecimenProcessing {
  SpecimenProcessing(
    time: None,
    additive: [],
    procedure: None,
    description: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Specimen#resource
pub type SpecimenContainer {
  SpecimenContainer(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    description: Option(String),
    type_: Option(Codeableconcept),
    capacity: Option(Quantity),
    specimen_quantity: Option(Quantity),
    additive: Option(SpecimenContainerAdditive),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Specimen#resource
pub type SpecimenContainerAdditive {
  SpecimenContainerAdditiveCodeableconcept(additive: Codeableconcept)
  SpecimenContainerAdditiveReference(additive: Reference)
}

pub fn specimen_container_additive_to_json(
  elt: SpecimenContainerAdditive,
) -> Json {
  case elt {
    SpecimenContainerAdditiveCodeableconcept(v) -> codeableconcept_to_json(v)
    SpecimenContainerAdditiveReference(v) -> reference_to_json(v)
  }
}

pub fn specimen_container_additive_decoder() -> Decoder(
  SpecimenContainerAdditive,
) {
  decode.one_of(
    decode.field(
      "additiveCodeableConcept",
      codeableconcept_decoder(),
      decode.success,
    )
      |> decode.map(SpecimenContainerAdditiveCodeableconcept),
    [
      decode.field("additiveReference", reference_decoder(), decode.success)
      |> decode.map(SpecimenContainerAdditiveReference),
    ],
  )
}

pub fn specimen_container_new() -> SpecimenContainer {
  SpecimenContainer(
    additive: None,
    specimen_quantity: None,
    capacity: None,
    type_: None,
    description: None,
    identifier: [],
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn specimen_container_to_json(specimen_container: SpecimenContainer) -> Json {
  let SpecimenContainer(
    additive:,
    specimen_quantity:,
    capacity:,
    type_:,
    description:,
    identifier:,
    modifier_extension:,
    extension:,
    id:,
  ) = specimen_container
  let fields = []
  let fields = case additive {
    Some(v) -> [
      #(
        "additive"
          <> case v {
          SpecimenContainerAdditiveCodeableconcept(_) -> "Codeableconcept"
          SpecimenContainerAdditiveReference(_) -> "Reference"
        },
        specimen_container_additive_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case specimen_quantity {
    Some(v) -> [#("specimenQuantity", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case capacity {
    Some(v) -> [#("capacity", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn specimen_container_decoder() -> Decoder(SpecimenContainer) {
  use additive <- decode.then(
    none_if_omitted(specimen_container_additive_decoder()),
  )
  use specimen_quantity <- decode.optional_field(
    "specimenQuantity",
    None,
    decode.optional(quantity_decoder()),
  )
  use capacity <- decode.optional_field(
    "capacity",
    None,
    decode.optional(quantity_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(SpecimenContainer(
    additive:,
    specimen_quantity:,
    capacity:,
    type_:,
    description:,
    identifier:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn specimen_processing_to_json(
  specimen_processing: SpecimenProcessing,
) -> Json {
  let SpecimenProcessing(
    time:,
    additive:,
    procedure:,
    description:,
    modifier_extension:,
    extension:,
    id:,
  ) = specimen_processing
  let fields = []
  let fields = case time {
    Some(v) -> [
      #(
        "time"
          <> case v {
          SpecimenProcessingTimeDatetime(_) -> "Datetime"
          SpecimenProcessingTimePeriod(_) -> "Period"
        },
        specimen_processing_time_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case additive {
    [] -> fields
    _ -> [#("additive", json.array(additive, reference_to_json)), ..fields]
  }
  let fields = case procedure {
    Some(v) -> [#("procedure", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn specimen_processing_decoder() -> Decoder(SpecimenProcessing) {
  use time <- decode.then(none_if_omitted(specimen_processing_time_decoder()))
  use additive <- decode.optional_field(
    "additive",
    [],
    decode.list(reference_decoder()),
  )
  use procedure <- decode.optional_field(
    "procedure",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(SpecimenProcessing(
    time:,
    additive:,
    procedure:,
    description:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn specimen_collection_to_json(
  specimen_collection: SpecimenCollection,
) -> Json {
  let SpecimenCollection(
    fasting_status:,
    body_site:,
    method:,
    quantity:,
    duration:,
    collected:,
    collector:,
    modifier_extension:,
    extension:,
    id:,
  ) = specimen_collection
  let fields = []
  let fields = case fasting_status {
    Some(v) -> [
      #(
        "fastingStatus"
          <> case v {
          SpecimenCollectionFastingstatusCodeableconcept(_) -> "Codeableconcept"
          SpecimenCollectionFastingstatusDuration(_) -> "Duration"
        },
        specimen_collection_fastingstatus_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case body_site {
    Some(v) -> [#("bodySite", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case method {
    Some(v) -> [#("method", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case quantity {
    Some(v) -> [#("quantity", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case duration {
    Some(v) -> [#("duration", duration_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case collected {
    Some(v) -> [
      #(
        "collected"
          <> case v {
          SpecimenCollectionCollectedDatetime(_) -> "Datetime"
          SpecimenCollectionCollectedPeriod(_) -> "Period"
        },
        specimen_collection_collected_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case collector {
    Some(v) -> [#("collector", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn specimen_collection_decoder() -> Decoder(SpecimenCollection) {
  use fasting_status <- decode.then(
    none_if_omitted(specimen_collection_fastingstatus_decoder()),
  )
  use body_site <- decode.optional_field(
    "bodySite",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use method <- decode.optional_field(
    "method",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use quantity <- decode.optional_field(
    "quantity",
    None,
    decode.optional(quantity_decoder()),
  )
  use duration <- decode.optional_field(
    "duration",
    None,
    decode.optional(duration_decoder()),
  )
  use collected <- decode.then(
    none_if_omitted(specimen_collection_collected_decoder()),
  )
  use collector <- decode.optional_field(
    "collector",
    None,
    decode.optional(reference_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(SpecimenCollection(
    fasting_status:,
    body_site:,
    method:,
    quantity:,
    duration:,
    collected:,
    collector:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn specimen_to_json(specimen: Specimen) -> Json {
  let Specimen(
    note:,
    condition:,
    container:,
    processing:,
    collection:,
    request:,
    parent:,
    received_time:,
    subject:,
    type_:,
    status:,
    accession_identifier:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = specimen
  let fields = []
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case condition {
    [] -> fields
    _ -> [
      #("condition", json.array(condition, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case container {
    [] -> fields
    _ -> [
      #("container", json.array(container, specimen_container_to_json)),
      ..fields
    ]
  }
  let fields = case processing {
    [] -> fields
    _ -> [
      #("processing", json.array(processing, specimen_processing_to_json)),
      ..fields
    ]
  }
  let fields = case collection {
    Some(v) -> [#("collection", specimen_collection_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case request {
    [] -> fields
    _ -> [#("request", json.array(request, reference_to_json)), ..fields]
  }
  let fields = case parent {
    [] -> fields
    _ -> [#("parent", json.array(parent, reference_to_json)), ..fields]
  }
  let fields = case received_time {
    Some(v) -> [#("receivedTime", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case subject {
    Some(v) -> [#("subject", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case status {
    Some(v) -> [#("status", r4bvaluesets.specimenstatus_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case accession_identifier {
    Some(v) -> [#("accessionIdentifier", identifier_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Specimen")), ..fields]
  json.object(fields)
}

pub fn specimen_decoder() -> Decoder(Specimen) {
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use condition <- decode.optional_field(
    "condition",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use container <- decode.optional_field(
    "container",
    [],
    decode.list(specimen_container_decoder()),
  )
  use processing <- decode.optional_field(
    "processing",
    [],
    decode.list(specimen_processing_decoder()),
  )
  use collection <- decode.optional_field(
    "collection",
    None,
    decode.optional(specimen_collection_decoder()),
  )
  use request <- decode.optional_field(
    "request",
    [],
    decode.list(reference_decoder()),
  )
  use parent <- decode.optional_field(
    "parent",
    [],
    decode.list(reference_decoder()),
  )
  use received_time <- decode.optional_field(
    "receivedTime",
    None,
    decode.optional(decode.string),
  )
  use subject <- decode.optional_field(
    "subject",
    None,
    decode.optional(reference_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use status <- decode.optional_field(
    "status",
    None,
    decode.optional(r4bvaluesets.specimenstatus_decoder()),
  )
  use accession_identifier <- decode.optional_field(
    "accessionIdentifier",
    None,
    decode.optional(identifier_decoder()),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Specimen",
    decode.failure(specimen_new(), "resourceType"),
  )
  decode.success(Specimen(
    note:,
    condition:,
    container:,
    processing:,
    collection:,
    request:,
    parent:,
    received_time:,
    subject:,
    type_:,
    status:,
    accession_identifier:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/SpecimenDefinition#resource
pub type Specimendefinition {
  Specimendefinition(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: Option(Identifier),
    type_collected: Option(Codeableconcept),
    patient_preparation: List(Codeableconcept),
    time_aspect: Option(String),
    collection: List(Codeableconcept),
    type_tested: List(SpecimendefinitionTypetested),
  )
}

pub fn specimendefinition_new() -> Specimendefinition {
  Specimendefinition(
    type_tested: [],
    collection: [],
    time_aspect: None,
    patient_preparation: [],
    type_collected: None,
    identifier: None,
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/SpecimenDefinition#resource
pub type SpecimendefinitionTypetested {
  SpecimendefinitionTypetested(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    is_derived: Option(Bool),
    type_: Option(Codeableconcept),
    preference: r4bvaluesets.Specimencontainedpreference,
    container: Option(SpecimendefinitionTypetestedContainer),
    requirement: Option(String),
    retention_time: Option(Duration),
    rejection_criterion: List(Codeableconcept),
    handling: List(SpecimendefinitionTypetestedHandling),
  )
}

pub fn specimendefinition_typetested_new(
  preference preference: r4bvaluesets.Specimencontainedpreference,
) -> SpecimendefinitionTypetested {
  SpecimendefinitionTypetested(
    handling: [],
    rejection_criterion: [],
    retention_time: None,
    requirement: None,
    container: None,
    preference:,
    type_: None,
    is_derived: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/SpecimenDefinition#resource
pub type SpecimendefinitionTypetestedContainer {
  SpecimendefinitionTypetestedContainer(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    material: Option(Codeableconcept),
    type_: Option(Codeableconcept),
    cap: Option(Codeableconcept),
    description: Option(String),
    capacity: Option(Quantity),
    minimum_volume: Option(SpecimendefinitionTypetestedContainerMinimumvolume),
    additive: List(SpecimendefinitionTypetestedContainerAdditive),
    preparation: Option(String),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/SpecimenDefinition#resource
pub type SpecimendefinitionTypetestedContainerMinimumvolume {
  SpecimendefinitionTypetestedContainerMinimumvolumeQuantity(
    minimum_volume: Quantity,
  )
  SpecimendefinitionTypetestedContainerMinimumvolumeString(
    minimum_volume: String,
  )
}

pub fn specimendefinition_typetested_container_minimumvolume_to_json(
  elt: SpecimendefinitionTypetestedContainerMinimumvolume,
) -> Json {
  case elt {
    SpecimendefinitionTypetestedContainerMinimumvolumeQuantity(v) ->
      quantity_to_json(v)
    SpecimendefinitionTypetestedContainerMinimumvolumeString(v) ->
      json.string(v)
  }
}

pub fn specimendefinition_typetested_container_minimumvolume_decoder() -> Decoder(
  SpecimendefinitionTypetestedContainerMinimumvolume,
) {
  decode.one_of(
    decode.field("minimumVolumeQuantity", quantity_decoder(), decode.success)
      |> decode.map(SpecimendefinitionTypetestedContainerMinimumvolumeQuantity),
    [
      decode.field("minimumVolumeString", decode.string, decode.success)
      |> decode.map(SpecimendefinitionTypetestedContainerMinimumvolumeString),
    ],
  )
}

pub fn specimendefinition_typetested_container_new() -> SpecimendefinitionTypetestedContainer {
  SpecimendefinitionTypetestedContainer(
    preparation: None,
    additive: [],
    minimum_volume: None,
    capacity: None,
    description: None,
    cap: None,
    type_: None,
    material: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/SpecimenDefinition#resource
pub type SpecimendefinitionTypetestedContainerAdditive {
  SpecimendefinitionTypetestedContainerAdditive(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    additive: SpecimendefinitionTypetestedContainerAdditiveAdditive,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/SpecimenDefinition#resource
pub type SpecimendefinitionTypetestedContainerAdditiveAdditive {
  SpecimendefinitionTypetestedContainerAdditiveAdditiveCodeableconcept(
    additive: Codeableconcept,
  )
  SpecimendefinitionTypetestedContainerAdditiveAdditiveReference(
    additive: Reference,
  )
}

pub fn specimendefinition_typetested_container_additive_additive_to_json(
  elt: SpecimendefinitionTypetestedContainerAdditiveAdditive,
) -> Json {
  case elt {
    SpecimendefinitionTypetestedContainerAdditiveAdditiveCodeableconcept(v) ->
      codeableconcept_to_json(v)
    SpecimendefinitionTypetestedContainerAdditiveAdditiveReference(v) ->
      reference_to_json(v)
  }
}

pub fn specimendefinition_typetested_container_additive_additive_decoder() -> Decoder(
  SpecimendefinitionTypetestedContainerAdditiveAdditive,
) {
  decode.one_of(
    decode.field(
      "additiveCodeableConcept",
      codeableconcept_decoder(),
      decode.success,
    )
      |> decode.map(
        SpecimendefinitionTypetestedContainerAdditiveAdditiveCodeableconcept,
      ),
    [
      decode.field("additiveReference", reference_decoder(), decode.success)
      |> decode.map(
        SpecimendefinitionTypetestedContainerAdditiveAdditiveReference,
      ),
    ],
  )
}

pub fn specimendefinition_typetested_container_additive_new(
  additive additive: SpecimendefinitionTypetestedContainerAdditiveAdditive,
) -> SpecimendefinitionTypetestedContainerAdditive {
  SpecimendefinitionTypetestedContainerAdditive(
    additive:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/SpecimenDefinition#resource
pub type SpecimendefinitionTypetestedHandling {
  SpecimendefinitionTypetestedHandling(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    temperature_qualifier: Option(Codeableconcept),
    temperature_range: Option(Range),
    max_duration: Option(Duration),
    instruction: Option(String),
  )
}

pub fn specimendefinition_typetested_handling_new() -> SpecimendefinitionTypetestedHandling {
  SpecimendefinitionTypetestedHandling(
    instruction: None,
    max_duration: None,
    temperature_range: None,
    temperature_qualifier: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn specimendefinition_typetested_handling_to_json(
  specimendefinition_typetested_handling: SpecimendefinitionTypetestedHandling,
) -> Json {
  let SpecimendefinitionTypetestedHandling(
    instruction:,
    max_duration:,
    temperature_range:,
    temperature_qualifier:,
    modifier_extension:,
    extension:,
    id:,
  ) = specimendefinition_typetested_handling
  let fields = []
  let fields = case instruction {
    Some(v) -> [#("instruction", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case max_duration {
    Some(v) -> [#("maxDuration", duration_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case temperature_range {
    Some(v) -> [#("temperatureRange", range_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case temperature_qualifier {
    Some(v) -> [#("temperatureQualifier", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn specimendefinition_typetested_handling_decoder() -> Decoder(
  SpecimendefinitionTypetestedHandling,
) {
  use instruction <- decode.optional_field(
    "instruction",
    None,
    decode.optional(decode.string),
  )
  use max_duration <- decode.optional_field(
    "maxDuration",
    None,
    decode.optional(duration_decoder()),
  )
  use temperature_range <- decode.optional_field(
    "temperatureRange",
    None,
    decode.optional(range_decoder()),
  )
  use temperature_qualifier <- decode.optional_field(
    "temperatureQualifier",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(SpecimendefinitionTypetestedHandling(
    instruction:,
    max_duration:,
    temperature_range:,
    temperature_qualifier:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn specimendefinition_typetested_container_additive_to_json(
  specimendefinition_typetested_container_additive: SpecimendefinitionTypetestedContainerAdditive,
) -> Json {
  let SpecimendefinitionTypetestedContainerAdditive(
    additive:,
    modifier_extension:,
    extension:,
    id:,
  ) = specimendefinition_typetested_container_additive
  let fields = [
    #(
      "additive",
      specimendefinition_typetested_container_additive_additive_to_json(
        additive,
      ),
    ),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn specimendefinition_typetested_container_additive_decoder() -> Decoder(
  SpecimendefinitionTypetestedContainerAdditive,
) {
  use additive <- decode.then(
    specimendefinition_typetested_container_additive_additive_decoder(),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(SpecimendefinitionTypetestedContainerAdditive(
    additive:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn specimendefinition_typetested_container_to_json(
  specimendefinition_typetested_container: SpecimendefinitionTypetestedContainer,
) -> Json {
  let SpecimendefinitionTypetestedContainer(
    preparation:,
    additive:,
    minimum_volume:,
    capacity:,
    description:,
    cap:,
    type_:,
    material:,
    modifier_extension:,
    extension:,
    id:,
  ) = specimendefinition_typetested_container
  let fields = []
  let fields = case preparation {
    Some(v) -> [#("preparation", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case additive {
    [] -> fields
    _ -> [
      #(
        "additive",
        json.array(
          additive,
          specimendefinition_typetested_container_additive_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case minimum_volume {
    Some(v) -> [
      #(
        "minimumVolume"
          <> case v {
          SpecimendefinitionTypetestedContainerMinimumvolumeQuantity(_) ->
            "Quantity"
          SpecimendefinitionTypetestedContainerMinimumvolumeString(_) ->
            "String"
        },
        specimendefinition_typetested_container_minimumvolume_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case capacity {
    Some(v) -> [#("capacity", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case cap {
    Some(v) -> [#("cap", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case material {
    Some(v) -> [#("material", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn specimendefinition_typetested_container_decoder() -> Decoder(
  SpecimendefinitionTypetestedContainer,
) {
  use preparation <- decode.optional_field(
    "preparation",
    None,
    decode.optional(decode.string),
  )
  use additive <- decode.optional_field(
    "additive",
    [],
    decode.list(specimendefinition_typetested_container_additive_decoder()),
  )
  use minimum_volume <- decode.then(
    none_if_omitted(
      specimendefinition_typetested_container_minimumvolume_decoder(),
    ),
  )
  use capacity <- decode.optional_field(
    "capacity",
    None,
    decode.optional(quantity_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use cap <- decode.optional_field(
    "cap",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use material <- decode.optional_field(
    "material",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(SpecimendefinitionTypetestedContainer(
    preparation:,
    additive:,
    minimum_volume:,
    capacity:,
    description:,
    cap:,
    type_:,
    material:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn specimendefinition_typetested_to_json(
  specimendefinition_typetested: SpecimendefinitionTypetested,
) -> Json {
  let SpecimendefinitionTypetested(
    handling:,
    rejection_criterion:,
    retention_time:,
    requirement:,
    container:,
    preference:,
    type_:,
    is_derived:,
    modifier_extension:,
    extension:,
    id:,
  ) = specimendefinition_typetested
  let fields = [
    #(
      "preference",
      r4bvaluesets.specimencontainedpreference_to_json(preference),
    ),
  ]
  let fields = case handling {
    [] -> fields
    _ -> [
      #(
        "handling",
        json.array(handling, specimendefinition_typetested_handling_to_json),
      ),
      ..fields
    ]
  }
  let fields = case rejection_criterion {
    [] -> fields
    _ -> [
      #(
        "rejectionCriterion",
        json.array(rejection_criterion, codeableconcept_to_json),
      ),
      ..fields
    ]
  }
  let fields = case retention_time {
    Some(v) -> [#("retentionTime", duration_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case requirement {
    Some(v) -> [#("requirement", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case container {
    Some(v) -> [
      #("container", specimendefinition_typetested_container_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case is_derived {
    Some(v) -> [#("isDerived", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn specimendefinition_typetested_decoder() -> Decoder(
  SpecimendefinitionTypetested,
) {
  use handling <- decode.optional_field(
    "handling",
    [],
    decode.list(specimendefinition_typetested_handling_decoder()),
  )
  use rejection_criterion <- decode.optional_field(
    "rejectionCriterion",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use retention_time <- decode.optional_field(
    "retentionTime",
    None,
    decode.optional(duration_decoder()),
  )
  use requirement <- decode.optional_field(
    "requirement",
    None,
    decode.optional(decode.string),
  )
  use container <- decode.optional_field(
    "container",
    None,
    decode.optional(specimendefinition_typetested_container_decoder()),
  )
  use preference <- decode.field(
    "preference",
    r4bvaluesets.specimencontainedpreference_decoder(),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use is_derived <- decode.optional_field(
    "isDerived",
    None,
    decode.optional(decode.bool),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(SpecimendefinitionTypetested(
    handling:,
    rejection_criterion:,
    retention_time:,
    requirement:,
    container:,
    preference:,
    type_:,
    is_derived:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn specimendefinition_to_json(
  specimendefinition: Specimendefinition,
) -> Json {
  let Specimendefinition(
    type_tested:,
    collection:,
    time_aspect:,
    patient_preparation:,
    type_collected:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = specimendefinition
  let fields = []
  let fields = case type_tested {
    [] -> fields
    _ -> [
      #(
        "typeTested",
        json.array(type_tested, specimendefinition_typetested_to_json),
      ),
      ..fields
    ]
  }
  let fields = case collection {
    [] -> fields
    _ -> [
      #("collection", json.array(collection, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case time_aspect {
    Some(v) -> [#("timeAspect", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case patient_preparation {
    [] -> fields
    _ -> [
      #(
        "patientPreparation",
        json.array(patient_preparation, codeableconcept_to_json),
      ),
      ..fields
    ]
  }
  let fields = case type_collected {
    Some(v) -> [#("typeCollected", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    Some(v) -> [#("identifier", identifier_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Specimendefinition")), ..fields]
  json.object(fields)
}

pub fn specimendefinition_decoder() -> Decoder(Specimendefinition) {
  use type_tested <- decode.optional_field(
    "typeTested",
    [],
    decode.list(specimendefinition_typetested_decoder()),
  )
  use collection <- decode.optional_field(
    "collection",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use time_aspect <- decode.optional_field(
    "timeAspect",
    None,
    decode.optional(decode.string),
  )
  use patient_preparation <- decode.optional_field(
    "patientPreparation",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use type_collected <- decode.optional_field(
    "typeCollected",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use identifier <- decode.optional_field(
    "identifier",
    None,
    decode.optional(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Specimendefinition",
    decode.failure(specimendefinition_new(), "resourceType"),
  )
  decode.success(Specimendefinition(
    type_tested:,
    collection:,
    time_aspect:,
    patient_preparation:,
    type_collected:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/StructureDefinition#resource
pub type Structuredefinition {
  Structuredefinition(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    url: String,
    identifier: List(Identifier),
    version: Option(String),
    name: String,
    title: Option(String),
    status: r4bvaluesets.Publicationstatus,
    experimental: Option(Bool),
    date: Option(String),
    publisher: Option(String),
    contact: List(Contactdetail),
    description: Option(String),
    use_context: List(Usagecontext),
    jurisdiction: List(Codeableconcept),
    purpose: Option(String),
    copyright: Option(String),
    keyword: List(Coding),
    fhir_version: Option(r4bvaluesets.Fhirversion),
    mapping: List(StructuredefinitionMapping),
    kind: r4bvaluesets.Structuredefinitionkind,
    abstract: Bool,
    context: List(StructuredefinitionContext),
    context_invariant: List(String),
    type_: String,
    base_definition: Option(String),
    derivation: Option(r4bvaluesets.Typederivationrule),
    snapshot: Option(StructuredefinitionSnapshot),
    differential: Option(StructuredefinitionDifferential),
  )
}

pub fn structuredefinition_new(
  type_ type_: String,
  abstract abstract: Bool,
  kind kind: r4bvaluesets.Structuredefinitionkind,
  status status: r4bvaluesets.Publicationstatus,
  name name: String,
  url url: String,
) -> Structuredefinition {
  Structuredefinition(
    differential: None,
    snapshot: None,
    derivation: None,
    base_definition: None,
    type_:,
    context_invariant: [],
    context: [],
    abstract:,
    kind:,
    mapping: [],
    fhir_version: None,
    keyword: [],
    copyright: None,
    purpose: None,
    jurisdiction: [],
    use_context: [],
    description: None,
    contact: [],
    publisher: None,
    date: None,
    experimental: None,
    status:,
    title: None,
    name:,
    version: None,
    identifier: [],
    url:,
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/StructureDefinition#resource
pub type StructuredefinitionMapping {
  StructuredefinitionMapping(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identity: String,
    uri: Option(String),
    name: Option(String),
    comment: Option(String),
  )
}

pub fn structuredefinition_mapping_new(
  identity identity: String,
) -> StructuredefinitionMapping {
  StructuredefinitionMapping(
    comment: None,
    name: None,
    uri: None,
    identity:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/StructureDefinition#resource
pub type StructuredefinitionContext {
  StructuredefinitionContext(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: r4bvaluesets.Extensioncontexttype,
    expression: String,
  )
}

pub fn structuredefinition_context_new(
  expression expression: String,
  type_ type_: r4bvaluesets.Extensioncontexttype,
) -> StructuredefinitionContext {
  StructuredefinitionContext(
    expression:,
    type_:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/StructureDefinition#resource
pub type StructuredefinitionSnapshot {
  StructuredefinitionSnapshot(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    element: List(Elementdefinition),
  )
}

pub fn structuredefinition_snapshot_new() -> StructuredefinitionSnapshot {
  StructuredefinitionSnapshot(
    element: [],
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/StructureDefinition#resource
pub type StructuredefinitionDifferential {
  StructuredefinitionDifferential(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    element: List(Elementdefinition),
  )
}

pub fn structuredefinition_differential_new() -> StructuredefinitionDifferential {
  StructuredefinitionDifferential(
    element: [],
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn structuredefinition_differential_to_json(
  structuredefinition_differential: StructuredefinitionDifferential,
) -> Json {
  let StructuredefinitionDifferential(
    element:,
    modifier_extension:,
    extension:,
    id:,
  ) = structuredefinition_differential
  let fields = []
  let fields = case element {
    [] -> fields
    _ -> [
      #("element", json.array(element, elementdefinition_to_json)),
      ..fields
    ]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn structuredefinition_differential_decoder() -> Decoder(
  StructuredefinitionDifferential,
) {
  use element <- decode.optional_field(
    "element",
    [],
    decode.list(elementdefinition_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(StructuredefinitionDifferential(
    element:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn structuredefinition_snapshot_to_json(
  structuredefinition_snapshot: StructuredefinitionSnapshot,
) -> Json {
  let StructuredefinitionSnapshot(
    element:,
    modifier_extension:,
    extension:,
    id:,
  ) = structuredefinition_snapshot
  let fields = []
  let fields = case element {
    [] -> fields
    _ -> [
      #("element", json.array(element, elementdefinition_to_json)),
      ..fields
    ]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn structuredefinition_snapshot_decoder() -> Decoder(
  StructuredefinitionSnapshot,
) {
  use element <- decode.optional_field(
    "element",
    [],
    decode.list(elementdefinition_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(StructuredefinitionSnapshot(
    element:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn structuredefinition_context_to_json(
  structuredefinition_context: StructuredefinitionContext,
) -> Json {
  let StructuredefinitionContext(
    expression:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = structuredefinition_context
  let fields = [
    #("expression", json.string(expression)),
    #("type", r4bvaluesets.extensioncontexttype_to_json(type_)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn structuredefinition_context_decoder() -> Decoder(
  StructuredefinitionContext,
) {
  use expression <- decode.field("expression", decode.string)
  use type_ <- decode.field("type", r4bvaluesets.extensioncontexttype_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(StructuredefinitionContext(
    expression:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn structuredefinition_mapping_to_json(
  structuredefinition_mapping: StructuredefinitionMapping,
) -> Json {
  let StructuredefinitionMapping(
    comment:,
    name:,
    uri:,
    identity:,
    modifier_extension:,
    extension:,
    id:,
  ) = structuredefinition_mapping
  let fields = [
    #("identity", json.string(identity)),
  ]
  let fields = case comment {
    Some(v) -> [#("comment", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case uri {
    Some(v) -> [#("uri", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn structuredefinition_mapping_decoder() -> Decoder(
  StructuredefinitionMapping,
) {
  use comment <- decode.optional_field(
    "comment",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use uri <- decode.optional_field("uri", None, decode.optional(decode.string))
  use identity <- decode.field("identity", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(StructuredefinitionMapping(
    comment:,
    name:,
    uri:,
    identity:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn structuredefinition_to_json(
  structuredefinition: Structuredefinition,
) -> Json {
  let Structuredefinition(
    differential:,
    snapshot:,
    derivation:,
    base_definition:,
    type_:,
    context_invariant:,
    context:,
    abstract:,
    kind:,
    mapping:,
    fhir_version:,
    keyword:,
    copyright:,
    purpose:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    experimental:,
    status:,
    title:,
    name:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = structuredefinition
  let fields = [
    #("type", json.string(type_)),
    #("abstract", json.bool(abstract)),
    #("kind", r4bvaluesets.structuredefinitionkind_to_json(kind)),
    #("status", r4bvaluesets.publicationstatus_to_json(status)),
    #("name", json.string(name)),
    #("url", json.string(url)),
  ]
  let fields = case differential {
    Some(v) -> [
      #("differential", structuredefinition_differential_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case snapshot {
    Some(v) -> [
      #("snapshot", structuredefinition_snapshot_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case derivation {
    Some(v) -> [
      #("derivation", r4bvaluesets.typederivationrule_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case base_definition {
    Some(v) -> [#("baseDefinition", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case context_invariant {
    [] -> fields
    _ -> [
      #("contextInvariant", json.array(context_invariant, json.string)),
      ..fields
    ]
  }
  let fields = case context {
    [] -> fields
    _ -> [
      #("context", json.array(context, structuredefinition_context_to_json)),
      ..fields
    ]
  }
  let fields = case mapping {
    [] -> fields
    _ -> [
      #("mapping", json.array(mapping, structuredefinition_mapping_to_json)),
      ..fields
    ]
  }
  let fields = case fhir_version {
    Some(v) -> [#("fhirVersion", r4bvaluesets.fhirversion_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case keyword {
    [] -> fields
    _ -> [#("keyword", json.array(keyword, coding_to_json)), ..fields]
  }
  let fields = case copyright {
    Some(v) -> [#("copyright", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case purpose {
    Some(v) -> [#("purpose", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case jurisdiction {
    [] -> fields
    _ -> [
      #("jurisdiction", json.array(jurisdiction, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case use_context {
    [] -> fields
    _ -> [
      #("useContext", json.array(use_context, usagecontext_to_json)),
      ..fields
    ]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case contact {
    [] -> fields
    _ -> [#("contact", json.array(contact, contactdetail_to_json)), ..fields]
  }
  let fields = case publisher {
    Some(v) -> [#("publisher", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case date {
    Some(v) -> [#("date", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case experimental {
    Some(v) -> [#("experimental", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case title {
    Some(v) -> [#("title", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case version {
    Some(v) -> [#("version", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Structuredefinition")), ..fields]
  json.object(fields)
}

pub fn structuredefinition_decoder() -> Decoder(Structuredefinition) {
  use differential <- decode.optional_field(
    "differential",
    None,
    decode.optional(structuredefinition_differential_decoder()),
  )
  use snapshot <- decode.optional_field(
    "snapshot",
    None,
    decode.optional(structuredefinition_snapshot_decoder()),
  )
  use derivation <- decode.optional_field(
    "derivation",
    None,
    decode.optional(r4bvaluesets.typederivationrule_decoder()),
  )
  use base_definition <- decode.optional_field(
    "baseDefinition",
    None,
    decode.optional(decode.string),
  )
  use type_ <- decode.field("type", decode.string)
  use context_invariant <- decode.optional_field(
    "contextInvariant",
    [],
    decode.list(decode.string),
  )
  use context <- decode.optional_field(
    "context",
    [],
    decode.list(structuredefinition_context_decoder()),
  )
  use abstract <- decode.field("abstract", decode.bool)
  use kind <- decode.field(
    "kind",
    r4bvaluesets.structuredefinitionkind_decoder(),
  )
  use mapping <- decode.optional_field(
    "mapping",
    [],
    decode.list(structuredefinition_mapping_decoder()),
  )
  use fhir_version <- decode.optional_field(
    "fhirVersion",
    None,
    decode.optional(r4bvaluesets.fhirversion_decoder()),
  )
  use keyword <- decode.optional_field(
    "keyword",
    [],
    decode.list(coding_decoder()),
  )
  use copyright <- decode.optional_field(
    "copyright",
    None,
    decode.optional(decode.string),
  )
  use purpose <- decode.optional_field(
    "purpose",
    None,
    decode.optional(decode.string),
  )
  use jurisdiction <- decode.optional_field(
    "jurisdiction",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use use_context <- decode.optional_field(
    "useContext",
    [],
    decode.list(usagecontext_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use contact <- decode.optional_field(
    "contact",
    [],
    decode.list(contactdetail_decoder()),
  )
  use publisher <- decode.optional_field(
    "publisher",
    None,
    decode.optional(decode.string),
  )
  use date <- decode.optional_field(
    "date",
    None,
    decode.optional(decode.string),
  )
  use experimental <- decode.optional_field(
    "experimental",
    None,
    decode.optional(decode.bool),
  )
  use status <- decode.field("status", r4bvaluesets.publicationstatus_decoder())
  use title <- decode.optional_field(
    "title",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.field("name", decode.string)
  use version <- decode.optional_field(
    "version",
    None,
    decode.optional(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use url <- decode.field("url", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Structuredefinition",
    decode.failure(
      structuredefinition_new(type_:, abstract:, kind:, status:, name:, url:),
      "resourceType",
    ),
  )
  decode.success(Structuredefinition(
    differential:,
    snapshot:,
    derivation:,
    base_definition:,
    type_:,
    context_invariant:,
    context:,
    abstract:,
    kind:,
    mapping:,
    fhir_version:,
    keyword:,
    copyright:,
    purpose:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    experimental:,
    status:,
    title:,
    name:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/StructureMap#resource
pub type Structuremap {
  Structuremap(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    url: String,
    identifier: List(Identifier),
    version: Option(String),
    name: String,
    title: Option(String),
    status: r4bvaluesets.Publicationstatus,
    experimental: Option(Bool),
    date: Option(String),
    publisher: Option(String),
    contact: List(Contactdetail),
    description: Option(String),
    use_context: List(Usagecontext),
    jurisdiction: List(Codeableconcept),
    purpose: Option(String),
    copyright: Option(String),
    structure: List(StructuremapStructure),
    import_: List(String),
    group: List(StructuremapGroup),
  )
}

pub fn structuremap_new(
  status status: r4bvaluesets.Publicationstatus,
  name name: String,
  url url: String,
) -> Structuremap {
  Structuremap(
    group: [],
    import_: [],
    structure: [],
    copyright: None,
    purpose: None,
    jurisdiction: [],
    use_context: [],
    description: None,
    contact: [],
    publisher: None,
    date: None,
    experimental: None,
    status:,
    title: None,
    name:,
    version: None,
    identifier: [],
    url:,
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/StructureMap#resource
pub type StructuremapStructure {
  StructuremapStructure(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    url: String,
    mode: r4bvaluesets.Mapmodelmode,
    alias: Option(String),
    documentation: Option(String),
  )
}

pub fn structuremap_structure_new(
  mode mode: r4bvaluesets.Mapmodelmode,
  url url: String,
) -> StructuremapStructure {
  StructuremapStructure(
    documentation: None,
    alias: None,
    mode:,
    url:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/StructureMap#resource
pub type StructuremapGroup {
  StructuremapGroup(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    name: String,
    extends: Option(String),
    type_mode: r4bvaluesets.Mapgrouptypemode,
    documentation: Option(String),
    input: List(StructuremapGroupInput),
    rule: List(StructuremapGroupRule),
  )
}

pub fn structuremap_group_new(
  type_mode type_mode: r4bvaluesets.Mapgrouptypemode,
  name name: String,
) -> StructuremapGroup {
  StructuremapGroup(
    rule: [],
    input: [],
    documentation: None,
    type_mode:,
    extends: None,
    name:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/StructureMap#resource
pub type StructuremapGroupInput {
  StructuremapGroupInput(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    name: String,
    type_: Option(String),
    mode: r4bvaluesets.Mapinputmode,
    documentation: Option(String),
  )
}

pub fn structuremap_group_input_new(
  mode mode: r4bvaluesets.Mapinputmode,
  name name: String,
) -> StructuremapGroupInput {
  StructuremapGroupInput(
    documentation: None,
    mode:,
    type_: None,
    name:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/StructureMap#resource
pub type StructuremapGroupRule {
  StructuremapGroupRule(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    name: String,
    source: List(StructuremapGroupRuleSource),
    target: List(StructuremapGroupRuleTarget),
    dependent: List(StructuremapGroupRuleDependent),
    documentation: Option(String),
  )
}

pub fn structuremap_group_rule_new(name name: String) -> StructuremapGroupRule {
  StructuremapGroupRule(
    documentation: None,
    dependent: [],
    target: [],
    source: [],
    name:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/StructureMap#resource
pub type StructuremapGroupRuleSource {
  StructuremapGroupRuleSource(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    context: String,
    min: Option(Int),
    max: Option(String),
    type_: Option(String),
    default_value: Option(StructuremapGroupRuleSourceDefaultvalue),
    element: Option(String),
    list_mode: Option(r4bvaluesets.Mapsourcelistmode),
    variable: Option(String),
    condition: Option(String),
    check: Option(String),
    log_message: Option(String),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/StructureMap#resource
pub type StructuremapGroupRuleSourceDefaultvalue {
  StructuremapGroupRuleSourceDefaultvalueBase64binary(default_value: String)
  StructuremapGroupRuleSourceDefaultvalueBoolean(default_value: Bool)
  StructuremapGroupRuleSourceDefaultvalueCanonical(default_value: String)
  StructuremapGroupRuleSourceDefaultvalueCode(default_value: String)
  StructuremapGroupRuleSourceDefaultvalueDate(default_value: String)
  StructuremapGroupRuleSourceDefaultvalueDatetime(default_value: String)
  StructuremapGroupRuleSourceDefaultvalueDecimal(default_value: Float)
  StructuremapGroupRuleSourceDefaultvalueId(default_value: String)
  StructuremapGroupRuleSourceDefaultvalueInstant(default_value: String)
  StructuremapGroupRuleSourceDefaultvalueInteger(default_value: Int)
  StructuremapGroupRuleSourceDefaultvalueMarkdown(default_value: String)
  StructuremapGroupRuleSourceDefaultvalueOid(default_value: String)
  StructuremapGroupRuleSourceDefaultvaluePositiveint(default_value: Int)
  StructuremapGroupRuleSourceDefaultvalueString(default_value: String)
  StructuremapGroupRuleSourceDefaultvalueTime(default_value: String)
  StructuremapGroupRuleSourceDefaultvalueUnsignedint(default_value: Int)
  StructuremapGroupRuleSourceDefaultvalueUri(default_value: String)
  StructuremapGroupRuleSourceDefaultvalueUrl(default_value: String)
  StructuremapGroupRuleSourceDefaultvalueUuid(default_value: String)
  StructuremapGroupRuleSourceDefaultvalueAddress(default_value: Address)
  StructuremapGroupRuleSourceDefaultvalueAge(default_value: Age)
  StructuremapGroupRuleSourceDefaultvalueAnnotation(default_value: Annotation)
  StructuremapGroupRuleSourceDefaultvalueAttachment(default_value: Attachment)
  StructuremapGroupRuleSourceDefaultvalueCodeableconcept(
    default_value: Codeableconcept,
  )
  StructuremapGroupRuleSourceDefaultvalueCoding(default_value: Coding)
  StructuremapGroupRuleSourceDefaultvalueContactpoint(
    default_value: Contactpoint,
  )
  StructuremapGroupRuleSourceDefaultvalueCount(default_value: Count)
  StructuremapGroupRuleSourceDefaultvalueDistance(default_value: Distance)
  StructuremapGroupRuleSourceDefaultvalueDuration(default_value: Duration)
  StructuremapGroupRuleSourceDefaultvalueHumanname(default_value: Humanname)
  StructuremapGroupRuleSourceDefaultvalueIdentifier(default_value: Identifier)
  StructuremapGroupRuleSourceDefaultvalueMoney(default_value: Money)
  StructuremapGroupRuleSourceDefaultvaluePeriod(default_value: Period)
  StructuremapGroupRuleSourceDefaultvalueQuantity(default_value: Quantity)
  StructuremapGroupRuleSourceDefaultvalueRange(default_value: Range)
  StructuremapGroupRuleSourceDefaultvalueRatio(default_value: Ratio)
  StructuremapGroupRuleSourceDefaultvalueReference(default_value: Reference)
  StructuremapGroupRuleSourceDefaultvalueSampleddata(default_value: Sampleddata)
  StructuremapGroupRuleSourceDefaultvalueSignature(default_value: Signature)
  StructuremapGroupRuleSourceDefaultvalueTiming(default_value: Timing)
  StructuremapGroupRuleSourceDefaultvalueContactdetail(
    default_value: Contactdetail,
  )
  StructuremapGroupRuleSourceDefaultvalueContributor(default_value: Contributor)
  StructuremapGroupRuleSourceDefaultvalueDatarequirement(
    default_value: Datarequirement,
  )
  StructuremapGroupRuleSourceDefaultvalueExpression(default_value: Expression)
  StructuremapGroupRuleSourceDefaultvalueParameterdefinition(
    default_value: Parameterdefinition,
  )
  StructuremapGroupRuleSourceDefaultvalueRelatedartifact(
    default_value: Relatedartifact,
  )
  StructuremapGroupRuleSourceDefaultvalueTriggerdefinition(
    default_value: Triggerdefinition,
  )
  StructuremapGroupRuleSourceDefaultvalueUsagecontext(
    default_value: Usagecontext,
  )
  StructuremapGroupRuleSourceDefaultvalueDosage(default_value: Dosage)
  StructuremapGroupRuleSourceDefaultvalueMeta(default_value: Meta)
}

pub fn structuremap_group_rule_source_defaultvalue_to_json(
  elt: StructuremapGroupRuleSourceDefaultvalue,
) -> Json {
  case elt {
    StructuremapGroupRuleSourceDefaultvalueBase64binary(v) -> json.string(v)
    StructuremapGroupRuleSourceDefaultvalueBoolean(v) -> json.bool(v)
    StructuremapGroupRuleSourceDefaultvalueCanonical(v) -> json.string(v)
    StructuremapGroupRuleSourceDefaultvalueCode(v) -> json.string(v)
    StructuremapGroupRuleSourceDefaultvalueDate(v) -> json.string(v)
    StructuremapGroupRuleSourceDefaultvalueDatetime(v) -> json.string(v)
    StructuremapGroupRuleSourceDefaultvalueDecimal(v) -> json.float(v)
    StructuremapGroupRuleSourceDefaultvalueId(v) -> json.string(v)
    StructuremapGroupRuleSourceDefaultvalueInstant(v) -> json.string(v)
    StructuremapGroupRuleSourceDefaultvalueInteger(v) -> json.int(v)
    StructuremapGroupRuleSourceDefaultvalueMarkdown(v) -> json.string(v)
    StructuremapGroupRuleSourceDefaultvalueOid(v) -> json.string(v)
    StructuremapGroupRuleSourceDefaultvaluePositiveint(v) -> json.int(v)
    StructuremapGroupRuleSourceDefaultvalueString(v) -> json.string(v)
    StructuremapGroupRuleSourceDefaultvalueTime(v) -> json.string(v)
    StructuremapGroupRuleSourceDefaultvalueUnsignedint(v) -> json.int(v)
    StructuremapGroupRuleSourceDefaultvalueUri(v) -> json.string(v)
    StructuremapGroupRuleSourceDefaultvalueUrl(v) -> json.string(v)
    StructuremapGroupRuleSourceDefaultvalueUuid(v) -> json.string(v)
    StructuremapGroupRuleSourceDefaultvalueAddress(v) -> address_to_json(v)
    StructuremapGroupRuleSourceDefaultvalueAge(v) -> age_to_json(v)
    StructuremapGroupRuleSourceDefaultvalueAnnotation(v) ->
      annotation_to_json(v)
    StructuremapGroupRuleSourceDefaultvalueAttachment(v) ->
      attachment_to_json(v)
    StructuremapGroupRuleSourceDefaultvalueCodeableconcept(v) ->
      codeableconcept_to_json(v)
    StructuremapGroupRuleSourceDefaultvalueCoding(v) -> coding_to_json(v)
    StructuremapGroupRuleSourceDefaultvalueContactpoint(v) ->
      contactpoint_to_json(v)
    StructuremapGroupRuleSourceDefaultvalueCount(v) -> count_to_json(v)
    StructuremapGroupRuleSourceDefaultvalueDistance(v) -> distance_to_json(v)
    StructuremapGroupRuleSourceDefaultvalueDuration(v) -> duration_to_json(v)
    StructuremapGroupRuleSourceDefaultvalueHumanname(v) -> humanname_to_json(v)
    StructuremapGroupRuleSourceDefaultvalueIdentifier(v) ->
      identifier_to_json(v)
    StructuremapGroupRuleSourceDefaultvalueMoney(v) -> money_to_json(v)
    StructuremapGroupRuleSourceDefaultvaluePeriod(v) -> period_to_json(v)
    StructuremapGroupRuleSourceDefaultvalueQuantity(v) -> quantity_to_json(v)
    StructuremapGroupRuleSourceDefaultvalueRange(v) -> range_to_json(v)
    StructuremapGroupRuleSourceDefaultvalueRatio(v) -> ratio_to_json(v)
    StructuremapGroupRuleSourceDefaultvalueReference(v) -> reference_to_json(v)
    StructuremapGroupRuleSourceDefaultvalueSampleddata(v) ->
      sampleddata_to_json(v)
    StructuremapGroupRuleSourceDefaultvalueSignature(v) -> signature_to_json(v)
    StructuremapGroupRuleSourceDefaultvalueTiming(v) -> timing_to_json(v)
    StructuremapGroupRuleSourceDefaultvalueContactdetail(v) ->
      contactdetail_to_json(v)
    StructuremapGroupRuleSourceDefaultvalueContributor(v) ->
      contributor_to_json(v)
    StructuremapGroupRuleSourceDefaultvalueDatarequirement(v) ->
      datarequirement_to_json(v)
    StructuremapGroupRuleSourceDefaultvalueExpression(v) ->
      expression_to_json(v)
    StructuremapGroupRuleSourceDefaultvalueParameterdefinition(v) ->
      parameterdefinition_to_json(v)
    StructuremapGroupRuleSourceDefaultvalueRelatedartifact(v) ->
      relatedartifact_to_json(v)
    StructuremapGroupRuleSourceDefaultvalueTriggerdefinition(v) ->
      triggerdefinition_to_json(v)
    StructuremapGroupRuleSourceDefaultvalueUsagecontext(v) ->
      usagecontext_to_json(v)
    StructuremapGroupRuleSourceDefaultvalueDosage(v) -> dosage_to_json(v)
    StructuremapGroupRuleSourceDefaultvalueMeta(v) -> meta_to_json(v)
  }
}

pub fn structuremap_group_rule_source_defaultvalue_decoder() -> Decoder(
  StructuremapGroupRuleSourceDefaultvalue,
) {
  decode.one_of(
    decode.field("defaultValueBase64Binary", decode.string, decode.success)
      |> decode.map(StructuremapGroupRuleSourceDefaultvalueBase64binary),
    [
      decode.field("defaultValueBoolean", decode.bool, decode.success)
        |> decode.map(StructuremapGroupRuleSourceDefaultvalueBoolean),
      decode.field("defaultValueCanonical", decode.string, decode.success)
        |> decode.map(StructuremapGroupRuleSourceDefaultvalueCanonical),
      decode.field("defaultValueCode", decode.string, decode.success)
        |> decode.map(StructuremapGroupRuleSourceDefaultvalueCode),
      decode.field("defaultValueDate", decode.string, decode.success)
        |> decode.map(StructuremapGroupRuleSourceDefaultvalueDate),
      decode.field("defaultValueDateTime", decode.string, decode.success)
        |> decode.map(StructuremapGroupRuleSourceDefaultvalueDatetime),
      decode.field("defaultValueDecimal", decode.float, decode.success)
        |> decode.map(StructuremapGroupRuleSourceDefaultvalueDecimal),
      decode.field("defaultValueId", decode.string, decode.success)
        |> decode.map(StructuremapGroupRuleSourceDefaultvalueId),
      decode.field("defaultValueInstant", decode.string, decode.success)
        |> decode.map(StructuremapGroupRuleSourceDefaultvalueInstant),
      decode.field("defaultValueInteger", decode.int, decode.success)
        |> decode.map(StructuremapGroupRuleSourceDefaultvalueInteger),
      decode.field("defaultValueMarkdown", decode.string, decode.success)
        |> decode.map(StructuremapGroupRuleSourceDefaultvalueMarkdown),
      decode.field("defaultValueOid", decode.string, decode.success)
        |> decode.map(StructuremapGroupRuleSourceDefaultvalueOid),
      decode.field("defaultValuePositiveInt", decode.int, decode.success)
        |> decode.map(StructuremapGroupRuleSourceDefaultvaluePositiveint),
      decode.field("defaultValueString", decode.string, decode.success)
        |> decode.map(StructuremapGroupRuleSourceDefaultvalueString),
      decode.field("defaultValueTime", decode.string, decode.success)
        |> decode.map(StructuremapGroupRuleSourceDefaultvalueTime),
      decode.field("defaultValueUnsignedInt", decode.int, decode.success)
        |> decode.map(StructuremapGroupRuleSourceDefaultvalueUnsignedint),
      decode.field("defaultValueUri", decode.string, decode.success)
        |> decode.map(StructuremapGroupRuleSourceDefaultvalueUri),
      decode.field("defaultValueUrl", decode.string, decode.success)
        |> decode.map(StructuremapGroupRuleSourceDefaultvalueUrl),
      decode.field("defaultValueUuid", decode.string, decode.success)
        |> decode.map(StructuremapGroupRuleSourceDefaultvalueUuid),
      decode.field("defaultValueAddress", address_decoder(), decode.success)
        |> decode.map(StructuremapGroupRuleSourceDefaultvalueAddress),
      decode.field("defaultValueAge", age_decoder(), decode.success)
        |> decode.map(StructuremapGroupRuleSourceDefaultvalueAge),
      decode.field(
        "defaultValueAnnotation",
        annotation_decoder(),
        decode.success,
      )
        |> decode.map(StructuremapGroupRuleSourceDefaultvalueAnnotation),
      decode.field(
        "defaultValueAttachment",
        attachment_decoder(),
        decode.success,
      )
        |> decode.map(StructuremapGroupRuleSourceDefaultvalueAttachment),
      decode.field(
        "defaultValueCodeableConcept",
        codeableconcept_decoder(),
        decode.success,
      )
        |> decode.map(StructuremapGroupRuleSourceDefaultvalueCodeableconcept),
      decode.field("defaultValueCoding", coding_decoder(), decode.success)
        |> decode.map(StructuremapGroupRuleSourceDefaultvalueCoding),
      decode.field(
        "defaultValueContactPoint",
        contactpoint_decoder(),
        decode.success,
      )
        |> decode.map(StructuremapGroupRuleSourceDefaultvalueContactpoint),
      decode.field("defaultValueCount", count_decoder(), decode.success)
        |> decode.map(StructuremapGroupRuleSourceDefaultvalueCount),
      decode.field("defaultValueDistance", distance_decoder(), decode.success)
        |> decode.map(StructuremapGroupRuleSourceDefaultvalueDistance),
      decode.field("defaultValueDuration", duration_decoder(), decode.success)
        |> decode.map(StructuremapGroupRuleSourceDefaultvalueDuration),
      decode.field("defaultValueHumanName", humanname_decoder(), decode.success)
        |> decode.map(StructuremapGroupRuleSourceDefaultvalueHumanname),
      decode.field(
        "defaultValueIdentifier",
        identifier_decoder(),
        decode.success,
      )
        |> decode.map(StructuremapGroupRuleSourceDefaultvalueIdentifier),
      decode.field("defaultValueMoney", money_decoder(), decode.success)
        |> decode.map(StructuremapGroupRuleSourceDefaultvalueMoney),
      decode.field("defaultValuePeriod", period_decoder(), decode.success)
        |> decode.map(StructuremapGroupRuleSourceDefaultvaluePeriod),
      decode.field("defaultValueQuantity", quantity_decoder(), decode.success)
        |> decode.map(StructuremapGroupRuleSourceDefaultvalueQuantity),
      decode.field("defaultValueRange", range_decoder(), decode.success)
        |> decode.map(StructuremapGroupRuleSourceDefaultvalueRange),
      decode.field("defaultValueRatio", ratio_decoder(), decode.success)
        |> decode.map(StructuremapGroupRuleSourceDefaultvalueRatio),
      decode.field("defaultValueReference", reference_decoder(), decode.success)
        |> decode.map(StructuremapGroupRuleSourceDefaultvalueReference),
      decode.field(
        "defaultValueSampledData",
        sampleddata_decoder(),
        decode.success,
      )
        |> decode.map(StructuremapGroupRuleSourceDefaultvalueSampleddata),
      decode.field("defaultValueSignature", signature_decoder(), decode.success)
        |> decode.map(StructuremapGroupRuleSourceDefaultvalueSignature),
      decode.field("defaultValueTiming", timing_decoder(), decode.success)
        |> decode.map(StructuremapGroupRuleSourceDefaultvalueTiming),
      decode.field(
        "defaultValueContactDetail",
        contactdetail_decoder(),
        decode.success,
      )
        |> decode.map(StructuremapGroupRuleSourceDefaultvalueContactdetail),
      decode.field(
        "defaultValueContributor",
        contributor_decoder(),
        decode.success,
      )
        |> decode.map(StructuremapGroupRuleSourceDefaultvalueContributor),
      decode.field(
        "defaultValueDataRequirement",
        datarequirement_decoder(),
        decode.success,
      )
        |> decode.map(StructuremapGroupRuleSourceDefaultvalueDatarequirement),
      decode.field(
        "defaultValueExpression",
        expression_decoder(),
        decode.success,
      )
        |> decode.map(StructuremapGroupRuleSourceDefaultvalueExpression),
      decode.field(
        "defaultValueParameterDefinition",
        parameterdefinition_decoder(),
        decode.success,
      )
        |> decode.map(
          StructuremapGroupRuleSourceDefaultvalueParameterdefinition,
        ),
      decode.field(
        "defaultValueRelatedArtifact",
        relatedartifact_decoder(),
        decode.success,
      )
        |> decode.map(StructuremapGroupRuleSourceDefaultvalueRelatedartifact),
      decode.field(
        "defaultValueTriggerDefinition",
        triggerdefinition_decoder(),
        decode.success,
      )
        |> decode.map(StructuremapGroupRuleSourceDefaultvalueTriggerdefinition),
      decode.field(
        "defaultValueUsageContext",
        usagecontext_decoder(),
        decode.success,
      )
        |> decode.map(StructuremapGroupRuleSourceDefaultvalueUsagecontext),
      decode.field("defaultValueDosage", dosage_decoder(), decode.success)
        |> decode.map(StructuremapGroupRuleSourceDefaultvalueDosage),
      decode.field("defaultValueMeta", meta_decoder(), decode.success)
        |> decode.map(StructuremapGroupRuleSourceDefaultvalueMeta),
    ],
  )
}

pub fn structuremap_group_rule_source_new(
  context context: String,
) -> StructuremapGroupRuleSource {
  StructuremapGroupRuleSource(
    log_message: None,
    check: None,
    condition: None,
    variable: None,
    list_mode: None,
    element: None,
    default_value: None,
    type_: None,
    max: None,
    min: None,
    context:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/StructureMap#resource
pub type StructuremapGroupRuleTarget {
  StructuremapGroupRuleTarget(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    context: Option(String),
    context_type: Option(r4bvaluesets.Mapcontexttype),
    element: Option(String),
    variable: Option(String),
    list_mode: List(r4bvaluesets.Maptargetlistmode),
    list_rule_id: Option(String),
    transform: Option(r4bvaluesets.Maptransform),
    parameter: List(StructuremapGroupRuleTargetParameter),
  )
}

pub fn structuremap_group_rule_target_new() -> StructuremapGroupRuleTarget {
  StructuremapGroupRuleTarget(
    parameter: [],
    transform: None,
    list_rule_id: None,
    list_mode: [],
    variable: None,
    element: None,
    context_type: None,
    context: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/StructureMap#resource
pub type StructuremapGroupRuleTargetParameter {
  StructuremapGroupRuleTargetParameter(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    value: StructuremapGroupRuleTargetParameterValue,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/StructureMap#resource
pub type StructuremapGroupRuleTargetParameterValue {
  StructuremapGroupRuleTargetParameterValueId(value: String)
  StructuremapGroupRuleTargetParameterValueString(value: String)
  StructuremapGroupRuleTargetParameterValueBoolean(value: Bool)
  StructuremapGroupRuleTargetParameterValueInteger(value: Int)
  StructuremapGroupRuleTargetParameterValueDecimal(value: Float)
}

pub fn structuremap_group_rule_target_parameter_value_to_json(
  elt: StructuremapGroupRuleTargetParameterValue,
) -> Json {
  case elt {
    StructuremapGroupRuleTargetParameterValueId(v) -> json.string(v)
    StructuremapGroupRuleTargetParameterValueString(v) -> json.string(v)
    StructuremapGroupRuleTargetParameterValueBoolean(v) -> json.bool(v)
    StructuremapGroupRuleTargetParameterValueInteger(v) -> json.int(v)
    StructuremapGroupRuleTargetParameterValueDecimal(v) -> json.float(v)
  }
}

pub fn structuremap_group_rule_target_parameter_value_decoder() -> Decoder(
  StructuremapGroupRuleTargetParameterValue,
) {
  decode.one_of(
    decode.field("valueId", decode.string, decode.success)
      |> decode.map(StructuremapGroupRuleTargetParameterValueId),
    [
      decode.field("valueString", decode.string, decode.success)
        |> decode.map(StructuremapGroupRuleTargetParameterValueString),
      decode.field("valueBoolean", decode.bool, decode.success)
        |> decode.map(StructuremapGroupRuleTargetParameterValueBoolean),
      decode.field("valueInteger", decode.int, decode.success)
        |> decode.map(StructuremapGroupRuleTargetParameterValueInteger),
      decode.field("valueDecimal", decode.float, decode.success)
        |> decode.map(StructuremapGroupRuleTargetParameterValueDecimal),
    ],
  )
}

pub fn structuremap_group_rule_target_parameter_new(
  value value: StructuremapGroupRuleTargetParameterValue,
) -> StructuremapGroupRuleTargetParameter {
  StructuremapGroupRuleTargetParameter(
    value:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/StructureMap#resource
pub type StructuremapGroupRuleDependent {
  StructuremapGroupRuleDependent(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    name: String,
    variable: List(String),
  )
}

pub fn structuremap_group_rule_dependent_new(
  name name: String,
) -> StructuremapGroupRuleDependent {
  StructuremapGroupRuleDependent(
    variable: [],
    name:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn structuremap_group_rule_dependent_to_json(
  structuremap_group_rule_dependent: StructuremapGroupRuleDependent,
) -> Json {
  let StructuremapGroupRuleDependent(
    variable:,
    name:,
    modifier_extension:,
    extension:,
    id:,
  ) = structuremap_group_rule_dependent
  let fields = [
    #("name", json.string(name)),
  ]
  let fields = case variable {
    [] -> fields
    _ -> [#("variable", json.array(variable, json.string)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn structuremap_group_rule_dependent_decoder() -> Decoder(
  StructuremapGroupRuleDependent,
) {
  use variable <- decode.optional_field(
    "variable",
    [],
    decode.list(decode.string),
  )
  use name <- decode.field("name", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(StructuremapGroupRuleDependent(
    variable:,
    name:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn structuremap_group_rule_target_parameter_to_json(
  structuremap_group_rule_target_parameter: StructuremapGroupRuleTargetParameter,
) -> Json {
  let StructuremapGroupRuleTargetParameter(
    value:,
    modifier_extension:,
    extension:,
    id:,
  ) = structuremap_group_rule_target_parameter
  let fields = [
    #("value", structuremap_group_rule_target_parameter_value_to_json(value)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn structuremap_group_rule_target_parameter_decoder() -> Decoder(
  StructuremapGroupRuleTargetParameter,
) {
  use value <- decode.then(
    structuremap_group_rule_target_parameter_value_decoder(),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(StructuremapGroupRuleTargetParameter(
    value:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn structuremap_group_rule_target_to_json(
  structuremap_group_rule_target: StructuremapGroupRuleTarget,
) -> Json {
  let StructuremapGroupRuleTarget(
    parameter:,
    transform:,
    list_rule_id:,
    list_mode:,
    variable:,
    element:,
    context_type:,
    context:,
    modifier_extension:,
    extension:,
    id:,
  ) = structuremap_group_rule_target
  let fields = []
  let fields = case parameter {
    [] -> fields
    _ -> [
      #(
        "parameter",
        json.array(parameter, structuremap_group_rule_target_parameter_to_json),
      ),
      ..fields
    ]
  }
  let fields = case transform {
    Some(v) -> [#("transform", r4bvaluesets.maptransform_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case list_rule_id {
    Some(v) -> [#("listRuleId", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case list_mode {
    [] -> fields
    _ -> [
      #(
        "listMode",
        json.array(list_mode, r4bvaluesets.maptargetlistmode_to_json),
      ),
      ..fields
    ]
  }
  let fields = case variable {
    Some(v) -> [#("variable", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case element {
    Some(v) -> [#("element", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case context_type {
    Some(v) -> [
      #("contextType", r4bvaluesets.mapcontexttype_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case context {
    Some(v) -> [#("context", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn structuremap_group_rule_target_decoder() -> Decoder(
  StructuremapGroupRuleTarget,
) {
  use parameter <- decode.optional_field(
    "parameter",
    [],
    decode.list(structuremap_group_rule_target_parameter_decoder()),
  )
  use transform <- decode.optional_field(
    "transform",
    None,
    decode.optional(r4bvaluesets.maptransform_decoder()),
  )
  use list_rule_id <- decode.optional_field(
    "listRuleId",
    None,
    decode.optional(decode.string),
  )
  use list_mode <- decode.optional_field(
    "listMode",
    [],
    decode.list(r4bvaluesets.maptargetlistmode_decoder()),
  )
  use variable <- decode.optional_field(
    "variable",
    None,
    decode.optional(decode.string),
  )
  use element <- decode.optional_field(
    "element",
    None,
    decode.optional(decode.string),
  )
  use context_type <- decode.optional_field(
    "contextType",
    None,
    decode.optional(r4bvaluesets.mapcontexttype_decoder()),
  )
  use context <- decode.optional_field(
    "context",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(StructuremapGroupRuleTarget(
    parameter:,
    transform:,
    list_rule_id:,
    list_mode:,
    variable:,
    element:,
    context_type:,
    context:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn structuremap_group_rule_source_to_json(
  structuremap_group_rule_source: StructuremapGroupRuleSource,
) -> Json {
  let StructuremapGroupRuleSource(
    log_message:,
    check:,
    condition:,
    variable:,
    list_mode:,
    element:,
    default_value:,
    type_:,
    max:,
    min:,
    context:,
    modifier_extension:,
    extension:,
    id:,
  ) = structuremap_group_rule_source
  let fields = [
    #("context", json.string(context)),
  ]
  let fields = case log_message {
    Some(v) -> [#("logMessage", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case check {
    Some(v) -> [#("check", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case condition {
    Some(v) -> [#("condition", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case variable {
    Some(v) -> [#("variable", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case list_mode {
    Some(v) -> [
      #("listMode", r4bvaluesets.mapsourcelistmode_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case element {
    Some(v) -> [#("element", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case default_value {
    Some(v) -> [
      #(
        "defaultValue"
          <> case v {
          StructuremapGroupRuleSourceDefaultvalueBase64binary(_) ->
            "Base64binary"
          StructuremapGroupRuleSourceDefaultvalueBoolean(_) -> "Boolean"
          StructuremapGroupRuleSourceDefaultvalueCanonical(_) -> "Canonical"
          StructuremapGroupRuleSourceDefaultvalueCode(_) -> "Code"
          StructuremapGroupRuleSourceDefaultvalueDate(_) -> "Date"
          StructuremapGroupRuleSourceDefaultvalueDatetime(_) -> "Datetime"
          StructuremapGroupRuleSourceDefaultvalueDecimal(_) -> "Decimal"
          StructuremapGroupRuleSourceDefaultvalueId(_) -> "Id"
          StructuremapGroupRuleSourceDefaultvalueInstant(_) -> "Instant"
          StructuremapGroupRuleSourceDefaultvalueInteger(_) -> "Integer"
          StructuremapGroupRuleSourceDefaultvalueMarkdown(_) -> "Markdown"
          StructuremapGroupRuleSourceDefaultvalueOid(_) -> "Oid"
          StructuremapGroupRuleSourceDefaultvaluePositiveint(_) -> "Positiveint"
          StructuremapGroupRuleSourceDefaultvalueString(_) -> "String"
          StructuremapGroupRuleSourceDefaultvalueTime(_) -> "Time"
          StructuremapGroupRuleSourceDefaultvalueUnsignedint(_) -> "Unsignedint"
          StructuremapGroupRuleSourceDefaultvalueUri(_) -> "Uri"
          StructuremapGroupRuleSourceDefaultvalueUrl(_) -> "Url"
          StructuremapGroupRuleSourceDefaultvalueUuid(_) -> "Uuid"
          StructuremapGroupRuleSourceDefaultvalueAddress(_) -> "Address"
          StructuremapGroupRuleSourceDefaultvalueAge(_) -> "Age"
          StructuremapGroupRuleSourceDefaultvalueAnnotation(_) -> "Annotation"
          StructuremapGroupRuleSourceDefaultvalueAttachment(_) -> "Attachment"
          StructuremapGroupRuleSourceDefaultvalueCodeableconcept(_) ->
            "Codeableconcept"
          StructuremapGroupRuleSourceDefaultvalueCoding(_) -> "Coding"
          StructuremapGroupRuleSourceDefaultvalueContactpoint(_) ->
            "Contactpoint"
          StructuremapGroupRuleSourceDefaultvalueCount(_) -> "Count"
          StructuremapGroupRuleSourceDefaultvalueDistance(_) -> "Distance"
          StructuremapGroupRuleSourceDefaultvalueDuration(_) -> "Duration"
          StructuremapGroupRuleSourceDefaultvalueHumanname(_) -> "Humanname"
          StructuremapGroupRuleSourceDefaultvalueIdentifier(_) -> "Identifier"
          StructuremapGroupRuleSourceDefaultvalueMoney(_) -> "Money"
          StructuremapGroupRuleSourceDefaultvaluePeriod(_) -> "Period"
          StructuremapGroupRuleSourceDefaultvalueQuantity(_) -> "Quantity"
          StructuremapGroupRuleSourceDefaultvalueRange(_) -> "Range"
          StructuremapGroupRuleSourceDefaultvalueRatio(_) -> "Ratio"
          StructuremapGroupRuleSourceDefaultvalueReference(_) -> "Reference"
          StructuremapGroupRuleSourceDefaultvalueSampleddata(_) -> "Sampleddata"
          StructuremapGroupRuleSourceDefaultvalueSignature(_) -> "Signature"
          StructuremapGroupRuleSourceDefaultvalueTiming(_) -> "Timing"
          StructuremapGroupRuleSourceDefaultvalueContactdetail(_) ->
            "Contactdetail"
          StructuremapGroupRuleSourceDefaultvalueContributor(_) -> "Contributor"
          StructuremapGroupRuleSourceDefaultvalueDatarequirement(_) ->
            "Datarequirement"
          StructuremapGroupRuleSourceDefaultvalueExpression(_) -> "Expression"
          StructuremapGroupRuleSourceDefaultvalueParameterdefinition(_) ->
            "Parameterdefinition"
          StructuremapGroupRuleSourceDefaultvalueRelatedartifact(_) ->
            "Relatedartifact"
          StructuremapGroupRuleSourceDefaultvalueTriggerdefinition(_) ->
            "Triggerdefinition"
          StructuremapGroupRuleSourceDefaultvalueUsagecontext(_) ->
            "Usagecontext"
          StructuremapGroupRuleSourceDefaultvalueDosage(_) -> "Dosage"
          StructuremapGroupRuleSourceDefaultvalueMeta(_) -> "Meta"
        },
        structuremap_group_rule_source_defaultvalue_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case max {
    Some(v) -> [#("max", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case min {
    Some(v) -> [#("min", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn structuremap_group_rule_source_decoder() -> Decoder(
  StructuremapGroupRuleSource,
) {
  use log_message <- decode.optional_field(
    "logMessage",
    None,
    decode.optional(decode.string),
  )
  use check <- decode.optional_field(
    "check",
    None,
    decode.optional(decode.string),
  )
  use condition <- decode.optional_field(
    "condition",
    None,
    decode.optional(decode.string),
  )
  use variable <- decode.optional_field(
    "variable",
    None,
    decode.optional(decode.string),
  )
  use list_mode <- decode.optional_field(
    "listMode",
    None,
    decode.optional(r4bvaluesets.mapsourcelistmode_decoder()),
  )
  use element <- decode.optional_field(
    "element",
    None,
    decode.optional(decode.string),
  )
  use default_value <- decode.then(
    none_if_omitted(structuremap_group_rule_source_defaultvalue_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(decode.string),
  )
  use max <- decode.optional_field("max", None, decode.optional(decode.string))
  use min <- decode.optional_field("min", None, decode.optional(decode.int))
  use context <- decode.field("context", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(StructuremapGroupRuleSource(
    log_message:,
    check:,
    condition:,
    variable:,
    list_mode:,
    element:,
    default_value:,
    type_:,
    max:,
    min:,
    context:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn structuremap_group_rule_to_json(
  structuremap_group_rule: StructuremapGroupRule,
) -> Json {
  let StructuremapGroupRule(
    documentation:,
    dependent:,
    target:,
    source:,
    name:,
    modifier_extension:,
    extension:,
    id:,
  ) = structuremap_group_rule
  let fields = [
    #("name", json.string(name)),
  ]
  let fields = case documentation {
    Some(v) -> [#("documentation", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case dependent {
    [] -> fields
    _ -> [
      #(
        "dependent",
        json.array(dependent, structuremap_group_rule_dependent_to_json),
      ),
      ..fields
    ]
  }
  let fields = case target {
    [] -> fields
    _ -> [
      #("target", json.array(target, structuremap_group_rule_target_to_json)),
      ..fields
    ]
  }
  let fields = case source {
    [] -> fields
    _ -> [
      #("source", json.array(source, structuremap_group_rule_source_to_json)),
      ..fields
    ]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn structuremap_group_rule_decoder() -> Decoder(StructuremapGroupRule) {
  use documentation <- decode.optional_field(
    "documentation",
    None,
    decode.optional(decode.string),
  )
  use dependent <- decode.optional_field(
    "dependent",
    [],
    decode.list(structuremap_group_rule_dependent_decoder()),
  )
  use target <- decode.optional_field(
    "target",
    [],
    decode.list(structuremap_group_rule_target_decoder()),
  )
  use source <- decode.optional_field(
    "source",
    [],
    decode.list(structuremap_group_rule_source_decoder()),
  )
  use name <- decode.field("name", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(StructuremapGroupRule(
    documentation:,
    dependent:,
    target:,
    source:,
    name:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn structuremap_group_input_to_json(
  structuremap_group_input: StructuremapGroupInput,
) -> Json {
  let StructuremapGroupInput(
    documentation:,
    mode:,
    type_:,
    name:,
    modifier_extension:,
    extension:,
    id:,
  ) = structuremap_group_input
  let fields = [
    #("mode", r4bvaluesets.mapinputmode_to_json(mode)),
    #("name", json.string(name)),
  ]
  let fields = case documentation {
    Some(v) -> [#("documentation", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn structuremap_group_input_decoder() -> Decoder(StructuremapGroupInput) {
  use documentation <- decode.optional_field(
    "documentation",
    None,
    decode.optional(decode.string),
  )
  use mode <- decode.field("mode", r4bvaluesets.mapinputmode_decoder())
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.field("name", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(StructuremapGroupInput(
    documentation:,
    mode:,
    type_:,
    name:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn structuremap_group_to_json(structuremap_group: StructuremapGroup) -> Json {
  let StructuremapGroup(
    rule:,
    input:,
    documentation:,
    type_mode:,
    extends:,
    name:,
    modifier_extension:,
    extension:,
    id:,
  ) = structuremap_group
  let fields = [
    #("typeMode", r4bvaluesets.mapgrouptypemode_to_json(type_mode)),
    #("name", json.string(name)),
  ]
  let fields = case rule {
    [] -> fields
    _ -> [
      #("rule", json.array(rule, structuremap_group_rule_to_json)),
      ..fields
    ]
  }
  let fields = case input {
    [] -> fields
    _ -> [
      #("input", json.array(input, structuremap_group_input_to_json)),
      ..fields
    ]
  }
  let fields = case documentation {
    Some(v) -> [#("documentation", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case extends {
    Some(v) -> [#("extends", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn structuremap_group_decoder() -> Decoder(StructuremapGroup) {
  use rule <- decode.optional_field(
    "rule",
    [],
    decode.list(structuremap_group_rule_decoder()),
  )
  use input <- decode.optional_field(
    "input",
    [],
    decode.list(structuremap_group_input_decoder()),
  )
  use documentation <- decode.optional_field(
    "documentation",
    None,
    decode.optional(decode.string),
  )
  use type_mode <- decode.field(
    "typeMode",
    r4bvaluesets.mapgrouptypemode_decoder(),
  )
  use extends <- decode.optional_field(
    "extends",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.field("name", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(StructuremapGroup(
    rule:,
    input:,
    documentation:,
    type_mode:,
    extends:,
    name:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn structuremap_structure_to_json(
  structuremap_structure: StructuremapStructure,
) -> Json {
  let StructuremapStructure(
    documentation:,
    alias:,
    mode:,
    url:,
    modifier_extension:,
    extension:,
    id:,
  ) = structuremap_structure
  let fields = [
    #("mode", r4bvaluesets.mapmodelmode_to_json(mode)),
    #("url", json.string(url)),
  ]
  let fields = case documentation {
    Some(v) -> [#("documentation", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case alias {
    Some(v) -> [#("alias", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn structuremap_structure_decoder() -> Decoder(StructuremapStructure) {
  use documentation <- decode.optional_field(
    "documentation",
    None,
    decode.optional(decode.string),
  )
  use alias <- decode.optional_field(
    "alias",
    None,
    decode.optional(decode.string),
  )
  use mode <- decode.field("mode", r4bvaluesets.mapmodelmode_decoder())
  use url <- decode.field("url", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(StructuremapStructure(
    documentation:,
    alias:,
    mode:,
    url:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn structuremap_to_json(structuremap: Structuremap) -> Json {
  let Structuremap(
    group:,
    import_:,
    structure:,
    copyright:,
    purpose:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    experimental:,
    status:,
    title:,
    name:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = structuremap
  let fields = [
    #("status", r4bvaluesets.publicationstatus_to_json(status)),
    #("name", json.string(name)),
    #("url", json.string(url)),
  ]
  let fields = case group {
    [] -> fields
    _ -> [#("group", json.array(group, structuremap_group_to_json)), ..fields]
  }
  let fields = case import_ {
    [] -> fields
    _ -> [#("import", json.array(import_, json.string)), ..fields]
  }
  let fields = case structure {
    [] -> fields
    _ -> [
      #("structure", json.array(structure, structuremap_structure_to_json)),
      ..fields
    ]
  }
  let fields = case copyright {
    Some(v) -> [#("copyright", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case purpose {
    Some(v) -> [#("purpose", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case jurisdiction {
    [] -> fields
    _ -> [
      #("jurisdiction", json.array(jurisdiction, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case use_context {
    [] -> fields
    _ -> [
      #("useContext", json.array(use_context, usagecontext_to_json)),
      ..fields
    ]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case contact {
    [] -> fields
    _ -> [#("contact", json.array(contact, contactdetail_to_json)), ..fields]
  }
  let fields = case publisher {
    Some(v) -> [#("publisher", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case date {
    Some(v) -> [#("date", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case experimental {
    Some(v) -> [#("experimental", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case title {
    Some(v) -> [#("title", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case version {
    Some(v) -> [#("version", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Structuremap")), ..fields]
  json.object(fields)
}

pub fn structuremap_decoder() -> Decoder(Structuremap) {
  use group <- decode.optional_field(
    "group",
    [],
    decode.list(structuremap_group_decoder()),
  )
  use import_ <- decode.optional_field("import", [], decode.list(decode.string))
  use structure <- decode.optional_field(
    "structure",
    [],
    decode.list(structuremap_structure_decoder()),
  )
  use copyright <- decode.optional_field(
    "copyright",
    None,
    decode.optional(decode.string),
  )
  use purpose <- decode.optional_field(
    "purpose",
    None,
    decode.optional(decode.string),
  )
  use jurisdiction <- decode.optional_field(
    "jurisdiction",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use use_context <- decode.optional_field(
    "useContext",
    [],
    decode.list(usagecontext_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use contact <- decode.optional_field(
    "contact",
    [],
    decode.list(contactdetail_decoder()),
  )
  use publisher <- decode.optional_field(
    "publisher",
    None,
    decode.optional(decode.string),
  )
  use date <- decode.optional_field(
    "date",
    None,
    decode.optional(decode.string),
  )
  use experimental <- decode.optional_field(
    "experimental",
    None,
    decode.optional(decode.bool),
  )
  use status <- decode.field("status", r4bvaluesets.publicationstatus_decoder())
  use title <- decode.optional_field(
    "title",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.field("name", decode.string)
  use version <- decode.optional_field(
    "version",
    None,
    decode.optional(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use url <- decode.field("url", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Structuremap",
    decode.failure(structuremap_new(status:, name:, url:), "resourceType"),
  )
  decode.success(Structuremap(
    group:,
    import_:,
    structure:,
    copyright:,
    purpose:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    experimental:,
    status:,
    title:,
    name:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/Subscription#resource
pub type Subscription {
  Subscription(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    status: r4bvaluesets.Subscriptionstatus,
    contact: List(Contactpoint),
    end: Option(String),
    reason: String,
    criteria: String,
    error: Option(String),
    channel: SubscriptionChannel,
  )
}

pub fn subscription_new(
  channel channel: SubscriptionChannel,
  criteria criteria: String,
  reason reason: String,
  status status: r4bvaluesets.Subscriptionstatus,
) -> Subscription {
  Subscription(
    channel:,
    error: None,
    criteria:,
    reason:,
    end: None,
    contact: [],
    status:,
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Subscription#resource
pub type SubscriptionChannel {
  SubscriptionChannel(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: r4bvaluesets.Subscriptionchanneltype,
    endpoint: Option(String),
    payload: Option(String),
    header: List(String),
  )
}

pub fn subscription_channel_new(
  type_ type_: r4bvaluesets.Subscriptionchanneltype,
) -> SubscriptionChannel {
  SubscriptionChannel(
    header: [],
    payload: None,
    endpoint: None,
    type_:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn subscription_channel_to_json(
  subscription_channel: SubscriptionChannel,
) -> Json {
  let SubscriptionChannel(
    header:,
    payload:,
    endpoint:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = subscription_channel
  let fields = [
    #("type", r4bvaluesets.subscriptionchanneltype_to_json(type_)),
  ]
  let fields = case header {
    [] -> fields
    _ -> [#("header", json.array(header, json.string)), ..fields]
  }
  let fields = case payload {
    Some(v) -> [#("payload", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case endpoint {
    Some(v) -> [#("endpoint", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn subscription_channel_decoder() -> Decoder(SubscriptionChannel) {
  use header <- decode.optional_field("header", [], decode.list(decode.string))
  use payload <- decode.optional_field(
    "payload",
    None,
    decode.optional(decode.string),
  )
  use endpoint <- decode.optional_field(
    "endpoint",
    None,
    decode.optional(decode.string),
  )
  use type_ <- decode.field(
    "type",
    r4bvaluesets.subscriptionchanneltype_decoder(),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(SubscriptionChannel(
    header:,
    payload:,
    endpoint:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn subscription_to_json(subscription: Subscription) -> Json {
  let Subscription(
    channel:,
    error:,
    criteria:,
    reason:,
    end:,
    contact:,
    status:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = subscription
  let fields = [
    #("channel", subscription_channel_to_json(channel)),
    #("criteria", json.string(criteria)),
    #("reason", json.string(reason)),
    #("status", r4bvaluesets.subscriptionstatus_to_json(status)),
  ]
  let fields = case error {
    Some(v) -> [#("error", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case end {
    Some(v) -> [#("end", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case contact {
    [] -> fields
    _ -> [#("contact", json.array(contact, contactpoint_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Subscription")), ..fields]
  json.object(fields)
}

pub fn subscription_decoder() -> Decoder(Subscription) {
  use channel <- decode.field("channel", subscription_channel_decoder())
  use error <- decode.optional_field(
    "error",
    None,
    decode.optional(decode.string),
  )
  use criteria <- decode.field("criteria", decode.string)
  use reason <- decode.field("reason", decode.string)
  use end <- decode.optional_field("end", None, decode.optional(decode.string))
  use contact <- decode.optional_field(
    "contact",
    [],
    decode.list(contactpoint_decoder()),
  )
  use status <- decode.field(
    "status",
    r4bvaluesets.subscriptionstatus_decoder(),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Subscription",
    decode.failure(
      subscription_new(channel:, criteria:, reason:, status:),
      "resourceType",
    ),
  )
  decode.success(Subscription(
    channel:,
    error:,
    criteria:,
    reason:,
    end:,
    contact:,
    status:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/SubscriptionStatus#resource
pub type Subscriptionstatus {
  Subscriptionstatus(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    status: Option(r4bvaluesets.Subscriptionstatus),
    type_: r4bvaluesets.Subscriptionnotificationtype,
    events_since_subscription_start: Option(String),
    notification_event: List(SubscriptionstatusNotificationevent),
    subscription: Reference,
    topic: Option(String),
    error: List(Codeableconcept),
  )
}

pub fn subscriptionstatus_new(
  subscription subscription: Reference,
  type_ type_: r4bvaluesets.Subscriptionnotificationtype,
) -> Subscriptionstatus {
  Subscriptionstatus(
    error: [],
    topic: None,
    subscription:,
    notification_event: [],
    events_since_subscription_start: None,
    type_:,
    status: None,
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/SubscriptionStatus#resource
pub type SubscriptionstatusNotificationevent {
  SubscriptionstatusNotificationevent(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    event_number: String,
    timestamp: Option(String),
    focus: Option(Reference),
    additional_context: List(Reference),
  )
}

pub fn subscriptionstatus_notificationevent_new(
  event_number event_number: String,
) -> SubscriptionstatusNotificationevent {
  SubscriptionstatusNotificationevent(
    additional_context: [],
    focus: None,
    timestamp: None,
    event_number:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn subscriptionstatus_notificationevent_to_json(
  subscriptionstatus_notificationevent: SubscriptionstatusNotificationevent,
) -> Json {
  let SubscriptionstatusNotificationevent(
    additional_context:,
    focus:,
    timestamp:,
    event_number:,
    modifier_extension:,
    extension:,
    id:,
  ) = subscriptionstatus_notificationevent
  let fields = [
    #("eventNumber", json.string(event_number)),
  ]
  let fields = case additional_context {
    [] -> fields
    _ -> [
      #("additionalContext", json.array(additional_context, reference_to_json)),
      ..fields
    ]
  }
  let fields = case focus {
    Some(v) -> [#("focus", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case timestamp {
    Some(v) -> [#("timestamp", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn subscriptionstatus_notificationevent_decoder() -> Decoder(
  SubscriptionstatusNotificationevent,
) {
  use additional_context <- decode.optional_field(
    "additionalContext",
    [],
    decode.list(reference_decoder()),
  )
  use focus <- decode.optional_field(
    "focus",
    None,
    decode.optional(reference_decoder()),
  )
  use timestamp <- decode.optional_field(
    "timestamp",
    None,
    decode.optional(decode.string),
  )
  use event_number <- decode.field("eventNumber", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(SubscriptionstatusNotificationevent(
    additional_context:,
    focus:,
    timestamp:,
    event_number:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn subscriptionstatus_to_json(
  subscriptionstatus: Subscriptionstatus,
) -> Json {
  let Subscriptionstatus(
    error:,
    topic:,
    subscription:,
    notification_event:,
    events_since_subscription_start:,
    type_:,
    status:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = subscriptionstatus
  let fields = [
    #("subscription", reference_to_json(subscription)),
    #("type", r4bvaluesets.subscriptionnotificationtype_to_json(type_)),
  ]
  let fields = case error {
    [] -> fields
    _ -> [#("error", json.array(error, codeableconcept_to_json)), ..fields]
  }
  let fields = case topic {
    Some(v) -> [#("topic", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case notification_event {
    [] -> fields
    _ -> [
      #(
        "notificationEvent",
        json.array(
          notification_event,
          subscriptionstatus_notificationevent_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case events_since_subscription_start {
    Some(v) -> [#("eventsSinceSubscriptionStart", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case status {
    Some(v) -> [
      #("status", r4bvaluesets.subscriptionstatus_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Subscriptionstatus")), ..fields]
  json.object(fields)
}

pub fn subscriptionstatus_decoder() -> Decoder(Subscriptionstatus) {
  use error <- decode.optional_field(
    "error",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use topic <- decode.optional_field(
    "topic",
    None,
    decode.optional(decode.string),
  )
  use subscription <- decode.field("subscription", reference_decoder())
  use notification_event <- decode.optional_field(
    "notificationEvent",
    [],
    decode.list(subscriptionstatus_notificationevent_decoder()),
  )
  use events_since_subscription_start <- decode.optional_field(
    "eventsSinceSubscriptionStart",
    None,
    decode.optional(decode.string),
  )
  use type_ <- decode.field(
    "type",
    r4bvaluesets.subscriptionnotificationtype_decoder(),
  )
  use status <- decode.optional_field(
    "status",
    None,
    decode.optional(r4bvaluesets.subscriptionstatus_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Subscriptionstatus",
    decode.failure(
      subscriptionstatus_new(subscription:, type_:),
      "resourceType",
    ),
  )
  decode.success(Subscriptionstatus(
    error:,
    topic:,
    subscription:,
    notification_event:,
    events_since_subscription_start:,
    type_:,
    status:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/SubscriptionTopic#resource
pub type Subscriptiontopic {
  Subscriptiontopic(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    url: String,
    identifier: List(Identifier),
    version: Option(String),
    title: Option(String),
    derived_from: List(String),
    status: r4bvaluesets.Publicationstatus,
    experimental: Option(Bool),
    date: Option(String),
    publisher: Option(String),
    contact: List(Contactdetail),
    description: Option(String),
    use_context: List(Usagecontext),
    jurisdiction: List(Codeableconcept),
    purpose: Option(String),
    copyright: Option(String),
    approval_date: Option(String),
    last_review_date: Option(String),
    effective_period: Option(Period),
    resource_trigger: List(SubscriptiontopicResourcetrigger),
    event_trigger: List(SubscriptiontopicEventtrigger),
    can_filter_by: List(SubscriptiontopicCanfilterby),
    notification_shape: List(SubscriptiontopicNotificationshape),
  )
}

pub fn subscriptiontopic_new(
  status status: r4bvaluesets.Publicationstatus,
  url url: String,
) -> Subscriptiontopic {
  Subscriptiontopic(
    notification_shape: [],
    can_filter_by: [],
    event_trigger: [],
    resource_trigger: [],
    effective_period: None,
    last_review_date: None,
    approval_date: None,
    copyright: None,
    purpose: None,
    jurisdiction: [],
    use_context: [],
    description: None,
    contact: [],
    publisher: None,
    date: None,
    experimental: None,
    status:,
    derived_from: [],
    title: None,
    version: None,
    identifier: [],
    url:,
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/SubscriptionTopic#resource
pub type SubscriptiontopicResourcetrigger {
  SubscriptiontopicResourcetrigger(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    description: Option(String),
    resource: String,
    supported_interaction: List(r4bvaluesets.Interactiontrigger),
    query_criteria: Option(SubscriptiontopicResourcetriggerQuerycriteria),
    fhir_path_criteria: Option(String),
  )
}

pub fn subscriptiontopic_resourcetrigger_new(
  resource resource: String,
) -> SubscriptiontopicResourcetrigger {
  SubscriptiontopicResourcetrigger(
    fhir_path_criteria: None,
    query_criteria: None,
    supported_interaction: [],
    resource:,
    description: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/SubscriptionTopic#resource
pub type SubscriptiontopicResourcetriggerQuerycriteria {
  SubscriptiontopicResourcetriggerQuerycriteria(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    previous: Option(String),
    result_for_create: Option(r4bvaluesets.Subscriptiontopiccrbehavior),
    current: Option(String),
    result_for_delete: Option(r4bvaluesets.Subscriptiontopiccrbehavior),
    require_both: Option(Bool),
  )
}

pub fn subscriptiontopic_resourcetrigger_querycriteria_new() -> SubscriptiontopicResourcetriggerQuerycriteria {
  SubscriptiontopicResourcetriggerQuerycriteria(
    require_both: None,
    result_for_delete: None,
    current: None,
    result_for_create: None,
    previous: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/SubscriptionTopic#resource
pub type SubscriptiontopicEventtrigger {
  SubscriptiontopicEventtrigger(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    description: Option(String),
    event: Codeableconcept,
    resource: String,
  )
}

pub fn subscriptiontopic_eventtrigger_new(
  resource resource: String,
  event event: Codeableconcept,
) -> SubscriptiontopicEventtrigger {
  SubscriptiontopicEventtrigger(
    resource:,
    event:,
    description: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/SubscriptionTopic#resource
pub type SubscriptiontopicCanfilterby {
  SubscriptiontopicCanfilterby(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    description: Option(String),
    resource: Option(String),
    filter_parameter: String,
    filter_definition: Option(String),
    modifier: List(r4bvaluesets.Subscriptionsearchmodifier),
  )
}

pub fn subscriptiontopic_canfilterby_new(
  filter_parameter filter_parameter: String,
) -> SubscriptiontopicCanfilterby {
  SubscriptiontopicCanfilterby(
    modifier: [],
    filter_definition: None,
    filter_parameter:,
    resource: None,
    description: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/SubscriptionTopic#resource
pub type SubscriptiontopicNotificationshape {
  SubscriptiontopicNotificationshape(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    resource: String,
    include: List(String),
    rev_include: List(String),
  )
}

pub fn subscriptiontopic_notificationshape_new(
  resource resource: String,
) -> SubscriptiontopicNotificationshape {
  SubscriptiontopicNotificationshape(
    rev_include: [],
    include: [],
    resource:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn subscriptiontopic_notificationshape_to_json(
  subscriptiontopic_notificationshape: SubscriptiontopicNotificationshape,
) -> Json {
  let SubscriptiontopicNotificationshape(
    rev_include:,
    include:,
    resource:,
    modifier_extension:,
    extension:,
    id:,
  ) = subscriptiontopic_notificationshape
  let fields = [
    #("resource", json.string(resource)),
  ]
  let fields = case rev_include {
    [] -> fields
    _ -> [#("revInclude", json.array(rev_include, json.string)), ..fields]
  }
  let fields = case include {
    [] -> fields
    _ -> [#("include", json.array(include, json.string)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn subscriptiontopic_notificationshape_decoder() -> Decoder(
  SubscriptiontopicNotificationshape,
) {
  use rev_include <- decode.optional_field(
    "revInclude",
    [],
    decode.list(decode.string),
  )
  use include <- decode.optional_field(
    "include",
    [],
    decode.list(decode.string),
  )
  use resource <- decode.field("resource", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(SubscriptiontopicNotificationshape(
    rev_include:,
    include:,
    resource:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn subscriptiontopic_canfilterby_to_json(
  subscriptiontopic_canfilterby: SubscriptiontopicCanfilterby,
) -> Json {
  let SubscriptiontopicCanfilterby(
    modifier:,
    filter_definition:,
    filter_parameter:,
    resource:,
    description:,
    modifier_extension:,
    extension:,
    id:,
  ) = subscriptiontopic_canfilterby
  let fields = [
    #("filterParameter", json.string(filter_parameter)),
  ]
  let fields = case modifier {
    [] -> fields
    _ -> [
      #(
        "modifier",
        json.array(modifier, r4bvaluesets.subscriptionsearchmodifier_to_json),
      ),
      ..fields
    ]
  }
  let fields = case filter_definition {
    Some(v) -> [#("filterDefinition", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case resource {
    Some(v) -> [#("resource", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn subscriptiontopic_canfilterby_decoder() -> Decoder(
  SubscriptiontopicCanfilterby,
) {
  use modifier <- decode.optional_field(
    "modifier",
    [],
    decode.list(r4bvaluesets.subscriptionsearchmodifier_decoder()),
  )
  use filter_definition <- decode.optional_field(
    "filterDefinition",
    None,
    decode.optional(decode.string),
  )
  use filter_parameter <- decode.field("filterParameter", decode.string)
  use resource <- decode.optional_field(
    "resource",
    None,
    decode.optional(decode.string),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(SubscriptiontopicCanfilterby(
    modifier:,
    filter_definition:,
    filter_parameter:,
    resource:,
    description:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn subscriptiontopic_eventtrigger_to_json(
  subscriptiontopic_eventtrigger: SubscriptiontopicEventtrigger,
) -> Json {
  let SubscriptiontopicEventtrigger(
    resource:,
    event:,
    description:,
    modifier_extension:,
    extension:,
    id:,
  ) = subscriptiontopic_eventtrigger
  let fields = [
    #("resource", json.string(resource)),
    #("event", codeableconcept_to_json(event)),
  ]
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn subscriptiontopic_eventtrigger_decoder() -> Decoder(
  SubscriptiontopicEventtrigger,
) {
  use resource <- decode.field("resource", decode.string)
  use event <- decode.field("event", codeableconcept_decoder())
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(SubscriptiontopicEventtrigger(
    resource:,
    event:,
    description:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn subscriptiontopic_resourcetrigger_querycriteria_to_json(
  subscriptiontopic_resourcetrigger_querycriteria: SubscriptiontopicResourcetriggerQuerycriteria,
) -> Json {
  let SubscriptiontopicResourcetriggerQuerycriteria(
    require_both:,
    result_for_delete:,
    current:,
    result_for_create:,
    previous:,
    modifier_extension:,
    extension:,
    id:,
  ) = subscriptiontopic_resourcetrigger_querycriteria
  let fields = []
  let fields = case require_both {
    Some(v) -> [#("requireBoth", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case result_for_delete {
    Some(v) -> [
      #("resultForDelete", r4bvaluesets.subscriptiontopiccrbehavior_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case current {
    Some(v) -> [#("current", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case result_for_create {
    Some(v) -> [
      #("resultForCreate", r4bvaluesets.subscriptiontopiccrbehavior_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case previous {
    Some(v) -> [#("previous", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn subscriptiontopic_resourcetrigger_querycriteria_decoder() -> Decoder(
  SubscriptiontopicResourcetriggerQuerycriteria,
) {
  use require_both <- decode.optional_field(
    "requireBoth",
    None,
    decode.optional(decode.bool),
  )
  use result_for_delete <- decode.optional_field(
    "resultForDelete",
    None,
    decode.optional(r4bvaluesets.subscriptiontopiccrbehavior_decoder()),
  )
  use current <- decode.optional_field(
    "current",
    None,
    decode.optional(decode.string),
  )
  use result_for_create <- decode.optional_field(
    "resultForCreate",
    None,
    decode.optional(r4bvaluesets.subscriptiontopiccrbehavior_decoder()),
  )
  use previous <- decode.optional_field(
    "previous",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(SubscriptiontopicResourcetriggerQuerycriteria(
    require_both:,
    result_for_delete:,
    current:,
    result_for_create:,
    previous:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn subscriptiontopic_resourcetrigger_to_json(
  subscriptiontopic_resourcetrigger: SubscriptiontopicResourcetrigger,
) -> Json {
  let SubscriptiontopicResourcetrigger(
    fhir_path_criteria:,
    query_criteria:,
    supported_interaction:,
    resource:,
    description:,
    modifier_extension:,
    extension:,
    id:,
  ) = subscriptiontopic_resourcetrigger
  let fields = [
    #("resource", json.string(resource)),
  ]
  let fields = case fhir_path_criteria {
    Some(v) -> [#("fhirPathCriteria", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case query_criteria {
    Some(v) -> [
      #(
        "queryCriteria",
        subscriptiontopic_resourcetrigger_querycriteria_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case supported_interaction {
    [] -> fields
    _ -> [
      #(
        "supportedInteraction",
        json.array(
          supported_interaction,
          r4bvaluesets.interactiontrigger_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn subscriptiontopic_resourcetrigger_decoder() -> Decoder(
  SubscriptiontopicResourcetrigger,
) {
  use fhir_path_criteria <- decode.optional_field(
    "fhirPathCriteria",
    None,
    decode.optional(decode.string),
  )
  use query_criteria <- decode.optional_field(
    "queryCriteria",
    None,
    decode.optional(subscriptiontopic_resourcetrigger_querycriteria_decoder()),
  )
  use supported_interaction <- decode.optional_field(
    "supportedInteraction",
    [],
    decode.list(r4bvaluesets.interactiontrigger_decoder()),
  )
  use resource <- decode.field("resource", decode.string)
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(SubscriptiontopicResourcetrigger(
    fhir_path_criteria:,
    query_criteria:,
    supported_interaction:,
    resource:,
    description:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn subscriptiontopic_to_json(subscriptiontopic: Subscriptiontopic) -> Json {
  let Subscriptiontopic(
    notification_shape:,
    can_filter_by:,
    event_trigger:,
    resource_trigger:,
    effective_period:,
    last_review_date:,
    approval_date:,
    copyright:,
    purpose:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    experimental:,
    status:,
    derived_from:,
    title:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = subscriptiontopic
  let fields = [
    #("status", r4bvaluesets.publicationstatus_to_json(status)),
    #("url", json.string(url)),
  ]
  let fields = case notification_shape {
    [] -> fields
    _ -> [
      #(
        "notificationShape",
        json.array(
          notification_shape,
          subscriptiontopic_notificationshape_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case can_filter_by {
    [] -> fields
    _ -> [
      #(
        "canFilterBy",
        json.array(can_filter_by, subscriptiontopic_canfilterby_to_json),
      ),
      ..fields
    ]
  }
  let fields = case event_trigger {
    [] -> fields
    _ -> [
      #(
        "eventTrigger",
        json.array(event_trigger, subscriptiontopic_eventtrigger_to_json),
      ),
      ..fields
    ]
  }
  let fields = case resource_trigger {
    [] -> fields
    _ -> [
      #(
        "resourceTrigger",
        json.array(resource_trigger, subscriptiontopic_resourcetrigger_to_json),
      ),
      ..fields
    ]
  }
  let fields = case effective_period {
    Some(v) -> [#("effectivePeriod", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case last_review_date {
    Some(v) -> [#("lastReviewDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case approval_date {
    Some(v) -> [#("approvalDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case copyright {
    Some(v) -> [#("copyright", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case purpose {
    Some(v) -> [#("purpose", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case jurisdiction {
    [] -> fields
    _ -> [
      #("jurisdiction", json.array(jurisdiction, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case use_context {
    [] -> fields
    _ -> [
      #("useContext", json.array(use_context, usagecontext_to_json)),
      ..fields
    ]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case contact {
    [] -> fields
    _ -> [#("contact", json.array(contact, contactdetail_to_json)), ..fields]
  }
  let fields = case publisher {
    Some(v) -> [#("publisher", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case date {
    Some(v) -> [#("date", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case experimental {
    Some(v) -> [#("experimental", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case derived_from {
    [] -> fields
    _ -> [#("derivedFrom", json.array(derived_from, json.string)), ..fields]
  }
  let fields = case title {
    Some(v) -> [#("title", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case version {
    Some(v) -> [#("version", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Subscriptiontopic")), ..fields]
  json.object(fields)
}

pub fn subscriptiontopic_decoder() -> Decoder(Subscriptiontopic) {
  use notification_shape <- decode.optional_field(
    "notificationShape",
    [],
    decode.list(subscriptiontopic_notificationshape_decoder()),
  )
  use can_filter_by <- decode.optional_field(
    "canFilterBy",
    [],
    decode.list(subscriptiontopic_canfilterby_decoder()),
  )
  use event_trigger <- decode.optional_field(
    "eventTrigger",
    [],
    decode.list(subscriptiontopic_eventtrigger_decoder()),
  )
  use resource_trigger <- decode.optional_field(
    "resourceTrigger",
    [],
    decode.list(subscriptiontopic_resourcetrigger_decoder()),
  )
  use effective_period <- decode.optional_field(
    "effectivePeriod",
    None,
    decode.optional(period_decoder()),
  )
  use last_review_date <- decode.optional_field(
    "lastReviewDate",
    None,
    decode.optional(decode.string),
  )
  use approval_date <- decode.optional_field(
    "approvalDate",
    None,
    decode.optional(decode.string),
  )
  use copyright <- decode.optional_field(
    "copyright",
    None,
    decode.optional(decode.string),
  )
  use purpose <- decode.optional_field(
    "purpose",
    None,
    decode.optional(decode.string),
  )
  use jurisdiction <- decode.optional_field(
    "jurisdiction",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use use_context <- decode.optional_field(
    "useContext",
    [],
    decode.list(usagecontext_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use contact <- decode.optional_field(
    "contact",
    [],
    decode.list(contactdetail_decoder()),
  )
  use publisher <- decode.optional_field(
    "publisher",
    None,
    decode.optional(decode.string),
  )
  use date <- decode.optional_field(
    "date",
    None,
    decode.optional(decode.string),
  )
  use experimental <- decode.optional_field(
    "experimental",
    None,
    decode.optional(decode.bool),
  )
  use status <- decode.field("status", r4bvaluesets.publicationstatus_decoder())
  use derived_from <- decode.optional_field(
    "derivedFrom",
    [],
    decode.list(decode.string),
  )
  use title <- decode.optional_field(
    "title",
    None,
    decode.optional(decode.string),
  )
  use version <- decode.optional_field(
    "version",
    None,
    decode.optional(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use url <- decode.field("url", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Subscriptiontopic",
    decode.failure(subscriptiontopic_new(status:, url:), "resourceType"),
  )
  decode.success(Subscriptiontopic(
    notification_shape:,
    can_filter_by:,
    event_trigger:,
    resource_trigger:,
    effective_period:,
    last_review_date:,
    approval_date:,
    copyright:,
    purpose:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    experimental:,
    status:,
    derived_from:,
    title:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/Substance#resource
pub type Substance {
  Substance(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    status: Option(r4bvaluesets.Substancestatus),
    category: List(Codeableconcept),
    code: Codeableconcept,
    description: Option(String),
    instance: List(SubstanceInstance),
    ingredient: List(SubstanceIngredient),
  )
}

pub fn substance_new(code code: Codeableconcept) -> Substance {
  Substance(
    ingredient: [],
    instance: [],
    description: None,
    code:,
    category: [],
    status: None,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Substance#resource
pub type SubstanceInstance {
  SubstanceInstance(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: Option(Identifier),
    expiry: Option(String),
    quantity: Option(Quantity),
  )
}

pub fn substance_instance_new() -> SubstanceInstance {
  SubstanceInstance(
    quantity: None,
    expiry: None,
    identifier: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Substance#resource
pub type SubstanceIngredient {
  SubstanceIngredient(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    quantity: Option(Ratio),
    substance: SubstanceIngredientSubstance,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Substance#resource
pub type SubstanceIngredientSubstance {
  SubstanceIngredientSubstanceCodeableconcept(substance: Codeableconcept)
  SubstanceIngredientSubstanceReference(substance: Reference)
}

pub fn substance_ingredient_substance_to_json(
  elt: SubstanceIngredientSubstance,
) -> Json {
  case elt {
    SubstanceIngredientSubstanceCodeableconcept(v) -> codeableconcept_to_json(v)
    SubstanceIngredientSubstanceReference(v) -> reference_to_json(v)
  }
}

pub fn substance_ingredient_substance_decoder() -> Decoder(
  SubstanceIngredientSubstance,
) {
  decode.one_of(
    decode.field(
      "substanceCodeableConcept",
      codeableconcept_decoder(),
      decode.success,
    )
      |> decode.map(SubstanceIngredientSubstanceCodeableconcept),
    [
      decode.field("substanceReference", reference_decoder(), decode.success)
      |> decode.map(SubstanceIngredientSubstanceReference),
    ],
  )
}

pub fn substance_ingredient_new(
  substance substance: SubstanceIngredientSubstance,
) -> SubstanceIngredient {
  SubstanceIngredient(
    substance:,
    quantity: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn substance_ingredient_to_json(
  substance_ingredient: SubstanceIngredient,
) -> Json {
  let SubstanceIngredient(
    substance:,
    quantity:,
    modifier_extension:,
    extension:,
    id:,
  ) = substance_ingredient
  let fields = [
    #("substance", substance_ingredient_substance_to_json(substance)),
  ]
  let fields = case quantity {
    Some(v) -> [#("quantity", ratio_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn substance_ingredient_decoder() -> Decoder(SubstanceIngredient) {
  use substance <- decode.then(substance_ingredient_substance_decoder())
  use quantity <- decode.optional_field(
    "quantity",
    None,
    decode.optional(ratio_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(SubstanceIngredient(
    substance:,
    quantity:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn substance_instance_to_json(substance_instance: SubstanceInstance) -> Json {
  let SubstanceInstance(
    quantity:,
    expiry:,
    identifier:,
    modifier_extension:,
    extension:,
    id:,
  ) = substance_instance
  let fields = []
  let fields = case quantity {
    Some(v) -> [#("quantity", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case expiry {
    Some(v) -> [#("expiry", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    Some(v) -> [#("identifier", identifier_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn substance_instance_decoder() -> Decoder(SubstanceInstance) {
  use quantity <- decode.optional_field(
    "quantity",
    None,
    decode.optional(quantity_decoder()),
  )
  use expiry <- decode.optional_field(
    "expiry",
    None,
    decode.optional(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    None,
    decode.optional(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(SubstanceInstance(
    quantity:,
    expiry:,
    identifier:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn substance_to_json(substance: Substance) -> Json {
  let Substance(
    ingredient:,
    instance:,
    description:,
    code:,
    category:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = substance
  let fields = [
    #("code", codeableconcept_to_json(code)),
  ]
  let fields = case ingredient {
    [] -> fields
    _ -> [
      #("ingredient", json.array(ingredient, substance_ingredient_to_json)),
      ..fields
    ]
  }
  let fields = case instance {
    [] -> fields
    _ -> [
      #("instance", json.array(instance, substance_instance_to_json)),
      ..fields
    ]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case category {
    [] -> fields
    _ -> [
      #("category", json.array(category, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case status {
    Some(v) -> [#("status", r4bvaluesets.substancestatus_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Substance")), ..fields]
  json.object(fields)
}

pub fn substance_decoder() -> Decoder(Substance) {
  use ingredient <- decode.optional_field(
    "ingredient",
    [],
    decode.list(substance_ingredient_decoder()),
  )
  use instance <- decode.optional_field(
    "instance",
    [],
    decode.list(substance_instance_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use code <- decode.field("code", codeableconcept_decoder())
  use category <- decode.optional_field(
    "category",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use status <- decode.optional_field(
    "status",
    None,
    decode.optional(r4bvaluesets.substancestatus_decoder()),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Substance",
    decode.failure(substance_new(code:), "resourceType"),
  )
  decode.success(Substance(
    ingredient:,
    instance:,
    description:,
    code:,
    category:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/SubstanceDefinition#resource
pub type Substancedefinition {
  Substancedefinition(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    version: Option(String),
    status: Option(Codeableconcept),
    classification: List(Codeableconcept),
    domain: Option(Codeableconcept),
    grade: List(Codeableconcept),
    description: Option(String),
    information_source: List(Reference),
    note: List(Annotation),
    manufacturer: List(Reference),
    supplier: List(Reference),
    moiety: List(SubstancedefinitionMoiety),
    property: List(SubstancedefinitionProperty),
    molecular_weight: List(SubstancedefinitionMolecularweight),
    structure: Option(SubstancedefinitionStructure),
    code: List(SubstancedefinitionCode),
    name: List(SubstancedefinitionName),
    relationship: List(SubstancedefinitionRelationship),
    source_material: Option(SubstancedefinitionSourcematerial),
  )
}

pub fn substancedefinition_new() -> Substancedefinition {
  Substancedefinition(
    source_material: None,
    relationship: [],
    name: [],
    code: [],
    structure: None,
    molecular_weight: [],
    property: [],
    moiety: [],
    supplier: [],
    manufacturer: [],
    note: [],
    information_source: [],
    description: None,
    grade: [],
    domain: None,
    classification: [],
    status: None,
    version: None,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/SubstanceDefinition#resource
pub type SubstancedefinitionMoiety {
  SubstancedefinitionMoiety(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    role: Option(Codeableconcept),
    identifier: Option(Identifier),
    name: Option(String),
    stereochemistry: Option(Codeableconcept),
    optical_activity: Option(Codeableconcept),
    molecular_formula: Option(String),
    amount: Option(SubstancedefinitionMoietyAmount),
    measurement_type: Option(Codeableconcept),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/SubstanceDefinition#resource
pub type SubstancedefinitionMoietyAmount {
  SubstancedefinitionMoietyAmountQuantity(amount: Quantity)
  SubstancedefinitionMoietyAmountString(amount: String)
}

pub fn substancedefinition_moiety_amount_to_json(
  elt: SubstancedefinitionMoietyAmount,
) -> Json {
  case elt {
    SubstancedefinitionMoietyAmountQuantity(v) -> quantity_to_json(v)
    SubstancedefinitionMoietyAmountString(v) -> json.string(v)
  }
}

pub fn substancedefinition_moiety_amount_decoder() -> Decoder(
  SubstancedefinitionMoietyAmount,
) {
  decode.one_of(
    decode.field("amountQuantity", quantity_decoder(), decode.success)
      |> decode.map(SubstancedefinitionMoietyAmountQuantity),
    [
      decode.field("amountString", decode.string, decode.success)
      |> decode.map(SubstancedefinitionMoietyAmountString),
    ],
  )
}

pub fn substancedefinition_moiety_new() -> SubstancedefinitionMoiety {
  SubstancedefinitionMoiety(
    measurement_type: None,
    amount: None,
    molecular_formula: None,
    optical_activity: None,
    stereochemistry: None,
    name: None,
    identifier: None,
    role: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/SubstanceDefinition#resource
pub type SubstancedefinitionProperty {
  SubstancedefinitionProperty(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Codeableconcept,
    value: Option(SubstancedefinitionPropertyValue),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/SubstanceDefinition#resource
pub type SubstancedefinitionPropertyValue {
  SubstancedefinitionPropertyValueCodeableconcept(value: Codeableconcept)
  SubstancedefinitionPropertyValueQuantity(value: Quantity)
  SubstancedefinitionPropertyValueDate(value: String)
  SubstancedefinitionPropertyValueBoolean(value: Bool)
  SubstancedefinitionPropertyValueAttachment(value: Attachment)
}

pub fn substancedefinition_property_value_to_json(
  elt: SubstancedefinitionPropertyValue,
) -> Json {
  case elt {
    SubstancedefinitionPropertyValueCodeableconcept(v) ->
      codeableconcept_to_json(v)
    SubstancedefinitionPropertyValueQuantity(v) -> quantity_to_json(v)
    SubstancedefinitionPropertyValueDate(v) -> json.string(v)
    SubstancedefinitionPropertyValueBoolean(v) -> json.bool(v)
    SubstancedefinitionPropertyValueAttachment(v) -> attachment_to_json(v)
  }
}

pub fn substancedefinition_property_value_decoder() -> Decoder(
  SubstancedefinitionPropertyValue,
) {
  decode.one_of(
    decode.field(
      "valueCodeableConcept",
      codeableconcept_decoder(),
      decode.success,
    )
      |> decode.map(SubstancedefinitionPropertyValueCodeableconcept),
    [
      decode.field("valueQuantity", quantity_decoder(), decode.success)
        |> decode.map(SubstancedefinitionPropertyValueQuantity),
      decode.field("valueDate", decode.string, decode.success)
        |> decode.map(SubstancedefinitionPropertyValueDate),
      decode.field("valueBoolean", decode.bool, decode.success)
        |> decode.map(SubstancedefinitionPropertyValueBoolean),
      decode.field("valueAttachment", attachment_decoder(), decode.success)
        |> decode.map(SubstancedefinitionPropertyValueAttachment),
    ],
  )
}

pub fn substancedefinition_property_new(
  type_ type_: Codeableconcept,
) -> SubstancedefinitionProperty {
  SubstancedefinitionProperty(
    value: None,
    type_:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/SubstanceDefinition#resource
pub type SubstancedefinitionMolecularweight {
  SubstancedefinitionMolecularweight(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    method: Option(Codeableconcept),
    type_: Option(Codeableconcept),
    amount: Quantity,
  )
}

pub fn substancedefinition_molecularweight_new(
  amount amount: Quantity,
) -> SubstancedefinitionMolecularweight {
  SubstancedefinitionMolecularweight(
    amount:,
    type_: None,
    method: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/SubstanceDefinition#resource
pub type SubstancedefinitionStructure {
  SubstancedefinitionStructure(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    stereochemistry: Option(Codeableconcept),
    optical_activity: Option(Codeableconcept),
    molecular_formula: Option(String),
    molecular_formula_by_moiety: Option(String),
    technique: List(Codeableconcept),
    source_document: List(Reference),
    representation: List(SubstancedefinitionStructureRepresentation),
  )
}

pub fn substancedefinition_structure_new() -> SubstancedefinitionStructure {
  SubstancedefinitionStructure(
    representation: [],
    source_document: [],
    technique: [],
    molecular_formula_by_moiety: None,
    molecular_formula: None,
    optical_activity: None,
    stereochemistry: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/SubstanceDefinition#resource
pub type SubstancedefinitionStructureRepresentation {
  SubstancedefinitionStructureRepresentation(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Option(Codeableconcept),
    representation: Option(String),
    format: Option(Codeableconcept),
    document: Option(Reference),
  )
}

pub fn substancedefinition_structure_representation_new() -> SubstancedefinitionStructureRepresentation {
  SubstancedefinitionStructureRepresentation(
    document: None,
    format: None,
    representation: None,
    type_: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/SubstanceDefinition#resource
pub type SubstancedefinitionCode {
  SubstancedefinitionCode(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    code: Option(Codeableconcept),
    status: Option(Codeableconcept),
    status_date: Option(String),
    note: List(Annotation),
    source: List(Reference),
  )
}

pub fn substancedefinition_code_new() -> SubstancedefinitionCode {
  SubstancedefinitionCode(
    source: [],
    note: [],
    status_date: None,
    status: None,
    code: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/SubstanceDefinition#resource
pub type SubstancedefinitionName {
  SubstancedefinitionName(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    name: String,
    type_: Option(Codeableconcept),
    status: Option(Codeableconcept),
    preferred: Option(Bool),
    language: List(Codeableconcept),
    domain: List(Codeableconcept),
    jurisdiction: List(Codeableconcept),
    official: List(SubstancedefinitionNameOfficial),
    source: List(Reference),
  )
}

pub fn substancedefinition_name_new(
  name name: String,
) -> SubstancedefinitionName {
  SubstancedefinitionName(
    source: [],
    official: [],
    jurisdiction: [],
    domain: [],
    language: [],
    preferred: None,
    status: None,
    type_: None,
    name:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/SubstanceDefinition#resource
pub type SubstancedefinitionNameOfficial {
  SubstancedefinitionNameOfficial(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    authority: Option(Codeableconcept),
    status: Option(Codeableconcept),
    date: Option(String),
  )
}

pub fn substancedefinition_name_official_new() -> SubstancedefinitionNameOfficial {
  SubstancedefinitionNameOfficial(
    date: None,
    status: None,
    authority: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/SubstanceDefinition#resource
pub type SubstancedefinitionRelationship {
  SubstancedefinitionRelationship(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    substance_definition: Option(
      SubstancedefinitionRelationshipSubstancedefinition,
    ),
    type_: Codeableconcept,
    is_defining: Option(Bool),
    amount: Option(SubstancedefinitionRelationshipAmount),
    ratio_high_limit_amount: Option(Ratio),
    comparator: Option(Codeableconcept),
    source: List(Reference),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/SubstanceDefinition#resource
pub type SubstancedefinitionRelationshipSubstancedefinition {
  SubstancedefinitionRelationshipSubstancedefinitionReference(
    substance_definition: Reference,
  )
  SubstancedefinitionRelationshipSubstancedefinitionCodeableconcept(
    substance_definition: Codeableconcept,
  )
}

pub fn substancedefinition_relationship_substancedefinition_to_json(
  elt: SubstancedefinitionRelationshipSubstancedefinition,
) -> Json {
  case elt {
    SubstancedefinitionRelationshipSubstancedefinitionReference(v) ->
      reference_to_json(v)
    SubstancedefinitionRelationshipSubstancedefinitionCodeableconcept(v) ->
      codeableconcept_to_json(v)
  }
}

pub fn substancedefinition_relationship_substancedefinition_decoder() -> Decoder(
  SubstancedefinitionRelationshipSubstancedefinition,
) {
  decode.one_of(
    decode.field(
      "substanceDefinitionReference",
      reference_decoder(),
      decode.success,
    )
      |> decode.map(SubstancedefinitionRelationshipSubstancedefinitionReference),
    [
      decode.field(
        "substanceDefinitionCodeableConcept",
        codeableconcept_decoder(),
        decode.success,
      )
      |> decode.map(
        SubstancedefinitionRelationshipSubstancedefinitionCodeableconcept,
      ),
    ],
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/SubstanceDefinition#resource
pub type SubstancedefinitionRelationshipAmount {
  SubstancedefinitionRelationshipAmountQuantity(amount: Quantity)
  SubstancedefinitionRelationshipAmountRatio(amount: Ratio)
  SubstancedefinitionRelationshipAmountString(amount: String)
}

pub fn substancedefinition_relationship_amount_to_json(
  elt: SubstancedefinitionRelationshipAmount,
) -> Json {
  case elt {
    SubstancedefinitionRelationshipAmountQuantity(v) -> quantity_to_json(v)
    SubstancedefinitionRelationshipAmountRatio(v) -> ratio_to_json(v)
    SubstancedefinitionRelationshipAmountString(v) -> json.string(v)
  }
}

pub fn substancedefinition_relationship_amount_decoder() -> Decoder(
  SubstancedefinitionRelationshipAmount,
) {
  decode.one_of(
    decode.field("amountQuantity", quantity_decoder(), decode.success)
      |> decode.map(SubstancedefinitionRelationshipAmountQuantity),
    [
      decode.field("amountRatio", ratio_decoder(), decode.success)
        |> decode.map(SubstancedefinitionRelationshipAmountRatio),
      decode.field("amountString", decode.string, decode.success)
        |> decode.map(SubstancedefinitionRelationshipAmountString),
    ],
  )
}

pub fn substancedefinition_relationship_new(
  type_ type_: Codeableconcept,
) -> SubstancedefinitionRelationship {
  SubstancedefinitionRelationship(
    source: [],
    comparator: None,
    ratio_high_limit_amount: None,
    amount: None,
    is_defining: None,
    type_:,
    substance_definition: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/SubstanceDefinition#resource
pub type SubstancedefinitionSourcematerial {
  SubstancedefinitionSourcematerial(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Option(Codeableconcept),
    genus: Option(Codeableconcept),
    species: Option(Codeableconcept),
    part: Option(Codeableconcept),
    country_of_origin: List(Codeableconcept),
  )
}

pub fn substancedefinition_sourcematerial_new() -> SubstancedefinitionSourcematerial {
  SubstancedefinitionSourcematerial(
    country_of_origin: [],
    part: None,
    species: None,
    genus: None,
    type_: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn substancedefinition_sourcematerial_to_json(
  substancedefinition_sourcematerial: SubstancedefinitionSourcematerial,
) -> Json {
  let SubstancedefinitionSourcematerial(
    country_of_origin:,
    part:,
    species:,
    genus:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = substancedefinition_sourcematerial
  let fields = []
  let fields = case country_of_origin {
    [] -> fields
    _ -> [
      #(
        "countryOfOrigin",
        json.array(country_of_origin, codeableconcept_to_json),
      ),
      ..fields
    ]
  }
  let fields = case part {
    Some(v) -> [#("part", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case species {
    Some(v) -> [#("species", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case genus {
    Some(v) -> [#("genus", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn substancedefinition_sourcematerial_decoder() -> Decoder(
  SubstancedefinitionSourcematerial,
) {
  use country_of_origin <- decode.optional_field(
    "countryOfOrigin",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use part <- decode.optional_field(
    "part",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use species <- decode.optional_field(
    "species",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use genus <- decode.optional_field(
    "genus",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(SubstancedefinitionSourcematerial(
    country_of_origin:,
    part:,
    species:,
    genus:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn substancedefinition_relationship_to_json(
  substancedefinition_relationship: SubstancedefinitionRelationship,
) -> Json {
  let SubstancedefinitionRelationship(
    source:,
    comparator:,
    ratio_high_limit_amount:,
    amount:,
    is_defining:,
    type_:,
    substance_definition:,
    modifier_extension:,
    extension:,
    id:,
  ) = substancedefinition_relationship
  let fields = [
    #("type", codeableconcept_to_json(type_)),
  ]
  let fields = case source {
    [] -> fields
    _ -> [#("source", json.array(source, reference_to_json)), ..fields]
  }
  let fields = case comparator {
    Some(v) -> [#("comparator", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case ratio_high_limit_amount {
    Some(v) -> [#("ratioHighLimitAmount", ratio_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case amount {
    Some(v) -> [
      #(
        "amount"
          <> case v {
          SubstancedefinitionRelationshipAmountQuantity(_) -> "Quantity"
          SubstancedefinitionRelationshipAmountRatio(_) -> "Ratio"
          SubstancedefinitionRelationshipAmountString(_) -> "String"
        },
        substancedefinition_relationship_amount_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case is_defining {
    Some(v) -> [#("isDefining", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case substance_definition {
    Some(v) -> [
      #(
        "substanceDefinition"
          <> case v {
          SubstancedefinitionRelationshipSubstancedefinitionReference(_) ->
            "Reference"
          SubstancedefinitionRelationshipSubstancedefinitionCodeableconcept(_) ->
            "Codeableconcept"
        },
        substancedefinition_relationship_substancedefinition_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn substancedefinition_relationship_decoder() -> Decoder(
  SubstancedefinitionRelationship,
) {
  use source <- decode.optional_field(
    "source",
    [],
    decode.list(reference_decoder()),
  )
  use comparator <- decode.optional_field(
    "comparator",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use ratio_high_limit_amount <- decode.optional_field(
    "ratioHighLimitAmount",
    None,
    decode.optional(ratio_decoder()),
  )
  use amount <- decode.then(
    none_if_omitted(substancedefinition_relationship_amount_decoder()),
  )
  use is_defining <- decode.optional_field(
    "isDefining",
    None,
    decode.optional(decode.bool),
  )
  use type_ <- decode.field("type", codeableconcept_decoder())
  use substance_definition <- decode.then(
    none_if_omitted(
      substancedefinition_relationship_substancedefinition_decoder(),
    ),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(SubstancedefinitionRelationship(
    source:,
    comparator:,
    ratio_high_limit_amount:,
    amount:,
    is_defining:,
    type_:,
    substance_definition:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn substancedefinition_name_official_to_json(
  substancedefinition_name_official: SubstancedefinitionNameOfficial,
) -> Json {
  let SubstancedefinitionNameOfficial(
    date:,
    status:,
    authority:,
    modifier_extension:,
    extension:,
    id:,
  ) = substancedefinition_name_official
  let fields = []
  let fields = case date {
    Some(v) -> [#("date", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case status {
    Some(v) -> [#("status", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case authority {
    Some(v) -> [#("authority", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn substancedefinition_name_official_decoder() -> Decoder(
  SubstancedefinitionNameOfficial,
) {
  use date <- decode.optional_field(
    "date",
    None,
    decode.optional(decode.string),
  )
  use status <- decode.optional_field(
    "status",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use authority <- decode.optional_field(
    "authority",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(SubstancedefinitionNameOfficial(
    date:,
    status:,
    authority:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn substancedefinition_name_to_json(
  substancedefinition_name: SubstancedefinitionName,
) -> Json {
  let SubstancedefinitionName(
    source:,
    official:,
    jurisdiction:,
    domain:,
    language:,
    preferred:,
    status:,
    type_:,
    name:,
    modifier_extension:,
    extension:,
    id:,
  ) = substancedefinition_name
  let fields = [
    #("name", json.string(name)),
  ]
  let fields = case source {
    [] -> fields
    _ -> [#("source", json.array(source, reference_to_json)), ..fields]
  }
  let fields = case official {
    [] -> fields
    _ -> [
      #(
        "official",
        json.array(official, substancedefinition_name_official_to_json),
      ),
      ..fields
    ]
  }
  let fields = case jurisdiction {
    [] -> fields
    _ -> [
      #("jurisdiction", json.array(jurisdiction, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case domain {
    [] -> fields
    _ -> [#("domain", json.array(domain, codeableconcept_to_json)), ..fields]
  }
  let fields = case language {
    [] -> fields
    _ -> [
      #("language", json.array(language, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case preferred {
    Some(v) -> [#("preferred", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case status {
    Some(v) -> [#("status", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn substancedefinition_name_decoder() -> Decoder(SubstancedefinitionName) {
  use source <- decode.optional_field(
    "source",
    [],
    decode.list(reference_decoder()),
  )
  use official <- decode.optional_field(
    "official",
    [],
    decode.list(substancedefinition_name_official_decoder()),
  )
  use jurisdiction <- decode.optional_field(
    "jurisdiction",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use domain <- decode.optional_field(
    "domain",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use preferred <- decode.optional_field(
    "preferred",
    None,
    decode.optional(decode.bool),
  )
  use status <- decode.optional_field(
    "status",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use name <- decode.field("name", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(SubstancedefinitionName(
    source:,
    official:,
    jurisdiction:,
    domain:,
    language:,
    preferred:,
    status:,
    type_:,
    name:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn substancedefinition_code_to_json(
  substancedefinition_code: SubstancedefinitionCode,
) -> Json {
  let SubstancedefinitionCode(
    source:,
    note:,
    status_date:,
    status:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ) = substancedefinition_code
  let fields = []
  let fields = case source {
    [] -> fields
    _ -> [#("source", json.array(source, reference_to_json)), ..fields]
  }
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case status_date {
    Some(v) -> [#("statusDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case status {
    Some(v) -> [#("status", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case code {
    Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn substancedefinition_code_decoder() -> Decoder(SubstancedefinitionCode) {
  use source <- decode.optional_field(
    "source",
    [],
    decode.list(reference_decoder()),
  )
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use status_date <- decode.optional_field(
    "statusDate",
    None,
    decode.optional(decode.string),
  )
  use status <- decode.optional_field(
    "status",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(SubstancedefinitionCode(
    source:,
    note:,
    status_date:,
    status:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn substancedefinition_structure_representation_to_json(
  substancedefinition_structure_representation: SubstancedefinitionStructureRepresentation,
) -> Json {
  let SubstancedefinitionStructureRepresentation(
    document:,
    format:,
    representation:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = substancedefinition_structure_representation
  let fields = []
  let fields = case document {
    Some(v) -> [#("document", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case format {
    Some(v) -> [#("format", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case representation {
    Some(v) -> [#("representation", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn substancedefinition_structure_representation_decoder() -> Decoder(
  SubstancedefinitionStructureRepresentation,
) {
  use document <- decode.optional_field(
    "document",
    None,
    decode.optional(reference_decoder()),
  )
  use format <- decode.optional_field(
    "format",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use representation <- decode.optional_field(
    "representation",
    None,
    decode.optional(decode.string),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(SubstancedefinitionStructureRepresentation(
    document:,
    format:,
    representation:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn substancedefinition_structure_to_json(
  substancedefinition_structure: SubstancedefinitionStructure,
) -> Json {
  let SubstancedefinitionStructure(
    representation:,
    source_document:,
    technique:,
    molecular_formula_by_moiety:,
    molecular_formula:,
    optical_activity:,
    stereochemistry:,
    modifier_extension:,
    extension:,
    id:,
  ) = substancedefinition_structure
  let fields = []
  let fields = case representation {
    [] -> fields
    _ -> [
      #(
        "representation",
        json.array(
          representation,
          substancedefinition_structure_representation_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case source_document {
    [] -> fields
    _ -> [
      #("sourceDocument", json.array(source_document, reference_to_json)),
      ..fields
    ]
  }
  let fields = case technique {
    [] -> fields
    _ -> [
      #("technique", json.array(technique, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case molecular_formula_by_moiety {
    Some(v) -> [#("molecularFormulaByMoiety", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case molecular_formula {
    Some(v) -> [#("molecularFormula", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case optical_activity {
    Some(v) -> [#("opticalActivity", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case stereochemistry {
    Some(v) -> [#("stereochemistry", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn substancedefinition_structure_decoder() -> Decoder(
  SubstancedefinitionStructure,
) {
  use representation <- decode.optional_field(
    "representation",
    [],
    decode.list(substancedefinition_structure_representation_decoder()),
  )
  use source_document <- decode.optional_field(
    "sourceDocument",
    [],
    decode.list(reference_decoder()),
  )
  use technique <- decode.optional_field(
    "technique",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use molecular_formula_by_moiety <- decode.optional_field(
    "molecularFormulaByMoiety",
    None,
    decode.optional(decode.string),
  )
  use molecular_formula <- decode.optional_field(
    "molecularFormula",
    None,
    decode.optional(decode.string),
  )
  use optical_activity <- decode.optional_field(
    "opticalActivity",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use stereochemistry <- decode.optional_field(
    "stereochemistry",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(SubstancedefinitionStructure(
    representation:,
    source_document:,
    technique:,
    molecular_formula_by_moiety:,
    molecular_formula:,
    optical_activity:,
    stereochemistry:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn substancedefinition_molecularweight_to_json(
  substancedefinition_molecularweight: SubstancedefinitionMolecularweight,
) -> Json {
  let SubstancedefinitionMolecularweight(
    amount:,
    type_:,
    method:,
    modifier_extension:,
    extension:,
    id:,
  ) = substancedefinition_molecularweight
  let fields = [
    #("amount", quantity_to_json(amount)),
  ]
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case method {
    Some(v) -> [#("method", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn substancedefinition_molecularweight_decoder() -> Decoder(
  SubstancedefinitionMolecularweight,
) {
  use amount <- decode.field("amount", quantity_decoder())
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use method <- decode.optional_field(
    "method",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(SubstancedefinitionMolecularweight(
    amount:,
    type_:,
    method:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn substancedefinition_property_to_json(
  substancedefinition_property: SubstancedefinitionProperty,
) -> Json {
  let SubstancedefinitionProperty(
    value:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = substancedefinition_property
  let fields = [
    #("type", codeableconcept_to_json(type_)),
  ]
  let fields = case value {
    Some(v) -> [
      #(
        "value"
          <> case v {
          SubstancedefinitionPropertyValueCodeableconcept(_) ->
            "Codeableconcept"
          SubstancedefinitionPropertyValueQuantity(_) -> "Quantity"
          SubstancedefinitionPropertyValueDate(_) -> "Date"
          SubstancedefinitionPropertyValueBoolean(_) -> "Boolean"
          SubstancedefinitionPropertyValueAttachment(_) -> "Attachment"
        },
        substancedefinition_property_value_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn substancedefinition_property_decoder() -> Decoder(
  SubstancedefinitionProperty,
) {
  use value <- decode.then(
    none_if_omitted(substancedefinition_property_value_decoder()),
  )
  use type_ <- decode.field("type", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(SubstancedefinitionProperty(
    value:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn substancedefinition_moiety_to_json(
  substancedefinition_moiety: SubstancedefinitionMoiety,
) -> Json {
  let SubstancedefinitionMoiety(
    measurement_type:,
    amount:,
    molecular_formula:,
    optical_activity:,
    stereochemistry:,
    name:,
    identifier:,
    role:,
    modifier_extension:,
    extension:,
    id:,
  ) = substancedefinition_moiety
  let fields = []
  let fields = case measurement_type {
    Some(v) -> [#("measurementType", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case amount {
    Some(v) -> [
      #(
        "amount"
          <> case v {
          SubstancedefinitionMoietyAmountQuantity(_) -> "Quantity"
          SubstancedefinitionMoietyAmountString(_) -> "String"
        },
        substancedefinition_moiety_amount_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case molecular_formula {
    Some(v) -> [#("molecularFormula", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case optical_activity {
    Some(v) -> [#("opticalActivity", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case stereochemistry {
    Some(v) -> [#("stereochemistry", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    Some(v) -> [#("identifier", identifier_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case role {
    Some(v) -> [#("role", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn substancedefinition_moiety_decoder() -> Decoder(
  SubstancedefinitionMoiety,
) {
  use measurement_type <- decode.optional_field(
    "measurementType",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use amount <- decode.then(
    none_if_omitted(substancedefinition_moiety_amount_decoder()),
  )
  use molecular_formula <- decode.optional_field(
    "molecularFormula",
    None,
    decode.optional(decode.string),
  )
  use optical_activity <- decode.optional_field(
    "opticalActivity",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use stereochemistry <- decode.optional_field(
    "stereochemistry",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    None,
    decode.optional(identifier_decoder()),
  )
  use role <- decode.optional_field(
    "role",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(SubstancedefinitionMoiety(
    measurement_type:,
    amount:,
    molecular_formula:,
    optical_activity:,
    stereochemistry:,
    name:,
    identifier:,
    role:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn substancedefinition_to_json(
  substancedefinition: Substancedefinition,
) -> Json {
  let Substancedefinition(
    source_material:,
    relationship:,
    name:,
    code:,
    structure:,
    molecular_weight:,
    property:,
    moiety:,
    supplier:,
    manufacturer:,
    note:,
    information_source:,
    description:,
    grade:,
    domain:,
    classification:,
    status:,
    version:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = substancedefinition
  let fields = []
  let fields = case source_material {
    Some(v) -> [
      #("sourceMaterial", substancedefinition_sourcematerial_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case relationship {
    [] -> fields
    _ -> [
      #(
        "relationship",
        json.array(relationship, substancedefinition_relationship_to_json),
      ),
      ..fields
    ]
  }
  let fields = case name {
    [] -> fields
    _ -> [
      #("name", json.array(name, substancedefinition_name_to_json)),
      ..fields
    ]
  }
  let fields = case code {
    [] -> fields
    _ -> [
      #("code", json.array(code, substancedefinition_code_to_json)),
      ..fields
    ]
  }
  let fields = case structure {
    Some(v) -> [
      #("structure", substancedefinition_structure_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case molecular_weight {
    [] -> fields
    _ -> [
      #(
        "molecularWeight",
        json.array(
          molecular_weight,
          substancedefinition_molecularweight_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case property {
    [] -> fields
    _ -> [
      #("property", json.array(property, substancedefinition_property_to_json)),
      ..fields
    ]
  }
  let fields = case moiety {
    [] -> fields
    _ -> [
      #("moiety", json.array(moiety, substancedefinition_moiety_to_json)),
      ..fields
    ]
  }
  let fields = case supplier {
    [] -> fields
    _ -> [#("supplier", json.array(supplier, reference_to_json)), ..fields]
  }
  let fields = case manufacturer {
    [] -> fields
    _ -> [
      #("manufacturer", json.array(manufacturer, reference_to_json)),
      ..fields
    ]
  }
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case information_source {
    [] -> fields
    _ -> [
      #("informationSource", json.array(information_source, reference_to_json)),
      ..fields
    ]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case grade {
    [] -> fields
    _ -> [#("grade", json.array(grade, codeableconcept_to_json)), ..fields]
  }
  let fields = case domain {
    Some(v) -> [#("domain", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case classification {
    [] -> fields
    _ -> [
      #("classification", json.array(classification, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case status {
    Some(v) -> [#("status", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case version {
    Some(v) -> [#("version", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Substancedefinition")), ..fields]
  json.object(fields)
}

pub fn substancedefinition_decoder() -> Decoder(Substancedefinition) {
  use source_material <- decode.optional_field(
    "sourceMaterial",
    None,
    decode.optional(substancedefinition_sourcematerial_decoder()),
  )
  use relationship <- decode.optional_field(
    "relationship",
    [],
    decode.list(substancedefinition_relationship_decoder()),
  )
  use name <- decode.optional_field(
    "name",
    [],
    decode.list(substancedefinition_name_decoder()),
  )
  use code <- decode.optional_field(
    "code",
    [],
    decode.list(substancedefinition_code_decoder()),
  )
  use structure <- decode.optional_field(
    "structure",
    None,
    decode.optional(substancedefinition_structure_decoder()),
  )
  use molecular_weight <- decode.optional_field(
    "molecularWeight",
    [],
    decode.list(substancedefinition_molecularweight_decoder()),
  )
  use property <- decode.optional_field(
    "property",
    [],
    decode.list(substancedefinition_property_decoder()),
  )
  use moiety <- decode.optional_field(
    "moiety",
    [],
    decode.list(substancedefinition_moiety_decoder()),
  )
  use supplier <- decode.optional_field(
    "supplier",
    [],
    decode.list(reference_decoder()),
  )
  use manufacturer <- decode.optional_field(
    "manufacturer",
    [],
    decode.list(reference_decoder()),
  )
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use information_source <- decode.optional_field(
    "informationSource",
    [],
    decode.list(reference_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use grade <- decode.optional_field(
    "grade",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use domain <- decode.optional_field(
    "domain",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use classification <- decode.optional_field(
    "classification",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use status <- decode.optional_field(
    "status",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use version <- decode.optional_field(
    "version",
    None,
    decode.optional(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Substancedefinition",
    decode.failure(substancedefinition_new(), "resourceType"),
  )
  decode.success(Substancedefinition(
    source_material:,
    relationship:,
    name:,
    code:,
    structure:,
    molecular_weight:,
    property:,
    moiety:,
    supplier:,
    manufacturer:,
    note:,
    information_source:,
    description:,
    grade:,
    domain:,
    classification:,
    status:,
    version:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/SupplyDelivery#resource
pub type Supplydelivery {
  Supplydelivery(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    based_on: List(Reference),
    part_of: List(Reference),
    status: Option(r4bvaluesets.Supplydeliverystatus),
    patient: Option(Reference),
    type_: Option(Codeableconcept),
    supplied_item: Option(SupplydeliverySupplieditem),
    occurrence: Option(SupplydeliveryOccurrence),
    supplier: Option(Reference),
    destination: Option(Reference),
    receiver: List(Reference),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/SupplyDelivery#resource
pub type SupplydeliveryOccurrence {
  SupplydeliveryOccurrenceDatetime(occurrence: String)
  SupplydeliveryOccurrencePeriod(occurrence: Period)
  SupplydeliveryOccurrenceTiming(occurrence: Timing)
}

pub fn supplydelivery_occurrence_to_json(elt: SupplydeliveryOccurrence) -> Json {
  case elt {
    SupplydeliveryOccurrenceDatetime(v) -> json.string(v)
    SupplydeliveryOccurrencePeriod(v) -> period_to_json(v)
    SupplydeliveryOccurrenceTiming(v) -> timing_to_json(v)
  }
}

pub fn supplydelivery_occurrence_decoder() -> Decoder(SupplydeliveryOccurrence) {
  decode.one_of(
    decode.field("occurrenceDateTime", decode.string, decode.success)
      |> decode.map(SupplydeliveryOccurrenceDatetime),
    [
      decode.field("occurrencePeriod", period_decoder(), decode.success)
        |> decode.map(SupplydeliveryOccurrencePeriod),
      decode.field("occurrenceTiming", timing_decoder(), decode.success)
        |> decode.map(SupplydeliveryOccurrenceTiming),
    ],
  )
}

pub fn supplydelivery_new() -> Supplydelivery {
  Supplydelivery(
    receiver: [],
    destination: None,
    supplier: None,
    occurrence: None,
    supplied_item: None,
    type_: None,
    patient: None,
    status: None,
    part_of: [],
    based_on: [],
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/SupplyDelivery#resource
pub type SupplydeliverySupplieditem {
  SupplydeliverySupplieditem(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    quantity: Option(Quantity),
    item: Option(SupplydeliverySupplieditemItem),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/SupplyDelivery#resource
pub type SupplydeliverySupplieditemItem {
  SupplydeliverySupplieditemItemCodeableconcept(item: Codeableconcept)
  SupplydeliverySupplieditemItemReference(item: Reference)
}

pub fn supplydelivery_supplieditem_item_to_json(
  elt: SupplydeliverySupplieditemItem,
) -> Json {
  case elt {
    SupplydeliverySupplieditemItemCodeableconcept(v) ->
      codeableconcept_to_json(v)
    SupplydeliverySupplieditemItemReference(v) -> reference_to_json(v)
  }
}

pub fn supplydelivery_supplieditem_item_decoder() -> Decoder(
  SupplydeliverySupplieditemItem,
) {
  decode.one_of(
    decode.field(
      "itemCodeableConcept",
      codeableconcept_decoder(),
      decode.success,
    )
      |> decode.map(SupplydeliverySupplieditemItemCodeableconcept),
    [
      decode.field("itemReference", reference_decoder(), decode.success)
      |> decode.map(SupplydeliverySupplieditemItemReference),
    ],
  )
}

pub fn supplydelivery_supplieditem_new() -> SupplydeliverySupplieditem {
  SupplydeliverySupplieditem(
    item: None,
    quantity: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn supplydelivery_supplieditem_to_json(
  supplydelivery_supplieditem: SupplydeliverySupplieditem,
) -> Json {
  let SupplydeliverySupplieditem(
    item:,
    quantity:,
    modifier_extension:,
    extension:,
    id:,
  ) = supplydelivery_supplieditem
  let fields = []
  let fields = case item {
    Some(v) -> [
      #(
        "item"
          <> case v {
          SupplydeliverySupplieditemItemCodeableconcept(_) -> "Codeableconcept"
          SupplydeliverySupplieditemItemReference(_) -> "Reference"
        },
        supplydelivery_supplieditem_item_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case quantity {
    Some(v) -> [#("quantity", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn supplydelivery_supplieditem_decoder() -> Decoder(
  SupplydeliverySupplieditem,
) {
  use item <- decode.then(
    none_if_omitted(supplydelivery_supplieditem_item_decoder()),
  )
  use quantity <- decode.optional_field(
    "quantity",
    None,
    decode.optional(quantity_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(SupplydeliverySupplieditem(
    item:,
    quantity:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn supplydelivery_to_json(supplydelivery: Supplydelivery) -> Json {
  let Supplydelivery(
    receiver:,
    destination:,
    supplier:,
    occurrence:,
    supplied_item:,
    type_:,
    patient:,
    status:,
    part_of:,
    based_on:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = supplydelivery
  let fields = []
  let fields = case receiver {
    [] -> fields
    _ -> [#("receiver", json.array(receiver, reference_to_json)), ..fields]
  }
  let fields = case destination {
    Some(v) -> [#("destination", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case supplier {
    Some(v) -> [#("supplier", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case occurrence {
    Some(v) -> [
      #(
        "occurrence"
          <> case v {
          SupplydeliveryOccurrenceDatetime(_) -> "Datetime"
          SupplydeliveryOccurrencePeriod(_) -> "Period"
          SupplydeliveryOccurrenceTiming(_) -> "Timing"
        },
        supplydelivery_occurrence_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case supplied_item {
    Some(v) -> [
      #("suppliedItem", supplydelivery_supplieditem_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case patient {
    Some(v) -> [#("patient", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case status {
    Some(v) -> [
      #("status", r4bvaluesets.supplydeliverystatus_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case part_of {
    [] -> fields
    _ -> [#("partOf", json.array(part_of, reference_to_json)), ..fields]
  }
  let fields = case based_on {
    [] -> fields
    _ -> [#("basedOn", json.array(based_on, reference_to_json)), ..fields]
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Supplydelivery")), ..fields]
  json.object(fields)
}

pub fn supplydelivery_decoder() -> Decoder(Supplydelivery) {
  use receiver <- decode.optional_field(
    "receiver",
    [],
    decode.list(reference_decoder()),
  )
  use destination <- decode.optional_field(
    "destination",
    None,
    decode.optional(reference_decoder()),
  )
  use supplier <- decode.optional_field(
    "supplier",
    None,
    decode.optional(reference_decoder()),
  )
  use occurrence <- decode.then(
    none_if_omitted(supplydelivery_occurrence_decoder()),
  )
  use supplied_item <- decode.optional_field(
    "suppliedItem",
    None,
    decode.optional(supplydelivery_supplieditem_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use patient <- decode.optional_field(
    "patient",
    None,
    decode.optional(reference_decoder()),
  )
  use status <- decode.optional_field(
    "status",
    None,
    decode.optional(r4bvaluesets.supplydeliverystatus_decoder()),
  )
  use part_of <- decode.optional_field(
    "partOf",
    [],
    decode.list(reference_decoder()),
  )
  use based_on <- decode.optional_field(
    "basedOn",
    [],
    decode.list(reference_decoder()),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Supplydelivery",
    decode.failure(supplydelivery_new(), "resourceType"),
  )
  decode.success(Supplydelivery(
    receiver:,
    destination:,
    supplier:,
    occurrence:,
    supplied_item:,
    type_:,
    patient:,
    status:,
    part_of:,
    based_on:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/SupplyRequest#resource
pub type Supplyrequest {
  Supplyrequest(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    status: Option(r4bvaluesets.Supplyrequeststatus),
    category: Option(Codeableconcept),
    priority: Option(r4bvaluesets.Requestpriority),
    item: SupplyrequestItem,
    quantity: Quantity,
    parameter: List(SupplyrequestParameter),
    occurrence: Option(SupplyrequestOccurrence),
    authored_on: Option(String),
    requester: Option(Reference),
    supplier: List(Reference),
    reason_code: List(Codeableconcept),
    reason_reference: List(Reference),
    deliver_from: Option(Reference),
    deliver_to: Option(Reference),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/SupplyRequest#resource
pub type SupplyrequestItem {
  SupplyrequestItemCodeableconcept(item: Codeableconcept)
  SupplyrequestItemReference(item: Reference)
}

pub fn supplyrequest_item_to_json(elt: SupplyrequestItem) -> Json {
  case elt {
    SupplyrequestItemCodeableconcept(v) -> codeableconcept_to_json(v)
    SupplyrequestItemReference(v) -> reference_to_json(v)
  }
}

pub fn supplyrequest_item_decoder() -> Decoder(SupplyrequestItem) {
  decode.one_of(
    decode.field(
      "itemCodeableConcept",
      codeableconcept_decoder(),
      decode.success,
    )
      |> decode.map(SupplyrequestItemCodeableconcept),
    [
      decode.field("itemReference", reference_decoder(), decode.success)
      |> decode.map(SupplyrequestItemReference),
    ],
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/SupplyRequest#resource
pub type SupplyrequestOccurrence {
  SupplyrequestOccurrenceDatetime(occurrence: String)
  SupplyrequestOccurrencePeriod(occurrence: Period)
  SupplyrequestOccurrenceTiming(occurrence: Timing)
}

pub fn supplyrequest_occurrence_to_json(elt: SupplyrequestOccurrence) -> Json {
  case elt {
    SupplyrequestOccurrenceDatetime(v) -> json.string(v)
    SupplyrequestOccurrencePeriod(v) -> period_to_json(v)
    SupplyrequestOccurrenceTiming(v) -> timing_to_json(v)
  }
}

pub fn supplyrequest_occurrence_decoder() -> Decoder(SupplyrequestOccurrence) {
  decode.one_of(
    decode.field("occurrenceDateTime", decode.string, decode.success)
      |> decode.map(SupplyrequestOccurrenceDatetime),
    [
      decode.field("occurrencePeriod", period_decoder(), decode.success)
        |> decode.map(SupplyrequestOccurrencePeriod),
      decode.field("occurrenceTiming", timing_decoder(), decode.success)
        |> decode.map(SupplyrequestOccurrenceTiming),
    ],
  )
}

pub fn supplyrequest_new(
  quantity quantity: Quantity,
  item item: SupplyrequestItem,
) -> Supplyrequest {
  Supplyrequest(
    deliver_to: None,
    deliver_from: None,
    reason_reference: [],
    reason_code: [],
    supplier: [],
    requester: None,
    authored_on: None,
    occurrence: None,
    parameter: [],
    quantity:,
    item:,
    priority: None,
    category: None,
    status: None,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/SupplyRequest#resource
pub type SupplyrequestParameter {
  SupplyrequestParameter(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    code: Option(Codeableconcept),
    value: Option(SupplyrequestParameterValue),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/SupplyRequest#resource
pub type SupplyrequestParameterValue {
  SupplyrequestParameterValueCodeableconcept(value: Codeableconcept)
  SupplyrequestParameterValueQuantity(value: Quantity)
  SupplyrequestParameterValueRange(value: Range)
  SupplyrequestParameterValueBoolean(value: Bool)
}

pub fn supplyrequest_parameter_value_to_json(
  elt: SupplyrequestParameterValue,
) -> Json {
  case elt {
    SupplyrequestParameterValueCodeableconcept(v) -> codeableconcept_to_json(v)
    SupplyrequestParameterValueQuantity(v) -> quantity_to_json(v)
    SupplyrequestParameterValueRange(v) -> range_to_json(v)
    SupplyrequestParameterValueBoolean(v) -> json.bool(v)
  }
}

pub fn supplyrequest_parameter_value_decoder() -> Decoder(
  SupplyrequestParameterValue,
) {
  decode.one_of(
    decode.field(
      "valueCodeableConcept",
      codeableconcept_decoder(),
      decode.success,
    )
      |> decode.map(SupplyrequestParameterValueCodeableconcept),
    [
      decode.field("valueQuantity", quantity_decoder(), decode.success)
        |> decode.map(SupplyrequestParameterValueQuantity),
      decode.field("valueRange", range_decoder(), decode.success)
        |> decode.map(SupplyrequestParameterValueRange),
      decode.field("valueBoolean", decode.bool, decode.success)
        |> decode.map(SupplyrequestParameterValueBoolean),
    ],
  )
}

pub fn supplyrequest_parameter_new() -> SupplyrequestParameter {
  SupplyrequestParameter(
    value: None,
    code: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn supplyrequest_parameter_to_json(
  supplyrequest_parameter: SupplyrequestParameter,
) -> Json {
  let SupplyrequestParameter(
    value:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ) = supplyrequest_parameter
  let fields = []
  let fields = case value {
    Some(v) -> [
      #(
        "value"
          <> case v {
          SupplyrequestParameterValueCodeableconcept(_) -> "Codeableconcept"
          SupplyrequestParameterValueQuantity(_) -> "Quantity"
          SupplyrequestParameterValueRange(_) -> "Range"
          SupplyrequestParameterValueBoolean(_) -> "Boolean"
        },
        supplyrequest_parameter_value_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case code {
    Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn supplyrequest_parameter_decoder() -> Decoder(SupplyrequestParameter) {
  use value <- decode.then(
    none_if_omitted(supplyrequest_parameter_value_decoder()),
  )
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(SupplyrequestParameter(
    value:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn supplyrequest_to_json(supplyrequest: Supplyrequest) -> Json {
  let Supplyrequest(
    deliver_to:,
    deliver_from:,
    reason_reference:,
    reason_code:,
    supplier:,
    requester:,
    authored_on:,
    occurrence:,
    parameter:,
    quantity:,
    item:,
    priority:,
    category:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = supplyrequest
  let fields = [
    #("quantity", quantity_to_json(quantity)),
    #("item", supplyrequest_item_to_json(item)),
  ]
  let fields = case deliver_to {
    Some(v) -> [#("deliverTo", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case deliver_from {
    Some(v) -> [#("deliverFrom", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case reason_reference {
    [] -> fields
    _ -> [
      #("reasonReference", json.array(reason_reference, reference_to_json)),
      ..fields
    ]
  }
  let fields = case reason_code {
    [] -> fields
    _ -> [
      #("reasonCode", json.array(reason_code, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case supplier {
    [] -> fields
    _ -> [#("supplier", json.array(supplier, reference_to_json)), ..fields]
  }
  let fields = case requester {
    Some(v) -> [#("requester", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case authored_on {
    Some(v) -> [#("authoredOn", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case occurrence {
    Some(v) -> [
      #(
        "occurrence"
          <> case v {
          SupplyrequestOccurrenceDatetime(_) -> "Datetime"
          SupplyrequestOccurrencePeriod(_) -> "Period"
          SupplyrequestOccurrenceTiming(_) -> "Timing"
        },
        supplyrequest_occurrence_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case parameter {
    [] -> fields
    _ -> [
      #("parameter", json.array(parameter, supplyrequest_parameter_to_json)),
      ..fields
    ]
  }
  let fields = case priority {
    Some(v) -> [
      #("priority", r4bvaluesets.requestpriority_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case category {
    Some(v) -> [#("category", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case status {
    Some(v) -> [
      #("status", r4bvaluesets.supplyrequeststatus_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Supplyrequest")), ..fields]
  json.object(fields)
}

pub fn supplyrequest_decoder() -> Decoder(Supplyrequest) {
  use deliver_to <- decode.optional_field(
    "deliverTo",
    None,
    decode.optional(reference_decoder()),
  )
  use deliver_from <- decode.optional_field(
    "deliverFrom",
    None,
    decode.optional(reference_decoder()),
  )
  use reason_reference <- decode.optional_field(
    "reasonReference",
    [],
    decode.list(reference_decoder()),
  )
  use reason_code <- decode.optional_field(
    "reasonCode",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use supplier <- decode.optional_field(
    "supplier",
    [],
    decode.list(reference_decoder()),
  )
  use requester <- decode.optional_field(
    "requester",
    None,
    decode.optional(reference_decoder()),
  )
  use authored_on <- decode.optional_field(
    "authoredOn",
    None,
    decode.optional(decode.string),
  )
  use occurrence <- decode.then(
    none_if_omitted(supplyrequest_occurrence_decoder()),
  )
  use parameter <- decode.optional_field(
    "parameter",
    [],
    decode.list(supplyrequest_parameter_decoder()),
  )
  use quantity <- decode.field("quantity", quantity_decoder())
  use item <- decode.then(supplyrequest_item_decoder())
  use priority <- decode.optional_field(
    "priority",
    None,
    decode.optional(r4bvaluesets.requestpriority_decoder()),
  )
  use category <- decode.optional_field(
    "category",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use status <- decode.optional_field(
    "status",
    None,
    decode.optional(r4bvaluesets.supplyrequeststatus_decoder()),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Supplyrequest",
    decode.failure(supplyrequest_new(quantity:, item:), "resourceType"),
  )
  decode.success(Supplyrequest(
    deliver_to:,
    deliver_from:,
    reason_reference:,
    reason_code:,
    supplier:,
    requester:,
    authored_on:,
    occurrence:,
    parameter:,
    quantity:,
    item:,
    priority:,
    category:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/Task#resource
pub type Task {
  Task(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    instantiates_canonical: Option(String),
    instantiates_uri: Option(String),
    based_on: List(Reference),
    group_identifier: Option(Identifier),
    part_of: List(Reference),
    status: r4bvaluesets.Taskstatus,
    status_reason: Option(Codeableconcept),
    business_status: Option(Codeableconcept),
    intent: r4bvaluesets.Taskintent,
    priority: Option(r4bvaluesets.Requestpriority),
    code: Option(Codeableconcept),
    description: Option(String),
    focus: Option(Reference),
    for: Option(Reference),
    encounter: Option(Reference),
    execution_period: Option(Period),
    authored_on: Option(String),
    last_modified: Option(String),
    requester: Option(Reference),
    performer_type: List(Codeableconcept),
    owner: Option(Reference),
    location: Option(Reference),
    reason_code: Option(Codeableconcept),
    reason_reference: Option(Reference),
    insurance: List(Reference),
    note: List(Annotation),
    relevant_history: List(Reference),
    restriction: Option(TaskRestriction),
    input: List(TaskInput),
    output: List(TaskOutput),
  )
}

pub fn task_new(
  intent intent: r4bvaluesets.Taskintent,
  status status: r4bvaluesets.Taskstatus,
) -> Task {
  Task(
    output: [],
    input: [],
    restriction: None,
    relevant_history: [],
    note: [],
    insurance: [],
    reason_reference: None,
    reason_code: None,
    location: None,
    owner: None,
    performer_type: [],
    requester: None,
    last_modified: None,
    authored_on: None,
    execution_period: None,
    encounter: None,
    for: None,
    focus: None,
    description: None,
    code: None,
    priority: None,
    intent:,
    business_status: None,
    status_reason: None,
    status:,
    part_of: [],
    group_identifier: None,
    based_on: [],
    instantiates_uri: None,
    instantiates_canonical: None,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Task#resource
pub type TaskRestriction {
  TaskRestriction(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    repetitions: Option(Int),
    period: Option(Period),
    recipient: List(Reference),
  )
}

pub fn task_restriction_new() -> TaskRestriction {
  TaskRestriction(
    recipient: [],
    period: None,
    repetitions: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Task#resource
pub type TaskInput {
  TaskInput(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Codeableconcept,
    value: TaskInputValue,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Task#resource
pub type TaskInputValue {
  TaskInputValueBase64binary(value: String)
  TaskInputValueBoolean(value: Bool)
  TaskInputValueCanonical(value: String)
  TaskInputValueCode(value: String)
  TaskInputValueDate(value: String)
  TaskInputValueDatetime(value: String)
  TaskInputValueDecimal(value: Float)
  TaskInputValueId(value: String)
  TaskInputValueInstant(value: String)
  TaskInputValueInteger(value: Int)
  TaskInputValueMarkdown(value: String)
  TaskInputValueOid(value: String)
  TaskInputValuePositiveint(value: Int)
  TaskInputValueString(value: String)
  TaskInputValueTime(value: String)
  TaskInputValueUnsignedint(value: Int)
  TaskInputValueUri(value: String)
  TaskInputValueUrl(value: String)
  TaskInputValueUuid(value: String)
  TaskInputValueAddress(value: Address)
  TaskInputValueAge(value: Age)
  TaskInputValueAnnotation(value: Annotation)
  TaskInputValueAttachment(value: Attachment)
  TaskInputValueCodeableconcept(value: Codeableconcept)
  TaskInputValueCoding(value: Coding)
  TaskInputValueContactpoint(value: Contactpoint)
  TaskInputValueCount(value: Count)
  TaskInputValueDistance(value: Distance)
  TaskInputValueDuration(value: Duration)
  TaskInputValueHumanname(value: Humanname)
  TaskInputValueIdentifier(value: Identifier)
  TaskInputValueMoney(value: Money)
  TaskInputValuePeriod(value: Period)
  TaskInputValueQuantity(value: Quantity)
  TaskInputValueRange(value: Range)
  TaskInputValueRatio(value: Ratio)
  TaskInputValueReference(value: Reference)
  TaskInputValueSampleddata(value: Sampleddata)
  TaskInputValueSignature(value: Signature)
  TaskInputValueTiming(value: Timing)
  TaskInputValueContactdetail(value: Contactdetail)
  TaskInputValueContributor(value: Contributor)
  TaskInputValueDatarequirement(value: Datarequirement)
  TaskInputValueExpression(value: Expression)
  TaskInputValueParameterdefinition(value: Parameterdefinition)
  TaskInputValueRelatedartifact(value: Relatedartifact)
  TaskInputValueTriggerdefinition(value: Triggerdefinition)
  TaskInputValueUsagecontext(value: Usagecontext)
  TaskInputValueDosage(value: Dosage)
  TaskInputValueMeta(value: Meta)
}

pub fn task_input_value_to_json(elt: TaskInputValue) -> Json {
  case elt {
    TaskInputValueBase64binary(v) -> json.string(v)
    TaskInputValueBoolean(v) -> json.bool(v)
    TaskInputValueCanonical(v) -> json.string(v)
    TaskInputValueCode(v) -> json.string(v)
    TaskInputValueDate(v) -> json.string(v)
    TaskInputValueDatetime(v) -> json.string(v)
    TaskInputValueDecimal(v) -> json.float(v)
    TaskInputValueId(v) -> json.string(v)
    TaskInputValueInstant(v) -> json.string(v)
    TaskInputValueInteger(v) -> json.int(v)
    TaskInputValueMarkdown(v) -> json.string(v)
    TaskInputValueOid(v) -> json.string(v)
    TaskInputValuePositiveint(v) -> json.int(v)
    TaskInputValueString(v) -> json.string(v)
    TaskInputValueTime(v) -> json.string(v)
    TaskInputValueUnsignedint(v) -> json.int(v)
    TaskInputValueUri(v) -> json.string(v)
    TaskInputValueUrl(v) -> json.string(v)
    TaskInputValueUuid(v) -> json.string(v)
    TaskInputValueAddress(v) -> address_to_json(v)
    TaskInputValueAge(v) -> age_to_json(v)
    TaskInputValueAnnotation(v) -> annotation_to_json(v)
    TaskInputValueAttachment(v) -> attachment_to_json(v)
    TaskInputValueCodeableconcept(v) -> codeableconcept_to_json(v)
    TaskInputValueCoding(v) -> coding_to_json(v)
    TaskInputValueContactpoint(v) -> contactpoint_to_json(v)
    TaskInputValueCount(v) -> count_to_json(v)
    TaskInputValueDistance(v) -> distance_to_json(v)
    TaskInputValueDuration(v) -> duration_to_json(v)
    TaskInputValueHumanname(v) -> humanname_to_json(v)
    TaskInputValueIdentifier(v) -> identifier_to_json(v)
    TaskInputValueMoney(v) -> money_to_json(v)
    TaskInputValuePeriod(v) -> period_to_json(v)
    TaskInputValueQuantity(v) -> quantity_to_json(v)
    TaskInputValueRange(v) -> range_to_json(v)
    TaskInputValueRatio(v) -> ratio_to_json(v)
    TaskInputValueReference(v) -> reference_to_json(v)
    TaskInputValueSampleddata(v) -> sampleddata_to_json(v)
    TaskInputValueSignature(v) -> signature_to_json(v)
    TaskInputValueTiming(v) -> timing_to_json(v)
    TaskInputValueContactdetail(v) -> contactdetail_to_json(v)
    TaskInputValueContributor(v) -> contributor_to_json(v)
    TaskInputValueDatarequirement(v) -> datarequirement_to_json(v)
    TaskInputValueExpression(v) -> expression_to_json(v)
    TaskInputValueParameterdefinition(v) -> parameterdefinition_to_json(v)
    TaskInputValueRelatedartifact(v) -> relatedartifact_to_json(v)
    TaskInputValueTriggerdefinition(v) -> triggerdefinition_to_json(v)
    TaskInputValueUsagecontext(v) -> usagecontext_to_json(v)
    TaskInputValueDosage(v) -> dosage_to_json(v)
    TaskInputValueMeta(v) -> meta_to_json(v)
  }
}

pub fn task_input_value_decoder() -> Decoder(TaskInputValue) {
  decode.one_of(
    decode.field("valueBase64Binary", decode.string, decode.success)
      |> decode.map(TaskInputValueBase64binary),
    [
      decode.field("valueBoolean", decode.bool, decode.success)
        |> decode.map(TaskInputValueBoolean),
      decode.field("valueCanonical", decode.string, decode.success)
        |> decode.map(TaskInputValueCanonical),
      decode.field("valueCode", decode.string, decode.success)
        |> decode.map(TaskInputValueCode),
      decode.field("valueDate", decode.string, decode.success)
        |> decode.map(TaskInputValueDate),
      decode.field("valueDateTime", decode.string, decode.success)
        |> decode.map(TaskInputValueDatetime),
      decode.field("valueDecimal", decode.float, decode.success)
        |> decode.map(TaskInputValueDecimal),
      decode.field("valueId", decode.string, decode.success)
        |> decode.map(TaskInputValueId),
      decode.field("valueInstant", decode.string, decode.success)
        |> decode.map(TaskInputValueInstant),
      decode.field("valueInteger", decode.int, decode.success)
        |> decode.map(TaskInputValueInteger),
      decode.field("valueMarkdown", decode.string, decode.success)
        |> decode.map(TaskInputValueMarkdown),
      decode.field("valueOid", decode.string, decode.success)
        |> decode.map(TaskInputValueOid),
      decode.field("valuePositiveInt", decode.int, decode.success)
        |> decode.map(TaskInputValuePositiveint),
      decode.field("valueString", decode.string, decode.success)
        |> decode.map(TaskInputValueString),
      decode.field("valueTime", decode.string, decode.success)
        |> decode.map(TaskInputValueTime),
      decode.field("valueUnsignedInt", decode.int, decode.success)
        |> decode.map(TaskInputValueUnsignedint),
      decode.field("valueUri", decode.string, decode.success)
        |> decode.map(TaskInputValueUri),
      decode.field("valueUrl", decode.string, decode.success)
        |> decode.map(TaskInputValueUrl),
      decode.field("valueUuid", decode.string, decode.success)
        |> decode.map(TaskInputValueUuid),
      decode.field("valueAddress", address_decoder(), decode.success)
        |> decode.map(TaskInputValueAddress),
      decode.field("valueAge", age_decoder(), decode.success)
        |> decode.map(TaskInputValueAge),
      decode.field("valueAnnotation", annotation_decoder(), decode.success)
        |> decode.map(TaskInputValueAnnotation),
      decode.field("valueAttachment", attachment_decoder(), decode.success)
        |> decode.map(TaskInputValueAttachment),
      decode.field(
        "valueCodeableConcept",
        codeableconcept_decoder(),
        decode.success,
      )
        |> decode.map(TaskInputValueCodeableconcept),
      decode.field("valueCoding", coding_decoder(), decode.success)
        |> decode.map(TaskInputValueCoding),
      decode.field("valueContactPoint", contactpoint_decoder(), decode.success)
        |> decode.map(TaskInputValueContactpoint),
      decode.field("valueCount", count_decoder(), decode.success)
        |> decode.map(TaskInputValueCount),
      decode.field("valueDistance", distance_decoder(), decode.success)
        |> decode.map(TaskInputValueDistance),
      decode.field("valueDuration", duration_decoder(), decode.success)
        |> decode.map(TaskInputValueDuration),
      decode.field("valueHumanName", humanname_decoder(), decode.success)
        |> decode.map(TaskInputValueHumanname),
      decode.field("valueIdentifier", identifier_decoder(), decode.success)
        |> decode.map(TaskInputValueIdentifier),
      decode.field("valueMoney", money_decoder(), decode.success)
        |> decode.map(TaskInputValueMoney),
      decode.field("valuePeriod", period_decoder(), decode.success)
        |> decode.map(TaskInputValuePeriod),
      decode.field("valueQuantity", quantity_decoder(), decode.success)
        |> decode.map(TaskInputValueQuantity),
      decode.field("valueRange", range_decoder(), decode.success)
        |> decode.map(TaskInputValueRange),
      decode.field("valueRatio", ratio_decoder(), decode.success)
        |> decode.map(TaskInputValueRatio),
      decode.field("valueReference", reference_decoder(), decode.success)
        |> decode.map(TaskInputValueReference),
      decode.field("valueSampledData", sampleddata_decoder(), decode.success)
        |> decode.map(TaskInputValueSampleddata),
      decode.field("valueSignature", signature_decoder(), decode.success)
        |> decode.map(TaskInputValueSignature),
      decode.field("valueTiming", timing_decoder(), decode.success)
        |> decode.map(TaskInputValueTiming),
      decode.field(
        "valueContactDetail",
        contactdetail_decoder(),
        decode.success,
      )
        |> decode.map(TaskInputValueContactdetail),
      decode.field("valueContributor", contributor_decoder(), decode.success)
        |> decode.map(TaskInputValueContributor),
      decode.field(
        "valueDataRequirement",
        datarequirement_decoder(),
        decode.success,
      )
        |> decode.map(TaskInputValueDatarequirement),
      decode.field("valueExpression", expression_decoder(), decode.success)
        |> decode.map(TaskInputValueExpression),
      decode.field(
        "valueParameterDefinition",
        parameterdefinition_decoder(),
        decode.success,
      )
        |> decode.map(TaskInputValueParameterdefinition),
      decode.field(
        "valueRelatedArtifact",
        relatedartifact_decoder(),
        decode.success,
      )
        |> decode.map(TaskInputValueRelatedartifact),
      decode.field(
        "valueTriggerDefinition",
        triggerdefinition_decoder(),
        decode.success,
      )
        |> decode.map(TaskInputValueTriggerdefinition),
      decode.field("valueUsageContext", usagecontext_decoder(), decode.success)
        |> decode.map(TaskInputValueUsagecontext),
      decode.field("valueDosage", dosage_decoder(), decode.success)
        |> decode.map(TaskInputValueDosage),
      decode.field("valueMeta", meta_decoder(), decode.success)
        |> decode.map(TaskInputValueMeta),
    ],
  )
}

pub fn task_input_new(
  value value: TaskInputValue,
  type_ type_: Codeableconcept,
) -> TaskInput {
  TaskInput(value:, type_:, modifier_extension: [], extension: [], id: None)
}

///http://hl7.org/fhir/r4b/StructureDefinition/Task#resource
pub type TaskOutput {
  TaskOutput(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Codeableconcept,
    value: TaskOutputValue,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/Task#resource
pub type TaskOutputValue {
  TaskOutputValueBase64binary(value: String)
  TaskOutputValueBoolean(value: Bool)
  TaskOutputValueCanonical(value: String)
  TaskOutputValueCode(value: String)
  TaskOutputValueDate(value: String)
  TaskOutputValueDatetime(value: String)
  TaskOutputValueDecimal(value: Float)
  TaskOutputValueId(value: String)
  TaskOutputValueInstant(value: String)
  TaskOutputValueInteger(value: Int)
  TaskOutputValueMarkdown(value: String)
  TaskOutputValueOid(value: String)
  TaskOutputValuePositiveint(value: Int)
  TaskOutputValueString(value: String)
  TaskOutputValueTime(value: String)
  TaskOutputValueUnsignedint(value: Int)
  TaskOutputValueUri(value: String)
  TaskOutputValueUrl(value: String)
  TaskOutputValueUuid(value: String)
  TaskOutputValueAddress(value: Address)
  TaskOutputValueAge(value: Age)
  TaskOutputValueAnnotation(value: Annotation)
  TaskOutputValueAttachment(value: Attachment)
  TaskOutputValueCodeableconcept(value: Codeableconcept)
  TaskOutputValueCoding(value: Coding)
  TaskOutputValueContactpoint(value: Contactpoint)
  TaskOutputValueCount(value: Count)
  TaskOutputValueDistance(value: Distance)
  TaskOutputValueDuration(value: Duration)
  TaskOutputValueHumanname(value: Humanname)
  TaskOutputValueIdentifier(value: Identifier)
  TaskOutputValueMoney(value: Money)
  TaskOutputValuePeriod(value: Period)
  TaskOutputValueQuantity(value: Quantity)
  TaskOutputValueRange(value: Range)
  TaskOutputValueRatio(value: Ratio)
  TaskOutputValueReference(value: Reference)
  TaskOutputValueSampleddata(value: Sampleddata)
  TaskOutputValueSignature(value: Signature)
  TaskOutputValueTiming(value: Timing)
  TaskOutputValueContactdetail(value: Contactdetail)
  TaskOutputValueContributor(value: Contributor)
  TaskOutputValueDatarequirement(value: Datarequirement)
  TaskOutputValueExpression(value: Expression)
  TaskOutputValueParameterdefinition(value: Parameterdefinition)
  TaskOutputValueRelatedartifact(value: Relatedartifact)
  TaskOutputValueTriggerdefinition(value: Triggerdefinition)
  TaskOutputValueUsagecontext(value: Usagecontext)
  TaskOutputValueDosage(value: Dosage)
  TaskOutputValueMeta(value: Meta)
}

pub fn task_output_value_to_json(elt: TaskOutputValue) -> Json {
  case elt {
    TaskOutputValueBase64binary(v) -> json.string(v)
    TaskOutputValueBoolean(v) -> json.bool(v)
    TaskOutputValueCanonical(v) -> json.string(v)
    TaskOutputValueCode(v) -> json.string(v)
    TaskOutputValueDate(v) -> json.string(v)
    TaskOutputValueDatetime(v) -> json.string(v)
    TaskOutputValueDecimal(v) -> json.float(v)
    TaskOutputValueId(v) -> json.string(v)
    TaskOutputValueInstant(v) -> json.string(v)
    TaskOutputValueInteger(v) -> json.int(v)
    TaskOutputValueMarkdown(v) -> json.string(v)
    TaskOutputValueOid(v) -> json.string(v)
    TaskOutputValuePositiveint(v) -> json.int(v)
    TaskOutputValueString(v) -> json.string(v)
    TaskOutputValueTime(v) -> json.string(v)
    TaskOutputValueUnsignedint(v) -> json.int(v)
    TaskOutputValueUri(v) -> json.string(v)
    TaskOutputValueUrl(v) -> json.string(v)
    TaskOutputValueUuid(v) -> json.string(v)
    TaskOutputValueAddress(v) -> address_to_json(v)
    TaskOutputValueAge(v) -> age_to_json(v)
    TaskOutputValueAnnotation(v) -> annotation_to_json(v)
    TaskOutputValueAttachment(v) -> attachment_to_json(v)
    TaskOutputValueCodeableconcept(v) -> codeableconcept_to_json(v)
    TaskOutputValueCoding(v) -> coding_to_json(v)
    TaskOutputValueContactpoint(v) -> contactpoint_to_json(v)
    TaskOutputValueCount(v) -> count_to_json(v)
    TaskOutputValueDistance(v) -> distance_to_json(v)
    TaskOutputValueDuration(v) -> duration_to_json(v)
    TaskOutputValueHumanname(v) -> humanname_to_json(v)
    TaskOutputValueIdentifier(v) -> identifier_to_json(v)
    TaskOutputValueMoney(v) -> money_to_json(v)
    TaskOutputValuePeriod(v) -> period_to_json(v)
    TaskOutputValueQuantity(v) -> quantity_to_json(v)
    TaskOutputValueRange(v) -> range_to_json(v)
    TaskOutputValueRatio(v) -> ratio_to_json(v)
    TaskOutputValueReference(v) -> reference_to_json(v)
    TaskOutputValueSampleddata(v) -> sampleddata_to_json(v)
    TaskOutputValueSignature(v) -> signature_to_json(v)
    TaskOutputValueTiming(v) -> timing_to_json(v)
    TaskOutputValueContactdetail(v) -> contactdetail_to_json(v)
    TaskOutputValueContributor(v) -> contributor_to_json(v)
    TaskOutputValueDatarequirement(v) -> datarequirement_to_json(v)
    TaskOutputValueExpression(v) -> expression_to_json(v)
    TaskOutputValueParameterdefinition(v) -> parameterdefinition_to_json(v)
    TaskOutputValueRelatedartifact(v) -> relatedartifact_to_json(v)
    TaskOutputValueTriggerdefinition(v) -> triggerdefinition_to_json(v)
    TaskOutputValueUsagecontext(v) -> usagecontext_to_json(v)
    TaskOutputValueDosage(v) -> dosage_to_json(v)
    TaskOutputValueMeta(v) -> meta_to_json(v)
  }
}

pub fn task_output_value_decoder() -> Decoder(TaskOutputValue) {
  decode.one_of(
    decode.field("valueBase64Binary", decode.string, decode.success)
      |> decode.map(TaskOutputValueBase64binary),
    [
      decode.field("valueBoolean", decode.bool, decode.success)
        |> decode.map(TaskOutputValueBoolean),
      decode.field("valueCanonical", decode.string, decode.success)
        |> decode.map(TaskOutputValueCanonical),
      decode.field("valueCode", decode.string, decode.success)
        |> decode.map(TaskOutputValueCode),
      decode.field("valueDate", decode.string, decode.success)
        |> decode.map(TaskOutputValueDate),
      decode.field("valueDateTime", decode.string, decode.success)
        |> decode.map(TaskOutputValueDatetime),
      decode.field("valueDecimal", decode.float, decode.success)
        |> decode.map(TaskOutputValueDecimal),
      decode.field("valueId", decode.string, decode.success)
        |> decode.map(TaskOutputValueId),
      decode.field("valueInstant", decode.string, decode.success)
        |> decode.map(TaskOutputValueInstant),
      decode.field("valueInteger", decode.int, decode.success)
        |> decode.map(TaskOutputValueInteger),
      decode.field("valueMarkdown", decode.string, decode.success)
        |> decode.map(TaskOutputValueMarkdown),
      decode.field("valueOid", decode.string, decode.success)
        |> decode.map(TaskOutputValueOid),
      decode.field("valuePositiveInt", decode.int, decode.success)
        |> decode.map(TaskOutputValuePositiveint),
      decode.field("valueString", decode.string, decode.success)
        |> decode.map(TaskOutputValueString),
      decode.field("valueTime", decode.string, decode.success)
        |> decode.map(TaskOutputValueTime),
      decode.field("valueUnsignedInt", decode.int, decode.success)
        |> decode.map(TaskOutputValueUnsignedint),
      decode.field("valueUri", decode.string, decode.success)
        |> decode.map(TaskOutputValueUri),
      decode.field("valueUrl", decode.string, decode.success)
        |> decode.map(TaskOutputValueUrl),
      decode.field("valueUuid", decode.string, decode.success)
        |> decode.map(TaskOutputValueUuid),
      decode.field("valueAddress", address_decoder(), decode.success)
        |> decode.map(TaskOutputValueAddress),
      decode.field("valueAge", age_decoder(), decode.success)
        |> decode.map(TaskOutputValueAge),
      decode.field("valueAnnotation", annotation_decoder(), decode.success)
        |> decode.map(TaskOutputValueAnnotation),
      decode.field("valueAttachment", attachment_decoder(), decode.success)
        |> decode.map(TaskOutputValueAttachment),
      decode.field(
        "valueCodeableConcept",
        codeableconcept_decoder(),
        decode.success,
      )
        |> decode.map(TaskOutputValueCodeableconcept),
      decode.field("valueCoding", coding_decoder(), decode.success)
        |> decode.map(TaskOutputValueCoding),
      decode.field("valueContactPoint", contactpoint_decoder(), decode.success)
        |> decode.map(TaskOutputValueContactpoint),
      decode.field("valueCount", count_decoder(), decode.success)
        |> decode.map(TaskOutputValueCount),
      decode.field("valueDistance", distance_decoder(), decode.success)
        |> decode.map(TaskOutputValueDistance),
      decode.field("valueDuration", duration_decoder(), decode.success)
        |> decode.map(TaskOutputValueDuration),
      decode.field("valueHumanName", humanname_decoder(), decode.success)
        |> decode.map(TaskOutputValueHumanname),
      decode.field("valueIdentifier", identifier_decoder(), decode.success)
        |> decode.map(TaskOutputValueIdentifier),
      decode.field("valueMoney", money_decoder(), decode.success)
        |> decode.map(TaskOutputValueMoney),
      decode.field("valuePeriod", period_decoder(), decode.success)
        |> decode.map(TaskOutputValuePeriod),
      decode.field("valueQuantity", quantity_decoder(), decode.success)
        |> decode.map(TaskOutputValueQuantity),
      decode.field("valueRange", range_decoder(), decode.success)
        |> decode.map(TaskOutputValueRange),
      decode.field("valueRatio", ratio_decoder(), decode.success)
        |> decode.map(TaskOutputValueRatio),
      decode.field("valueReference", reference_decoder(), decode.success)
        |> decode.map(TaskOutputValueReference),
      decode.field("valueSampledData", sampleddata_decoder(), decode.success)
        |> decode.map(TaskOutputValueSampleddata),
      decode.field("valueSignature", signature_decoder(), decode.success)
        |> decode.map(TaskOutputValueSignature),
      decode.field("valueTiming", timing_decoder(), decode.success)
        |> decode.map(TaskOutputValueTiming),
      decode.field(
        "valueContactDetail",
        contactdetail_decoder(),
        decode.success,
      )
        |> decode.map(TaskOutputValueContactdetail),
      decode.field("valueContributor", contributor_decoder(), decode.success)
        |> decode.map(TaskOutputValueContributor),
      decode.field(
        "valueDataRequirement",
        datarequirement_decoder(),
        decode.success,
      )
        |> decode.map(TaskOutputValueDatarequirement),
      decode.field("valueExpression", expression_decoder(), decode.success)
        |> decode.map(TaskOutputValueExpression),
      decode.field(
        "valueParameterDefinition",
        parameterdefinition_decoder(),
        decode.success,
      )
        |> decode.map(TaskOutputValueParameterdefinition),
      decode.field(
        "valueRelatedArtifact",
        relatedartifact_decoder(),
        decode.success,
      )
        |> decode.map(TaskOutputValueRelatedartifact),
      decode.field(
        "valueTriggerDefinition",
        triggerdefinition_decoder(),
        decode.success,
      )
        |> decode.map(TaskOutputValueTriggerdefinition),
      decode.field("valueUsageContext", usagecontext_decoder(), decode.success)
        |> decode.map(TaskOutputValueUsagecontext),
      decode.field("valueDosage", dosage_decoder(), decode.success)
        |> decode.map(TaskOutputValueDosage),
      decode.field("valueMeta", meta_decoder(), decode.success)
        |> decode.map(TaskOutputValueMeta),
    ],
  )
}

pub fn task_output_new(
  value value: TaskOutputValue,
  type_ type_: Codeableconcept,
) -> TaskOutput {
  TaskOutput(value:, type_:, modifier_extension: [], extension: [], id: None)
}

pub fn task_output_to_json(task_output: TaskOutput) -> Json {
  let TaskOutput(value:, type_:, modifier_extension:, extension:, id:) =
    task_output
  let fields = [
    #("value", task_output_value_to_json(value)),
    #("type", codeableconcept_to_json(type_)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn task_output_decoder() -> Decoder(TaskOutput) {
  use value <- decode.then(task_output_value_decoder())
  use type_ <- decode.field("type", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(TaskOutput(
    value:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn task_input_to_json(task_input: TaskInput) -> Json {
  let TaskInput(value:, type_:, modifier_extension:, extension:, id:) =
    task_input
  let fields = [
    #("value", task_input_value_to_json(value)),
    #("type", codeableconcept_to_json(type_)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn task_input_decoder() -> Decoder(TaskInput) {
  use value <- decode.then(task_input_value_decoder())
  use type_ <- decode.field("type", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(TaskInput(value:, type_:, modifier_extension:, extension:, id:))
}

pub fn task_restriction_to_json(task_restriction: TaskRestriction) -> Json {
  let TaskRestriction(
    recipient:,
    period:,
    repetitions:,
    modifier_extension:,
    extension:,
    id:,
  ) = task_restriction
  let fields = []
  let fields = case recipient {
    [] -> fields
    _ -> [#("recipient", json.array(recipient, reference_to_json)), ..fields]
  }
  let fields = case period {
    Some(v) -> [#("period", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case repetitions {
    Some(v) -> [#("repetitions", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn task_restriction_decoder() -> Decoder(TaskRestriction) {
  use recipient <- decode.optional_field(
    "recipient",
    [],
    decode.list(reference_decoder()),
  )
  use period <- decode.optional_field(
    "period",
    None,
    decode.optional(period_decoder()),
  )
  use repetitions <- decode.optional_field(
    "repetitions",
    None,
    decode.optional(decode.int),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(TaskRestriction(
    recipient:,
    period:,
    repetitions:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn task_to_json(task: Task) -> Json {
  let Task(
    output:,
    input:,
    restriction:,
    relevant_history:,
    note:,
    insurance:,
    reason_reference:,
    reason_code:,
    location:,
    owner:,
    performer_type:,
    requester:,
    last_modified:,
    authored_on:,
    execution_period:,
    encounter:,
    for:,
    focus:,
    description:,
    code:,
    priority:,
    intent:,
    business_status:,
    status_reason:,
    status:,
    part_of:,
    group_identifier:,
    based_on:,
    instantiates_uri:,
    instantiates_canonical:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = task
  let fields = [
    #("intent", r4bvaluesets.taskintent_to_json(intent)),
    #("status", r4bvaluesets.taskstatus_to_json(status)),
  ]
  let fields = case output {
    [] -> fields
    _ -> [#("output", json.array(output, task_output_to_json)), ..fields]
  }
  let fields = case input {
    [] -> fields
    _ -> [#("input", json.array(input, task_input_to_json)), ..fields]
  }
  let fields = case restriction {
    Some(v) -> [#("restriction", task_restriction_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case relevant_history {
    [] -> fields
    _ -> [
      #("relevantHistory", json.array(relevant_history, reference_to_json)),
      ..fields
    ]
  }
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case insurance {
    [] -> fields
    _ -> [#("insurance", json.array(insurance, reference_to_json)), ..fields]
  }
  let fields = case reason_reference {
    Some(v) -> [#("reasonReference", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case reason_code {
    Some(v) -> [#("reasonCode", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case location {
    Some(v) -> [#("location", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case owner {
    Some(v) -> [#("owner", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case performer_type {
    [] -> fields
    _ -> [
      #("performerType", json.array(performer_type, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case requester {
    Some(v) -> [#("requester", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case last_modified {
    Some(v) -> [#("lastModified", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case authored_on {
    Some(v) -> [#("authoredOn", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case execution_period {
    Some(v) -> [#("executionPeriod", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case encounter {
    Some(v) -> [#("encounter", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case for {
    Some(v) -> [#("for", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case focus {
    Some(v) -> [#("focus", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case code {
    Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case priority {
    Some(v) -> [
      #("priority", r4bvaluesets.requestpriority_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case business_status {
    Some(v) -> [#("businessStatus", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case status_reason {
    Some(v) -> [#("statusReason", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case part_of {
    [] -> fields
    _ -> [#("partOf", json.array(part_of, reference_to_json)), ..fields]
  }
  let fields = case group_identifier {
    Some(v) -> [#("groupIdentifier", identifier_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case based_on {
    [] -> fields
    _ -> [#("basedOn", json.array(based_on, reference_to_json)), ..fields]
  }
  let fields = case instantiates_uri {
    Some(v) -> [#("instantiatesUri", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case instantiates_canonical {
    Some(v) -> [#("instantiatesCanonical", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Task")), ..fields]
  json.object(fields)
}

pub fn task_decoder() -> Decoder(Task) {
  use output <- decode.optional_field(
    "output",
    [],
    decode.list(task_output_decoder()),
  )
  use input <- decode.optional_field(
    "input",
    [],
    decode.list(task_input_decoder()),
  )
  use restriction <- decode.optional_field(
    "restriction",
    None,
    decode.optional(task_restriction_decoder()),
  )
  use relevant_history <- decode.optional_field(
    "relevantHistory",
    [],
    decode.list(reference_decoder()),
  )
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use insurance <- decode.optional_field(
    "insurance",
    [],
    decode.list(reference_decoder()),
  )
  use reason_reference <- decode.optional_field(
    "reasonReference",
    None,
    decode.optional(reference_decoder()),
  )
  use reason_code <- decode.optional_field(
    "reasonCode",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use location <- decode.optional_field(
    "location",
    None,
    decode.optional(reference_decoder()),
  )
  use owner <- decode.optional_field(
    "owner",
    None,
    decode.optional(reference_decoder()),
  )
  use performer_type <- decode.optional_field(
    "performerType",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use requester <- decode.optional_field(
    "requester",
    None,
    decode.optional(reference_decoder()),
  )
  use last_modified <- decode.optional_field(
    "lastModified",
    None,
    decode.optional(decode.string),
  )
  use authored_on <- decode.optional_field(
    "authoredOn",
    None,
    decode.optional(decode.string),
  )
  use execution_period <- decode.optional_field(
    "executionPeriod",
    None,
    decode.optional(period_decoder()),
  )
  use encounter <- decode.optional_field(
    "encounter",
    None,
    decode.optional(reference_decoder()),
  )
  use for <- decode.optional_field(
    "for",
    None,
    decode.optional(reference_decoder()),
  )
  use focus <- decode.optional_field(
    "focus",
    None,
    decode.optional(reference_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use priority <- decode.optional_field(
    "priority",
    None,
    decode.optional(r4bvaluesets.requestpriority_decoder()),
  )
  use intent <- decode.field("intent", r4bvaluesets.taskintent_decoder())
  use business_status <- decode.optional_field(
    "businessStatus",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use status_reason <- decode.optional_field(
    "statusReason",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use status <- decode.field("status", r4bvaluesets.taskstatus_decoder())
  use part_of <- decode.optional_field(
    "partOf",
    [],
    decode.list(reference_decoder()),
  )
  use group_identifier <- decode.optional_field(
    "groupIdentifier",
    None,
    decode.optional(identifier_decoder()),
  )
  use based_on <- decode.optional_field(
    "basedOn",
    [],
    decode.list(reference_decoder()),
  )
  use instantiates_uri <- decode.optional_field(
    "instantiatesUri",
    None,
    decode.optional(decode.string),
  )
  use instantiates_canonical <- decode.optional_field(
    "instantiatesCanonical",
    None,
    decode.optional(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Task",
    decode.failure(task_new(intent:, status:), "resourceType"),
  )
  decode.success(Task(
    output:,
    input:,
    restriction:,
    relevant_history:,
    note:,
    insurance:,
    reason_reference:,
    reason_code:,
    location:,
    owner:,
    performer_type:,
    requester:,
    last_modified:,
    authored_on:,
    execution_period:,
    encounter:,
    for:,
    focus:,
    description:,
    code:,
    priority:,
    intent:,
    business_status:,
    status_reason:,
    status:,
    part_of:,
    group_identifier:,
    based_on:,
    instantiates_uri:,
    instantiates_canonical:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/TerminologyCapabilities#resource
pub type Terminologycapabilities {
  Terminologycapabilities(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    url: Option(String),
    version: Option(String),
    name: Option(String),
    title: Option(String),
    status: r4bvaluesets.Publicationstatus,
    experimental: Option(Bool),
    date: String,
    publisher: Option(String),
    contact: List(Contactdetail),
    description: Option(String),
    use_context: List(Usagecontext),
    jurisdiction: List(Codeableconcept),
    purpose: Option(String),
    copyright: Option(String),
    kind: r4bvaluesets.Capabilitystatementkind,
    software: Option(TerminologycapabilitiesSoftware),
    implementation: Option(TerminologycapabilitiesImplementation),
    locked_date: Option(Bool),
    code_system: List(TerminologycapabilitiesCodesystem),
    expansion: Option(TerminologycapabilitiesExpansion),
    code_search: Option(r4bvaluesets.Codesearchsupport),
    validate_code: Option(TerminologycapabilitiesValidatecode),
    translation: Option(TerminologycapabilitiesTranslation),
    closure: Option(TerminologycapabilitiesClosure),
  )
}

pub fn terminologycapabilities_new(
  kind kind: r4bvaluesets.Capabilitystatementkind,
  date date: String,
  status status: r4bvaluesets.Publicationstatus,
) -> Terminologycapabilities {
  Terminologycapabilities(
    closure: None,
    translation: None,
    validate_code: None,
    code_search: None,
    expansion: None,
    code_system: [],
    locked_date: None,
    implementation: None,
    software: None,
    kind:,
    copyright: None,
    purpose: None,
    jurisdiction: [],
    use_context: [],
    description: None,
    contact: [],
    publisher: None,
    date:,
    experimental: None,
    status:,
    title: None,
    name: None,
    version: None,
    url: None,
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/TerminologyCapabilities#resource
pub type TerminologycapabilitiesSoftware {
  TerminologycapabilitiesSoftware(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    name: String,
    version: Option(String),
  )
}

pub fn terminologycapabilities_software_new(
  name name: String,
) -> TerminologycapabilitiesSoftware {
  TerminologycapabilitiesSoftware(
    version: None,
    name:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/TerminologyCapabilities#resource
pub type TerminologycapabilitiesImplementation {
  TerminologycapabilitiesImplementation(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    description: String,
    url: Option(String),
  )
}

pub fn terminologycapabilities_implementation_new(
  description description: String,
) -> TerminologycapabilitiesImplementation {
  TerminologycapabilitiesImplementation(
    url: None,
    description:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/TerminologyCapabilities#resource
pub type TerminologycapabilitiesCodesystem {
  TerminologycapabilitiesCodesystem(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    uri: Option(String),
    version: List(TerminologycapabilitiesCodesystemVersion),
    subsumption: Option(Bool),
  )
}

pub fn terminologycapabilities_codesystem_new() -> TerminologycapabilitiesCodesystem {
  TerminologycapabilitiesCodesystem(
    subsumption: None,
    version: [],
    uri: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/TerminologyCapabilities#resource
pub type TerminologycapabilitiesCodesystemVersion {
  TerminologycapabilitiesCodesystemVersion(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    code: Option(String),
    is_default: Option(Bool),
    compositional: Option(Bool),
    language: List(String),
    filter: List(TerminologycapabilitiesCodesystemVersionFilter),
    property: List(String),
  )
}

pub fn terminologycapabilities_codesystem_version_new() -> TerminologycapabilitiesCodesystemVersion {
  TerminologycapabilitiesCodesystemVersion(
    property: [],
    filter: [],
    language: [],
    compositional: None,
    is_default: None,
    code: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/TerminologyCapabilities#resource
pub type TerminologycapabilitiesCodesystemVersionFilter {
  TerminologycapabilitiesCodesystemVersionFilter(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    code: String,
    op: List(String),
  )
}

pub fn terminologycapabilities_codesystem_version_filter_new(
  code code: String,
) -> TerminologycapabilitiesCodesystemVersionFilter {
  TerminologycapabilitiesCodesystemVersionFilter(
    op: [],
    code:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/TerminologyCapabilities#resource
pub type TerminologycapabilitiesExpansion {
  TerminologycapabilitiesExpansion(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    hierarchical: Option(Bool),
    paging: Option(Bool),
    incomplete: Option(Bool),
    parameter: List(TerminologycapabilitiesExpansionParameter),
    text_filter: Option(String),
  )
}

pub fn terminologycapabilities_expansion_new() -> TerminologycapabilitiesExpansion {
  TerminologycapabilitiesExpansion(
    text_filter: None,
    parameter: [],
    incomplete: None,
    paging: None,
    hierarchical: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/TerminologyCapabilities#resource
pub type TerminologycapabilitiesExpansionParameter {
  TerminologycapabilitiesExpansionParameter(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    name: String,
    documentation: Option(String),
  )
}

pub fn terminologycapabilities_expansion_parameter_new(
  name name: String,
) -> TerminologycapabilitiesExpansionParameter {
  TerminologycapabilitiesExpansionParameter(
    documentation: None,
    name:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/TerminologyCapabilities#resource
pub type TerminologycapabilitiesValidatecode {
  TerminologycapabilitiesValidatecode(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    translations: Bool,
  )
}

pub fn terminologycapabilities_validatecode_new(
  translations translations: Bool,
) -> TerminologycapabilitiesValidatecode {
  TerminologycapabilitiesValidatecode(
    translations:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/TerminologyCapabilities#resource
pub type TerminologycapabilitiesTranslation {
  TerminologycapabilitiesTranslation(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    needs_map: Bool,
  )
}

pub fn terminologycapabilities_translation_new(
  needs_map needs_map: Bool,
) -> TerminologycapabilitiesTranslation {
  TerminologycapabilitiesTranslation(
    needs_map:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/TerminologyCapabilities#resource
pub type TerminologycapabilitiesClosure {
  TerminologycapabilitiesClosure(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    translation: Option(Bool),
  )
}

pub fn terminologycapabilities_closure_new() -> TerminologycapabilitiesClosure {
  TerminologycapabilitiesClosure(
    translation: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn terminologycapabilities_closure_to_json(
  terminologycapabilities_closure: TerminologycapabilitiesClosure,
) -> Json {
  let TerminologycapabilitiesClosure(
    translation:,
    modifier_extension:,
    extension:,
    id:,
  ) = terminologycapabilities_closure
  let fields = []
  let fields = case translation {
    Some(v) -> [#("translation", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn terminologycapabilities_closure_decoder() -> Decoder(
  TerminologycapabilitiesClosure,
) {
  use translation <- decode.optional_field(
    "translation",
    None,
    decode.optional(decode.bool),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(TerminologycapabilitiesClosure(
    translation:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn terminologycapabilities_translation_to_json(
  terminologycapabilities_translation: TerminologycapabilitiesTranslation,
) -> Json {
  let TerminologycapabilitiesTranslation(
    needs_map:,
    modifier_extension:,
    extension:,
    id:,
  ) = terminologycapabilities_translation
  let fields = [
    #("needsMap", json.bool(needs_map)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn terminologycapabilities_translation_decoder() -> Decoder(
  TerminologycapabilitiesTranslation,
) {
  use needs_map <- decode.field("needsMap", decode.bool)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(TerminologycapabilitiesTranslation(
    needs_map:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn terminologycapabilities_validatecode_to_json(
  terminologycapabilities_validatecode: TerminologycapabilitiesValidatecode,
) -> Json {
  let TerminologycapabilitiesValidatecode(
    translations:,
    modifier_extension:,
    extension:,
    id:,
  ) = terminologycapabilities_validatecode
  let fields = [
    #("translations", json.bool(translations)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn terminologycapabilities_validatecode_decoder() -> Decoder(
  TerminologycapabilitiesValidatecode,
) {
  use translations <- decode.field("translations", decode.bool)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(TerminologycapabilitiesValidatecode(
    translations:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn terminologycapabilities_expansion_parameter_to_json(
  terminologycapabilities_expansion_parameter: TerminologycapabilitiesExpansionParameter,
) -> Json {
  let TerminologycapabilitiesExpansionParameter(
    documentation:,
    name:,
    modifier_extension:,
    extension:,
    id:,
  ) = terminologycapabilities_expansion_parameter
  let fields = [
    #("name", json.string(name)),
  ]
  let fields = case documentation {
    Some(v) -> [#("documentation", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn terminologycapabilities_expansion_parameter_decoder() -> Decoder(
  TerminologycapabilitiesExpansionParameter,
) {
  use documentation <- decode.optional_field(
    "documentation",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.field("name", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(TerminologycapabilitiesExpansionParameter(
    documentation:,
    name:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn terminologycapabilities_expansion_to_json(
  terminologycapabilities_expansion: TerminologycapabilitiesExpansion,
) -> Json {
  let TerminologycapabilitiesExpansion(
    text_filter:,
    parameter:,
    incomplete:,
    paging:,
    hierarchical:,
    modifier_extension:,
    extension:,
    id:,
  ) = terminologycapabilities_expansion
  let fields = []
  let fields = case text_filter {
    Some(v) -> [#("textFilter", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case parameter {
    [] -> fields
    _ -> [
      #(
        "parameter",
        json.array(
          parameter,
          terminologycapabilities_expansion_parameter_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case incomplete {
    Some(v) -> [#("incomplete", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case paging {
    Some(v) -> [#("paging", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case hierarchical {
    Some(v) -> [#("hierarchical", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn terminologycapabilities_expansion_decoder() -> Decoder(
  TerminologycapabilitiesExpansion,
) {
  use text_filter <- decode.optional_field(
    "textFilter",
    None,
    decode.optional(decode.string),
  )
  use parameter <- decode.optional_field(
    "parameter",
    [],
    decode.list(terminologycapabilities_expansion_parameter_decoder()),
  )
  use incomplete <- decode.optional_field(
    "incomplete",
    None,
    decode.optional(decode.bool),
  )
  use paging <- decode.optional_field(
    "paging",
    None,
    decode.optional(decode.bool),
  )
  use hierarchical <- decode.optional_field(
    "hierarchical",
    None,
    decode.optional(decode.bool),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(TerminologycapabilitiesExpansion(
    text_filter:,
    parameter:,
    incomplete:,
    paging:,
    hierarchical:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn terminologycapabilities_codesystem_version_filter_to_json(
  terminologycapabilities_codesystem_version_filter: TerminologycapabilitiesCodesystemVersionFilter,
) -> Json {
  let TerminologycapabilitiesCodesystemVersionFilter(
    op:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ) = terminologycapabilities_codesystem_version_filter
  let fields = [
    #("code", json.string(code)),
  ]
  let fields = case op {
    [] -> fields
    _ -> [#("op", json.array(op, json.string)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn terminologycapabilities_codesystem_version_filter_decoder() -> Decoder(
  TerminologycapabilitiesCodesystemVersionFilter,
) {
  use op <- decode.optional_field("op", [], decode.list(decode.string))
  use code <- decode.field("code", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(TerminologycapabilitiesCodesystemVersionFilter(
    op:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn terminologycapabilities_codesystem_version_to_json(
  terminologycapabilities_codesystem_version: TerminologycapabilitiesCodesystemVersion,
) -> Json {
  let TerminologycapabilitiesCodesystemVersion(
    property:,
    filter:,
    language:,
    compositional:,
    is_default:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ) = terminologycapabilities_codesystem_version
  let fields = []
  let fields = case property {
    [] -> fields
    _ -> [#("property", json.array(property, json.string)), ..fields]
  }
  let fields = case filter {
    [] -> fields
    _ -> [
      #(
        "filter",
        json.array(
          filter,
          terminologycapabilities_codesystem_version_filter_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case language {
    [] -> fields
    _ -> [#("language", json.array(language, json.string)), ..fields]
  }
  let fields = case compositional {
    Some(v) -> [#("compositional", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case is_default {
    Some(v) -> [#("isDefault", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case code {
    Some(v) -> [#("code", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn terminologycapabilities_codesystem_version_decoder() -> Decoder(
  TerminologycapabilitiesCodesystemVersion,
) {
  use property <- decode.optional_field(
    "property",
    [],
    decode.list(decode.string),
  )
  use filter <- decode.optional_field(
    "filter",
    [],
    decode.list(terminologycapabilities_codesystem_version_filter_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    [],
    decode.list(decode.string),
  )
  use compositional <- decode.optional_field(
    "compositional",
    None,
    decode.optional(decode.bool),
  )
  use is_default <- decode.optional_field(
    "isDefault",
    None,
    decode.optional(decode.bool),
  )
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(TerminologycapabilitiesCodesystemVersion(
    property:,
    filter:,
    language:,
    compositional:,
    is_default:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn terminologycapabilities_codesystem_to_json(
  terminologycapabilities_codesystem: TerminologycapabilitiesCodesystem,
) -> Json {
  let TerminologycapabilitiesCodesystem(
    subsumption:,
    version:,
    uri:,
    modifier_extension:,
    extension:,
    id:,
  ) = terminologycapabilities_codesystem
  let fields = []
  let fields = case subsumption {
    Some(v) -> [#("subsumption", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case version {
    [] -> fields
    _ -> [
      #(
        "version",
        json.array(version, terminologycapabilities_codesystem_version_to_json),
      ),
      ..fields
    ]
  }
  let fields = case uri {
    Some(v) -> [#("uri", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn terminologycapabilities_codesystem_decoder() -> Decoder(
  TerminologycapabilitiesCodesystem,
) {
  use subsumption <- decode.optional_field(
    "subsumption",
    None,
    decode.optional(decode.bool),
  )
  use version <- decode.optional_field(
    "version",
    [],
    decode.list(terminologycapabilities_codesystem_version_decoder()),
  )
  use uri <- decode.optional_field("uri", None, decode.optional(decode.string))
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(TerminologycapabilitiesCodesystem(
    subsumption:,
    version:,
    uri:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn terminologycapabilities_implementation_to_json(
  terminologycapabilities_implementation: TerminologycapabilitiesImplementation,
) -> Json {
  let TerminologycapabilitiesImplementation(
    url:,
    description:,
    modifier_extension:,
    extension:,
    id:,
  ) = terminologycapabilities_implementation
  let fields = [
    #("description", json.string(description)),
  ]
  let fields = case url {
    Some(v) -> [#("url", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn terminologycapabilities_implementation_decoder() -> Decoder(
  TerminologycapabilitiesImplementation,
) {
  use url <- decode.optional_field("url", None, decode.optional(decode.string))
  use description <- decode.field("description", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(TerminologycapabilitiesImplementation(
    url:,
    description:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn terminologycapabilities_software_to_json(
  terminologycapabilities_software: TerminologycapabilitiesSoftware,
) -> Json {
  let TerminologycapabilitiesSoftware(
    version:,
    name:,
    modifier_extension:,
    extension:,
    id:,
  ) = terminologycapabilities_software
  let fields = [
    #("name", json.string(name)),
  ]
  let fields = case version {
    Some(v) -> [#("version", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn terminologycapabilities_software_decoder() -> Decoder(
  TerminologycapabilitiesSoftware,
) {
  use version <- decode.optional_field(
    "version",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.field("name", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(TerminologycapabilitiesSoftware(
    version:,
    name:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn terminologycapabilities_to_json(
  terminologycapabilities: Terminologycapabilities,
) -> Json {
  let Terminologycapabilities(
    closure:,
    translation:,
    validate_code:,
    code_search:,
    expansion:,
    code_system:,
    locked_date:,
    implementation:,
    software:,
    kind:,
    copyright:,
    purpose:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    experimental:,
    status:,
    title:,
    name:,
    version:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = terminologycapabilities
  let fields = [
    #("kind", r4bvaluesets.capabilitystatementkind_to_json(kind)),
    #("date", json.string(date)),
    #("status", r4bvaluesets.publicationstatus_to_json(status)),
  ]
  let fields = case closure {
    Some(v) -> [
      #("closure", terminologycapabilities_closure_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case translation {
    Some(v) -> [
      #("translation", terminologycapabilities_translation_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case validate_code {
    Some(v) -> [
      #("validateCode", terminologycapabilities_validatecode_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case code_search {
    Some(v) -> [
      #("codeSearch", r4bvaluesets.codesearchsupport_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case expansion {
    Some(v) -> [
      #("expansion", terminologycapabilities_expansion_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case code_system {
    [] -> fields
    _ -> [
      #(
        "codeSystem",
        json.array(code_system, terminologycapabilities_codesystem_to_json),
      ),
      ..fields
    ]
  }
  let fields = case locked_date {
    Some(v) -> [#("lockedDate", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case implementation {
    Some(v) -> [
      #("implementation", terminologycapabilities_implementation_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case software {
    Some(v) -> [
      #("software", terminologycapabilities_software_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case copyright {
    Some(v) -> [#("copyright", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case purpose {
    Some(v) -> [#("purpose", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case jurisdiction {
    [] -> fields
    _ -> [
      #("jurisdiction", json.array(jurisdiction, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case use_context {
    [] -> fields
    _ -> [
      #("useContext", json.array(use_context, usagecontext_to_json)),
      ..fields
    ]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case contact {
    [] -> fields
    _ -> [#("contact", json.array(contact, contactdetail_to_json)), ..fields]
  }
  let fields = case publisher {
    Some(v) -> [#("publisher", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case experimental {
    Some(v) -> [#("experimental", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case title {
    Some(v) -> [#("title", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case version {
    Some(v) -> [#("version", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case url {
    Some(v) -> [#("url", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [
    #("resourceType", json.string("Terminologycapabilities")),
    ..fields
  ]
  json.object(fields)
}

pub fn terminologycapabilities_decoder() -> Decoder(Terminologycapabilities) {
  use closure <- decode.optional_field(
    "closure",
    None,
    decode.optional(terminologycapabilities_closure_decoder()),
  )
  use translation <- decode.optional_field(
    "translation",
    None,
    decode.optional(terminologycapabilities_translation_decoder()),
  )
  use validate_code <- decode.optional_field(
    "validateCode",
    None,
    decode.optional(terminologycapabilities_validatecode_decoder()),
  )
  use code_search <- decode.optional_field(
    "codeSearch",
    None,
    decode.optional(r4bvaluesets.codesearchsupport_decoder()),
  )
  use expansion <- decode.optional_field(
    "expansion",
    None,
    decode.optional(terminologycapabilities_expansion_decoder()),
  )
  use code_system <- decode.optional_field(
    "codeSystem",
    [],
    decode.list(terminologycapabilities_codesystem_decoder()),
  )
  use locked_date <- decode.optional_field(
    "lockedDate",
    None,
    decode.optional(decode.bool),
  )
  use implementation <- decode.optional_field(
    "implementation",
    None,
    decode.optional(terminologycapabilities_implementation_decoder()),
  )
  use software <- decode.optional_field(
    "software",
    None,
    decode.optional(terminologycapabilities_software_decoder()),
  )
  use kind <- decode.field(
    "kind",
    r4bvaluesets.capabilitystatementkind_decoder(),
  )
  use copyright <- decode.optional_field(
    "copyright",
    None,
    decode.optional(decode.string),
  )
  use purpose <- decode.optional_field(
    "purpose",
    None,
    decode.optional(decode.string),
  )
  use jurisdiction <- decode.optional_field(
    "jurisdiction",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use use_context <- decode.optional_field(
    "useContext",
    [],
    decode.list(usagecontext_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use contact <- decode.optional_field(
    "contact",
    [],
    decode.list(contactdetail_decoder()),
  )
  use publisher <- decode.optional_field(
    "publisher",
    None,
    decode.optional(decode.string),
  )
  use date <- decode.field("date", decode.string)
  use experimental <- decode.optional_field(
    "experimental",
    None,
    decode.optional(decode.bool),
  )
  use status <- decode.field("status", r4bvaluesets.publicationstatus_decoder())
  use title <- decode.optional_field(
    "title",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use version <- decode.optional_field(
    "version",
    None,
    decode.optional(decode.string),
  )
  use url <- decode.optional_field("url", None, decode.optional(decode.string))
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Terminologycapabilities",
    decode.failure(
      terminologycapabilities_new(kind:, date:, status:),
      "resourceType",
    ),
  )
  decode.success(Terminologycapabilities(
    closure:,
    translation:,
    validate_code:,
    code_search:,
    expansion:,
    code_system:,
    locked_date:,
    implementation:,
    software:,
    kind:,
    copyright:,
    purpose:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    experimental:,
    status:,
    title:,
    name:,
    version:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/TestReport#resource
pub type Testreport {
  Testreport(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: Option(Identifier),
    name: Option(String),
    status: r4bvaluesets.Reportstatuscodes,
    test_script: Reference,
    result: r4bvaluesets.Reportresultcodes,
    score: Option(Float),
    tester: Option(String),
    issued: Option(String),
    participant: List(TestreportParticipant),
    setup: Option(TestreportSetup),
    test_: List(TestreportTest),
    teardown: Option(TestreportTeardown),
  )
}

pub fn testreport_new(
  result result: r4bvaluesets.Reportresultcodes,
  test_script test_script: Reference,
  status status: r4bvaluesets.Reportstatuscodes,
) -> Testreport {
  Testreport(
    teardown: None,
    test_: [],
    setup: None,
    participant: [],
    issued: None,
    tester: None,
    score: None,
    result:,
    test_script:,
    status:,
    name: None,
    identifier: None,
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/TestReport#resource
pub type TestreportParticipant {
  TestreportParticipant(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: r4bvaluesets.Reportparticipanttype,
    uri: String,
    display: Option(String),
  )
}

pub fn testreport_participant_new(
  uri uri: String,
  type_ type_: r4bvaluesets.Reportparticipanttype,
) -> TestreportParticipant {
  TestreportParticipant(
    display: None,
    uri:,
    type_:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/TestReport#resource
pub type TestreportSetup {
  TestreportSetup(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    action: List(TestreportSetupAction),
  )
}

pub fn testreport_setup_new() -> TestreportSetup {
  TestreportSetup(action: [], modifier_extension: [], extension: [], id: None)
}

///http://hl7.org/fhir/r4b/StructureDefinition/TestReport#resource
pub type TestreportSetupAction {
  TestreportSetupAction(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    operation: Option(TestreportSetupActionOperation),
    assert_: Option(TestreportSetupActionAssert),
  )
}

pub fn testreport_setup_action_new() -> TestreportSetupAction {
  TestreportSetupAction(
    assert_: None,
    operation: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/TestReport#resource
pub type TestreportSetupActionOperation {
  TestreportSetupActionOperation(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    result: r4bvaluesets.Reportactionresultcodes,
    message: Option(String),
    detail: Option(String),
  )
}

pub fn testreport_setup_action_operation_new(
  result result: r4bvaluesets.Reportactionresultcodes,
) -> TestreportSetupActionOperation {
  TestreportSetupActionOperation(
    detail: None,
    message: None,
    result:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/TestReport#resource
pub type TestreportSetupActionAssert {
  TestreportSetupActionAssert(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    result: r4bvaluesets.Reportactionresultcodes,
    message: Option(String),
    detail: Option(String),
  )
}

pub fn testreport_setup_action_assert_new(
  result result: r4bvaluesets.Reportactionresultcodes,
) -> TestreportSetupActionAssert {
  TestreportSetupActionAssert(
    detail: None,
    message: None,
    result:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/TestReport#resource
pub type TestreportTest {
  TestreportTest(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    name: Option(String),
    description: Option(String),
    action: List(TestreportTestAction),
  )
}

pub fn testreport_test_new() -> TestreportTest {
  TestreportTest(
    action: [],
    description: None,
    name: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/TestReport#resource
pub type TestreportTestAction {
  TestreportTestAction(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
  )
}

pub fn testreport_test_action_new() -> TestreportTestAction {
  TestreportTestAction(modifier_extension: [], extension: [], id: None)
}

///http://hl7.org/fhir/r4b/StructureDefinition/TestReport#resource
pub type TestreportTeardown {
  TestreportTeardown(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    action: List(TestreportTeardownAction),
  )
}

pub fn testreport_teardown_new() -> TestreportTeardown {
  TestreportTeardown(
    action: [],
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/TestReport#resource
pub type TestreportTeardownAction {
  TestreportTeardownAction(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
  )
}

pub fn testreport_teardown_action_new() -> TestreportTeardownAction {
  TestreportTeardownAction(modifier_extension: [], extension: [], id: None)
}

pub fn testreport_teardown_action_to_json(
  testreport_teardown_action: TestreportTeardownAction,
) -> Json {
  let TestreportTeardownAction(modifier_extension:, extension:, id:) =
    testreport_teardown_action
  let fields = []
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn testreport_teardown_action_decoder() -> Decoder(TestreportTeardownAction) {
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(TestreportTeardownAction(modifier_extension:, extension:, id:))
}

pub fn testreport_teardown_to_json(
  testreport_teardown: TestreportTeardown,
) -> Json {
  let TestreportTeardown(action:, modifier_extension:, extension:, id:) =
    testreport_teardown
  let fields = []
  let fields = case action {
    [] -> fields
    _ -> [
      #("action", json.array(action, testreport_teardown_action_to_json)),
      ..fields
    ]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn testreport_teardown_decoder() -> Decoder(TestreportTeardown) {
  use action <- decode.optional_field(
    "action",
    [],
    decode.list(testreport_teardown_action_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(TestreportTeardown(
    action:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn testreport_test_action_to_json(
  testreport_test_action: TestreportTestAction,
) -> Json {
  let TestreportTestAction(modifier_extension:, extension:, id:) =
    testreport_test_action
  let fields = []
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn testreport_test_action_decoder() -> Decoder(TestreportTestAction) {
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(TestreportTestAction(modifier_extension:, extension:, id:))
}

pub fn testreport_test_to_json(testreport_test: TestreportTest) -> Json {
  let TestreportTest(
    action:,
    description:,
    name:,
    modifier_extension:,
    extension:,
    id:,
  ) = testreport_test
  let fields = []
  let fields = case action {
    [] -> fields
    _ -> [
      #("action", json.array(action, testreport_test_action_to_json)),
      ..fields
    ]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn testreport_test_decoder() -> Decoder(TestreportTest) {
  use action <- decode.optional_field(
    "action",
    [],
    decode.list(testreport_test_action_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(TestreportTest(
    action:,
    description:,
    name:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn testreport_setup_action_assert_to_json(
  testreport_setup_action_assert: TestreportSetupActionAssert,
) -> Json {
  let TestreportSetupActionAssert(
    detail:,
    message:,
    result:,
    modifier_extension:,
    extension:,
    id:,
  ) = testreport_setup_action_assert
  let fields = [
    #("result", r4bvaluesets.reportactionresultcodes_to_json(result)),
  ]
  let fields = case detail {
    Some(v) -> [#("detail", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case message {
    Some(v) -> [#("message", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn testreport_setup_action_assert_decoder() -> Decoder(
  TestreportSetupActionAssert,
) {
  use detail <- decode.optional_field(
    "detail",
    None,
    decode.optional(decode.string),
  )
  use message <- decode.optional_field(
    "message",
    None,
    decode.optional(decode.string),
  )
  use result <- decode.field(
    "result",
    r4bvaluesets.reportactionresultcodes_decoder(),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(TestreportSetupActionAssert(
    detail:,
    message:,
    result:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn testreport_setup_action_operation_to_json(
  testreport_setup_action_operation: TestreportSetupActionOperation,
) -> Json {
  let TestreportSetupActionOperation(
    detail:,
    message:,
    result:,
    modifier_extension:,
    extension:,
    id:,
  ) = testreport_setup_action_operation
  let fields = [
    #("result", r4bvaluesets.reportactionresultcodes_to_json(result)),
  ]
  let fields = case detail {
    Some(v) -> [#("detail", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case message {
    Some(v) -> [#("message", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn testreport_setup_action_operation_decoder() -> Decoder(
  TestreportSetupActionOperation,
) {
  use detail <- decode.optional_field(
    "detail",
    None,
    decode.optional(decode.string),
  )
  use message <- decode.optional_field(
    "message",
    None,
    decode.optional(decode.string),
  )
  use result <- decode.field(
    "result",
    r4bvaluesets.reportactionresultcodes_decoder(),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(TestreportSetupActionOperation(
    detail:,
    message:,
    result:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn testreport_setup_action_to_json(
  testreport_setup_action: TestreportSetupAction,
) -> Json {
  let TestreportSetupAction(
    assert_:,
    operation:,
    modifier_extension:,
    extension:,
    id:,
  ) = testreport_setup_action
  let fields = []
  let fields = case assert_ {
    Some(v) -> [
      #("assert", testreport_setup_action_assert_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case operation {
    Some(v) -> [
      #("operation", testreport_setup_action_operation_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn testreport_setup_action_decoder() -> Decoder(TestreportSetupAction) {
  use assert_ <- decode.optional_field(
    "assert",
    None,
    decode.optional(testreport_setup_action_assert_decoder()),
  )
  use operation <- decode.optional_field(
    "operation",
    None,
    decode.optional(testreport_setup_action_operation_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(TestreportSetupAction(
    assert_:,
    operation:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn testreport_setup_to_json(testreport_setup: TestreportSetup) -> Json {
  let TestreportSetup(action:, modifier_extension:, extension:, id:) =
    testreport_setup
  let fields = []
  let fields = case action {
    [] -> fields
    _ -> [
      #("action", json.array(action, testreport_setup_action_to_json)),
      ..fields
    ]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn testreport_setup_decoder() -> Decoder(TestreportSetup) {
  use action <- decode.optional_field(
    "action",
    [],
    decode.list(testreport_setup_action_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(TestreportSetup(action:, modifier_extension:, extension:, id:))
}

pub fn testreport_participant_to_json(
  testreport_participant: TestreportParticipant,
) -> Json {
  let TestreportParticipant(
    display:,
    uri:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = testreport_participant
  let fields = [
    #("uri", json.string(uri)),
    #("type", r4bvaluesets.reportparticipanttype_to_json(type_)),
  ]
  let fields = case display {
    Some(v) -> [#("display", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn testreport_participant_decoder() -> Decoder(TestreportParticipant) {
  use display <- decode.optional_field(
    "display",
    None,
    decode.optional(decode.string),
  )
  use uri <- decode.field("uri", decode.string)
  use type_ <- decode.field(
    "type",
    r4bvaluesets.reportparticipanttype_decoder(),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(TestreportParticipant(
    display:,
    uri:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn testreport_to_json(testreport: Testreport) -> Json {
  let Testreport(
    teardown:,
    test_:,
    setup:,
    participant:,
    issued:,
    tester:,
    score:,
    result:,
    test_script:,
    status:,
    name:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = testreport
  let fields = [
    #("result", r4bvaluesets.reportresultcodes_to_json(result)),
    #("testScript", reference_to_json(test_script)),
    #("status", r4bvaluesets.reportstatuscodes_to_json(status)),
  ]
  let fields = case teardown {
    Some(v) -> [#("teardown", testreport_teardown_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case test_ {
    [] -> fields
    _ -> [#("test", json.array(test_, testreport_test_to_json)), ..fields]
  }
  let fields = case setup {
    Some(v) -> [#("setup", testreport_setup_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case participant {
    [] -> fields
    _ -> [
      #("participant", json.array(participant, testreport_participant_to_json)),
      ..fields
    ]
  }
  let fields = case issued {
    Some(v) -> [#("issued", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case tester {
    Some(v) -> [#("tester", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case score {
    Some(v) -> [#("score", json.float(v)), ..fields]
    None -> fields
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    Some(v) -> [#("identifier", identifier_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Testreport")), ..fields]
  json.object(fields)
}

pub fn testreport_decoder() -> Decoder(Testreport) {
  use teardown <- decode.optional_field(
    "teardown",
    None,
    decode.optional(testreport_teardown_decoder()),
  )
  use test_ <- decode.optional_field(
    "test",
    [],
    decode.list(testreport_test_decoder()),
  )
  use setup <- decode.optional_field(
    "setup",
    None,
    decode.optional(testreport_setup_decoder()),
  )
  use participant <- decode.optional_field(
    "participant",
    [],
    decode.list(testreport_participant_decoder()),
  )
  use issued <- decode.optional_field(
    "issued",
    None,
    decode.optional(decode.string),
  )
  use tester <- decode.optional_field(
    "tester",
    None,
    decode.optional(decode.string),
  )
  use score <- decode.optional_field(
    "score",
    None,
    decode.optional(decode.float),
  )
  use result <- decode.field("result", r4bvaluesets.reportresultcodes_decoder())
  use test_script <- decode.field("testScript", reference_decoder())
  use status <- decode.field("status", r4bvaluesets.reportstatuscodes_decoder())
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    None,
    decode.optional(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Testreport",
    decode.failure(
      testreport_new(result:, test_script:, status:),
      "resourceType",
    ),
  )
  decode.success(Testreport(
    teardown:,
    test_:,
    setup:,
    participant:,
    issued:,
    tester:,
    score:,
    result:,
    test_script:,
    status:,
    name:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/TestScript#resource
pub type Testscript {
  Testscript(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    url: String,
    identifier: Option(Identifier),
    version: Option(String),
    name: String,
    title: Option(String),
    status: r4bvaluesets.Publicationstatus,
    experimental: Option(Bool),
    date: Option(String),
    publisher: Option(String),
    contact: List(Contactdetail),
    description: Option(String),
    use_context: List(Usagecontext),
    jurisdiction: List(Codeableconcept),
    purpose: Option(String),
    copyright: Option(String),
    origin: List(TestscriptOrigin),
    destination: List(TestscriptDestination),
    metadata: Option(TestscriptMetadata),
    fixture: List(TestscriptFixture),
    profile: List(Reference),
    variable: List(TestscriptVariable),
    setup: Option(TestscriptSetup),
    test_: List(TestscriptTest),
    teardown: Option(TestscriptTeardown),
  )
}

pub fn testscript_new(
  status status: r4bvaluesets.Publicationstatus,
  name name: String,
  url url: String,
) -> Testscript {
  Testscript(
    teardown: None,
    test_: [],
    setup: None,
    variable: [],
    profile: [],
    fixture: [],
    metadata: None,
    destination: [],
    origin: [],
    copyright: None,
    purpose: None,
    jurisdiction: [],
    use_context: [],
    description: None,
    contact: [],
    publisher: None,
    date: None,
    experimental: None,
    status:,
    title: None,
    name:,
    version: None,
    identifier: None,
    url:,
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/TestScript#resource
pub type TestscriptOrigin {
  TestscriptOrigin(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    index: Int,
    profile: Coding,
  )
}

pub fn testscript_origin_new(
  profile profile: Coding,
  index index: Int,
) -> TestscriptOrigin {
  TestscriptOrigin(
    profile:,
    index:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/TestScript#resource
pub type TestscriptDestination {
  TestscriptDestination(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    index: Int,
    profile: Coding,
  )
}

pub fn testscript_destination_new(
  profile profile: Coding,
  index index: Int,
) -> TestscriptDestination {
  TestscriptDestination(
    profile:,
    index:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/TestScript#resource
pub type TestscriptMetadata {
  TestscriptMetadata(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    link: List(TestscriptMetadataLink),
    capability: List(TestscriptMetadataCapability),
  )
}

pub fn testscript_metadata_new() -> TestscriptMetadata {
  TestscriptMetadata(
    capability: [],
    link: [],
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/TestScript#resource
pub type TestscriptMetadataLink {
  TestscriptMetadataLink(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    url: String,
    description: Option(String),
  )
}

pub fn testscript_metadata_link_new(url url: String) -> TestscriptMetadataLink {
  TestscriptMetadataLink(
    description: None,
    url:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/TestScript#resource
pub type TestscriptMetadataCapability {
  TestscriptMetadataCapability(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    required: Bool,
    validated: Bool,
    description: Option(String),
    origin: List(Int),
    destination: Option(Int),
    link: List(String),
    capabilities: String,
  )
}

pub fn testscript_metadata_capability_new(
  capabilities capabilities: String,
  validated validated: Bool,
  required required: Bool,
) -> TestscriptMetadataCapability {
  TestscriptMetadataCapability(
    capabilities:,
    link: [],
    destination: None,
    origin: [],
    description: None,
    validated:,
    required:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/TestScript#resource
pub type TestscriptFixture {
  TestscriptFixture(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    autocreate: Bool,
    autodelete: Bool,
    resource: Option(Reference),
  )
}

pub fn testscript_fixture_new(
  autodelete autodelete: Bool,
  autocreate autocreate: Bool,
) -> TestscriptFixture {
  TestscriptFixture(
    resource: None,
    autodelete:,
    autocreate:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/TestScript#resource
pub type TestscriptVariable {
  TestscriptVariable(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    name: String,
    default_value: Option(String),
    description: Option(String),
    expression: Option(String),
    header_field: Option(String),
    hint: Option(String),
    path: Option(String),
    source_id: Option(String),
  )
}

pub fn testscript_variable_new(name name: String) -> TestscriptVariable {
  TestscriptVariable(
    source_id: None,
    path: None,
    hint: None,
    header_field: None,
    expression: None,
    description: None,
    default_value: None,
    name:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/TestScript#resource
pub type TestscriptSetup {
  TestscriptSetup(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    action: List(TestscriptSetupAction),
  )
}

pub fn testscript_setup_new() -> TestscriptSetup {
  TestscriptSetup(action: [], modifier_extension: [], extension: [], id: None)
}

///http://hl7.org/fhir/r4b/StructureDefinition/TestScript#resource
pub type TestscriptSetupAction {
  TestscriptSetupAction(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    operation: Option(TestscriptSetupActionOperation),
    assert_: Option(TestscriptSetupActionAssert),
  )
}

pub fn testscript_setup_action_new() -> TestscriptSetupAction {
  TestscriptSetupAction(
    assert_: None,
    operation: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/TestScript#resource
pub type TestscriptSetupActionOperation {
  TestscriptSetupActionOperation(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Option(Coding),
    resource: Option(r4bvaluesets.Definedtypes),
    label: Option(String),
    description: Option(String),
    accept: Option(String),
    content_type: Option(String),
    destination: Option(Int),
    encode_request_url: Bool,
    method: Option(r4bvaluesets.Httpoperations),
    origin: Option(Int),
    params: Option(String),
    request_header: List(TestscriptSetupActionOperationRequestheader),
    request_id: Option(String),
    response_id: Option(String),
    source_id: Option(String),
    target_id: Option(String),
    url: Option(String),
  )
}

pub fn testscript_setup_action_operation_new(
  encode_request_url encode_request_url: Bool,
) -> TestscriptSetupActionOperation {
  TestscriptSetupActionOperation(
    url: None,
    target_id: None,
    source_id: None,
    response_id: None,
    request_id: None,
    request_header: [],
    params: None,
    origin: None,
    method: None,
    encode_request_url:,
    destination: None,
    content_type: None,
    accept: None,
    description: None,
    label: None,
    resource: None,
    type_: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/TestScript#resource
pub type TestscriptSetupActionOperationRequestheader {
  TestscriptSetupActionOperationRequestheader(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    field: String,
    value: String,
  )
}

pub fn testscript_setup_action_operation_requestheader_new(
  value value: String,
  field field: String,
) -> TestscriptSetupActionOperationRequestheader {
  TestscriptSetupActionOperationRequestheader(
    value:,
    field:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/TestScript#resource
pub type TestscriptSetupActionAssert {
  TestscriptSetupActionAssert(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    label: Option(String),
    description: Option(String),
    direction: Option(r4bvaluesets.Assertdirectioncodes),
    compare_to_source_id: Option(String),
    compare_to_source_expression: Option(String),
    compare_to_source_path: Option(String),
    content_type: Option(String),
    expression: Option(String),
    header_field: Option(String),
    minimum_id: Option(String),
    navigation_links: Option(Bool),
    operator: Option(r4bvaluesets.Assertoperatorcodes),
    path: Option(String),
    request_method: Option(r4bvaluesets.Httpoperations),
    request_url: Option(String),
    resource: Option(r4bvaluesets.Definedtypes),
    response: Option(r4bvaluesets.Assertresponsecodetypes),
    response_code: Option(String),
    source_id: Option(String),
    validate_profile_id: Option(String),
    value: Option(String),
    warning_only: Bool,
  )
}

pub fn testscript_setup_action_assert_new(
  warning_only warning_only: Bool,
) -> TestscriptSetupActionAssert {
  TestscriptSetupActionAssert(
    warning_only:,
    value: None,
    validate_profile_id: None,
    source_id: None,
    response_code: None,
    response: None,
    resource: None,
    request_url: None,
    request_method: None,
    path: None,
    operator: None,
    navigation_links: None,
    minimum_id: None,
    header_field: None,
    expression: None,
    content_type: None,
    compare_to_source_path: None,
    compare_to_source_expression: None,
    compare_to_source_id: None,
    direction: None,
    description: None,
    label: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/TestScript#resource
pub type TestscriptTest {
  TestscriptTest(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    name: Option(String),
    description: Option(String),
    action: List(TestscriptTestAction),
  )
}

pub fn testscript_test_new() -> TestscriptTest {
  TestscriptTest(
    action: [],
    description: None,
    name: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/TestScript#resource
pub type TestscriptTestAction {
  TestscriptTestAction(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
  )
}

pub fn testscript_test_action_new() -> TestscriptTestAction {
  TestscriptTestAction(modifier_extension: [], extension: [], id: None)
}

///http://hl7.org/fhir/r4b/StructureDefinition/TestScript#resource
pub type TestscriptTeardown {
  TestscriptTeardown(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    action: List(TestscriptTeardownAction),
  )
}

pub fn testscript_teardown_new() -> TestscriptTeardown {
  TestscriptTeardown(
    action: [],
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/TestScript#resource
pub type TestscriptTeardownAction {
  TestscriptTeardownAction(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
  )
}

pub fn testscript_teardown_action_new() -> TestscriptTeardownAction {
  TestscriptTeardownAction(modifier_extension: [], extension: [], id: None)
}

pub fn testscript_teardown_action_to_json(
  testscript_teardown_action: TestscriptTeardownAction,
) -> Json {
  let TestscriptTeardownAction(modifier_extension:, extension:, id:) =
    testscript_teardown_action
  let fields = []
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn testscript_teardown_action_decoder() -> Decoder(TestscriptTeardownAction) {
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(TestscriptTeardownAction(modifier_extension:, extension:, id:))
}

pub fn testscript_teardown_to_json(
  testscript_teardown: TestscriptTeardown,
) -> Json {
  let TestscriptTeardown(action:, modifier_extension:, extension:, id:) =
    testscript_teardown
  let fields = []
  let fields = case action {
    [] -> fields
    _ -> [
      #("action", json.array(action, testscript_teardown_action_to_json)),
      ..fields
    ]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn testscript_teardown_decoder() -> Decoder(TestscriptTeardown) {
  use action <- decode.optional_field(
    "action",
    [],
    decode.list(testscript_teardown_action_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(TestscriptTeardown(
    action:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn testscript_test_action_to_json(
  testscript_test_action: TestscriptTestAction,
) -> Json {
  let TestscriptTestAction(modifier_extension:, extension:, id:) =
    testscript_test_action
  let fields = []
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn testscript_test_action_decoder() -> Decoder(TestscriptTestAction) {
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(TestscriptTestAction(modifier_extension:, extension:, id:))
}

pub fn testscript_test_to_json(testscript_test: TestscriptTest) -> Json {
  let TestscriptTest(
    action:,
    description:,
    name:,
    modifier_extension:,
    extension:,
    id:,
  ) = testscript_test
  let fields = []
  let fields = case action {
    [] -> fields
    _ -> [
      #("action", json.array(action, testscript_test_action_to_json)),
      ..fields
    ]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn testscript_test_decoder() -> Decoder(TestscriptTest) {
  use action <- decode.optional_field(
    "action",
    [],
    decode.list(testscript_test_action_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(TestscriptTest(
    action:,
    description:,
    name:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn testscript_setup_action_assert_to_json(
  testscript_setup_action_assert: TestscriptSetupActionAssert,
) -> Json {
  let TestscriptSetupActionAssert(
    warning_only:,
    value:,
    validate_profile_id:,
    source_id:,
    response_code:,
    response:,
    resource:,
    request_url:,
    request_method:,
    path:,
    operator:,
    navigation_links:,
    minimum_id:,
    header_field:,
    expression:,
    content_type:,
    compare_to_source_path:,
    compare_to_source_expression:,
    compare_to_source_id:,
    direction:,
    description:,
    label:,
    modifier_extension:,
    extension:,
    id:,
  ) = testscript_setup_action_assert
  let fields = [
    #("warningOnly", json.bool(warning_only)),
  ]
  let fields = case value {
    Some(v) -> [#("value", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case validate_profile_id {
    Some(v) -> [#("validateProfileId", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case source_id {
    Some(v) -> [#("sourceId", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case response_code {
    Some(v) -> [#("responseCode", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case response {
    Some(v) -> [
      #("response", r4bvaluesets.assertresponsecodetypes_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case resource {
    Some(v) -> [#("resource", r4bvaluesets.definedtypes_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case request_url {
    Some(v) -> [#("requestURL", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case request_method {
    Some(v) -> [
      #("requestMethod", r4bvaluesets.httpoperations_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case path {
    Some(v) -> [#("path", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case operator {
    Some(v) -> [
      #("operator", r4bvaluesets.assertoperatorcodes_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case navigation_links {
    Some(v) -> [#("navigationLinks", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case minimum_id {
    Some(v) -> [#("minimumId", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case header_field {
    Some(v) -> [#("headerField", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case expression {
    Some(v) -> [#("expression", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case content_type {
    Some(v) -> [#("contentType", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case compare_to_source_path {
    Some(v) -> [#("compareToSourcePath", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case compare_to_source_expression {
    Some(v) -> [#("compareToSourceExpression", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case compare_to_source_id {
    Some(v) -> [#("compareToSourceId", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case direction {
    Some(v) -> [
      #("direction", r4bvaluesets.assertdirectioncodes_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case label {
    Some(v) -> [#("label", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn testscript_setup_action_assert_decoder() -> Decoder(
  TestscriptSetupActionAssert,
) {
  use warning_only <- decode.field("warningOnly", decode.bool)
  use value <- decode.optional_field(
    "value",
    None,
    decode.optional(decode.string),
  )
  use validate_profile_id <- decode.optional_field(
    "validateProfileId",
    None,
    decode.optional(decode.string),
  )
  use source_id <- decode.optional_field(
    "sourceId",
    None,
    decode.optional(decode.string),
  )
  use response_code <- decode.optional_field(
    "responseCode",
    None,
    decode.optional(decode.string),
  )
  use response <- decode.optional_field(
    "response",
    None,
    decode.optional(r4bvaluesets.assertresponsecodetypes_decoder()),
  )
  use resource <- decode.optional_field(
    "resource",
    None,
    decode.optional(r4bvaluesets.definedtypes_decoder()),
  )
  use request_url <- decode.optional_field(
    "requestURL",
    None,
    decode.optional(decode.string),
  )
  use request_method <- decode.optional_field(
    "requestMethod",
    None,
    decode.optional(r4bvaluesets.httpoperations_decoder()),
  )
  use path <- decode.optional_field(
    "path",
    None,
    decode.optional(decode.string),
  )
  use operator <- decode.optional_field(
    "operator",
    None,
    decode.optional(r4bvaluesets.assertoperatorcodes_decoder()),
  )
  use navigation_links <- decode.optional_field(
    "navigationLinks",
    None,
    decode.optional(decode.bool),
  )
  use minimum_id <- decode.optional_field(
    "minimumId",
    None,
    decode.optional(decode.string),
  )
  use header_field <- decode.optional_field(
    "headerField",
    None,
    decode.optional(decode.string),
  )
  use expression <- decode.optional_field(
    "expression",
    None,
    decode.optional(decode.string),
  )
  use content_type <- decode.optional_field(
    "contentType",
    None,
    decode.optional(decode.string),
  )
  use compare_to_source_path <- decode.optional_field(
    "compareToSourcePath",
    None,
    decode.optional(decode.string),
  )
  use compare_to_source_expression <- decode.optional_field(
    "compareToSourceExpression",
    None,
    decode.optional(decode.string),
  )
  use compare_to_source_id <- decode.optional_field(
    "compareToSourceId",
    None,
    decode.optional(decode.string),
  )
  use direction <- decode.optional_field(
    "direction",
    None,
    decode.optional(r4bvaluesets.assertdirectioncodes_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use label <- decode.optional_field(
    "label",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(TestscriptSetupActionAssert(
    warning_only:,
    value:,
    validate_profile_id:,
    source_id:,
    response_code:,
    response:,
    resource:,
    request_url:,
    request_method:,
    path:,
    operator:,
    navigation_links:,
    minimum_id:,
    header_field:,
    expression:,
    content_type:,
    compare_to_source_path:,
    compare_to_source_expression:,
    compare_to_source_id:,
    direction:,
    description:,
    label:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn testscript_setup_action_operation_requestheader_to_json(
  testscript_setup_action_operation_requestheader: TestscriptSetupActionOperationRequestheader,
) -> Json {
  let TestscriptSetupActionOperationRequestheader(
    value:,
    field:,
    modifier_extension:,
    extension:,
    id:,
  ) = testscript_setup_action_operation_requestheader
  let fields = [
    #("value", json.string(value)),
    #("field", json.string(field)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn testscript_setup_action_operation_requestheader_decoder() -> Decoder(
  TestscriptSetupActionOperationRequestheader,
) {
  use value <- decode.field("value", decode.string)
  use field <- decode.field("field", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(TestscriptSetupActionOperationRequestheader(
    value:,
    field:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn testscript_setup_action_operation_to_json(
  testscript_setup_action_operation: TestscriptSetupActionOperation,
) -> Json {
  let TestscriptSetupActionOperation(
    url:,
    target_id:,
    source_id:,
    response_id:,
    request_id:,
    request_header:,
    params:,
    origin:,
    method:,
    encode_request_url:,
    destination:,
    content_type:,
    accept:,
    description:,
    label:,
    resource:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = testscript_setup_action_operation
  let fields = [
    #("encodeRequestUrl", json.bool(encode_request_url)),
  ]
  let fields = case url {
    Some(v) -> [#("url", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case target_id {
    Some(v) -> [#("targetId", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case source_id {
    Some(v) -> [#("sourceId", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case response_id {
    Some(v) -> [#("responseId", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case request_id {
    Some(v) -> [#("requestId", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case request_header {
    [] -> fields
    _ -> [
      #(
        "requestHeader",
        json.array(
          request_header,
          testscript_setup_action_operation_requestheader_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case params {
    Some(v) -> [#("params", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case origin {
    Some(v) -> [#("origin", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case method {
    Some(v) -> [#("method", r4bvaluesets.httpoperations_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case destination {
    Some(v) -> [#("destination", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case content_type {
    Some(v) -> [#("contentType", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case accept {
    Some(v) -> [#("accept", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case label {
    Some(v) -> [#("label", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case resource {
    Some(v) -> [#("resource", r4bvaluesets.definedtypes_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", coding_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn testscript_setup_action_operation_decoder() -> Decoder(
  TestscriptSetupActionOperation,
) {
  use url <- decode.optional_field("url", None, decode.optional(decode.string))
  use target_id <- decode.optional_field(
    "targetId",
    None,
    decode.optional(decode.string),
  )
  use source_id <- decode.optional_field(
    "sourceId",
    None,
    decode.optional(decode.string),
  )
  use response_id <- decode.optional_field(
    "responseId",
    None,
    decode.optional(decode.string),
  )
  use request_id <- decode.optional_field(
    "requestId",
    None,
    decode.optional(decode.string),
  )
  use request_header <- decode.optional_field(
    "requestHeader",
    [],
    decode.list(testscript_setup_action_operation_requestheader_decoder()),
  )
  use params <- decode.optional_field(
    "params",
    None,
    decode.optional(decode.string),
  )
  use origin <- decode.optional_field(
    "origin",
    None,
    decode.optional(decode.int),
  )
  use method <- decode.optional_field(
    "method",
    None,
    decode.optional(r4bvaluesets.httpoperations_decoder()),
  )
  use encode_request_url <- decode.field("encodeRequestUrl", decode.bool)
  use destination <- decode.optional_field(
    "destination",
    None,
    decode.optional(decode.int),
  )
  use content_type <- decode.optional_field(
    "contentType",
    None,
    decode.optional(decode.string),
  )
  use accept <- decode.optional_field(
    "accept",
    None,
    decode.optional(decode.string),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use label <- decode.optional_field(
    "label",
    None,
    decode.optional(decode.string),
  )
  use resource <- decode.optional_field(
    "resource",
    None,
    decode.optional(r4bvaluesets.definedtypes_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(coding_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(TestscriptSetupActionOperation(
    url:,
    target_id:,
    source_id:,
    response_id:,
    request_id:,
    request_header:,
    params:,
    origin:,
    method:,
    encode_request_url:,
    destination:,
    content_type:,
    accept:,
    description:,
    label:,
    resource:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn testscript_setup_action_to_json(
  testscript_setup_action: TestscriptSetupAction,
) -> Json {
  let TestscriptSetupAction(
    assert_:,
    operation:,
    modifier_extension:,
    extension:,
    id:,
  ) = testscript_setup_action
  let fields = []
  let fields = case assert_ {
    Some(v) -> [
      #("assert", testscript_setup_action_assert_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case operation {
    Some(v) -> [
      #("operation", testscript_setup_action_operation_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn testscript_setup_action_decoder() -> Decoder(TestscriptSetupAction) {
  use assert_ <- decode.optional_field(
    "assert",
    None,
    decode.optional(testscript_setup_action_assert_decoder()),
  )
  use operation <- decode.optional_field(
    "operation",
    None,
    decode.optional(testscript_setup_action_operation_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(TestscriptSetupAction(
    assert_:,
    operation:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn testscript_setup_to_json(testscript_setup: TestscriptSetup) -> Json {
  let TestscriptSetup(action:, modifier_extension:, extension:, id:) =
    testscript_setup
  let fields = []
  let fields = case action {
    [] -> fields
    _ -> [
      #("action", json.array(action, testscript_setup_action_to_json)),
      ..fields
    ]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn testscript_setup_decoder() -> Decoder(TestscriptSetup) {
  use action <- decode.optional_field(
    "action",
    [],
    decode.list(testscript_setup_action_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(TestscriptSetup(action:, modifier_extension:, extension:, id:))
}

pub fn testscript_variable_to_json(
  testscript_variable: TestscriptVariable,
) -> Json {
  let TestscriptVariable(
    source_id:,
    path:,
    hint:,
    header_field:,
    expression:,
    description:,
    default_value:,
    name:,
    modifier_extension:,
    extension:,
    id:,
  ) = testscript_variable
  let fields = [
    #("name", json.string(name)),
  ]
  let fields = case source_id {
    Some(v) -> [#("sourceId", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case path {
    Some(v) -> [#("path", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case hint {
    Some(v) -> [#("hint", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case header_field {
    Some(v) -> [#("headerField", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case expression {
    Some(v) -> [#("expression", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case default_value {
    Some(v) -> [#("defaultValue", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn testscript_variable_decoder() -> Decoder(TestscriptVariable) {
  use source_id <- decode.optional_field(
    "sourceId",
    None,
    decode.optional(decode.string),
  )
  use path <- decode.optional_field(
    "path",
    None,
    decode.optional(decode.string),
  )
  use hint <- decode.optional_field(
    "hint",
    None,
    decode.optional(decode.string),
  )
  use header_field <- decode.optional_field(
    "headerField",
    None,
    decode.optional(decode.string),
  )
  use expression <- decode.optional_field(
    "expression",
    None,
    decode.optional(decode.string),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use default_value <- decode.optional_field(
    "defaultValue",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.field("name", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(TestscriptVariable(
    source_id:,
    path:,
    hint:,
    header_field:,
    expression:,
    description:,
    default_value:,
    name:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn testscript_fixture_to_json(testscript_fixture: TestscriptFixture) -> Json {
  let TestscriptFixture(
    resource:,
    autodelete:,
    autocreate:,
    modifier_extension:,
    extension:,
    id:,
  ) = testscript_fixture
  let fields = [
    #("autodelete", json.bool(autodelete)),
    #("autocreate", json.bool(autocreate)),
  ]
  let fields = case resource {
    Some(v) -> [#("resource", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn testscript_fixture_decoder() -> Decoder(TestscriptFixture) {
  use resource <- decode.optional_field(
    "resource",
    None,
    decode.optional(reference_decoder()),
  )
  use autodelete <- decode.field("autodelete", decode.bool)
  use autocreate <- decode.field("autocreate", decode.bool)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(TestscriptFixture(
    resource:,
    autodelete:,
    autocreate:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn testscript_metadata_capability_to_json(
  testscript_metadata_capability: TestscriptMetadataCapability,
) -> Json {
  let TestscriptMetadataCapability(
    capabilities:,
    link:,
    destination:,
    origin:,
    description:,
    validated:,
    required:,
    modifier_extension:,
    extension:,
    id:,
  ) = testscript_metadata_capability
  let fields = [
    #("capabilities", json.string(capabilities)),
    #("validated", json.bool(validated)),
    #("required", json.bool(required)),
  ]
  let fields = case link {
    [] -> fields
    _ -> [#("link", json.array(link, json.string)), ..fields]
  }
  let fields = case destination {
    Some(v) -> [#("destination", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case origin {
    [] -> fields
    _ -> [#("origin", json.array(origin, json.int)), ..fields]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn testscript_metadata_capability_decoder() -> Decoder(
  TestscriptMetadataCapability,
) {
  use capabilities <- decode.field("capabilities", decode.string)
  use link <- decode.optional_field("link", [], decode.list(decode.string))
  use destination <- decode.optional_field(
    "destination",
    None,
    decode.optional(decode.int),
  )
  use origin <- decode.optional_field("origin", [], decode.list(decode.int))
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use validated <- decode.field("validated", decode.bool)
  use required <- decode.field("required", decode.bool)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(TestscriptMetadataCapability(
    capabilities:,
    link:,
    destination:,
    origin:,
    description:,
    validated:,
    required:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn testscript_metadata_link_to_json(
  testscript_metadata_link: TestscriptMetadataLink,
) -> Json {
  let TestscriptMetadataLink(
    description:,
    url:,
    modifier_extension:,
    extension:,
    id:,
  ) = testscript_metadata_link
  let fields = [
    #("url", json.string(url)),
  ]
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn testscript_metadata_link_decoder() -> Decoder(TestscriptMetadataLink) {
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use url <- decode.field("url", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(TestscriptMetadataLink(
    description:,
    url:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn testscript_metadata_to_json(
  testscript_metadata: TestscriptMetadata,
) -> Json {
  let TestscriptMetadata(
    capability:,
    link:,
    modifier_extension:,
    extension:,
    id:,
  ) = testscript_metadata
  let fields = []
  let fields = case capability {
    [] -> fields
    _ -> [
      #(
        "capability",
        json.array(capability, testscript_metadata_capability_to_json),
      ),
      ..fields
    ]
  }
  let fields = case link {
    [] -> fields
    _ -> [
      #("link", json.array(link, testscript_metadata_link_to_json)),
      ..fields
    ]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn testscript_metadata_decoder() -> Decoder(TestscriptMetadata) {
  use capability <- decode.optional_field(
    "capability",
    [],
    decode.list(testscript_metadata_capability_decoder()),
  )
  use link <- decode.optional_field(
    "link",
    [],
    decode.list(testscript_metadata_link_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(TestscriptMetadata(
    capability:,
    link:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn testscript_destination_to_json(
  testscript_destination: TestscriptDestination,
) -> Json {
  let TestscriptDestination(
    profile:,
    index:,
    modifier_extension:,
    extension:,
    id:,
  ) = testscript_destination
  let fields = [
    #("profile", coding_to_json(profile)),
    #("index", json.int(index)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn testscript_destination_decoder() -> Decoder(TestscriptDestination) {
  use profile <- decode.field("profile", coding_decoder())
  use index <- decode.field("index", decode.int)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(TestscriptDestination(
    profile:,
    index:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn testscript_origin_to_json(testscript_origin: TestscriptOrigin) -> Json {
  let TestscriptOrigin(profile:, index:, modifier_extension:, extension:, id:) =
    testscript_origin
  let fields = [
    #("profile", coding_to_json(profile)),
    #("index", json.int(index)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn testscript_origin_decoder() -> Decoder(TestscriptOrigin) {
  use profile <- decode.field("profile", coding_decoder())
  use index <- decode.field("index", decode.int)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(TestscriptOrigin(
    profile:,
    index:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn testscript_to_json(testscript: Testscript) -> Json {
  let Testscript(
    teardown:,
    test_:,
    setup:,
    variable:,
    profile:,
    fixture:,
    metadata:,
    destination:,
    origin:,
    copyright:,
    purpose:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    experimental:,
    status:,
    title:,
    name:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = testscript
  let fields = [
    #("status", r4bvaluesets.publicationstatus_to_json(status)),
    #("name", json.string(name)),
    #("url", json.string(url)),
  ]
  let fields = case teardown {
    Some(v) -> [#("teardown", testscript_teardown_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case test_ {
    [] -> fields
    _ -> [#("test", json.array(test_, testscript_test_to_json)), ..fields]
  }
  let fields = case setup {
    Some(v) -> [#("setup", testscript_setup_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case variable {
    [] -> fields
    _ -> [
      #("variable", json.array(variable, testscript_variable_to_json)),
      ..fields
    ]
  }
  let fields = case profile {
    [] -> fields
    _ -> [#("profile", json.array(profile, reference_to_json)), ..fields]
  }
  let fields = case fixture {
    [] -> fields
    _ -> [
      #("fixture", json.array(fixture, testscript_fixture_to_json)),
      ..fields
    ]
  }
  let fields = case metadata {
    Some(v) -> [#("metadata", testscript_metadata_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case destination {
    [] -> fields
    _ -> [
      #("destination", json.array(destination, testscript_destination_to_json)),
      ..fields
    ]
  }
  let fields = case origin {
    [] -> fields
    _ -> [#("origin", json.array(origin, testscript_origin_to_json)), ..fields]
  }
  let fields = case copyright {
    Some(v) -> [#("copyright", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case purpose {
    Some(v) -> [#("purpose", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case jurisdiction {
    [] -> fields
    _ -> [
      #("jurisdiction", json.array(jurisdiction, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case use_context {
    [] -> fields
    _ -> [
      #("useContext", json.array(use_context, usagecontext_to_json)),
      ..fields
    ]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case contact {
    [] -> fields
    _ -> [#("contact", json.array(contact, contactdetail_to_json)), ..fields]
  }
  let fields = case publisher {
    Some(v) -> [#("publisher", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case date {
    Some(v) -> [#("date", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case experimental {
    Some(v) -> [#("experimental", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case title {
    Some(v) -> [#("title", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case version {
    Some(v) -> [#("version", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    Some(v) -> [#("identifier", identifier_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Testscript")), ..fields]
  json.object(fields)
}

pub fn testscript_decoder() -> Decoder(Testscript) {
  use teardown <- decode.optional_field(
    "teardown",
    None,
    decode.optional(testscript_teardown_decoder()),
  )
  use test_ <- decode.optional_field(
    "test",
    [],
    decode.list(testscript_test_decoder()),
  )
  use setup <- decode.optional_field(
    "setup",
    None,
    decode.optional(testscript_setup_decoder()),
  )
  use variable <- decode.optional_field(
    "variable",
    [],
    decode.list(testscript_variable_decoder()),
  )
  use profile <- decode.optional_field(
    "profile",
    [],
    decode.list(reference_decoder()),
  )
  use fixture <- decode.optional_field(
    "fixture",
    [],
    decode.list(testscript_fixture_decoder()),
  )
  use metadata <- decode.optional_field(
    "metadata",
    None,
    decode.optional(testscript_metadata_decoder()),
  )
  use destination <- decode.optional_field(
    "destination",
    [],
    decode.list(testscript_destination_decoder()),
  )
  use origin <- decode.optional_field(
    "origin",
    [],
    decode.list(testscript_origin_decoder()),
  )
  use copyright <- decode.optional_field(
    "copyright",
    None,
    decode.optional(decode.string),
  )
  use purpose <- decode.optional_field(
    "purpose",
    None,
    decode.optional(decode.string),
  )
  use jurisdiction <- decode.optional_field(
    "jurisdiction",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use use_context <- decode.optional_field(
    "useContext",
    [],
    decode.list(usagecontext_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use contact <- decode.optional_field(
    "contact",
    [],
    decode.list(contactdetail_decoder()),
  )
  use publisher <- decode.optional_field(
    "publisher",
    None,
    decode.optional(decode.string),
  )
  use date <- decode.optional_field(
    "date",
    None,
    decode.optional(decode.string),
  )
  use experimental <- decode.optional_field(
    "experimental",
    None,
    decode.optional(decode.bool),
  )
  use status <- decode.field("status", r4bvaluesets.publicationstatus_decoder())
  use title <- decode.optional_field(
    "title",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.field("name", decode.string)
  use version <- decode.optional_field(
    "version",
    None,
    decode.optional(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    None,
    decode.optional(identifier_decoder()),
  )
  use url <- decode.field("url", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Testscript",
    decode.failure(testscript_new(status:, name:, url:), "resourceType"),
  )
  decode.success(Testscript(
    teardown:,
    test_:,
    setup:,
    variable:,
    profile:,
    fixture:,
    metadata:,
    destination:,
    origin:,
    copyright:,
    purpose:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    experimental:,
    status:,
    title:,
    name:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/ValueSet#resource
pub type Valueset {
  Valueset(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    url: Option(String),
    identifier: List(Identifier),
    version: Option(String),
    name: Option(String),
    title: Option(String),
    status: r4bvaluesets.Publicationstatus,
    experimental: Option(Bool),
    date: Option(String),
    publisher: Option(String),
    contact: List(Contactdetail),
    description: Option(String),
    use_context: List(Usagecontext),
    jurisdiction: List(Codeableconcept),
    immutable: Option(Bool),
    purpose: Option(String),
    copyright: Option(String),
    compose: Option(ValuesetCompose),
    expansion: Option(ValuesetExpansion),
  )
}

pub fn valueset_new(status status: r4bvaluesets.Publicationstatus) -> Valueset {
  Valueset(
    expansion: None,
    compose: None,
    copyright: None,
    purpose: None,
    immutable: None,
    jurisdiction: [],
    use_context: [],
    description: None,
    contact: [],
    publisher: None,
    date: None,
    experimental: None,
    status:,
    title: None,
    name: None,
    version: None,
    identifier: [],
    url: None,
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ValueSet#resource
pub type ValuesetCompose {
  ValuesetCompose(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    locked_date: Option(String),
    inactive: Option(Bool),
    include: List(ValuesetComposeInclude),
  )
}

pub fn valueset_compose_new() -> ValuesetCompose {
  ValuesetCompose(
    include: [],
    inactive: None,
    locked_date: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ValueSet#resource
pub type ValuesetComposeInclude {
  ValuesetComposeInclude(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    system: Option(String),
    version: Option(String),
    concept: List(ValuesetComposeIncludeConcept),
    filter: List(ValuesetComposeIncludeFilter),
    value_set: List(String),
  )
}

pub fn valueset_compose_include_new() -> ValuesetComposeInclude {
  ValuesetComposeInclude(
    value_set: [],
    filter: [],
    concept: [],
    version: None,
    system: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ValueSet#resource
pub type ValuesetComposeIncludeConcept {
  ValuesetComposeIncludeConcept(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    code: String,
    display: Option(String),
    designation: List(ValuesetComposeIncludeConceptDesignation),
  )
}

pub fn valueset_compose_include_concept_new(
  code code: String,
) -> ValuesetComposeIncludeConcept {
  ValuesetComposeIncludeConcept(
    designation: [],
    display: None,
    code:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ValueSet#resource
pub type ValuesetComposeIncludeConceptDesignation {
  ValuesetComposeIncludeConceptDesignation(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    language: Option(String),
    use_: Option(Coding),
    value: String,
  )
}

pub fn valueset_compose_include_concept_designation_new(
  value value: String,
) -> ValuesetComposeIncludeConceptDesignation {
  ValuesetComposeIncludeConceptDesignation(
    value:,
    use_: None,
    language: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ValueSet#resource
pub type ValuesetComposeIncludeFilter {
  ValuesetComposeIncludeFilter(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    property: String,
    op: r4bvaluesets.Filteroperator,
    value: String,
  )
}

pub fn valueset_compose_include_filter_new(
  value value: String,
  op op: r4bvaluesets.Filteroperator,
  property property: String,
) -> ValuesetComposeIncludeFilter {
  ValuesetComposeIncludeFilter(
    value:,
    op:,
    property:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ValueSet#resource
pub type ValuesetExpansion {
  ValuesetExpansion(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: Option(String),
    timestamp: String,
    total: Option(Int),
    offset: Option(Int),
    parameter: List(ValuesetExpansionParameter),
    contains: List(ValuesetExpansionContains),
  )
}

pub fn valueset_expansion_new(timestamp timestamp: String) -> ValuesetExpansion {
  ValuesetExpansion(
    contains: [],
    parameter: [],
    offset: None,
    total: None,
    timestamp:,
    identifier: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ValueSet#resource
pub type ValuesetExpansionParameter {
  ValuesetExpansionParameter(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    name: String,
    value: Option(ValuesetExpansionParameterValue),
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ValueSet#resource
pub type ValuesetExpansionParameterValue {
  ValuesetExpansionParameterValueString(value: String)
  ValuesetExpansionParameterValueBoolean(value: Bool)
  ValuesetExpansionParameterValueInteger(value: Int)
  ValuesetExpansionParameterValueDecimal(value: Float)
  ValuesetExpansionParameterValueUri(value: String)
  ValuesetExpansionParameterValueCode(value: String)
  ValuesetExpansionParameterValueDatetime(value: String)
}

pub fn valueset_expansion_parameter_value_to_json(
  elt: ValuesetExpansionParameterValue,
) -> Json {
  case elt {
    ValuesetExpansionParameterValueString(v) -> json.string(v)
    ValuesetExpansionParameterValueBoolean(v) -> json.bool(v)
    ValuesetExpansionParameterValueInteger(v) -> json.int(v)
    ValuesetExpansionParameterValueDecimal(v) -> json.float(v)
    ValuesetExpansionParameterValueUri(v) -> json.string(v)
    ValuesetExpansionParameterValueCode(v) -> json.string(v)
    ValuesetExpansionParameterValueDatetime(v) -> json.string(v)
  }
}

pub fn valueset_expansion_parameter_value_decoder() -> Decoder(
  ValuesetExpansionParameterValue,
) {
  decode.one_of(
    decode.field("valueString", decode.string, decode.success)
      |> decode.map(ValuesetExpansionParameterValueString),
    [
      decode.field("valueBoolean", decode.bool, decode.success)
        |> decode.map(ValuesetExpansionParameterValueBoolean),
      decode.field("valueInteger", decode.int, decode.success)
        |> decode.map(ValuesetExpansionParameterValueInteger),
      decode.field("valueDecimal", decode.float, decode.success)
        |> decode.map(ValuesetExpansionParameterValueDecimal),
      decode.field("valueUri", decode.string, decode.success)
        |> decode.map(ValuesetExpansionParameterValueUri),
      decode.field("valueCode", decode.string, decode.success)
        |> decode.map(ValuesetExpansionParameterValueCode),
      decode.field("valueDateTime", decode.string, decode.success)
        |> decode.map(ValuesetExpansionParameterValueDatetime),
    ],
  )
}

pub fn valueset_expansion_parameter_new(
  name name: String,
) -> ValuesetExpansionParameter {
  ValuesetExpansionParameter(
    value: None,
    name:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/ValueSet#resource
pub type ValuesetExpansionContains {
  ValuesetExpansionContains(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    system: Option(String),
    abstract: Option(Bool),
    inactive: Option(Bool),
    version: Option(String),
    code: Option(String),
    display: Option(String),
  )
}

pub fn valueset_expansion_contains_new() -> ValuesetExpansionContains {
  ValuesetExpansionContains(
    display: None,
    code: None,
    version: None,
    inactive: None,
    abstract: None,
    system: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn valueset_expansion_contains_to_json(
  valueset_expansion_contains: ValuesetExpansionContains,
) -> Json {
  let ValuesetExpansionContains(
    display:,
    code:,
    version:,
    inactive:,
    abstract:,
    system:,
    modifier_extension:,
    extension:,
    id:,
  ) = valueset_expansion_contains
  let fields = []
  let fields = case display {
    Some(v) -> [#("display", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case code {
    Some(v) -> [#("code", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case version {
    Some(v) -> [#("version", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case inactive {
    Some(v) -> [#("inactive", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case abstract {
    Some(v) -> [#("abstract", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case system {
    Some(v) -> [#("system", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn valueset_expansion_contains_decoder() -> Decoder(
  ValuesetExpansionContains,
) {
  use display <- decode.optional_field(
    "display",
    None,
    decode.optional(decode.string),
  )
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(decode.string),
  )
  use version <- decode.optional_field(
    "version",
    None,
    decode.optional(decode.string),
  )
  use inactive <- decode.optional_field(
    "inactive",
    None,
    decode.optional(decode.bool),
  )
  use abstract <- decode.optional_field(
    "abstract",
    None,
    decode.optional(decode.bool),
  )
  use system <- decode.optional_field(
    "system",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ValuesetExpansionContains(
    display:,
    code:,
    version:,
    inactive:,
    abstract:,
    system:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn valueset_expansion_parameter_to_json(
  valueset_expansion_parameter: ValuesetExpansionParameter,
) -> Json {
  let ValuesetExpansionParameter(
    value:,
    name:,
    modifier_extension:,
    extension:,
    id:,
  ) = valueset_expansion_parameter
  let fields = [
    #("name", json.string(name)),
  ]
  let fields = case value {
    Some(v) -> [
      #(
        "value"
          <> case v {
          ValuesetExpansionParameterValueString(_) -> "String"
          ValuesetExpansionParameterValueBoolean(_) -> "Boolean"
          ValuesetExpansionParameterValueInteger(_) -> "Integer"
          ValuesetExpansionParameterValueDecimal(_) -> "Decimal"
          ValuesetExpansionParameterValueUri(_) -> "Uri"
          ValuesetExpansionParameterValueCode(_) -> "Code"
          ValuesetExpansionParameterValueDatetime(_) -> "Datetime"
        },
        valueset_expansion_parameter_value_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn valueset_expansion_parameter_decoder() -> Decoder(
  ValuesetExpansionParameter,
) {
  use value <- decode.then(
    none_if_omitted(valueset_expansion_parameter_value_decoder()),
  )
  use name <- decode.field("name", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ValuesetExpansionParameter(
    value:,
    name:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn valueset_expansion_to_json(valueset_expansion: ValuesetExpansion) -> Json {
  let ValuesetExpansion(
    contains:,
    parameter:,
    offset:,
    total:,
    timestamp:,
    identifier:,
    modifier_extension:,
    extension:,
    id:,
  ) = valueset_expansion
  let fields = [
    #("timestamp", json.string(timestamp)),
  ]
  let fields = case contains {
    [] -> fields
    _ -> [
      #("contains", json.array(contains, valueset_expansion_contains_to_json)),
      ..fields
    ]
  }
  let fields = case parameter {
    [] -> fields
    _ -> [
      #(
        "parameter",
        json.array(parameter, valueset_expansion_parameter_to_json),
      ),
      ..fields
    ]
  }
  let fields = case offset {
    Some(v) -> [#("offset", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case total {
    Some(v) -> [#("total", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    Some(v) -> [#("identifier", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn valueset_expansion_decoder() -> Decoder(ValuesetExpansion) {
  use contains <- decode.optional_field(
    "contains",
    [],
    decode.list(valueset_expansion_contains_decoder()),
  )
  use parameter <- decode.optional_field(
    "parameter",
    [],
    decode.list(valueset_expansion_parameter_decoder()),
  )
  use offset <- decode.optional_field(
    "offset",
    None,
    decode.optional(decode.int),
  )
  use total <- decode.optional_field("total", None, decode.optional(decode.int))
  use timestamp <- decode.field("timestamp", decode.string)
  use identifier <- decode.optional_field(
    "identifier",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ValuesetExpansion(
    contains:,
    parameter:,
    offset:,
    total:,
    timestamp:,
    identifier:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn valueset_compose_include_filter_to_json(
  valueset_compose_include_filter: ValuesetComposeIncludeFilter,
) -> Json {
  let ValuesetComposeIncludeFilter(
    value:,
    op:,
    property:,
    modifier_extension:,
    extension:,
    id:,
  ) = valueset_compose_include_filter
  let fields = [
    #("value", json.string(value)),
    #("op", r4bvaluesets.filteroperator_to_json(op)),
    #("property", json.string(property)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn valueset_compose_include_filter_decoder() -> Decoder(
  ValuesetComposeIncludeFilter,
) {
  use value <- decode.field("value", decode.string)
  use op <- decode.field("op", r4bvaluesets.filteroperator_decoder())
  use property <- decode.field("property", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ValuesetComposeIncludeFilter(
    value:,
    op:,
    property:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn valueset_compose_include_concept_designation_to_json(
  valueset_compose_include_concept_designation: ValuesetComposeIncludeConceptDesignation,
) -> Json {
  let ValuesetComposeIncludeConceptDesignation(
    value:,
    use_:,
    language:,
    modifier_extension:,
    extension:,
    id:,
  ) = valueset_compose_include_concept_designation
  let fields = [
    #("value", json.string(value)),
  ]
  let fields = case use_ {
    Some(v) -> [#("use", coding_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn valueset_compose_include_concept_designation_decoder() -> Decoder(
  ValuesetComposeIncludeConceptDesignation,
) {
  use value <- decode.field("value", decode.string)
  use use_ <- decode.optional_field(
    "use",
    None,
    decode.optional(coding_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ValuesetComposeIncludeConceptDesignation(
    value:,
    use_:,
    language:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn valueset_compose_include_concept_to_json(
  valueset_compose_include_concept: ValuesetComposeIncludeConcept,
) -> Json {
  let ValuesetComposeIncludeConcept(
    designation:,
    display:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ) = valueset_compose_include_concept
  let fields = [
    #("code", json.string(code)),
  ]
  let fields = case designation {
    [] -> fields
    _ -> [
      #(
        "designation",
        json.array(
          designation,
          valueset_compose_include_concept_designation_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case display {
    Some(v) -> [#("display", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn valueset_compose_include_concept_decoder() -> Decoder(
  ValuesetComposeIncludeConcept,
) {
  use designation <- decode.optional_field(
    "designation",
    [],
    decode.list(valueset_compose_include_concept_designation_decoder()),
  )
  use display <- decode.optional_field(
    "display",
    None,
    decode.optional(decode.string),
  )
  use code <- decode.field("code", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ValuesetComposeIncludeConcept(
    designation:,
    display:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn valueset_compose_include_to_json(
  valueset_compose_include: ValuesetComposeInclude,
) -> Json {
  let ValuesetComposeInclude(
    value_set:,
    filter:,
    concept:,
    version:,
    system:,
    modifier_extension:,
    extension:,
    id:,
  ) = valueset_compose_include
  let fields = []
  let fields = case value_set {
    [] -> fields
    _ -> [#("valueSet", json.array(value_set, json.string)), ..fields]
  }
  let fields = case filter {
    [] -> fields
    _ -> [
      #("filter", json.array(filter, valueset_compose_include_filter_to_json)),
      ..fields
    ]
  }
  let fields = case concept {
    [] -> fields
    _ -> [
      #(
        "concept",
        json.array(concept, valueset_compose_include_concept_to_json),
      ),
      ..fields
    ]
  }
  let fields = case version {
    Some(v) -> [#("version", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case system {
    Some(v) -> [#("system", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn valueset_compose_include_decoder() -> Decoder(ValuesetComposeInclude) {
  use value_set <- decode.optional_field(
    "valueSet",
    [],
    decode.list(decode.string),
  )
  use filter <- decode.optional_field(
    "filter",
    [],
    decode.list(valueset_compose_include_filter_decoder()),
  )
  use concept <- decode.optional_field(
    "concept",
    [],
    decode.list(valueset_compose_include_concept_decoder()),
  )
  use version <- decode.optional_field(
    "version",
    None,
    decode.optional(decode.string),
  )
  use system <- decode.optional_field(
    "system",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ValuesetComposeInclude(
    value_set:,
    filter:,
    concept:,
    version:,
    system:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn valueset_compose_to_json(valueset_compose: ValuesetCompose) -> Json {
  let ValuesetCompose(
    include:,
    inactive:,
    locked_date:,
    modifier_extension:,
    extension:,
    id:,
  ) = valueset_compose
  let fields = []
  let fields = case include {
    [] -> fields
    _ -> [
      #("include", json.array(include, valueset_compose_include_to_json)),
      ..fields
    ]
  }
  let fields = case inactive {
    Some(v) -> [#("inactive", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case locked_date {
    Some(v) -> [#("lockedDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn valueset_compose_decoder() -> Decoder(ValuesetCompose) {
  use include <- decode.optional_field(
    "include",
    [],
    decode.list(valueset_compose_include_decoder()),
  )
  use inactive <- decode.optional_field(
    "inactive",
    None,
    decode.optional(decode.bool),
  )
  use locked_date <- decode.optional_field(
    "lockedDate",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ValuesetCompose(
    include:,
    inactive:,
    locked_date:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn valueset_to_json(valueset: Valueset) -> Json {
  let Valueset(
    expansion:,
    compose:,
    copyright:,
    purpose:,
    immutable:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    experimental:,
    status:,
    title:,
    name:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = valueset
  let fields = [
    #("status", r4bvaluesets.publicationstatus_to_json(status)),
  ]
  let fields = case expansion {
    Some(v) -> [#("expansion", valueset_expansion_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case compose {
    Some(v) -> [#("compose", valueset_compose_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case copyright {
    Some(v) -> [#("copyright", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case purpose {
    Some(v) -> [#("purpose", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case immutable {
    Some(v) -> [#("immutable", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case jurisdiction {
    [] -> fields
    _ -> [
      #("jurisdiction", json.array(jurisdiction, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case use_context {
    [] -> fields
    _ -> [
      #("useContext", json.array(use_context, usagecontext_to_json)),
      ..fields
    ]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case contact {
    [] -> fields
    _ -> [#("contact", json.array(contact, contactdetail_to_json)), ..fields]
  }
  let fields = case publisher {
    Some(v) -> [#("publisher", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case date {
    Some(v) -> [#("date", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case experimental {
    Some(v) -> [#("experimental", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case title {
    Some(v) -> [#("title", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case version {
    Some(v) -> [#("version", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case url {
    Some(v) -> [#("url", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Valueset")), ..fields]
  json.object(fields)
}

pub fn valueset_decoder() -> Decoder(Valueset) {
  use expansion <- decode.optional_field(
    "expansion",
    None,
    decode.optional(valueset_expansion_decoder()),
  )
  use compose <- decode.optional_field(
    "compose",
    None,
    decode.optional(valueset_compose_decoder()),
  )
  use copyright <- decode.optional_field(
    "copyright",
    None,
    decode.optional(decode.string),
  )
  use purpose <- decode.optional_field(
    "purpose",
    None,
    decode.optional(decode.string),
  )
  use immutable <- decode.optional_field(
    "immutable",
    None,
    decode.optional(decode.bool),
  )
  use jurisdiction <- decode.optional_field(
    "jurisdiction",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use use_context <- decode.optional_field(
    "useContext",
    [],
    decode.list(usagecontext_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use contact <- decode.optional_field(
    "contact",
    [],
    decode.list(contactdetail_decoder()),
  )
  use publisher <- decode.optional_field(
    "publisher",
    None,
    decode.optional(decode.string),
  )
  use date <- decode.optional_field(
    "date",
    None,
    decode.optional(decode.string),
  )
  use experimental <- decode.optional_field(
    "experimental",
    None,
    decode.optional(decode.bool),
  )
  use status <- decode.field("status", r4bvaluesets.publicationstatus_decoder())
  use title <- decode.optional_field(
    "title",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use version <- decode.optional_field(
    "version",
    None,
    decode.optional(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use url <- decode.optional_field("url", None, decode.optional(decode.string))
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Valueset",
    decode.failure(valueset_new(status:), "resourceType"),
  )
  decode.success(Valueset(
    expansion:,
    compose:,
    copyright:,
    purpose:,
    immutable:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    experimental:,
    status:,
    title:,
    name:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/VerificationResult#resource
pub type Verificationresult {
  Verificationresult(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    target: List(Reference),
    target_location: List(String),
    need: Option(Codeableconcept),
    status: r4bvaluesets.Verificationresultstatus,
    status_date: Option(String),
    validation_type: Option(Codeableconcept),
    validation_process: List(Codeableconcept),
    frequency: Option(Timing),
    last_performed: Option(String),
    next_scheduled: Option(String),
    failure_action: Option(Codeableconcept),
    primary_source: List(VerificationresultPrimarysource),
    attestation: Option(VerificationresultAttestation),
    validator: List(VerificationresultValidator),
  )
}

pub fn verificationresult_new(
  status status: r4bvaluesets.Verificationresultstatus,
) -> Verificationresult {
  Verificationresult(
    validator: [],
    attestation: None,
    primary_source: [],
    failure_action: None,
    next_scheduled: None,
    last_performed: None,
    frequency: None,
    validation_process: [],
    validation_type: None,
    status_date: None,
    status:,
    need: None,
    target_location: [],
    target: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/VerificationResult#resource
pub type VerificationresultPrimarysource {
  VerificationresultPrimarysource(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    who: Option(Reference),
    type_: List(Codeableconcept),
    communication_method: List(Codeableconcept),
    validation_status: Option(Codeableconcept),
    validation_date: Option(String),
    can_push_updates: Option(Codeableconcept),
    push_type_available: List(Codeableconcept),
  )
}

pub fn verificationresult_primarysource_new() -> VerificationresultPrimarysource {
  VerificationresultPrimarysource(
    push_type_available: [],
    can_push_updates: None,
    validation_date: None,
    validation_status: None,
    communication_method: [],
    type_: [],
    who: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/VerificationResult#resource
pub type VerificationresultAttestation {
  VerificationresultAttestation(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    who: Option(Reference),
    on_behalf_of: Option(Reference),
    communication_method: Option(Codeableconcept),
    date: Option(String),
    source_identity_certificate: Option(String),
    proxy_identity_certificate: Option(String),
    proxy_signature: Option(Signature),
    source_signature: Option(Signature),
  )
}

pub fn verificationresult_attestation_new() -> VerificationresultAttestation {
  VerificationresultAttestation(
    source_signature: None,
    proxy_signature: None,
    proxy_identity_certificate: None,
    source_identity_certificate: None,
    date: None,
    communication_method: None,
    on_behalf_of: None,
    who: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/VerificationResult#resource
pub type VerificationresultValidator {
  VerificationresultValidator(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    organization: Reference,
    identity_certificate: Option(String),
    attestation_signature: Option(Signature),
  )
}

pub fn verificationresult_validator_new(
  organization organization: Reference,
) -> VerificationresultValidator {
  VerificationresultValidator(
    attestation_signature: None,
    identity_certificate: None,
    organization:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn verificationresult_validator_to_json(
  verificationresult_validator: VerificationresultValidator,
) -> Json {
  let VerificationresultValidator(
    attestation_signature:,
    identity_certificate:,
    organization:,
    modifier_extension:,
    extension:,
    id:,
  ) = verificationresult_validator
  let fields = [
    #("organization", reference_to_json(organization)),
  ]
  let fields = case attestation_signature {
    Some(v) -> [#("attestationSignature", signature_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case identity_certificate {
    Some(v) -> [#("identityCertificate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn verificationresult_validator_decoder() -> Decoder(
  VerificationresultValidator,
) {
  use attestation_signature <- decode.optional_field(
    "attestationSignature",
    None,
    decode.optional(signature_decoder()),
  )
  use identity_certificate <- decode.optional_field(
    "identityCertificate",
    None,
    decode.optional(decode.string),
  )
  use organization <- decode.field("organization", reference_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(VerificationresultValidator(
    attestation_signature:,
    identity_certificate:,
    organization:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn verificationresult_attestation_to_json(
  verificationresult_attestation: VerificationresultAttestation,
) -> Json {
  let VerificationresultAttestation(
    source_signature:,
    proxy_signature:,
    proxy_identity_certificate:,
    source_identity_certificate:,
    date:,
    communication_method:,
    on_behalf_of:,
    who:,
    modifier_extension:,
    extension:,
    id:,
  ) = verificationresult_attestation
  let fields = []
  let fields = case source_signature {
    Some(v) -> [#("sourceSignature", signature_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case proxy_signature {
    Some(v) -> [#("proxySignature", signature_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case proxy_identity_certificate {
    Some(v) -> [#("proxyIdentityCertificate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case source_identity_certificate {
    Some(v) -> [#("sourceIdentityCertificate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case date {
    Some(v) -> [#("date", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case communication_method {
    Some(v) -> [#("communicationMethod", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case on_behalf_of {
    Some(v) -> [#("onBehalfOf", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case who {
    Some(v) -> [#("who", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn verificationresult_attestation_decoder() -> Decoder(
  VerificationresultAttestation,
) {
  use source_signature <- decode.optional_field(
    "sourceSignature",
    None,
    decode.optional(signature_decoder()),
  )
  use proxy_signature <- decode.optional_field(
    "proxySignature",
    None,
    decode.optional(signature_decoder()),
  )
  use proxy_identity_certificate <- decode.optional_field(
    "proxyIdentityCertificate",
    None,
    decode.optional(decode.string),
  )
  use source_identity_certificate <- decode.optional_field(
    "sourceIdentityCertificate",
    None,
    decode.optional(decode.string),
  )
  use date <- decode.optional_field(
    "date",
    None,
    decode.optional(decode.string),
  )
  use communication_method <- decode.optional_field(
    "communicationMethod",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use on_behalf_of <- decode.optional_field(
    "onBehalfOf",
    None,
    decode.optional(reference_decoder()),
  )
  use who <- decode.optional_field(
    "who",
    None,
    decode.optional(reference_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(VerificationresultAttestation(
    source_signature:,
    proxy_signature:,
    proxy_identity_certificate:,
    source_identity_certificate:,
    date:,
    communication_method:,
    on_behalf_of:,
    who:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn verificationresult_primarysource_to_json(
  verificationresult_primarysource: VerificationresultPrimarysource,
) -> Json {
  let VerificationresultPrimarysource(
    push_type_available:,
    can_push_updates:,
    validation_date:,
    validation_status:,
    communication_method:,
    type_:,
    who:,
    modifier_extension:,
    extension:,
    id:,
  ) = verificationresult_primarysource
  let fields = []
  let fields = case push_type_available {
    [] -> fields
    _ -> [
      #(
        "pushTypeAvailable",
        json.array(push_type_available, codeableconcept_to_json),
      ),
      ..fields
    ]
  }
  let fields = case can_push_updates {
    Some(v) -> [#("canPushUpdates", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case validation_date {
    Some(v) -> [#("validationDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case validation_status {
    Some(v) -> [#("validationStatus", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case communication_method {
    [] -> fields
    _ -> [
      #(
        "communicationMethod",
        json.array(communication_method, codeableconcept_to_json),
      ),
      ..fields
    ]
  }
  let fields = case type_ {
    [] -> fields
    _ -> [#("type", json.array(type_, codeableconcept_to_json)), ..fields]
  }
  let fields = case who {
    Some(v) -> [#("who", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn verificationresult_primarysource_decoder() -> Decoder(
  VerificationresultPrimarysource,
) {
  use push_type_available <- decode.optional_field(
    "pushTypeAvailable",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use can_push_updates <- decode.optional_field(
    "canPushUpdates",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use validation_date <- decode.optional_field(
    "validationDate",
    None,
    decode.optional(decode.string),
  )
  use validation_status <- decode.optional_field(
    "validationStatus",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use communication_method <- decode.optional_field(
    "communicationMethod",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use who <- decode.optional_field(
    "who",
    None,
    decode.optional(reference_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(VerificationresultPrimarysource(
    push_type_available:,
    can_push_updates:,
    validation_date:,
    validation_status:,
    communication_method:,
    type_:,
    who:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn verificationresult_to_json(
  verificationresult: Verificationresult,
) -> Json {
  let Verificationresult(
    validator:,
    attestation:,
    primary_source:,
    failure_action:,
    next_scheduled:,
    last_performed:,
    frequency:,
    validation_process:,
    validation_type:,
    status_date:,
    status:,
    need:,
    target_location:,
    target:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = verificationresult
  let fields = [
    #("status", r4bvaluesets.verificationresultstatus_to_json(status)),
  ]
  let fields = case validator {
    [] -> fields
    _ -> [
      #(
        "validator",
        json.array(validator, verificationresult_validator_to_json),
      ),
      ..fields
    ]
  }
  let fields = case attestation {
    Some(v) -> [
      #("attestation", verificationresult_attestation_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case primary_source {
    [] -> fields
    _ -> [
      #(
        "primarySource",
        json.array(primary_source, verificationresult_primarysource_to_json),
      ),
      ..fields
    ]
  }
  let fields = case failure_action {
    Some(v) -> [#("failureAction", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case next_scheduled {
    Some(v) -> [#("nextScheduled", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case last_performed {
    Some(v) -> [#("lastPerformed", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case frequency {
    Some(v) -> [#("frequency", timing_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case validation_process {
    [] -> fields
    _ -> [
      #(
        "validationProcess",
        json.array(validation_process, codeableconcept_to_json),
      ),
      ..fields
    ]
  }
  let fields = case validation_type {
    Some(v) -> [#("validationType", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case status_date {
    Some(v) -> [#("statusDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case need {
    Some(v) -> [#("need", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case target_location {
    [] -> fields
    _ -> [
      #("targetLocation", json.array(target_location, json.string)),
      ..fields
    ]
  }
  let fields = case target {
    [] -> fields
    _ -> [#("target", json.array(target, reference_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Verificationresult")), ..fields]
  json.object(fields)
}

pub fn verificationresult_decoder() -> Decoder(Verificationresult) {
  use validator <- decode.optional_field(
    "validator",
    [],
    decode.list(verificationresult_validator_decoder()),
  )
  use attestation <- decode.optional_field(
    "attestation",
    None,
    decode.optional(verificationresult_attestation_decoder()),
  )
  use primary_source <- decode.optional_field(
    "primarySource",
    [],
    decode.list(verificationresult_primarysource_decoder()),
  )
  use failure_action <- decode.optional_field(
    "failureAction",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use next_scheduled <- decode.optional_field(
    "nextScheduled",
    None,
    decode.optional(decode.string),
  )
  use last_performed <- decode.optional_field(
    "lastPerformed",
    None,
    decode.optional(decode.string),
  )
  use frequency <- decode.optional_field(
    "frequency",
    None,
    decode.optional(timing_decoder()),
  )
  use validation_process <- decode.optional_field(
    "validationProcess",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use validation_type <- decode.optional_field(
    "validationType",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use status_date <- decode.optional_field(
    "statusDate",
    None,
    decode.optional(decode.string),
  )
  use status <- decode.field(
    "status",
    r4bvaluesets.verificationresultstatus_decoder(),
  )
  use need <- decode.optional_field(
    "need",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use target_location <- decode.optional_field(
    "targetLocation",
    [],
    decode.list(decode.string),
  )
  use target <- decode.optional_field(
    "target",
    [],
    decode.list(reference_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Verificationresult",
    decode.failure(verificationresult_new(status:), "resourceType"),
  )
  decode.success(Verificationresult(
    validator:,
    attestation:,
    primary_source:,
    failure_action:,
    next_scheduled:,
    last_performed:,
    frequency:,
    validation_process:,
    validation_type:,
    status_date:,
    status:,
    need:,
    target_location:,
    target:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r4b/StructureDefinition/VisionPrescription#resource
pub type Visionprescription {
  Visionprescription(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    status: r4bvaluesets.Fmstatus,
    created: String,
    patient: Reference,
    encounter: Option(Reference),
    date_written: String,
    prescriber: Reference,
    lens_specification: List(VisionprescriptionLensspecification),
  )
}

pub fn visionprescription_new(
  prescriber prescriber: Reference,
  date_written date_written: String,
  patient patient: Reference,
  created created: String,
  status status: r4bvaluesets.Fmstatus,
) -> Visionprescription {
  Visionprescription(
    lens_specification: [],
    prescriber:,
    date_written:,
    encounter: None,
    patient:,
    created:,
    status:,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/VisionPrescription#resource
pub type VisionprescriptionLensspecification {
  VisionprescriptionLensspecification(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    product: Codeableconcept,
    eye: r4bvaluesets.Visioneyecodes,
    sphere: Option(Float),
    cylinder: Option(Float),
    axis: Option(Int),
    prism: List(VisionprescriptionLensspecificationPrism),
    add: Option(Float),
    power: Option(Float),
    back_curve: Option(Float),
    diameter: Option(Float),
    duration: Option(Quantity),
    color: Option(String),
    brand: Option(String),
    note: List(Annotation),
  )
}

pub fn visionprescription_lensspecification_new(
  eye eye: r4bvaluesets.Visioneyecodes,
  product product: Codeableconcept,
) -> VisionprescriptionLensspecification {
  VisionprescriptionLensspecification(
    note: [],
    brand: None,
    color: None,
    duration: None,
    diameter: None,
    back_curve: None,
    power: None,
    add: None,
    prism: [],
    axis: None,
    cylinder: None,
    sphere: None,
    eye:,
    product:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r4b/StructureDefinition/VisionPrescription#resource
pub type VisionprescriptionLensspecificationPrism {
  VisionprescriptionLensspecificationPrism(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    amount: Float,
    base: r4bvaluesets.Visionbasecodes,
  )
}

pub fn visionprescription_lensspecification_prism_new(
  base base: r4bvaluesets.Visionbasecodes,
  amount amount: Float,
) -> VisionprescriptionLensspecificationPrism {
  VisionprescriptionLensspecificationPrism(
    base:,
    amount:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn visionprescription_lensspecification_prism_to_json(
  visionprescription_lensspecification_prism: VisionprescriptionLensspecificationPrism,
) -> Json {
  let VisionprescriptionLensspecificationPrism(
    base:,
    amount:,
    modifier_extension:,
    extension:,
    id:,
  ) = visionprescription_lensspecification_prism
  let fields = [
    #("base", r4bvaluesets.visionbasecodes_to_json(base)),
    #("amount", json.float(amount)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn visionprescription_lensspecification_prism_decoder() -> Decoder(
  VisionprescriptionLensspecificationPrism,
) {
  use base <- decode.field("base", r4bvaluesets.visionbasecodes_decoder())
  use amount <- decode.field("amount", decode.float)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(VisionprescriptionLensspecificationPrism(
    base:,
    amount:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn visionprescription_lensspecification_to_json(
  visionprescription_lensspecification: VisionprescriptionLensspecification,
) -> Json {
  let VisionprescriptionLensspecification(
    note:,
    brand:,
    color:,
    duration:,
    diameter:,
    back_curve:,
    power:,
    add:,
    prism:,
    axis:,
    cylinder:,
    sphere:,
    eye:,
    product:,
    modifier_extension:,
    extension:,
    id:,
  ) = visionprescription_lensspecification
  let fields = [
    #("eye", r4bvaluesets.visioneyecodes_to_json(eye)),
    #("product", codeableconcept_to_json(product)),
  ]
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case brand {
    Some(v) -> [#("brand", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case color {
    Some(v) -> [#("color", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case duration {
    Some(v) -> [#("duration", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case diameter {
    Some(v) -> [#("diameter", json.float(v)), ..fields]
    None -> fields
  }
  let fields = case back_curve {
    Some(v) -> [#("backCurve", json.float(v)), ..fields]
    None -> fields
  }
  let fields = case power {
    Some(v) -> [#("power", json.float(v)), ..fields]
    None -> fields
  }
  let fields = case add {
    Some(v) -> [#("add", json.float(v)), ..fields]
    None -> fields
  }
  let fields = case prism {
    [] -> fields
    _ -> [
      #(
        "prism",
        json.array(prism, visionprescription_lensspecification_prism_to_json),
      ),
      ..fields
    ]
  }
  let fields = case axis {
    Some(v) -> [#("axis", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case cylinder {
    Some(v) -> [#("cylinder", json.float(v)), ..fields]
    None -> fields
  }
  let fields = case sphere {
    Some(v) -> [#("sphere", json.float(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn visionprescription_lensspecification_decoder() -> Decoder(
  VisionprescriptionLensspecification,
) {
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use brand <- decode.optional_field(
    "brand",
    None,
    decode.optional(decode.string),
  )
  use color <- decode.optional_field(
    "color",
    None,
    decode.optional(decode.string),
  )
  use duration <- decode.optional_field(
    "duration",
    None,
    decode.optional(quantity_decoder()),
  )
  use diameter <- decode.optional_field(
    "diameter",
    None,
    decode.optional(decode.float),
  )
  use back_curve <- decode.optional_field(
    "backCurve",
    None,
    decode.optional(decode.float),
  )
  use power <- decode.optional_field(
    "power",
    None,
    decode.optional(decode.float),
  )
  use add <- decode.optional_field("add", None, decode.optional(decode.float))
  use prism <- decode.optional_field(
    "prism",
    [],
    decode.list(visionprescription_lensspecification_prism_decoder()),
  )
  use axis <- decode.optional_field("axis", None, decode.optional(decode.int))
  use cylinder <- decode.optional_field(
    "cylinder",
    None,
    decode.optional(decode.float),
  )
  use sphere <- decode.optional_field(
    "sphere",
    None,
    decode.optional(decode.float),
  )
  use eye <- decode.field("eye", r4bvaluesets.visioneyecodes_decoder())
  use product <- decode.field("product", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(VisionprescriptionLensspecification(
    note:,
    brand:,
    color:,
    duration:,
    diameter:,
    back_curve:,
    power:,
    add:,
    prism:,
    axis:,
    cylinder:,
    sphere:,
    eye:,
    product:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn visionprescription_to_json(
  visionprescription: Visionprescription,
) -> Json {
  let Visionprescription(
    lens_specification:,
    prescriber:,
    date_written:,
    encounter:,
    patient:,
    created:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = visionprescription
  let fields = [
    #("prescriber", reference_to_json(prescriber)),
    #("dateWritten", json.string(date_written)),
    #("patient", reference_to_json(patient)),
    #("created", json.string(created)),
    #("status", r4bvaluesets.fmstatus_to_json(status)),
  ]
  let fields = case lens_specification {
    [] -> fields
    _ -> [
      #(
        "lensSpecification",
        json.array(
          lens_specification,
          visionprescription_lensspecification_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case encounter {
    Some(v) -> [#("encounter", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Visionprescription")), ..fields]
  json.object(fields)
}

pub fn visionprescription_decoder() -> Decoder(Visionprescription) {
  use lens_specification <- decode.optional_field(
    "lensSpecification",
    [],
    decode.list(visionprescription_lensspecification_decoder()),
  )
  use prescriber <- decode.field("prescriber", reference_decoder())
  use date_written <- decode.field("dateWritten", decode.string)
  use encounter <- decode.optional_field(
    "encounter",
    None,
    decode.optional(reference_decoder()),
  )
  use patient <- decode.field("patient", reference_decoder())
  use created <- decode.field("created", decode.string)
  use status <- decode.field("status", r4bvaluesets.fmstatus_decoder())
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Visionprescription",
    decode.failure(
      visionprescription_new(
        prescriber:,
        date_written:,
        patient:,
        created:,
        status:,
      ),
      "resourceType",
    ),
  )
  decode.success(Visionprescription(
    lens_specification:,
    prescriber:,
    date_written:,
    encounter:,
    patient:,
    created:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

pub type Resource {
  ResourceAccount(Account)
  ResourceActivitydefinition(Activitydefinition)
  ResourceAdministrableproductdefinition(Administrableproductdefinition)
  ResourceAdverseevent(Adverseevent)
  ResourceAllergyintolerance(Allergyintolerance)
  ResourceAppointment(Appointment)
  ResourceAppointmentresponse(Appointmentresponse)
  ResourceAuditevent(Auditevent)
  ResourceBasic(Basic)
  ResourceBinary(Binary)
  ResourceBiologicallyderivedproduct(Biologicallyderivedproduct)
  ResourceBodystructure(Bodystructure)
  ResourceBundle(Bundle)
  ResourceCapabilitystatement(Capabilitystatement)
  ResourceCareplan(Careplan)
  ResourceCareteam(Careteam)
  ResourceCatalogentry(Catalogentry)
  ResourceChargeitem(Chargeitem)
  ResourceChargeitemdefinition(Chargeitemdefinition)
  ResourceCitation(Citation)
  ResourceClaim(Claim)
  ResourceClaimresponse(Claimresponse)
  ResourceClinicalimpression(Clinicalimpression)
  ResourceClinicalusedefinition(Clinicalusedefinition)
  ResourceCodesystem(Codesystem)
  ResourceCommunication(Communication)
  ResourceCommunicationrequest(Communicationrequest)
  ResourceCompartmentdefinition(Compartmentdefinition)
  ResourceComposition(Composition)
  ResourceConceptmap(Conceptmap)
  ResourceCondition(Condition)
  ResourceConsent(Consent)
  ResourceContract(Contract)
  ResourceCoverage(Coverage)
  ResourceCoverageeligibilityrequest(Coverageeligibilityrequest)
  ResourceCoverageeligibilityresponse(Coverageeligibilityresponse)
  ResourceDetectedissue(Detectedissue)
  ResourceDevice(Device)
  ResourceDevicedefinition(Devicedefinition)
  ResourceDevicemetric(Devicemetric)
  ResourceDevicerequest(Devicerequest)
  ResourceDeviceusestatement(Deviceusestatement)
  ResourceDiagnosticreport(Diagnosticreport)
  ResourceDocumentmanifest(Documentmanifest)
  ResourceDocumentreference(Documentreference)
  ResourceDomainresource(Domainresource)
  ResourceEncounter(Encounter)
  ResourceEndpoint(Endpoint)
  ResourceEnrollmentrequest(Enrollmentrequest)
  ResourceEnrollmentresponse(Enrollmentresponse)
  ResourceEpisodeofcare(Episodeofcare)
  ResourceEventdefinition(Eventdefinition)
  ResourceEvidence(Evidence)
  ResourceEvidencereport(Evidencereport)
  ResourceEvidencevariable(Evidencevariable)
  ResourceExamplescenario(Examplescenario)
  ResourceExplanationofbenefit(Explanationofbenefit)
  ResourceFamilymemberhistory(Familymemberhistory)
  ResourceFlag(Flag)
  ResourceGoal(Goal)
  ResourceGraphdefinition(Graphdefinition)
  ResourceGroup(Group)
  ResourceGuidanceresponse(Guidanceresponse)
  ResourceHealthcareservice(Healthcareservice)
  ResourceImagingstudy(Imagingstudy)
  ResourceImmunization(Immunization)
  ResourceImmunizationevaluation(Immunizationevaluation)
  ResourceImmunizationrecommendation(Immunizationrecommendation)
  ResourceImplementationguide(Implementationguide)
  ResourceIngredient(Ingredient)
  ResourceInsuranceplan(Insuranceplan)
  ResourceInvoice(Invoice)
  ResourceLibrary(Library)
  ResourceLinkage(Linkage)
  ResourceListfhir(Listfhir)
  ResourceLocation(Location)
  ResourceManufactureditemdefinition(Manufactureditemdefinition)
  ResourceMeasure(Measure)
  ResourceMeasurereport(Measurereport)
  ResourceMedia(Media)
  ResourceMedication(Medication)
  ResourceMedicationadministration(Medicationadministration)
  ResourceMedicationdispense(Medicationdispense)
  ResourceMedicationknowledge(Medicationknowledge)
  ResourceMedicationrequest(Medicationrequest)
  ResourceMedicationstatement(Medicationstatement)
  ResourceMedicinalproductdefinition(Medicinalproductdefinition)
  ResourceMessagedefinition(Messagedefinition)
  ResourceMessageheader(Messageheader)
  ResourceMolecularsequence(Molecularsequence)
  ResourceNamingsystem(Namingsystem)
  ResourceNutritionorder(Nutritionorder)
  ResourceNutritionproduct(Nutritionproduct)
  ResourceObservation(Observation)
  ResourceObservationdefinition(Observationdefinition)
  ResourceOperationdefinition(Operationdefinition)
  ResourceOperationoutcome(Operationoutcome)
  ResourceOrganization(Organization)
  ResourceOrganizationaffiliation(Organizationaffiliation)
  ResourcePackagedproductdefinition(Packagedproductdefinition)
  ResourceParameters(Parameters)
  ResourcePatient(Patient)
  ResourcePaymentnotice(Paymentnotice)
  ResourcePaymentreconciliation(Paymentreconciliation)
  ResourcePerson(Person)
  ResourcePlandefinition(Plandefinition)
  ResourcePractitioner(Practitioner)
  ResourcePractitionerrole(Practitionerrole)
  ResourceProcedure(Procedure)
  ResourceProvenance(Provenance)
  ResourceQuestionnaire(Questionnaire)
  ResourceQuestionnaireresponse(Questionnaireresponse)
  ResourceRegulatedauthorization(Regulatedauthorization)
  ResourceRelatedperson(Relatedperson)
  ResourceRequestgroup(Requestgroup)
  ResourceResearchdefinition(Researchdefinition)
  ResourceResearchelementdefinition(Researchelementdefinition)
  ResourceResearchstudy(Researchstudy)
  ResourceResearchsubject(Researchsubject)
  ResourceRiskassessment(Riskassessment)
  ResourceSchedule(Schedule)
  ResourceSearchparameter(Searchparameter)
  ResourceServicerequest(Servicerequest)
  ResourceSlot(Slot)
  ResourceSpecimen(Specimen)
  ResourceSpecimendefinition(Specimendefinition)
  ResourceStructuredefinition(Structuredefinition)
  ResourceStructuremap(Structuremap)
  ResourceSubscription(Subscription)
  ResourceSubscriptionstatus(Subscriptionstatus)
  ResourceSubscriptiontopic(Subscriptiontopic)
  ResourceSubstance(Substance)
  ResourceSubstancedefinition(Substancedefinition)
  ResourceSupplydelivery(Supplydelivery)
  ResourceSupplyrequest(Supplyrequest)
  ResourceTask(Task)
  ResourceTerminologycapabilities(Terminologycapabilities)
  ResourceTestreport(Testreport)
  ResourceTestscript(Testscript)
  ResourceValueset(Valueset)
  ResourceVerificationresult(Verificationresult)
  ResourceVisionprescription(Visionprescription)
}

pub fn resource_to_json(res: Resource) {
  case res {
    ResourceAccount(r) -> account_to_json(r)
    ResourceActivitydefinition(r) -> activitydefinition_to_json(r)
    ResourceAdministrableproductdefinition(r) ->
      administrableproductdefinition_to_json(r)
    ResourceAdverseevent(r) -> adverseevent_to_json(r)
    ResourceAllergyintolerance(r) -> allergyintolerance_to_json(r)
    ResourceAppointment(r) -> appointment_to_json(r)
    ResourceAppointmentresponse(r) -> appointmentresponse_to_json(r)
    ResourceAuditevent(r) -> auditevent_to_json(r)
    ResourceBasic(r) -> basic_to_json(r)
    ResourceBinary(r) -> binary_to_json(r)
    ResourceBiologicallyderivedproduct(r) ->
      biologicallyderivedproduct_to_json(r)
    ResourceBodystructure(r) -> bodystructure_to_json(r)
    ResourceBundle(r) -> bundle_to_json(r)
    ResourceCapabilitystatement(r) -> capabilitystatement_to_json(r)
    ResourceCareplan(r) -> careplan_to_json(r)
    ResourceCareteam(r) -> careteam_to_json(r)
    ResourceCatalogentry(r) -> catalogentry_to_json(r)
    ResourceChargeitem(r) -> chargeitem_to_json(r)
    ResourceChargeitemdefinition(r) -> chargeitemdefinition_to_json(r)
    ResourceCitation(r) -> citation_to_json(r)
    ResourceClaim(r) -> claim_to_json(r)
    ResourceClaimresponse(r) -> claimresponse_to_json(r)
    ResourceClinicalimpression(r) -> clinicalimpression_to_json(r)
    ResourceClinicalusedefinition(r) -> clinicalusedefinition_to_json(r)
    ResourceCodesystem(r) -> codesystem_to_json(r)
    ResourceCommunication(r) -> communication_to_json(r)
    ResourceCommunicationrequest(r) -> communicationrequest_to_json(r)
    ResourceCompartmentdefinition(r) -> compartmentdefinition_to_json(r)
    ResourceComposition(r) -> composition_to_json(r)
    ResourceConceptmap(r) -> conceptmap_to_json(r)
    ResourceCondition(r) -> condition_to_json(r)
    ResourceConsent(r) -> consent_to_json(r)
    ResourceContract(r) -> contract_to_json(r)
    ResourceCoverage(r) -> coverage_to_json(r)
    ResourceCoverageeligibilityrequest(r) ->
      coverageeligibilityrequest_to_json(r)
    ResourceCoverageeligibilityresponse(r) ->
      coverageeligibilityresponse_to_json(r)
    ResourceDetectedissue(r) -> detectedissue_to_json(r)
    ResourceDevice(r) -> device_to_json(r)
    ResourceDevicedefinition(r) -> devicedefinition_to_json(r)
    ResourceDevicemetric(r) -> devicemetric_to_json(r)
    ResourceDevicerequest(r) -> devicerequest_to_json(r)
    ResourceDeviceusestatement(r) -> deviceusestatement_to_json(r)
    ResourceDiagnosticreport(r) -> diagnosticreport_to_json(r)
    ResourceDocumentmanifest(r) -> documentmanifest_to_json(r)
    ResourceDocumentreference(r) -> documentreference_to_json(r)
    ResourceDomainresource(r) -> domainresource_to_json(r)
    ResourceEncounter(r) -> encounter_to_json(r)
    ResourceEndpoint(r) -> endpoint_to_json(r)
    ResourceEnrollmentrequest(r) -> enrollmentrequest_to_json(r)
    ResourceEnrollmentresponse(r) -> enrollmentresponse_to_json(r)
    ResourceEpisodeofcare(r) -> episodeofcare_to_json(r)
    ResourceEventdefinition(r) -> eventdefinition_to_json(r)
    ResourceEvidence(r) -> evidence_to_json(r)
    ResourceEvidencereport(r) -> evidencereport_to_json(r)
    ResourceEvidencevariable(r) -> evidencevariable_to_json(r)
    ResourceExamplescenario(r) -> examplescenario_to_json(r)
    ResourceExplanationofbenefit(r) -> explanationofbenefit_to_json(r)
    ResourceFamilymemberhistory(r) -> familymemberhistory_to_json(r)
    ResourceFlag(r) -> flag_to_json(r)
    ResourceGoal(r) -> goal_to_json(r)
    ResourceGraphdefinition(r) -> graphdefinition_to_json(r)
    ResourceGroup(r) -> group_to_json(r)
    ResourceGuidanceresponse(r) -> guidanceresponse_to_json(r)
    ResourceHealthcareservice(r) -> healthcareservice_to_json(r)
    ResourceImagingstudy(r) -> imagingstudy_to_json(r)
    ResourceImmunization(r) -> immunization_to_json(r)
    ResourceImmunizationevaluation(r) -> immunizationevaluation_to_json(r)
    ResourceImmunizationrecommendation(r) ->
      immunizationrecommendation_to_json(r)
    ResourceImplementationguide(r) -> implementationguide_to_json(r)
    ResourceIngredient(r) -> ingredient_to_json(r)
    ResourceInsuranceplan(r) -> insuranceplan_to_json(r)
    ResourceInvoice(r) -> invoice_to_json(r)
    ResourceLibrary(r) -> library_to_json(r)
    ResourceLinkage(r) -> linkage_to_json(r)
    ResourceListfhir(r) -> listfhir_to_json(r)
    ResourceLocation(r) -> location_to_json(r)
    ResourceManufactureditemdefinition(r) ->
      manufactureditemdefinition_to_json(r)
    ResourceMeasure(r) -> measure_to_json(r)
    ResourceMeasurereport(r) -> measurereport_to_json(r)
    ResourceMedia(r) -> media_to_json(r)
    ResourceMedication(r) -> medication_to_json(r)
    ResourceMedicationadministration(r) -> medicationadministration_to_json(r)
    ResourceMedicationdispense(r) -> medicationdispense_to_json(r)
    ResourceMedicationknowledge(r) -> medicationknowledge_to_json(r)
    ResourceMedicationrequest(r) -> medicationrequest_to_json(r)
    ResourceMedicationstatement(r) -> medicationstatement_to_json(r)
    ResourceMedicinalproductdefinition(r) ->
      medicinalproductdefinition_to_json(r)
    ResourceMessagedefinition(r) -> messagedefinition_to_json(r)
    ResourceMessageheader(r) -> messageheader_to_json(r)
    ResourceMolecularsequence(r) -> molecularsequence_to_json(r)
    ResourceNamingsystem(r) -> namingsystem_to_json(r)
    ResourceNutritionorder(r) -> nutritionorder_to_json(r)
    ResourceNutritionproduct(r) -> nutritionproduct_to_json(r)
    ResourceObservation(r) -> observation_to_json(r)
    ResourceObservationdefinition(r) -> observationdefinition_to_json(r)
    ResourceOperationdefinition(r) -> operationdefinition_to_json(r)
    ResourceOperationoutcome(r) -> operationoutcome_to_json(r)
    ResourceOrganization(r) -> organization_to_json(r)
    ResourceOrganizationaffiliation(r) -> organizationaffiliation_to_json(r)
    ResourcePackagedproductdefinition(r) -> packagedproductdefinition_to_json(r)
    ResourceParameters(r) -> parameters_to_json(r)
    ResourcePatient(r) -> patient_to_json(r)
    ResourcePaymentnotice(r) -> paymentnotice_to_json(r)
    ResourcePaymentreconciliation(r) -> paymentreconciliation_to_json(r)
    ResourcePerson(r) -> person_to_json(r)
    ResourcePlandefinition(r) -> plandefinition_to_json(r)
    ResourcePractitioner(r) -> practitioner_to_json(r)
    ResourcePractitionerrole(r) -> practitionerrole_to_json(r)
    ResourceProcedure(r) -> procedure_to_json(r)
    ResourceProvenance(r) -> provenance_to_json(r)
    ResourceQuestionnaire(r) -> questionnaire_to_json(r)
    ResourceQuestionnaireresponse(r) -> questionnaireresponse_to_json(r)
    ResourceRegulatedauthorization(r) -> regulatedauthorization_to_json(r)
    ResourceRelatedperson(r) -> relatedperson_to_json(r)
    ResourceRequestgroup(r) -> requestgroup_to_json(r)
    ResourceResearchdefinition(r) -> researchdefinition_to_json(r)
    ResourceResearchelementdefinition(r) -> researchelementdefinition_to_json(r)
    ResourceResearchstudy(r) -> researchstudy_to_json(r)
    ResourceResearchsubject(r) -> researchsubject_to_json(r)
    ResourceRiskassessment(r) -> riskassessment_to_json(r)
    ResourceSchedule(r) -> schedule_to_json(r)
    ResourceSearchparameter(r) -> searchparameter_to_json(r)
    ResourceServicerequest(r) -> servicerequest_to_json(r)
    ResourceSlot(r) -> slot_to_json(r)
    ResourceSpecimen(r) -> specimen_to_json(r)
    ResourceSpecimendefinition(r) -> specimendefinition_to_json(r)
    ResourceStructuredefinition(r) -> structuredefinition_to_json(r)
    ResourceStructuremap(r) -> structuremap_to_json(r)
    ResourceSubscription(r) -> subscription_to_json(r)
    ResourceSubscriptionstatus(r) -> subscriptionstatus_to_json(r)
    ResourceSubscriptiontopic(r) -> subscriptiontopic_to_json(r)
    ResourceSubstance(r) -> substance_to_json(r)
    ResourceSubstancedefinition(r) -> substancedefinition_to_json(r)
    ResourceSupplydelivery(r) -> supplydelivery_to_json(r)
    ResourceSupplyrequest(r) -> supplyrequest_to_json(r)
    ResourceTask(r) -> task_to_json(r)
    ResourceTerminologycapabilities(r) -> terminologycapabilities_to_json(r)
    ResourceTestreport(r) -> testreport_to_json(r)
    ResourceTestscript(r) -> testscript_to_json(r)
    ResourceValueset(r) -> valueset_to_json(r)
    ResourceVerificationresult(r) -> verificationresult_to_json(r)
    ResourceVisionprescription(r) -> visionprescription_to_json(r)
  }
}

pub fn resource_decoder() -> Decoder(Resource) {
  use tag <- decode.field("resourceType", decode.string)
  case tag {
    "Account" -> account_decoder() |> decode.map(ResourceAccount)
    "Activitydefinition" ->
      activitydefinition_decoder() |> decode.map(ResourceActivitydefinition)
    "Administrableproductdefinition" ->
      administrableproductdefinition_decoder()
      |> decode.map(ResourceAdministrableproductdefinition)
    "Adverseevent" -> adverseevent_decoder() |> decode.map(ResourceAdverseevent)
    "Allergyintolerance" ->
      allergyintolerance_decoder() |> decode.map(ResourceAllergyintolerance)
    "Appointment" -> appointment_decoder() |> decode.map(ResourceAppointment)
    "Appointmentresponse" ->
      appointmentresponse_decoder() |> decode.map(ResourceAppointmentresponse)
    "Auditevent" -> auditevent_decoder() |> decode.map(ResourceAuditevent)
    "Basic" -> basic_decoder() |> decode.map(ResourceBasic)
    "Binary" -> binary_decoder() |> decode.map(ResourceBinary)
    "Biologicallyderivedproduct" ->
      biologicallyderivedproduct_decoder()
      |> decode.map(ResourceBiologicallyderivedproduct)
    "Bodystructure" ->
      bodystructure_decoder() |> decode.map(ResourceBodystructure)
    "Bundle" -> bundle_decoder() |> decode.map(ResourceBundle)
    "Capabilitystatement" ->
      capabilitystatement_decoder() |> decode.map(ResourceCapabilitystatement)
    "Careplan" -> careplan_decoder() |> decode.map(ResourceCareplan)
    "Careteam" -> careteam_decoder() |> decode.map(ResourceCareteam)
    "Catalogentry" -> catalogentry_decoder() |> decode.map(ResourceCatalogentry)
    "Chargeitem" -> chargeitem_decoder() |> decode.map(ResourceChargeitem)
    "Chargeitemdefinition" ->
      chargeitemdefinition_decoder() |> decode.map(ResourceChargeitemdefinition)
    "Citation" -> citation_decoder() |> decode.map(ResourceCitation)
    "Claim" -> claim_decoder() |> decode.map(ResourceClaim)
    "Claimresponse" ->
      claimresponse_decoder() |> decode.map(ResourceClaimresponse)
    "Clinicalimpression" ->
      clinicalimpression_decoder() |> decode.map(ResourceClinicalimpression)
    "Clinicalusedefinition" ->
      clinicalusedefinition_decoder()
      |> decode.map(ResourceClinicalusedefinition)
    "Codesystem" -> codesystem_decoder() |> decode.map(ResourceCodesystem)
    "Communication" ->
      communication_decoder() |> decode.map(ResourceCommunication)
    "Communicationrequest" ->
      communicationrequest_decoder() |> decode.map(ResourceCommunicationrequest)
    "Compartmentdefinition" ->
      compartmentdefinition_decoder()
      |> decode.map(ResourceCompartmentdefinition)
    "Composition" -> composition_decoder() |> decode.map(ResourceComposition)
    "Conceptmap" -> conceptmap_decoder() |> decode.map(ResourceConceptmap)
    "Condition" -> condition_decoder() |> decode.map(ResourceCondition)
    "Consent" -> consent_decoder() |> decode.map(ResourceConsent)
    "Contract" -> contract_decoder() |> decode.map(ResourceContract)
    "Coverage" -> coverage_decoder() |> decode.map(ResourceCoverage)
    "Coverageeligibilityrequest" ->
      coverageeligibilityrequest_decoder()
      |> decode.map(ResourceCoverageeligibilityrequest)
    "Coverageeligibilityresponse" ->
      coverageeligibilityresponse_decoder()
      |> decode.map(ResourceCoverageeligibilityresponse)
    "Detectedissue" ->
      detectedissue_decoder() |> decode.map(ResourceDetectedissue)
    "Device" -> device_decoder() |> decode.map(ResourceDevice)
    "Devicedefinition" ->
      devicedefinition_decoder() |> decode.map(ResourceDevicedefinition)
    "Devicemetric" -> devicemetric_decoder() |> decode.map(ResourceDevicemetric)
    "Devicerequest" ->
      devicerequest_decoder() |> decode.map(ResourceDevicerequest)
    "Deviceusestatement" ->
      deviceusestatement_decoder() |> decode.map(ResourceDeviceusestatement)
    "Diagnosticreport" ->
      diagnosticreport_decoder() |> decode.map(ResourceDiagnosticreport)
    "Documentmanifest" ->
      documentmanifest_decoder() |> decode.map(ResourceDocumentmanifest)
    "Documentreference" ->
      documentreference_decoder() |> decode.map(ResourceDocumentreference)
    "Domainresource" ->
      domainresource_decoder() |> decode.map(ResourceDomainresource)
    "Encounter" -> encounter_decoder() |> decode.map(ResourceEncounter)
    "Endpoint" -> endpoint_decoder() |> decode.map(ResourceEndpoint)
    "Enrollmentrequest" ->
      enrollmentrequest_decoder() |> decode.map(ResourceEnrollmentrequest)
    "Enrollmentresponse" ->
      enrollmentresponse_decoder() |> decode.map(ResourceEnrollmentresponse)
    "Episodeofcare" ->
      episodeofcare_decoder() |> decode.map(ResourceEpisodeofcare)
    "Eventdefinition" ->
      eventdefinition_decoder() |> decode.map(ResourceEventdefinition)
    "Evidence" -> evidence_decoder() |> decode.map(ResourceEvidence)
    "Evidencereport" ->
      evidencereport_decoder() |> decode.map(ResourceEvidencereport)
    "Evidencevariable" ->
      evidencevariable_decoder() |> decode.map(ResourceEvidencevariable)
    "Examplescenario" ->
      examplescenario_decoder() |> decode.map(ResourceExamplescenario)
    "Explanationofbenefit" ->
      explanationofbenefit_decoder() |> decode.map(ResourceExplanationofbenefit)
    "Familymemberhistory" ->
      familymemberhistory_decoder() |> decode.map(ResourceFamilymemberhistory)
    "Flag" -> flag_decoder() |> decode.map(ResourceFlag)
    "Goal" -> goal_decoder() |> decode.map(ResourceGoal)
    "Graphdefinition" ->
      graphdefinition_decoder() |> decode.map(ResourceGraphdefinition)
    "Group" -> group_decoder() |> decode.map(ResourceGroup)
    "Guidanceresponse" ->
      guidanceresponse_decoder() |> decode.map(ResourceGuidanceresponse)
    "Healthcareservice" ->
      healthcareservice_decoder() |> decode.map(ResourceHealthcareservice)
    "Imagingstudy" -> imagingstudy_decoder() |> decode.map(ResourceImagingstudy)
    "Immunization" -> immunization_decoder() |> decode.map(ResourceImmunization)
    "Immunizationevaluation" ->
      immunizationevaluation_decoder()
      |> decode.map(ResourceImmunizationevaluation)
    "Immunizationrecommendation" ->
      immunizationrecommendation_decoder()
      |> decode.map(ResourceImmunizationrecommendation)
    "Implementationguide" ->
      implementationguide_decoder() |> decode.map(ResourceImplementationguide)
    "Ingredient" -> ingredient_decoder() |> decode.map(ResourceIngredient)
    "Insuranceplan" ->
      insuranceplan_decoder() |> decode.map(ResourceInsuranceplan)
    "Invoice" -> invoice_decoder() |> decode.map(ResourceInvoice)
    "Library" -> library_decoder() |> decode.map(ResourceLibrary)
    "Linkage" -> linkage_decoder() |> decode.map(ResourceLinkage)
    "Listfhir" -> listfhir_decoder() |> decode.map(ResourceListfhir)
    "Location" -> location_decoder() |> decode.map(ResourceLocation)
    "Manufactureditemdefinition" ->
      manufactureditemdefinition_decoder()
      |> decode.map(ResourceManufactureditemdefinition)
    "Measure" -> measure_decoder() |> decode.map(ResourceMeasure)
    "Measurereport" ->
      measurereport_decoder() |> decode.map(ResourceMeasurereport)
    "Media" -> media_decoder() |> decode.map(ResourceMedia)
    "Medication" -> medication_decoder() |> decode.map(ResourceMedication)
    "Medicationadministration" ->
      medicationadministration_decoder()
      |> decode.map(ResourceMedicationadministration)
    "Medicationdispense" ->
      medicationdispense_decoder() |> decode.map(ResourceMedicationdispense)
    "Medicationknowledge" ->
      medicationknowledge_decoder() |> decode.map(ResourceMedicationknowledge)
    "Medicationrequest" ->
      medicationrequest_decoder() |> decode.map(ResourceMedicationrequest)
    "Medicationstatement" ->
      medicationstatement_decoder() |> decode.map(ResourceMedicationstatement)
    "Medicinalproductdefinition" ->
      medicinalproductdefinition_decoder()
      |> decode.map(ResourceMedicinalproductdefinition)
    "Messagedefinition" ->
      messagedefinition_decoder() |> decode.map(ResourceMessagedefinition)
    "Messageheader" ->
      messageheader_decoder() |> decode.map(ResourceMessageheader)
    "Molecularsequence" ->
      molecularsequence_decoder() |> decode.map(ResourceMolecularsequence)
    "Namingsystem" -> namingsystem_decoder() |> decode.map(ResourceNamingsystem)
    "Nutritionorder" ->
      nutritionorder_decoder() |> decode.map(ResourceNutritionorder)
    "Nutritionproduct" ->
      nutritionproduct_decoder() |> decode.map(ResourceNutritionproduct)
    "Observation" -> observation_decoder() |> decode.map(ResourceObservation)
    "Observationdefinition" ->
      observationdefinition_decoder()
      |> decode.map(ResourceObservationdefinition)
    "Operationdefinition" ->
      operationdefinition_decoder() |> decode.map(ResourceOperationdefinition)
    "Operationoutcome" ->
      operationoutcome_decoder() |> decode.map(ResourceOperationoutcome)
    "Organization" -> organization_decoder() |> decode.map(ResourceOrganization)
    "Organizationaffiliation" ->
      organizationaffiliation_decoder()
      |> decode.map(ResourceOrganizationaffiliation)
    "Packagedproductdefinition" ->
      packagedproductdefinition_decoder()
      |> decode.map(ResourcePackagedproductdefinition)
    "Parameters" -> parameters_decoder() |> decode.map(ResourceParameters)
    "Patient" -> patient_decoder() |> decode.map(ResourcePatient)
    "Paymentnotice" ->
      paymentnotice_decoder() |> decode.map(ResourcePaymentnotice)
    "Paymentreconciliation" ->
      paymentreconciliation_decoder()
      |> decode.map(ResourcePaymentreconciliation)
    "Person" -> person_decoder() |> decode.map(ResourcePerson)
    "Plandefinition" ->
      plandefinition_decoder() |> decode.map(ResourcePlandefinition)
    "Practitioner" -> practitioner_decoder() |> decode.map(ResourcePractitioner)
    "Practitionerrole" ->
      practitionerrole_decoder() |> decode.map(ResourcePractitionerrole)
    "Procedure" -> procedure_decoder() |> decode.map(ResourceProcedure)
    "Provenance" -> provenance_decoder() |> decode.map(ResourceProvenance)
    "Questionnaire" ->
      questionnaire_decoder() |> decode.map(ResourceQuestionnaire)
    "Questionnaireresponse" ->
      questionnaireresponse_decoder()
      |> decode.map(ResourceQuestionnaireresponse)
    "Regulatedauthorization" ->
      regulatedauthorization_decoder()
      |> decode.map(ResourceRegulatedauthorization)
    "Relatedperson" ->
      relatedperson_decoder() |> decode.map(ResourceRelatedperson)
    "Requestgroup" -> requestgroup_decoder() |> decode.map(ResourceRequestgroup)
    "Researchdefinition" ->
      researchdefinition_decoder() |> decode.map(ResourceResearchdefinition)
    "Researchelementdefinition" ->
      researchelementdefinition_decoder()
      |> decode.map(ResourceResearchelementdefinition)
    "Researchstudy" ->
      researchstudy_decoder() |> decode.map(ResourceResearchstudy)
    "Researchsubject" ->
      researchsubject_decoder() |> decode.map(ResourceResearchsubject)
    "Riskassessment" ->
      riskassessment_decoder() |> decode.map(ResourceRiskassessment)
    "Schedule" -> schedule_decoder() |> decode.map(ResourceSchedule)
    "Searchparameter" ->
      searchparameter_decoder() |> decode.map(ResourceSearchparameter)
    "Servicerequest" ->
      servicerequest_decoder() |> decode.map(ResourceServicerequest)
    "Slot" -> slot_decoder() |> decode.map(ResourceSlot)
    "Specimen" -> specimen_decoder() |> decode.map(ResourceSpecimen)
    "Specimendefinition" ->
      specimendefinition_decoder() |> decode.map(ResourceSpecimendefinition)
    "Structuredefinition" ->
      structuredefinition_decoder() |> decode.map(ResourceStructuredefinition)
    "Structuremap" -> structuremap_decoder() |> decode.map(ResourceStructuremap)
    "Subscription" -> subscription_decoder() |> decode.map(ResourceSubscription)
    "Subscriptionstatus" ->
      subscriptionstatus_decoder() |> decode.map(ResourceSubscriptionstatus)
    "Subscriptiontopic" ->
      subscriptiontopic_decoder() |> decode.map(ResourceSubscriptiontopic)
    "Substance" -> substance_decoder() |> decode.map(ResourceSubstance)
    "Substancedefinition" ->
      substancedefinition_decoder() |> decode.map(ResourceSubstancedefinition)
    "Supplydelivery" ->
      supplydelivery_decoder() |> decode.map(ResourceSupplydelivery)
    "Supplyrequest" ->
      supplyrequest_decoder() |> decode.map(ResourceSupplyrequest)
    "Task" -> task_decoder() |> decode.map(ResourceTask)
    "Terminologycapabilities" ->
      terminologycapabilities_decoder()
      |> decode.map(ResourceTerminologycapabilities)
    "Testreport" -> testreport_decoder() |> decode.map(ResourceTestreport)
    "Testscript" -> testscript_decoder() |> decode.map(ResourceTestscript)
    "Valueset" -> valueset_decoder() |> decode.map(ResourceValueset)
    "Verificationresult" ->
      verificationresult_decoder() |> decode.map(ResourceVerificationresult)
    "Visionprescription" ->
      visionprescription_decoder() |> decode.map(ResourceVisionprescription)

    _ ->
      decode.failure(ResourceCareteam(careteam_new()), expected: "resourceType")
  }
}

//std lib decode.optional supports myfield: null but what if myfield is omitted from json entirely?
fn none_if_omitted(d: decode.Decoder(a)) -> decode.Decoder(Option(a)) {
  decode.one_of(d |> decode.map(Some), [decode.success(None)])
}
