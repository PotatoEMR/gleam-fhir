////[https://hl7.org/fhir/FHIRVERSION](https://hl7.org/fhir/FHIRVERSION) FHIRVERSION sans-io request/response helpers suitable for building clients on top of, such as FHIRVERSION_httpc.gleam and FHIRVERSION_rsvp.gleam

import fhir/FHIRVERSION
import gleam/dynamic/decode
import gleam/http
import gleam/http/request.{type Request, Request}
import gleam/http/response.{type Response}
import gleam/json.{type Json}
import gleam/list
import gleam/option.{type Option, None, Some}
import gleam/string
import gleam/uri

/// a problem with your baseurl in `fhirclient_new(baseurl)`,
/// which you should only see if you have typo in server base url
pub type ErrBaseUrl {
  UriParseFail
  UriNoHttpOrHttps
  UriNoHost
}

/// FHIR client for sending http requests to server such as
/// `let pat = FHIRVERSION.patient_read("123", client)`
///
/// create client from server base url with fhirclient_new(baseurl)`
///
/// `let assert Ok(client) = FHIRVERSION_sansio.fhirclient_new("FHIRVERSION.smarthealthit.org/")`
///
/// `let assert Ok(client) = FHIRVERSION_sansio.fhirclient_new("https://FHIRVERSION.smarthealthit.org/")`
///
/// `let assert Ok(client) = FHIRVERSION_sansio.fhirclient_new("https://hapi.fhir.org/baseFHIRVERSION")`
///
/// `let assert Ok(client) = FHIRVERSION_sansio.fhirclient_new("127.0.0.1:8000")`
pub type FhirClient {
  FhirClient(baseurl: uri.Uri, basereq: Request(String))
}

/// creates a new client from server base url
///
/// `let assert Ok(client) = FHIRVERSION_sansio.fhirclient_new("FHIRVERSION.smarthealthit.org/")`
///
/// `let assert Ok(client) = FHIRVERSION_sansio.fhirclient_new("https://FHIRVERSION.smarthealthit.org/")`
///
/// `let assert Ok(client) = FHIRVERSION_sansio.fhirclient_new("https://hapi.fhir.org/baseFHIRVERSION")`
///
/// `let assert Ok(client) = FHIRVERSION_sansio.fhirclient_new("127.0.0.1:8000")`
pub fn fhirclient_new(
  server_base_url in_url: String,
) -> Result(FhirClient, ErrBaseUrl) {
  let in_url = case
    string.starts_with(in_url, "localhost")
    || string.starts_with(in_url, "127.0.0.1")
  {
    False -> in_url
    True -> "http://" <> in_url
  }
  let in_url = case string.starts_with(in_url, "http") {
    True -> in_url
    False -> "https://" <> in_url
  }
  case uri.parse(in_url) {
    Error(_) -> Error(UriParseFail)
    Ok(baseurl) ->
      case baseurl.host {
        None -> Error(UriNoHost)
        Some(host) -> {
          case baseurl.scheme {
            Some("http") -> create_base_req(http.Http, host, baseurl)
            Some("https") -> create_base_req(http.Https, host, baseurl)
            _ -> Error(UriNoHttpOrHttps)
          }
        }
      }
  }
}

fn create_base_req(
  scheme: http.Scheme,
  host: String,
  baseurl: uri.Uri,
) -> Result(FhirClient, a) {
  let basereq =
    Request(
      method: http.Get,
      headers: [#("Accept", "application/fhir+json")],
      body: "",
      scheme:,
      host:,
      port: baseurl.port,
      path: baseurl.path,
      query: None,
    )
  Ok(FhirClient(baseurl:, basereq:))
}

pub type Err {
  ///could not make a delete or update request because resource has no id
  ErrNoId
  ///got json but could not parse it, probably a missing required field
  ErrParseJson(json.DecodeError)
  ///did not get resource json, often server eg nginx gives basic html response
  ErrNotJson(Response(String))
  ///got operationoutcome error from fhir server
  ErrOperationcome(FHIRVERSION.Operationoutcome)
}

pub fn any_create_req(resource_json: Json, res_type: String, client: FhirClient) {
  client.basereq
  |> request.set_path(string.concat([client.basereq.path, "/", res_type]))
  |> request.set_header("Content-Type", "application/fhir+json")
  |> request.set_header("Prefer", "return=representation")
  |> request.set_body(resource_json |> json.to_string)
  |> request.set_method(http.Post)
}

pub fn any_read_req(id: String, res_type: String, client: FhirClient) {
  client.basereq
  |> request.set_path(
    string.concat([client.basereq.path, "/", res_type, "/", id]),
  )
}

pub fn any_update_req(
  id: Option(String),
  resource_json: Json,
  res_type: String,
  client: FhirClient,
) -> Result(Request(String), Err) {
  case id {
    None -> Error(ErrNoId)
    Some(id) ->
      Ok(
        client.basereq
        |> request.set_path(
          string.concat([client.basereq.path, "/", res_type, "/", id]),
        )
        |> request.set_header("Content-Type", "application/fhir+json")
        |> request.set_header("Prefer", "return=representation")
        |> request.set_body(resource_json |> json.to_string)
        |> request.set_method(http.Put),
      )
  }
}

pub fn any_delete_req(
  id: Option(String),
  res_type: String,
  client: FhirClient,
) -> Result(Request(String), Err) {
  case id {
    None -> Error(ErrNoId)
    Some(id) ->
      Ok(
        client.basereq
        |> request.set_path(
          string.concat([client.basereq.path, "/", res_type, "/", id]),
        )
        |> request.set_header("Accept", "application/fhir+json")
        |> request.set_method(http.Delete),
      )
  }
}

pub fn any_search_req(
  search_string: String,
  res_type: String,
  client: FhirClient,
) -> Request(String) {
  client.basereq
  |> request.set_path(
    string.concat([client.basereq.path, "/", res_type, "?", search_string]),
  )
}

pub fn any_operation_req(
  res_type: String,
  res_id: Option(String),
  operation_name: String,
  params: Option(FHIRVERSION.Parameters),
  client: FhirClient,
) -> Request(String) {
  let path = case res_id {
    Some(res_id) ->
      string.concat([
        client.basereq.path,
        "/",
        res_type,
        "/",
        res_id,
        "/$",
        operation_name,
      ])
    None ->
      string.concat([client.basereq.path, "/", res_type, "/$", operation_name])
  }
  let req =
    client.basereq
    |> request.set_path(path)
    |> request.set_header("Content-Type", "application/fhir+json")
    |> request.set_header("Prefer", "return=representation")
  case params {
    None -> req
    Some(params) ->
      req
      |> request.set_body(params |> FHIRVERSION.parameters_to_json |> json.to_string)
      |> request.set_method(http.Post)
  }
}

fn using_params(params) {
  list.fold(
    from: [],
    over: params,
    with: fn(acc, param: #(String, Option(String))) {
      case param.1 {
        None -> acc
        Some(p) -> [param.0 <> "=" <> p, ..acc]
      }
    },
  )
  |> string.join("&")
}

//decodes a resource (with type based on given decoder) or operationoutcome
pub fn any_resp(resp: Response(String), resource_dec: decode.Decoder(a)) {
  let decoded_resource =
    resp.body
    |> json.parse(case resp.status >= 300 {
      False -> resource_dec |> decode.map(fn(x) { Ok(x) })
      True -> FHIRVERSION.operationoutcome_decoder() |> decode.map(fn(x) { Error(x) })
    })
  case decoded_resource {
    Ok(Ok(resource)) -> Ok(resource)
    Ok(Error(op_outcome)) -> Error(ErrOperationcome(op_outcome))
    Error(dec_err) ->
      case dec_err {
        json.UnableToDecode(_) -> Error(ErrParseJson(dec_err))
        _ -> Error(ErrNotJson(resp))
      }
  }
}
